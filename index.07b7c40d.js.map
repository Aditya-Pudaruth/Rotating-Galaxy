{"mappings":"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EAAI,EAAI,EAAM,EAAI,EAAI,EAAM,EAAI,EAAI,EAAM,EAAI,EAAI,EAAM,EAAI,EAAI,EACtF,CAAE,CAAC,GAAG,CAAG,EAAI,EAAI,EAAM,EAAI,EAAI,EAAM,EAAI,EAAI,EAAM,EAAI,EAAI,EAAM,EAAI,EAAI,EAAM,EAAI,EAAI,EACvF,CAAE,CAAC,EAAE,CAAG,EAAI,EAAI,EAAM,EAAI,EAAI,EAAM,EAAI,EAAI,EAAM,EAAI,EAAI,EAAM,EAAI,EAAI,EAAM,EAAI,EAAI,EACtF,CAAE,CAAC,EAAE,CAAG,EAAI,EAAI,EAAM,EAAI,EAAI,EAAM,EAAI,EAAI,EAAM,EAAI,EAAI,EAAM,EAAI,EAAI,EAAM,EAAI,EAAI,EACtF,CAAE,CAAC,EAAE,CAAG,EAAI,EAAI,EAAM,EAAI,EAAI,EAAM,EAAI,EAAI,EAAM,EAAI,EAAI,EAAM,EAAI,EAAI,EAAM,EAAI,EAAI,EACtF,CAAE,CAAC,GAAG,CAAG,EAAI,EAAI,EAAM,EAAI,EAAI,EAAM,EAAI,EAAI,EAAM,EAAI,EAAI,EAAM,EAAI,EAAI,EAAM,EAAI,EAAI,EACvF,CAAE,CAAC,EAAE,CAAG,EAAI,EAAI,EAAM,EAAI,EAAI,EAAM,EAAI,EAAI,EAAM,EAAI,EAAI,EAAM,EAAI,EAAI,EAAM,EAAI,EAAI,EACtF,CAAE,CAAC,EAAE,CAAG,EAAI,EAAI,EAAM,EAAI,EAAI,EAAM,EAAI,EAAI,EAAM,EAAI,EAAI,EAAM,EAAI,EAAI,EAAM,EAAI,EAAI,EACtF,CAAE,CAAC,GAAG,CAAG,EAAI,EAAI,EAAM,EAAI,EAAI,EAAM,EAAI,EAAI,EAAM,EAAI,EAAI,EAAM,EAAI,EAAI,EAAM,EAAI,EAAI,EACvF,CAAE,CAAC,GAAG,CAAG,EAAI,EAAI,EAAM,EAAI,EAAI,EAAM,EAAI,EAAI,EAAM,EAAI,EAAI,EAAM,EAAI,EAAI,EAAM,EAAI,EAAI,EACvF,CAAE,CAAC,EAAE,CAAG,EAAI,EAAI,EAAM,EAAI,EAAI,EAAM,EAAI,EAAI,EAAM,EAAI,EAAI,EAAM,EAAI,EAAI,EAAM,EAAI,EAAI,EACtF,CAAE,CAAC,EAAE,CAAG,EAAI,EAAI,EAAM,EAAI,EAAI,EAAM,EAAI,EAAI,EAAM,EAAI,EAAI,EAAM,EAAI,EAAI,EAAM,EAAI,EAAI,EACtF,CAAE,CAAC,GAAG,CAAG,EAAI,EAAI,EAAM,EAAI,EAAI,EAAM,EAAI,EAAI,EAAM,EAAI,EAAI,EAAM,EAAI,EAAI,EAAM,EAAI,EAAI,EACvF,CAAE,CAAC,GAAG,CAAG,EAAI,EAAI,EAAM,EAAI,EAAI,EAAM,EAAI,EAAI,EAAM,EAAI,EAAI,EAAM,EAAI,EAAI,EAAM,EAAI,EAAI,EAEvF,IAAI,EAAM,CAAE,CAAE,EAAG,CAAG,CAAE,CAAE,EAAG,CAAG,CAAE,CAAE,EAAG,CAAG,CAAE,CAAE,EAAG,CAAG,CAAE,CAAE,EAAG,CAAG,CAAE,CAAE,EAAG,CAAG,CAAE,CAAE,EAAG,CAAG,CAAE,CAAE,GAAI,CAExF,GAAK,AAAO,GAAP,EAAW,CAEf,IAAI,EAAM,8DAEV,GAAK,EAEJ,MAAM,AAAI,MAAO,UAIjB,QAAQ,IAAI,CAAE,GAIf,IAAI,CAAC,QAAQ,GAEN,IAAI,AACZ,CAIA,OAFA,IAAI,CAAC,cAAc,CAAE,EAAI,GAElB,IAAI,AAEZ,EAEA,OAAA,EAEK,EAAY,IAAI,GAAM,OAAO,CAChC,EAAS,IAAI,GAAM,OAAO,CAEpB,SAAW,CAAW,CAAE,CAAQ,CAAE,CAAK,EAE7C,IAAI,EAAK,IAAI,CAAC,QAAQ,CAatB,OAXA,EAAU,QAAQ,GAClB,EAAU,yBAAyB,CAAE,GAErC,EAAO,SAAS,CAAE,EAAM,CAAC,CAAE,EAAM,CAAC,CAAE,EAAM,CAAC,EAE3C,IAAI,CAAC,gBAAgB,CAAE,EAAW,GAElC,CAAE,CAAC,GAAG,CAAG,EAAY,CAAC,CACtB,CAAE,CAAC,GAAG,CAAG,EAAY,CAAC,CACtB,CAAE,CAAC,GAAG,CAAG,EAAY,CAAC,CAEf,IAAI,AAEZ,GAID,SAAA,EAEK,EAAI,IAAI,GAAM,OAAO,CACxB,EAAI,IAAI,GAAM,OAAO,CACrB,EAAI,IAAI,GAAM,OAAO,CACrB,EAAS,IAAI,GAAM,OAAO,CAEpB,SAAW,CAAW,CAAE,CAAQ,CAAE,CAAK,EAE7C,IAAI,EAAK,IAAI,CAAC,QAAQ,CAqCtB,OAlCA,EAAE,GAAG,CAAE,CAAE,CAAC,EAAE,CAAE,CAAE,CAAC,EAAE,CAAE,CAAE,CAAC,EAAE,EAC1B,EAAE,GAAG,CAAE,CAAE,CAAC,EAAE,CAAE,CAAE,CAAC,EAAE,CAAE,CAAE,CAAC,EAAE,EAC1B,EAAE,GAAG,CAAE,CAAE,CAAC,EAAE,CAAE,CAAE,CAAC,EAAE,CAAE,CAAE,CAAC,GAAG,EAE3B,EAAgB,aAAuB,GAAM,OAAO,CAAK,EAAc,IAAI,GAAM,OAAO,CACxF,EAAa,aAAoB,GAAM,UAAU,CAAK,EAAW,IAAI,GAAM,UAAU,CAGrF,AAFA,CAAA,EAAU,aAAiB,GAAM,OAAO,CAAK,EAAQ,IAAI,GAAM,OAAO,AAAtE,EAEM,CAAC,CAAG,EAAE,MAAM,GAClB,EAAM,CAAC,CAAG,EAAE,MAAM,GAClB,EAAM,CAAC,CAAG,EAAE,MAAM,GAElB,EAAY,CAAC,CAAG,CAAE,CAAC,GAAG,CACtB,EAAY,CAAC,CAAG,CAAE,CAAC,GAAG,CACtB,EAAY,CAAC,CAAG,CAAE,CAAC,GAAG,CAItB,EAAO,IAAI,CAAE,IAAI,EAEjB,EAAO,QAAQ,CAAC,EAAE,EAAI,EAAM,CAAC,CAC7B,EAAO,QAAQ,CAAC,EAAE,EAAI,EAAM,CAAC,CAC7B,EAAO,QAAQ,CAAC,EAAE,EAAI,EAAM,CAAC,CAE7B,EAAO,QAAQ,CAAC,EAAE,EAAI,EAAM,CAAC,CAC7B,EAAO,QAAQ,CAAC,EAAE,EAAI,EAAM,CAAC,CAC7B,EAAO,QAAQ,CAAC,EAAE,EAAI,EAAM,CAAC,CAE7B,EAAO,QAAQ,CAAC,EAAE,EAAI,EAAM,CAAC,CAC7B,EAAO,QAAQ,CAAC,EAAE,EAAI,EAAM,CAAC,CAC7B,EAAO,QAAQ,CAAC,GAAG,EAAI,EAAM,CAAC,CAE9B,EAAS,qBAAqB,CAAE,GAEzB,CAAE,EAAa,EAAU,EAAO,AAExC,GAID,gBAAiB,SAAW,CAAC,EAE5B,IAAI,EAAK,IAAI,CAAC,QAAQ,CAClB,EAAK,EAAE,QAAQ,CAMnB,OAJA,CAAE,CAAC,GAAG,CAAG,CAAE,CAAC,GAAG,CACf,CAAE,CAAC,GAAG,CAAG,CAAE,CAAC,GAAG,CACf,CAAE,CAAC,GAAG,CAAG,CAAE,CAAC,GAAG,CAER,IAAI,AAEZ,EAEA,eAAA,EAEK,EAAK,IAAI,GAAM,OAAO,CAEnB,SAAW,CAAC,EAElB,IAAI,EAAK,IAAI,CAAC,QAAQ,CAClB,EAAK,EAAE,QAAQ,CAEf,EAAS,EAAI,EAAG,GAAG,CAAE,CAAE,CAAC,EAAE,CAAE,CAAE,CAAC,EAAE,CAAE,CAAE,CAAC,EAAE,EAAG,MAAM,GACjD,EAAS,EAAI,EAAG,GAAG,CAAE,CAAE,CAAC,EAAE,CAAE,CAAE,CAAC,EAAE,CAAE,CAAE,CAAC,EAAE,EAAG,MAAM,GACjD,EAAS,EAAI,EAAG,GAAG,CAAE,CAAE,CAAC,EAAE,CAAE,CAAE,CAAC,EAAE,CAAE,CAAE,CAAC,GAAG,EAAG,MAAM,GActD,OAZA,CAAE,CAAC,EAAE,CAAG,CAAE,CAAC,EAAE,CAAG,EAChB,CAAE,CAAC,EAAE,CAAG,CAAE,CAAC,EAAE,CAAG,EAChB,CAAE,CAAC,EAAE,CAAG,CAAE,CAAC,EAAE,CAAG,EAEhB,CAAE,CAAC,EAAE,CAAG,CAAE,CAAC,EAAE,CAAG,EAChB,CAAE,CAAC,EAAE,CAAG,CAAE,CAAC,EAAE,CAAG,EAChB,CAAE,CAAC,EAAE,CAAG,CAAE,CAAC,EAAE,CAAG,EAEhB,CAAE,CAAC,EAAE,CAAG,CAAE,CAAC,EAAE,CAAG,EAChB,CAAE,CAAC,EAAE,CAAG,CAAE,CAAC,EAAE,CAAG,EAChB,CAAE,CAAC,GAAG,CAAG,CAAE,CAAC,GAAG,CAAG,EAEX,IAAI,AAEZ,GAID,UAAW,SAAW,CAAC,EAEtB,IAAI,EAAK,IAAI,CAAC,QAAQ,CAClB,EAAI,EAAE,CAAC,CAAE,EAAI,EAAE,CAAC,CAAE,EAAI,EAAE,CAAC,CAO7B,OALA,CAAE,CAAC,GAAG,CAAG,CAAE,CAAC,EAAE,CAAG,EAAI,CAAE,CAAC,EAAE,CAAG,EAAI,CAAE,CAAC,EAAE,CAAG,EAAI,CAAE,CAAC,GAAG,CACnD,CAAE,CAAC,GAAG,CAAG,CAAE,CAAC,EAAE,CAAG,EAAI,CAAE,CAAC,EAAE,CAAG,EAAI,CAAE,CAAC,EAAE,CAAG,EAAI,CAAE,CAAC,GAAG,CACnD,CAAE,CAAC,GAAG,CAAG,CAAE,CAAC,EAAE,CAAG,EAAI,CAAE,CAAC,EAAE,CAAG,EAAI,CAAE,CAAC,GAAG,CAAG,EAAI,CAAE,CAAC,GAAG,CACpD,CAAE,CAAC,GAAG,CAAG,CAAE,CAAC,EAAE,CAAG,EAAI,CAAE,CAAC,EAAE,CAAG,EAAI,CAAE,CAAC,GAAG,CAAG,EAAI,CAAE,CAAC,GAAG,CAE7C,IAAI,AAEZ,EAEA,QAAS,SAAW,CAAK,EAExB,IAAI,EAAK,IAAI,CAAC,QAAQ,CAClB,EAAM,CAAE,CAAC,EAAE,CACX,EAAM,CAAE,CAAC,EAAE,CACX,EAAM,CAAE,CAAC,EAAE,CACX,EAAM,CAAE,CAAC,EAAE,CACX,EAAM,CAAE,CAAC,EAAE,CACX,EAAM,CAAE,CAAC,EAAE,CACX,EAAM,CAAE,CAAC,GAAG,CACZ,EAAM,CAAE,CAAC,GAAG,CACZ,EAAI,KAAK,GAAG,CAAE,GACd,EAAI,KAAK,GAAG,CAAE,GAYlB,OAVA,CAAE,CAAC,EAAE,CAAG,EAAI,EAAM,EAAI,EACtB,CAAE,CAAC,EAAE,CAAG,EAAI,EAAM,EAAI,EACtB,CAAE,CAAC,EAAE,CAAG,EAAI,EAAM,EAAI,EACtB,CAAE,CAAC,EAAE,CAAG,EAAI,EAAM,EAAI,EAEtB,CAAE,CAAC,EAAE,CAAG,EAAI,EAAM,EAAI,EACtB,CAAE,CAAC,EAAE,CAAG,EAAI,EAAM,EAAI,EACtB,CAAE,CAAC,GAAG,CAAG,EAAI,EAAM,EAAI,EACvB,CAAE,CAAC,GAAG,CAAG,EAAI,EAAM,EAAI,EAEhB,IAAI,AAEZ,EAEA,QAAS,SAAW,CAAK,EAExB,IAAI,EAAK,IAAI,CAAC,QAAQ,CAClB,EAAM,CAAE,CAAC,EAAE,CACX,EAAM,CAAE,CAAC,EAAE,CACX,EAAM,CAAE,CAAC,EAAE,CACX,EAAM,CAAE,CAAC,EAAE,CACX,EAAM,CAAE,CAAC,EAAE,CACX,EAAM,CAAE,CAAC,EAAE,CACX,EAAM,CAAE,CAAC,GAAG,CACZ,EAAM,CAAE,CAAC,GAAG,CACZ,EAAI,KAAK,GAAG,CAAE,GACd,EAAI,KAAK,GAAG,CAAE,GAYlB,OAVA,CAAE,CAAC,EAAE,CAAG,EAAI,EAAM,EAAI,EACtB,CAAE,CAAC,EAAE,CAAG,EAAI,EAAM,EAAI,EACtB,CAAE,CAAC,EAAE,CAAG,EAAI,EAAM,EAAI,EACtB,CAAE,CAAC,EAAE,CAAG,EAAI,EAAM,EAAI,EAEtB,CAAE,CAAC,EAAE,CAAG,EAAI,EAAM,EAAI,EACtB,CAAE,CAAC,EAAE,CAAG,EAAI,EAAM,EAAI,EACtB,CAAE,CAAC,GAAG,CAAG,EAAI,EAAM,EAAI,EACvB,CAAE,CAAC,GAAG,CAAG,EAAI,EAAM,EAAI,EAEhB,IAAI,AAEZ,EAEA,QAAS,SAAW,CAAK,EAExB,IAAI,EAAK,IAAI,CAAC,QAAQ,CAClB,EAAM,CAAE,CAAC,EAAE,CACX,EAAM,CAAE,CAAC,EAAE,CACX,EAAM,CAAE,CAAC,EAAE,CACX,EAAM,CAAE,CAAC,EAAE,CACX,EAAM,CAAE,CAAC,EAAE,CACX,EAAM,CAAE,CAAC,EAAE,CACX,EAAM,CAAE,CAAC,EAAE,CACX,EAAM,CAAE,CAAC,EAAE,CACX,EAAI,KAAK,GAAG,CAAE,GACd,EAAI,KAAK,GAAG,CAAE,GAYlB,OAVA,CAAE,CAAC,EAAE,CAAG,EAAI,EAAM,EAAI,EACtB,CAAE,CAAC,EAAE,CAAG,EAAI,EAAM,EAAI,EACtB,CAAE,CAAC,EAAE,CAAG,EAAI,EAAM,EAAI,EACtB,CAAE,CAAC,EAAE,CAAG,EAAI,EAAM,EAAI,EAEtB,CAAE,CAAC,EAAE,CAAG,EAAI,EAAM,EAAI,EACtB,CAAE,CAAC,EAAE,CAAG,EAAI,EAAM,EAAI,EACtB,CAAE,CAAC,EAAE,CAAG,EAAI,EAAM,EAAI,EACtB,CAAE,CAAC,EAAE,CAAG,EAAI,EAAM,EAAI,EAEf,IAAI,AAEZ,EAEA,aAAc,SAAW,CAAI,CAAE,CAAK,EAEnC,IAAI,EAAK,IAAI,CAAC,QAAQ,CAItB,GAAK,AAAW,IAAX,EAAK,CAAC,EAAU,AAAW,IAAX,EAAK,CAAC,EAAU,AAAW,IAAX,EAAK,CAAC,CAE1C,OAAO,IAAI,CAAC,OAAO,CAAE,GAEf,GAAK,AAAW,IAAX,EAAK,CAAC,EAAU,AAAW,IAAX,EAAK,CAAC,EAAU,AAAW,IAAX,EAAK,CAAC,CAEjD,OAAO,IAAI,CAAC,OAAO,CAAE,GAEf,GAAK,AAAW,IAAX,EAAK,CAAC,EAAU,AAAW,IAAX,EAAK,CAAC,EAAU,AAAW,IAAX,EAAK,CAAC,CAEjD,OAAO,IAAI,CAAC,OAAO,CAAE,GAItB,IAAI,EAAI,EAAK,CAAC,CAAE,EAAI,EAAK,CAAC,CAAE,EAAI,EAAK,CAAC,CAClC,EAAI,KAAK,IAAI,CAAC,EAAI,EAAI,EAAI,EAAI,EAAI,GAMlC,EAAK,AAJT,CAAA,GAAK,CAAA,EAIQ,EAAG,EAAK,AAHrB,CAAA,GAAK,CAAA,EAGoB,EAAG,EAAK,AAFjC,CAAA,GAAK,CAAA,EAEgC,EACjC,EAAI,KAAK,GAAG,CAAE,GACd,EAAI,KAAK,GAAG,CAAE,GACd,EAAiB,EAAI,EACrB,EAAK,EAAI,EAAI,EACb,EAAK,EAAI,EAAI,EACb,EAAK,EAAI,EAAI,EACb,EAAK,EAAI,EACT,EAAK,EAAI,EACT,EAAK,EAAI,EAET,EAAM,EAAM,AAAA,CAAA,EAAI,CAAA,EAAM,EACtB,EAAM,EAAK,EACX,EAAM,EAAK,EACX,EAAM,EAAK,EACX,EAAM,EAAM,AAAA,CAAA,EAAI,CAAA,EAAM,EACtB,EAAM,EAAK,EACX,EAAM,EAAK,EACX,EAAM,EAAK,EACX,EAAM,EAAM,AAAA,CAAA,EAAI,CAAA,EAAM,EAEtB,EAAM,CAAE,CAAC,EAAE,CAAE,EAAM,CAAE,CAAC,EAAE,CAAE,EAAM,CAAE,CAAC,EAAE,CAAE,EAAM,CAAE,CAAC,EAAE,CAClD,EAAM,CAAE,CAAC,EAAE,CAAE,EAAM,CAAE,CAAC,EAAE,CAAE,EAAM,CAAE,CAAC,EAAE,CAAE,EAAM,CAAE,CAAC,EAAE,CAClD,EAAM,CAAE,CAAC,EAAE,CAAE,EAAM,CAAE,CAAC,EAAE,CAAE,EAAM,CAAE,CAAC,GAAG,CAAE,EAAM,CAAE,CAAC,GAAG,CAiBxD,OAfA,CAAE,CAAC,EAAE,CAAG,EAAM,EAAM,EAAM,EAAM,EAAM,EACtC,CAAE,CAAC,EAAE,CAAG,EAAM,EAAM,EAAM,EAAM,EAAM,EACtC,CAAE,CAAC,EAAE,CAAG,EAAM,EAAM,EAAM,EAAM,EAAM,EACtC,CAAE,CAAC,EAAE,CAAG,EAAM,EAAM,EAAM,EAAM,EAAM,EAEtC,CAAE,CAAC,EAAE,CAAG,EAAM,EAAM,EAAM,EAAM,EAAM,EACtC,CAAE,CAAC,EAAE,CAAG,EAAM,EAAM,EAAM,EAAM,EAAM,EACtC,CAAE,CAAC,EAAE,CAAG,EAAM,EAAM,EAAM,EAAM,EAAM,EACtC,CAAE,CAAC,EAAE,CAAG,EAAM,EAAM,EAAM,EAAM,EAAM,EAEtC,CAAE,CAAC,EAAE,CAAG,EAAM,EAAM,EAAM,EAAM,EAAM,EACtC,CAAE,CAAC,EAAE,CAAG,EAAM,EAAM,EAAM,EAAM,EAAM,EACtC,CAAE,CAAC,GAAG,CAAG,EAAM,EAAM,EAAM,EAAM,EAAM,EACvC,CAAE,CAAC,GAAG,CAAG,EAAM,EAAM,EAAM,EAAM,EAAM,EAEhC,IAAI,AAEZ,EAEA,MAAO,SAAW,CAAC,EAElB,IAAI,EAAK,IAAI,CAAC,QAAQ,CAClB,EAAI,EAAE,CAAC,CAAE,EAAI,EAAE,CAAC,CAAE,EAAI,EAAE,CAAC,CAO7B,OALA,CAAE,CAAC,EAAE,EAAI,EAAG,CAAE,CAAC,EAAE,EAAI,EAAG,CAAE,CAAC,EAAE,EAAI,EACjC,CAAE,CAAC,EAAE,EAAI,EAAG,CAAE,CAAC,EAAE,EAAI,EAAG,CAAE,CAAC,EAAE,EAAI,EACjC,CAAE,CAAC,EAAE,EAAI,EAAG,CAAE,CAAC,EAAE,EAAI,EAAG,CAAE,CAAC,GAAG,EAAI,EAClC,CAAE,CAAC,EAAE,EAAI,EAAG,CAAE,CAAC,EAAE,EAAI,EAAG,CAAE,CAAC,GAAG,EAAI,EAE3B,IAAI,AAEZ,EAEA,kBAAmB,WAElB,IAAI,EAAK,IAAI,CAAC,QAAQ,CAMtB,OAAO,KAAK,IAAI,CAAE,KAAK,GAAG,CAJX,CAAE,CAAC,EAAE,CAAG,CAAE,CAAC,EAAE,CAAG,CAAE,CAAC,EAAE,CAAG,CAAE,CAAC,EAAE,CAAG,CAAE,CAAC,EAAE,CAAG,CAAE,CAAC,EAAE,CAItB,KAAK,GAAG,CAH/B,CAAE,CAAC,EAAE,CAAG,CAAE,CAAC,EAAE,CAAG,CAAE,CAAC,EAAE,CAAG,CAAE,CAAC,EAAE,CAAG,CAAE,CAAC,EAAE,CAAG,CAAE,CAAC,EAAE,CAC7C,CAAE,CAAC,EAAE,CAAG,CAAE,CAAC,EAAE,CAAG,CAAE,CAAC,EAAE,CAAG,CAAE,CAAC,EAAE,CAAG,CAAE,CAAC,GAAG,CAAG,CAAE,CAAC,GAAG,GAI/D,EAEA,gBAAiB,SAAW,CAAC,CAAE,CAAC,CAAE,CAAC,EAWlC,OATA,IAAI,CAAC,GAAG,CAEP,EAAG,EAAG,EAAG,EACT,EAAG,EAAG,EAAG,EACT,EAAG,EAAG,EAAG,EACT,EAAG,EAAG,EAAG,GAIH,IAAI,AAEZ,EAEA,cAAe,SAAW,CAAK,EAE9B,IAAI,EAAI,KAAK,GAAG,CAAE,GAAS,EAAI,KAAK,GAAG,CAAE,GAWzC,OATA,IAAI,CAAC,GAAG,CAEP,EAAG,EAAI,EAAG,EACV,EAAG,EAAG,CAAC,EAAG,EACV,EAAG,EAAI,EAAG,EACV,EAAG,EAAI,EAAG,GAIJ,IAAI,AAEZ,EAEA,cAAe,SAAW,CAAK,EAE9B,IAAI,EAAI,KAAK,GAAG,CAAE,GAAS,EAAI,KAAK,GAAG,CAAE,GAWzC,OATA,IAAI,CAAC,GAAG,CAEN,EAAG,EAAG,EAAG,EACT,EAAG,EAAG,EAAG,EACV,CAAC,EAAG,EAAG,EAAG,EACT,EAAG,EAAG,EAAG,GAIJ,IAAI,AAEZ,EAEA,cAAe,SAAW,CAAK,EAE9B,IAAI,EAAI,KAAK,GAAG,CAAE,GAAS,EAAI,KAAK,GAAG,CAAE,GAWzC,OATA,IAAI,CAAC,GAAG,CAEP,EAAG,CAAC,EAAG,EAAG,EACV,EAAI,EAAG,EAAG,EACV,EAAI,EAAG,EAAG,EACV,EAAI,EAAG,EAAG,GAIJ,IAAI,AAEZ,EAEA,iBAAkB,SAAW,CAAI,CAAE,CAAK,EAIvC,IAAI,EAAI,KAAK,GAAG,CAAE,GACd,EAAI,KAAK,GAAG,CAAE,GACd,EAAI,EAAI,EACR,EAAI,EAAK,CAAC,CAAE,EAAI,EAAK,CAAC,CAAE,EAAI,EAAK,CAAC,CAClC,EAAK,EAAI,EAAG,EAAK,EAAI,EAWxB,OATD,IAAI,CAAC,GAAG,CAEP,EAAK,EAAI,EAAG,EAAK,EAAI,EAAI,EAAG,EAAK,EAAI,EAAI,EAAG,EAC5C,EAAK,EAAI,EAAI,EAAG,EAAK,EAAI,EAAG,EAAK,EAAI,EAAI,EAAG,EAC5C,EAAK,EAAI,EAAI,EAAG,EAAK,EAAI,EAAI,EAAG,EAAI,EAAI,EAAI,EAAG,EAC/C,EAAG,EAAG,EAAG,GAIF,IAAI,AAEb,EAEA,UAAW,SAAW,CAAC,CAAE,CAAC,CAAE,CAAC,EAW5B,OATA,IAAI,CAAC,GAAG,CAEP,EAAG,EAAG,EAAG,EACT,EAAG,EAAG,EAAG,EACT,EAAG,EAAG,EAAG,EACT,EAAG,EAAG,EAAG,GAIH,IAAI,AAEZ,EAEA,YAAa,SAAW,CAAI,CAAE,CAAK,CAAE,CAAM,CAAE,CAAG,CAAE,CAAI,CAAE,CAAG,EAE1D,IAAI,EAAK,IAAI,CAAC,QAAQ,CActB,OALA,CAAE,CAAC,EAAE,CARG,EAAI,EAAS,CAAA,EAAQ,CAAA,EAQlB,CAAE,CAAC,EAAE,CAAG,EAAG,CAAE,CAAC,EAAE,CALnB,AAAE,CAAA,EAAQ,CAAA,EAAW,CAAA,EAAQ,CAAA,EAKJ,CAAE,CAAC,GAAG,CAAG,EAC1C,CAAE,CAAC,EAAE,CAAG,EAAG,CAAE,CAAC,EAAE,CARR,EAAI,EAAS,CAAA,EAAM,CAAA,EAQL,CAAE,CAAC,EAAE,CALnB,AAAE,CAAA,EAAM,CAAA,EAAa,CAAA,EAAM,CAAA,EAKF,CAAE,CAAC,GAAG,CAAG,EAC1C,CAAE,CAAC,EAAE,CAAG,EAAG,CAAE,CAAC,EAAE,CAAG,EAAG,CAAE,CAAC,GAAG,CALpB,CAAI,CAAA,EAAM,CAAA,EAAW,CAAA,EAAM,CAAA,EAKD,CAAE,CAAC,GAAG,CAJhC,GAAM,EAAM,EAAS,CAAA,EAAM,CAAA,EAKnC,CAAE,CAAC,EAAE,CAAG,EAAG,CAAE,CAAC,EAAE,CAAG,EAAG,CAAE,CAAC,GAAG,CAAG,GAAK,CAAE,CAAC,GAAG,CAAG,EAEtC,IAAI,AAEZ,EAEA,gBAAiB,SAAW,CAAG,CAAE,CAAM,CAAE,CAAI,CAAE,CAAG,EAEjD,IAAI,EAAO,EAAO,KAAK,GAAG,CAAE,GAAM,IAAI,CAAC,QAAQ,CAAE,AAAM,GAAN,IAC7C,EAAO,CAAE,EAIb,OAAO,IAAI,CAAC,WAAW,CAHZ,EAAO,EACP,EAAO,EAEmB,EAAM,EAAM,EAAM,EAExD,EAEA,iBAAkB,SAAW,CAAI,CAAE,CAAK,CAAE,CAAG,CAAE,CAAM,CAAE,CAAI,CAAE,CAAG,EAE/D,IAAI,EAAK,IAAI,CAAC,QAAQ,CAClB,EAAI,EAAQ,EACZ,EAAI,EAAM,EACV,EAAI,EAAM,EAWd,OALA,CAAE,CAAC,EAAE,CAAG,EAAI,EAAG,CAAE,CAAC,EAAE,CAAG,EAAG,CAAE,CAAC,EAAE,CAAG,EAAG,CAAE,CAAC,GAAG,CAAG,CAJtC,CAAA,AAAE,CAAA,EAAQ,CAAA,EAAS,CAAA,EAK3B,CAAE,CAAC,EAAE,CAAG,EAAG,CAAE,CAAC,EAAE,CAAG,EAAI,EAAG,CAAE,CAAC,EAAE,CAAG,EAAG,CAAE,CAAC,GAAG,CAAG,CAJtC,CAAA,AAAE,CAAA,EAAM,CAAA,EAAW,CAAA,EAK3B,CAAE,CAAC,EAAE,CAAG,EAAG,CAAE,CAAC,EAAE,CAAG,EAAG,CAAE,CAAC,GAAG,CAAG,GAAG,EAAG,CAAE,CAAC,GAAG,CAAG,CAJtC,CAAA,AAAE,CAAA,EAAM,CAAA,EAAS,CAAA,EAKzB,CAAE,CAAC,EAAE,CAAG,EAAG,CAAE,CAAC,EAAE,CAAG,EAAG,CAAE,CAAC,GAAG,CAAG,EAAG,CAAE,CAAC,GAAG,CAAG,EAEpC,IAAI,AAEZ,EAEA,MAAO,WAEN,IAAI,EAAK,IAAI,CAAC,QAAQ,CAEtB,OAAO,IAAI,GAAM,OAAO,CAEvB,CAAE,CAAC,EAAE,CAAE,CAAE,CAAC,EAAE,CAAE,CAAE,CAAC,EAAE,CAAE,CAAE,CAAC,GAAG,CAC3B,CAAE,CAAC,EAAE,CAAE,CAAE,CAAC,EAAE,CAAE,CAAE,CAAC,EAAE,CAAE,CAAE,CAAC,GAAG,CAC3B,CAAE,CAAC,EAAE,CAAE,CAAE,CAAC,EAAE,CAAE,CAAE,CAAC,GAAG,CAAE,CAAE,CAAC,GAAG,CAC5B,CAAE,CAAC,EAAE,CAAE,CAAE,CAAC,EAAE,CAAE,CAAE,CAAC,GAAG,CAAE,CAAE,CAAC,GAAG,CAI9B,CAED,GAKA,GAAM,GAAG,CAAG,SAAW,CAAM,CAAE,CAAS,EAEvC,IAAI,CAAC,MAAM,CAAK,AAAW,KAAA,IAAX,EAAyB,EAAS,IAAI,GAAM,OAAO,CACnE,IAAI,CAAC,SAAS,CAAK,AAAc,KAAA,IAAd,EAA4B,EAAY,IAAI,GAAM,OAAO,AAE7E,EAEA,GAAM,MAAM,CAAE,GAAM,GAAG,CAAC,SAAS,CAAE,CAElC,IAAK,SAAW,CAAM,CAAE,CAAS,EAKhC,OAHA,IAAI,CAAC,MAAM,CAAC,IAAI,CAAE,GAClB,IAAI,CAAC,SAAS,CAAC,IAAI,CAAE,GAEd,IAAI,AAEZ,EAEA,KAAM,SAAW,CAAG,EAKnB,OAHA,IAAI,CAAC,MAAM,CAAC,IAAI,CAAE,EAAI,MAAM,EAC5B,IAAI,CAAC,SAAS,CAAC,IAAI,CAAE,EAAI,SAAS,EAE3B,IAAI,AAEZ,EAEA,GAAI,SAAU,CAAC,CAAE,CAAc,EAI9B,MAAO,AAFM,CAAA,GAAkB,IAAI,GAAM,OAAO,AAAhD,EAEc,IAAI,CAAE,IAAI,CAAC,SAAS,EAAG,cAAc,CAAE,GAAI,GAAG,CAAE,IAAI,CAAC,MAAM,CAE1E,EAEA,MAAA,EAEK,EAAK,IAAI,GAAM,OAAO,CAEnB,SAAW,CAAC,EAIlB,OAFA,IAAI,CAAC,MAAM,CAAC,IAAI,CAAE,IAAI,CAAC,EAAE,CAAE,EAAG,IAEvB,IAAI,AAEZ,GAID,oBAAqB,SAAW,CAAK,CAAE,CAAc,EAEpD,IAAI,EAAS,GAAkB,IAAI,GAAM,OAAO,CAChD,EAAO,UAAU,CAAE,EAAO,IAAI,CAAC,MAAM,EACrC,IAAI,EAAoB,EAAO,GAAG,CAAE,IAAI,CAAC,SAAS,EAElD,OAAO,EAAO,IAAI,CAAE,IAAI,CAAC,SAAS,EAAG,cAAc,CAAE,GAAoB,GAAG,CAAE,IAAI,CAAC,MAAM,CAE1F,EAEA,eAAA,EAEK,EAAK,IAAI,GAAM,OAAO,CAEnB,SAAW,CAAK,EAEtB,IAAI,EAAoB,EAAG,UAAU,CAAE,EAAO,IAAI,CAAC,MAAM,EAAG,GAAG,CAAE,IAAI,CAAC,SAAS,EAG/E,OAFA,EAAG,IAAI,CAAE,IAAI,CAAC,SAAS,EAAG,cAAc,CAAE,GAAoB,GAAG,CAAE,IAAI,CAAC,MAAM,EAEvE,EAAG,UAAU,CAAE,EAEvB,GAID,qBAAsB,SAAU,CAAM,EAErC,OAAS,IAAI,CAAC,eAAe,CAAE,EAAO,MAAM,GAAM,EAAO,MAAM,AAEhE,EAEA,oBAAqB,SAAW,CAAK,SAKhB,GADF,EAAM,MAAM,CAAC,GAAG,CAAE,IAAI,CAAC,SAAS,GAQ9C,AAAwC,GAAxC,EAAM,eAAe,CAAE,IAAI,CAAC,MAAM,CAQvC,EAEA,gBAAiB,SAAW,CAAK,EAEhC,IAAI,EAAc,EAAM,MAAM,CAAC,GAAG,CAAE,IAAI,CAAC,SAAS,SAClD,AAAK,AAAe,GAAf,EAGJ,AAAI,AAAwC,GAAxC,EAAM,eAAe,CAAE,IAAI,CAAC,MAAM,EAE9B,EAKR,KAAA,EAIO,CAAI,CAAA,IAAI,CAAC,MAAM,CAAC,GAAG,CAAE,EAAM,MAAM,EAAK,EAAM,QAAO,AAAP,EAAa,CAIlE,EAEA,eAAgB,SAAW,CAAK,CAAE,CAAc,EAE/C,IAAI,EAAI,IAAI,CAAC,eAAe,CAAE,GAE9B,GAAK,AAAM,KAAA,IAAN,EAKL,OAAO,IAAI,CAAC,EAAE,CAAE,EAAG,EAEpB,EAEA,aAAc,SAAW,CAAO,EAM/B,OAJA,IAAI,CAAC,SAAS,CAAC,GAAG,CAAE,IAAI,CAAC,MAAM,EAAG,YAAY,CAAE,GAChD,IAAI,CAAC,MAAM,CAAC,YAAY,CAAE,GAC1B,IAAI,CAAC,SAAS,CAAC,GAAG,CAAE,IAAI,CAAC,MAAM,EAExB,IAAI,AACZ,EAEA,OAAQ,SAAW,CAAG,EAErB,OAAO,EAAI,MAAM,CAAC,MAAM,CAAE,IAAI,CAAC,MAAM,GAAM,EAAI,SAAS,CAAC,MAAM,CAAE,IAAI,CAAC,SAAS,CAEhF,EAEA,MAAO,WAEN,OAAO,IAAI,GAAM,GAAG,GAAG,IAAI,CAAE,IAAI,CAElC,CAED,GAMA,GAAM,MAAM,CAAG,SAAW,CAAM,CAAE,CAAM,EAEvC,IAAI,CAAC,MAAM,CAAK,AAAW,KAAA,IAAX,EAAyB,EAAS,IAAI,GAAM,OAAO,CACnE,IAAI,CAAC,MAAM,CAAG,AAAa,KAAA,IAAb,EAA2B,EAAS,CAEnD,EAEA,GAAM,MAAM,CAAE,GAAM,MAAM,CAAC,SAAS,CAAE,CAErC,IAAK,SAAW,CAAM,CAAE,CAAM,EAK7B,OAHA,IAAI,CAAC,MAAM,CAAC,IAAI,CAAE,GAClB,IAAI,CAAC,MAAM,CAAG,EAEP,IAAI,AACZ,EAEA,uBAAwB,SAAW,CAAM,CAAE,CAAM,EAIhD,IAAM,IAFF,EAAc,EAER,EAAI,EAAG,EAAK,EAAO,MAAM,CAAE,EAAI,EAAI,IAG5C,EAAc,KAAK,GAAG,CAAE,EADT,EAAO,iBAAiB,CAAE,CAAM,CAAE,EAAG,GAQrD,OAHA,IAAI,CAAC,MAAM,CAAG,EACd,IAAI,CAAC,MAAM,CAAG,KAAK,IAAI,CAAE,GAElB,IAAI,AAEZ,EAEA,KAAM,SAAW,CAAM,EAKtB,OAHA,IAAI,CAAC,MAAM,CAAC,IAAI,CAAE,EAAO,MAAM,EAC/B,IAAI,CAAC,MAAM,CAAG,EAAO,MAAM,CAEpB,IAAI,AAEZ,EAEA,MAAO,WAEN,OAAS,IAAI,CAAC,MAAM,EAAI,CAEzB,EAEA,cAAe,SAAW,CAAK,EAE9B,OAAS,EAAM,iBAAiB,CAAE,IAAI,CAAC,MAAM,GAAQ,IAAI,CAAC,MAAM,CAAG,IAAI,CAAC,MAAM,AAE/E,EAEA,gBAAiB,SAAW,CAAK,EAEhC,OAAS,EAAM,UAAU,CAAE,IAAI,CAAC,MAAM,EAAK,IAAI,CAAC,MAAM,AAEvD,EAEA,iBAAkB,SAAW,CAAM,EAElC,IAAI,EAAY,IAAI,CAAC,MAAM,CAAG,EAAO,MAAM,CAE3C,OAAO,EAAO,MAAM,CAAC,iBAAiB,CAAE,IAAI,CAAC,MAAM,GAAQ,EAAY,CAExE,EAEA,WAAY,SAAW,CAAK,CAAE,CAAc,EAE3C,IAAI,EAAgB,IAAI,CAAC,MAAM,CAAC,iBAAiB,CAAE,GAE/C,EAAS,GAAkB,IAAI,GAAM,OAAO,CAUhD,OATA,EAAO,IAAI,CAAE,GAER,EAAkB,IAAI,CAAC,MAAM,CAAG,IAAI,CAAC,MAAM,GAE/C,EAAO,GAAG,CAAE,IAAI,CAAC,MAAM,EAAG,SAAS,GACnC,EAAO,cAAc,CAAE,IAAI,CAAC,MAAM,EAAG,GAAG,CAAE,IAAI,CAAC,MAAM,GAI/C,CAER,EAEA,eAAgB,SAAW,CAAc,EAExC,IAAI,EAAM,GAAkB,IAAI,GAAM,IAAI,CAK1C,OAHA,EAAI,GAAG,CAAE,IAAI,CAAC,MAAM,CAAE,IAAI,CAAC,MAAM,EACjC,EAAI,cAAc,CAAE,IAAI,CAAC,MAAM,EAExB,CAER,EAEA,aAAc,SAAW,CAAM,EAK9B,OAHA,IAAI,CAAC,MAAM,CAAC,YAAY,CAAE,GAC1B,IAAI,CAAC,MAAM,CAAG,IAAI,CAAC,MAAM,CAAG,EAAO,iBAAiB,GAE7C,IAAI,AAEZ,EAEA,UAAW,SAAW,CAAM,EAI3B,OAFA,IAAI,CAAC,MAAM,CAAC,GAAG,CAAE,GAEV,IAAI,AAEZ,EAEA,OAAQ,SAAW,CAAM,EAExB,OAAO,EAAO,MAAM,CAAC,MAAM,CAAE,IAAI,CAAC,MAAM,GAAQ,EAAO,MAAM,GAAK,IAAI,CAAC,MAAM,AAE9E,EAEA,MAAO,WAEN,OAAO,IAAI,GAAM,MAAM,GAAG,IAAI,CAAE,IAAI,CAErC,CAED,GAOA,GAAM,OAAO,CAAG,SAAW,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,EAEhD,IAAI,CAAC,MAAM,CAAG,CAEX,AAAO,KAAA,IAAP,EAAqB,EAAK,IAAI,GAAM,KAAK,CACzC,AAAO,KAAA,IAAP,EAAqB,EAAK,IAAI,GAAM,KAAK,CACzC,AAAO,KAAA,IAAP,EAAqB,EAAK,IAAI,GAAM,KAAK,CACzC,AAAO,KAAA,IAAP,EAAqB,EAAK,IAAI,GAAM,KAAK,CACzC,AAAO,KAAA,IAAP,EAAqB,EAAK,IAAI,GAAM,KAAK,CACzC,AAAO,KAAA,IAAP,EAAqB,EAAK,IAAI,GAAM,KAAK,CAE3C,AAEF,EAEA,GAAM,MAAM,CAAE,GAAM,OAAO,CAAC,SAAS,CAAE,CAEtC,IAAK,SAAW,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,EAErC,IAAI,EAAS,IAAI,CAAC,MAAM,CASxB,OAPA,CAAM,CAAC,EAAE,CAAC,IAAI,CAAE,GAChB,CAAM,CAAC,EAAE,CAAC,IAAI,CAAE,GAChB,CAAM,CAAC,EAAE,CAAC,IAAI,CAAE,GAChB,CAAM,CAAC,EAAE,CAAC,IAAI,CAAE,GAChB,CAAM,CAAC,EAAE,CAAC,IAAI,CAAE,GAChB,CAAM,CAAC,EAAE,CAAC,IAAI,CAAE,GAET,IAAI,AAEZ,EAEA,KAAM,SAAW,CAAO,EAIvB,IAAK,IAFD,EAAS,IAAI,CAAC,MAAM,CAEf,EAAI,EAAG,EAAI,EAAG,IAEtB,CAAM,CAAC,EAAE,CAAC,IAAI,CAAE,EAAQ,MAAM,CAAC,EAAE,EAIlC,OAAO,IAAI,AAEZ,EAEA,cAAe,SAAW,CAAC,EAE1B,IAAI,EAAS,IAAI,CAAC,MAAM,CACpB,EAAK,EAAE,QAAQ,CACf,EAAM,CAAE,CAAC,EAAE,CAAE,EAAM,CAAE,CAAC,EAAE,CAAE,EAAM,CAAE,CAAC,EAAE,CAAE,EAAM,CAAE,CAAC,EAAE,CAClD,EAAM,CAAE,CAAC,EAAE,CAAE,EAAM,CAAE,CAAC,EAAE,CAAE,EAAM,CAAE,CAAC,EAAE,CAAE,EAAM,CAAE,CAAC,EAAE,CAClD,EAAM,CAAE,CAAC,EAAE,CAAE,EAAM,CAAE,CAAC,EAAE,CAAE,EAAO,CAAE,CAAC,GAAG,CAAE,EAAO,CAAE,CAAC,GAAG,CACtD,EAAO,CAAE,CAAC,GAAG,CAAE,EAAO,CAAE,CAAC,GAAG,CAAE,EAAO,CAAE,CAAC,GAAG,CAAE,EAAO,CAAE,CAAC,GAAG,CAS9D,OAPA,CAAM,CAAE,EAAG,CAAC,aAAa,CAAE,EAAM,EAAK,EAAM,EAAK,EAAO,EAAK,EAAO,GAAO,SAAS,GACpF,CAAM,CAAE,EAAG,CAAC,aAAa,CAAE,EAAM,EAAK,EAAM,EAAK,EAAO,EAAK,EAAO,GAAO,SAAS,GACpF,CAAM,CAAE,EAAG,CAAC,aAAa,CAAE,EAAM,EAAK,EAAM,EAAK,EAAO,EAAK,EAAO,GAAO,SAAS,GACpF,CAAM,CAAE,EAAG,CAAC,aAAa,CAAE,EAAM,EAAK,EAAM,EAAK,EAAO,EAAK,EAAO,GAAO,SAAS,GACpF,CAAM,CAAE,EAAG,CAAC,aAAa,CAAE,EAAM,EAAK,EAAM,EAAK,EAAO,EAAM,EAAO,GAAO,SAAS,GACrF,CAAM,CAAE,EAAG,CAAC,aAAa,CAAE,EAAM,EAAK,EAAM,EAAK,EAAO,EAAM,EAAO,GAAO,SAAS,GAE9E,IAAI,AAEZ,EAEA,gBAAA,EAEK,EAAS,IAAI,GAAM,OAAO,CAEvB,SAAW,CAAM,EAIvB,IAAI,EAAS,EAAO,WAAW,CAC3B,EAAS,IAAI,CAAC,MAAM,CACpB,EAAY,CAAE,EAAO,QAAQ,CAAC,cAAc,CAAC,MAAM,CAAG,EAAO,iBAAiB,GAElF,EAAO,qBAAqB,CAAE,GAE9B,IAAM,IAAI,EAAI,EAAG,EAAI,EAAG,IAIvB,GAAK,AAFU,CAAM,CAAE,EAAG,CAAC,eAAe,CAAE,GAE5B,EAEf,MAAO,CAAA,EAMT,MAAO,CAAA,CAER,GAID,iBAAkB,SAAW,CAAM,EAMlC,IAAM,IAJF,EAAS,IAAI,CAAC,MAAM,CACpB,EAAS,EAAO,MAAM,CACtB,EAAY,CAAC,EAAO,MAAM,CAEpB,EAAI,EAAG,EAAI,EAAG,IAIvB,GAAK,AAFU,CAAM,CAAE,EAAG,CAAC,eAAe,CAAE,GAE5B,EAEf,MAAO,CAAA,EAMT,MAAO,CAAA,CAER,EAEA,cAAe,SAAW,CAAK,EAI9B,IAAM,IAFF,EAAS,IAAI,CAAC,MAAM,CAEd,EAAI,EAAG,EAAI,EAAG,IAEvB,GAAK,AAAuC,EAAvC,CAAM,CAAE,EAAG,CAAC,eAAe,CAAE,GAEjC,MAAO,CAAA,EAMT,MAAO,CAAA,CAER,EAEA,MAAO,WAEN,OAAO,IAAI,GAAM,OAAO,GAAG,IAAI,CAAE,IAAI,CAEtC,CAED,GAKA,GAAM,KAAK,CAAG,SAAW,CAAM,CAAE,CAAQ,EAExC,IAAI,CAAC,MAAM,CAAK,AAAW,KAAA,IAAX,EAAyB,EAAS,IAAI,GAAM,OAAO,CAAE,EAAG,EAAG,GAC3E,IAAI,CAAC,QAAQ,CAAG,AAAe,KAAA,IAAf,EAA6B,EAAW,CAEzD,EAEA,GAAM,MAAM,CAAE,GAAM,KAAK,CAAC,SAAS,CAAE,CAEpC,IAAK,SAAW,CAAM,CAAE,CAAQ,EAK/B,OAHA,IAAI,CAAC,MAAM,CAAC,IAAI,CAAE,GAClB,IAAI,CAAC,QAAQ,CAAG,EAET,IAAI,AAEZ,EAEA,cAAe,SAAW,CAAC,CAAE,CAAC,CAAE,CAAC,CAAE,CAAC,EAKnC,OAHA,IAAI,CAAC,MAAM,CAAC,GAAG,CAAE,EAAG,EAAG,GACvB,IAAI,CAAC,QAAQ,CAAG,EAET,IAAI,AAEZ,EAEA,8BAA+B,SAAW,CAAM,CAAE,CAAK,EAKtD,OAHA,IAAI,CAAC,MAAM,CAAC,IAAI,CAAE,GAClB,IAAI,CAAC,QAAQ,CAAG,CAAE,EAAM,GAAG,CAAE,IAAI,CAAC,MAAM,EAEjC,IAAI,AAEZ,EAEA,qBAAA,EAEK,EAAK,IAAI,GAAM,OAAO,CACtB,EAAK,IAAI,GAAM,OAAO,CAEnB,SAAW,CAAC,CAAE,CAAC,CAAE,CAAC,EAExB,IAAI,EAAS,EAAG,UAAU,CAAE,EAAG,GAAI,KAAK,CAAE,EAAG,UAAU,CAAE,EAAG,IAAM,SAAS,GAM3E,OAFA,IAAI,CAAC,6BAA6B,CAAE,EAAQ,GAErC,IAAI,AAEZ,GAKD,KAAM,SAAW,CAAK,EAKrB,OAHA,IAAI,CAAC,MAAM,CAAC,IAAI,CAAE,EAAM,MAAM,EAC9B,IAAI,CAAC,QAAQ,CAAG,EAAM,QAAQ,CAEvB,IAAI,AAEZ,EAEA,UAAW,WAIV,IAAI,EAAsB,EAAM,IAAI,CAAC,MAAM,CAAC,MAAM,GAIlD,OAHA,IAAI,CAAC,MAAM,CAAC,cAAc,CAAE,GAC5B,IAAI,CAAC,QAAQ,EAAI,EAEV,IAAI,AAEZ,EAEA,OAAQ,WAKP,OAHA,IAAI,CAAC,QAAQ,EAAI,GACjB,IAAI,CAAC,MAAM,CAAC,MAAM,GAEX,IAAI,AAEZ,EAEA,gBAAiB,SAAW,CAAK,EAEhC,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAE,GAAU,IAAI,CAAC,QAAQ,AAEhD,EAEA,iBAAkB,SAAW,CAAM,EAElC,OAAO,IAAI,CAAC,eAAe,CAAE,EAAO,MAAM,EAAK,EAAO,MAAM,AAE7D,EAEA,aAAc,SAAW,CAAK,CAAE,CAAc,EAE7C,OAAO,IAAI,CAAC,UAAU,CAAE,EAAO,GAAiB,GAAG,CAAE,GAAQ,MAAM,EAEpE,EAEA,WAAY,SAAW,CAAK,CAAE,CAAc,EAE3C,IAAI,EAAyB,IAAI,CAAC,eAAe,CAAE,GAGnD,MAAO,AADM,CAAA,GAAkB,IAAI,GAAM,OAAO,AAAhD,EACc,IAAI,CAAE,IAAI,CAAC,MAAM,EAAG,cAAc,CAAE,EAEnD,EAEA,mBAAoB,SAAW,CAAI,EAIlC,IAAI,EAAY,IAAI,CAAC,eAAe,CAAE,EAAK,KAAK,EAC5C,EAAU,IAAI,CAAC,eAAe,CAAE,EAAK,GAAG,EAE5C,OAAS,EAAY,GAAK,EAAU,GAAS,EAAU,GAAK,EAAY,CAEzE,EAEA,aAAA,EAEK,EAAK,IAAI,GAAM,OAAO,CAEnB,SAAW,CAAI,CAAE,CAAc,EAErC,IAAI,EAAS,GAAkB,IAAI,GAAM,OAAO,CAE5C,EAAY,EAAK,KAAK,CAAE,GAExB,EAAc,IAAI,CAAC,MAAM,CAAC,GAAG,CAAE,GAEnC,GAAK,AAAe,GAAf,SAGJ,AAAI,AAAsC,GAAtC,IAAI,CAAC,eAAe,CAAE,EAAK,KAAK,EAE5B,EAAO,IAAI,CAAE,EAAK,KAAK,EAK/B,KAAA,EAID,IAAI,EAAI,CAAI,CAAA,EAAK,KAAK,CAAC,GAAG,CAAE,IAAI,CAAC,MAAM,EAAK,IAAI,CAAC,QAAO,AAAP,EAAa,EAE9D,GAAI,CAAA,CAAA,EAAI,CAAA,IAAK,CAAA,EAAI,CAAA,EAMjB,OAAO,EAAO,IAAI,CAAE,GAAY,cAAc,CAAE,GAAI,GAAG,CAAE,EAAK,KAAK,CAEpE,GAKD,cAAe,SAAW,CAAc,EAGvC,MAAO,AADM,CAAA,GAAkB,IAAI,GAAM,OAAO,AAAhD,EACc,IAAI,CAAE,IAAI,CAAC,MAAM,EAAG,cAAc,CAAE,CAAE,IAAI,CAAC,QAAQ,CAElE,EAEA,YAAA,EAEK,EAAK,IAAI,GAAM,OAAO,CACtB,EAAK,IAAI,GAAM,OAAO,CAEnB,SAAW,CAAM,CAAE,CAAoB,EAI7C,EAAuB,GAAwB,IAAI,GAAM,OAAO,GAAG,UAAU,CAAE,GAAS,SAAS,GACjG,IAAI,EAAY,EAAG,IAAI,CAAE,IAAI,CAAC,MAAM,EAAG,YAAY,CAAE,GAEjD,EAAmB,IAAI,CAAC,aAAa,CAAE,GAK3C,OAJA,EAAiB,YAAY,CAAE,GAE/B,IAAI,CAAC,6BAA6B,CAAE,EAAW,GAExC,IAAI,AAEZ,GAID,UAAW,SAAW,CAAM,EAI3B,OAFA,IAAI,CAAC,QAAQ,CAAG,IAAI,CAAC,QAAQ,CAAG,EAAO,GAAG,CAAE,IAAI,CAAC,MAAM,EAEhD,IAAI,AAEZ,EAEA,OAAQ,SAAW,CAAK,EAEvB,OAAO,EAAM,MAAM,CAAC,MAAM,CAAE,IAAI,CAAC,MAAM,GAAQ,EAAM,QAAQ,EAAI,IAAI,CAAC,QAAQ,AAE/E,EAEA,MAAO,WAEN,OAAO,IAAI,GAAM,KAAK,GAAG,IAAI,CAAE,IAAI,CAEpC,CAED,GAKA,GAAM,IAAI,CAAG,CAIZ,MAAO,SAAW,CAAC,CAAE,CAAC,CAAE,CAAC,EAExB,OAAS,EAAI,EAAM,EAAM,EAAM,EAAM,EAAI,CAE1C,EAIA,YAAa,SAAW,CAAC,CAAE,CAAC,EAE3B,OAAO,EAAI,EAAI,EAAI,CAEpB,EAIA,UAAW,SAAW,CAAC,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,EAEtC,OAAO,EAAO,AAAA,CAAA,EAAI,CAAA,EAAS,CAAA,EAAK,CAAA,EAAS,CAAA,EAAK,CAAA,CAE/C,EAIA,WAAY,SAAW,CAAC,CAAE,CAAG,CAAE,CAAG,SAEjC,AAAK,GAAK,EAAa,EAClB,GAAK,EAAa,EAIhB,AAFP,CAAA,EAAM,AAAA,CAAA,EAAI,CAAA,EAAQ,CAAA,EAAM,CAAA,CAAE,EAEjB,EAAG,CAAA,EAAI,EAAE,CAAA,CAEnB,EAEA,aAAc,SAAW,CAAC,CAAE,CAAG,CAAE,CAAG,SAEnC,AAAK,GAAK,EAAa,EAClB,GAAK,EAAa,EAIhB,AAFP,CAAA,EAAM,AAAA,CAAA,EAAI,CAAA,EAAQ,CAAA,EAAM,CAAA,CAAE,EAEjB,EAAE,EAAG,CAAA,EAAG,CAAA,AAAE,EAAF,EAAM,EAAA,EAAM,EAAA,CAE9B,EAKA,SAAU,WAET,MAAO,AAAE,CAAA,MAAQ,KAAK,MAAM,GAAK,IAAM,KAAK,MAAM,EAAA,EAAO,KAE1D,EAIA,QAAS,SAAW,CAAG,CAAE,CAAI,EAE5B,OAAO,EAAM,KAAK,KAAK,CAAE,KAAK,MAAM,GAAO,CAAA,EAAO,EAAM,CAAA,EAEzD,EAIA,UAAW,SAAW,CAAG,CAAE,CAAI,EAE9B,OAAO,EAAM,KAAK,MAAM,GAAO,CAAA,EAAO,CAAA,CAEvC,EAIA,gBAAiB,SAAW,CAAK,EAEhC,OAAO,EAAU,CAAA,GAAM,KAAK,MAAM,EAAA,CAEnC,EAEA,KAAM,SAAW,CAAC,EAEjB,OAAS,EAAI,EAAM,GAAO,EAAM,EAAM,EAAI,CAE3C,EAEA,QAAA,EAEK,EAAwB,KAAK,EAAE,CAAG,IAE/B,SAAW,CAAO,EAExB,OAAO,EAAU,CAElB,GAID,QAAA,EAEK,EAAwB,IAAM,KAAK,EAAE,CAElC,SAAW,CAAO,EAExB,OAAO,EAAU,CAElB,EAIF,EASA,GAAM,MAAM,CAAG,SAAW,CAAM,EAE/B,IAAI,CAAC,MAAM,CAAG,EAEd,IACA,EAAO,EAAU,EAAQ,EAAI,EAC7B,EAAI,EAAI,EAAI,EAFR,EAAI,EAAE,CAAE,EAAK,CAAE,EAAG,EAAG,EAAG,EAAG,EAAG,CAAE,EA0JpC,SAAS,EAAa,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAC,CAAE,CAAE,CAAE,CAAE,EAE9C,IAAI,EAAO,AAAA,CAAA,EAAK,CAAA,EAAO,GACtB,EAAK,AAAE,CAAA,EAAK,CAAA,EAAO,GAEpB,MAAO,AAAE,CAAA,EAAM,CAAA,EAAK,CAAA,EAAO,EAAK,CAAA,EAAO,EAAO,AAAA,CAAA,GAAQ,CAAA,EAAK,CAAA,EAAO,EAAI,EAAK,CAAA,EAAO,EAAK,EAAK,EAAI,CAEjG,CA7JA,IAAI,CAAC,aAAa,CAAG,SAAU,CAAC,EAE/B,IAAI,CAAC,MAAM,CAAG,EAAE,CAEhB,IAAM,IAAI,EAAI,EAAG,EAAI,EAAE,MAAM,CAAE,IAE9B,IAAI,CAAC,MAAM,CAAE,EAAG,CAAG,CAAE,EAAG,CAAC,CAAE,EAAG,CAAE,EAAG,CAAE,EAAG,CAAC,CAAE,EAAG,CAAE,EAAG,CAAE,EAAG,CAAC,CAAE,EAAG,CAAE,EAAG,AAAC,CAItE,EAEA,IAAI,CAAC,QAAQ,CAAG,SAAW,CAAC,EAuB3B,OApBA,EAAW,KAAK,KAAK,CADrB,EAAQ,AAAE,CAAA,IAAI,CAAC,MAAM,CAAC,MAAM,CAAG,CAAA,EAAM,GAErC,EAAS,EAAQ,EAEjB,CAAC,CAAE,EAAG,CAAG,AAAa,IAAb,EAAiB,EAAW,EAAW,EAChD,CAAC,CAAE,EAAG,CAAG,EACT,CAAC,CAAE,EAAG,CAAG,EAAY,IAAI,CAAC,MAAM,CAAC,MAAM,CAAG,EAAI,IAAI,CAAC,MAAM,CAAC,MAAM,CAAG,EAAI,EAAW,EAClF,CAAC,CAAE,EAAG,CAAG,EAAY,IAAI,CAAC,MAAM,CAAC,MAAM,CAAG,EAAI,IAAI,CAAC,MAAM,CAAC,MAAM,CAAG,EAAI,EAAW,EAElF,EAAK,IAAI,CAAC,MAAM,CAAE,CAAC,CAAE,EAAG,CAAE,CAC1B,EAAK,IAAI,CAAC,MAAM,CAAE,CAAC,CAAE,EAAG,CAAE,CAC1B,EAAK,IAAI,CAAC,MAAM,CAAE,CAAC,CAAE,EAAG,CAAE,CAC1B,EAAK,IAAI,CAAC,MAAM,CAAE,CAAC,CAAE,EAAG,CAAE,CAE1B,EAAK,EAAS,EACd,EAAK,EAAS,EAEd,EAAG,CAAC,CAAG,EAAa,EAAG,CAAC,CAAE,EAAG,CAAC,CAAE,EAAG,CAAC,CAAE,EAAG,CAAC,CAAE,EAAQ,EAAI,GACxD,EAAG,CAAC,CAAG,EAAa,EAAG,CAAC,CAAE,EAAG,CAAC,CAAE,EAAG,CAAC,CAAE,EAAG,CAAC,CAAE,EAAQ,EAAI,GACxD,EAAG,CAAC,CAAG,EAAa,EAAG,CAAC,CAAE,EAAG,CAAC,CAAE,EAAG,CAAC,CAAE,EAAG,CAAC,CAAE,EAAQ,EAAI,GAEjD,CAER,EAEA,IAAI,CAAC,qBAAqB,CAAG,WAE5B,IAAI,EAAG,EAAG,EAAI,IAAI,CAAC,MAAM,CAAC,MAAM,CAC/B,EAAS,EAAE,CAEZ,IAAM,EAAI,EAAG,EAAI,EAAG,IAEnB,EAAI,IAAI,CAAC,MAAM,CAAE,EAAG,CACpB,CAAM,CAAE,EAAG,CAAG,CAAE,EAAE,CAAC,CAAE,EAAE,CAAC,CAAE,EAAE,CAAC,CAAE,CAIhC,OAAO,CAER,EAIA,IAAI,CAAC,SAAS,CAAG,SAAW,CAAa,EAExC,IAAI,EAAG,EAAO,EAAU,EACZ,EAAW,EAAG,EAAc,EACvC,EAAc,IAAI,GAAM,OAAO,CAC/B,EAAS,IAAI,GAAM,OAAO,CAC1B,EAAe,EAAE,CACjB,EAAc,EAYf,IARA,CAAY,CAAE,EAAG,CAAG,EAEd,GAAgB,CAAA,EAAgB,GAAtC,EAEA,EAAW,IAAI,CAAC,MAAM,CAAC,MAAM,CAAG,EAEhC,EAAY,IAAI,CAAE,IAAI,CAAC,MAAM,CAAE,EAAG,EAE5B,EAAI,EAAG,EAAI,EAAU,IAE1B,EAAQ,EAAI,EAEZ,EAAW,IAAI,CAAC,QAAQ,CAAE,GAC1B,EAAO,IAAI,CAAE,GAEb,GAAe,EAAO,UAAU,CAAE,GAElC,EAAY,IAAI,CAAE,GAGlB,CAAA,EAAW,KAAK,KAAK,CADb,AAAE,CAAA,IAAI,CAAC,MAAM,CAAC,MAAM,CAAG,CAAA,EAAM,EACrC,GAEiB,IAEhB,CAAY,CAAE,EAAU,CAAG,EAC3B,EAAc,GAUhB,OAFA,CAAY,CAAE,EAAa,MAAM,CAAE,CAAG,EAE/B,CAAE,OAAQ,EAAc,MAAO,CAAY,CAEnD,EAEA,IAAI,CAAC,wBAAwB,CAAG,SAAW,CAAY,EAEtD,IAAI,EAAG,EACN,EAAO,EAAc,EAErB,EAAU,EACV,EAAY,EAAE,CACd,EAAS,IAAI,GAAM,OAAO,CAC1B,EAAK,IAAI,CAAC,SAAS,GAIpB,IAFA,EAAU,IAAI,CAAE,EAAO,IAAI,CAAE,IAAI,CAAC,MAAM,CAAE,EAAG,EAAG,KAAK,IAE/C,EAAI,EAAG,EAAI,IAAI,CAAC,MAAM,CAAC,MAAM,CAAE,IAAM,CAY1C,IAAM,EAAI,EALV,EAAW,KAAK,IAAI,CAAE,EAFP,CAAA,EAAG,MAAM,CAAE,EAAG,CAAG,EAAG,MAAM,CAAE,EAAI,EAAG,AAAH,EAEK,EAAG,KAAK,EAE5D,EAAe,AAAE,CAAA,EAAI,CAAA,EAAQ,CAAA,IAAI,CAAC,MAAM,CAAC,MAAM,CAAG,CAAA,EAClD,EAAY,EAAM,CAAA,IAAI,CAAC,MAAM,CAAC,MAAM,CAAG,CAAA,EAE1B,EAAI,EAAW,EAAG,IAE9B,EAAQ,EAAe,AAAM,EAAI,EAAV,EAAyB,CAAA,EAAY,CAAA,EAE5D,EAAW,IAAI,CAAC,QAAQ,CAAE,GAC1B,EAAU,IAAI,CAAE,EAAO,IAAI,CAAE,GAAW,KAAK,IAI9C,EAAU,IAAI,CAAE,EAAO,IAAI,CAAE,IAAI,CAAC,MAAM,CAAE,EAAG,EAAG,KAAK,GAEtD,CAEA,IAAI,CAAC,MAAM,CAAG,CAEf,CAaD,EAMA,GAAM,QAAQ,CAAG,SAAW,CAAC,CAAE,CAAC,CAAE,CAAC,EAElC,IAAI,CAAC,CAAC,CAAK,AAAM,KAAA,IAAN,EAAoB,EAAI,IAAI,GAAM,OAAO,CACpD,IAAI,CAAC,CAAC,CAAK,AAAM,KAAA,IAAN,EAAoB,EAAI,IAAI,GAAM,OAAO,CACpD,IAAI,CAAC,CAAC,CAAK,AAAM,KAAA,IAAN,EAAoB,EAAI,IAAI,GAAM,OAAO,AAErD,EAEA,GAAM,QAAQ,CAAC,MAAM,EAEhB,EAAK,IAAI,GAAM,OAAO,CAEnB,SAAU,CAAC,CAAE,CAAC,CAAE,CAAC,CAAE,CAAc,EAEvC,IAAI,EAAS,GAAkB,IAAI,GAAM,OAAO,CAEhD,EAAO,UAAU,CAAE,EAAG,GACtB,EAAG,UAAU,CAAE,EAAG,GAClB,EAAO,KAAK,CAAE,GAEd,IAAI,EAAiB,EAAO,QAAQ,UACpC,AAAI,EAAiB,EAEb,EAAO,cAAc,CAAE,EAAI,KAAK,IAAI,CAAE,IAIvC,EAAO,GAAG,CAAE,EAAG,EAAG,EAE1B,GAMD,GAAM,QAAQ,CAAC,kBAAkB,EAE5B,EAAK,IAAI,GAAM,OAAO,CACzB,EAAK,IAAI,GAAM,OAAO,CACtB,EAAK,IAAI,GAAM,OAAO,CAEhB,SAAW,CAAK,CAAE,CAAC,CAAE,CAAC,CAAE,CAAC,CAAE,CAAc,EAE/C,EAAG,UAAU,CAAE,EAAG,GAClB,EAAG,UAAU,CAAE,EAAG,GAClB,EAAG,UAAU,CAAE,EAAO,GAEtB,IAAI,EAAQ,EAAG,GAAG,CAAE,GAChB,EAAQ,EAAG,GAAG,CAAE,GAChB,EAAQ,EAAG,GAAG,CAAE,GAChB,EAAQ,EAAG,GAAG,CAAE,GAChB,EAAQ,EAAG,GAAG,CAAE,GAEhB,EAAU,EAAQ,EAAQ,EAAQ,EAElC,EAAS,GAAkB,IAAI,GAAM,OAAO,CAGhD,GAAI,AAAS,GAAT,EAGH,OAAO,EAAO,GAAG,CAAE,GAAI,GAAI,IAG5B,IAAI,EAAW,EAAI,EACf,EAAI,AAAE,CAAA,EAAQ,EAAQ,EAAQ,CAAA,EAAU,EACxC,EAAI,AAAE,CAAA,EAAQ,EAAQ,EAAQ,CAAA,EAAU,EAG5C,OAAO,EAAO,GAAG,CAAE,EAAI,EAAI,EAAG,EAAG,EAElC,GAID,GAAM,QAAQ,CAAC,aAAa,EAEvB,EAAK,IAAI,GAAM,OAAO,CAEnB,SAAW,CAAK,CAAE,CAAC,CAAE,CAAC,CAAE,CAAC,EAE/B,IAAI,EAAS,GAAM,QAAQ,CAAC,kBAAkB,CAAE,EAAO,EAAG,EAAG,EAAG,GAEhE,OAAS,EAAO,CAAC,EAAI,GAAS,EAAO,CAAC,EAAI,GAAW,EAAO,CAAC,CAAG,EAAO,CAAC,EAAM,CAE/E,GAID,GAAM,MAAM,CAAE,GAAM,QAAQ,CAAC,SAAS,CAAE,CAEvC,YAAa,GAAM,QAAQ,CAE3B,IAAK,SAAW,CAAC,CAAE,CAAC,CAAE,CAAC,EAMtB,OAJA,IAAI,CAAC,CAAC,CAAC,IAAI,CAAE,GACb,IAAI,CAAC,CAAC,CAAC,IAAI,CAAE,GACb,IAAI,CAAC,CAAC,CAAC,IAAI,CAAE,GAEN,IAAI,AAEZ,EAEA,wBAAyB,SAAW,CAAM,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,EAMrD,OAJA,IAAI,CAAC,CAAC,CAAC,IAAI,CAAE,CAAM,CAAC,EAAG,EACvB,IAAI,CAAC,CAAC,CAAC,IAAI,CAAE,CAAM,CAAC,EAAG,EACvB,IAAI,CAAC,CAAC,CAAC,IAAI,CAAE,CAAM,CAAC,EAAG,EAEhB,IAAI,AAEZ,EAEA,KAAM,SAAW,CAAQ,EAMxB,OAJA,IAAI,CAAC,CAAC,CAAC,IAAI,CAAE,EAAS,CAAC,EACvB,IAAI,CAAC,CAAC,CAAC,IAAI,CAAE,EAAS,CAAC,EACvB,IAAI,CAAC,CAAC,CAAC,IAAI,CAAE,EAAS,CAAC,EAEhB,IAAI,AAEZ,EAEA,IAAA,EAEK,EAAK,IAAI,GAAM,OAAO,CACtB,EAAK,IAAI,GAAM,OAAO,CAEnB,WAKN,OAHA,EAAG,UAAU,CAAE,IAAI,CAAC,CAAC,CAAE,IAAI,CAAC,CAAC,EAC7B,EAAG,UAAU,CAAE,IAAI,CAAC,CAAC,CAAE,IAAI,CAAC,CAAC,EAEtB,AAA0B,GAA1B,EAAG,KAAK,CAAE,GAAK,MAAM,EAE7B,GAID,SAAU,SAAW,CAAc,EAGlC,MAAO,AADM,CAAA,GAAkB,IAAI,GAAM,OAAO,AAAhD,EACc,UAAU,CAAE,IAAI,CAAC,CAAC,CAAE,IAAI,CAAC,CAAC,EAAG,GAAG,CAAE,IAAI,CAAC,CAAC,EAAG,cAAc,CAAE,EAAI,EAE9E,EAEA,OAAQ,SAAW,CAAc,EAEhC,OAAO,GAAM,QAAQ,CAAC,MAAM,CAAE,IAAI,CAAC,CAAC,CAAE,IAAI,CAAC,CAAC,CAAE,IAAI,CAAC,CAAC,CAAE,EAEvD,EAEA,MAAO,SAAW,CAAc,EAI/B,MAAO,AAFM,CAAA,GAAkB,IAAI,GAAM,KAAK,AAA9C,EAEc,qBAAqB,CAAE,IAAI,CAAC,CAAC,CAAE,IAAI,CAAC,CAAC,CAAE,IAAI,CAAC,CAAC,CAE5D,EAEA,mBAAoB,SAAW,CAAK,CAAE,CAAc,EAEnD,OAAO,GAAM,QAAQ,CAAC,kBAAkB,CAAE,EAAO,IAAI,CAAC,CAAC,CAAE,IAAI,CAAC,CAAC,CAAE,IAAI,CAAC,CAAC,CAAE,EAE1E,EAEA,cAAe,SAAW,CAAK,EAE9B,OAAO,GAAM,QAAQ,CAAC,aAAa,CAAE,EAAO,IAAI,CAAC,CAAC,CAAE,IAAI,CAAC,CAAC,CAAE,IAAI,CAAC,CAAC,CAEnE,EAEA,OAAQ,SAAW,CAAQ,EAE1B,OAAO,EAAS,CAAC,CAAC,MAAM,CAAE,IAAI,CAAC,CAAC,GAAM,EAAS,CAAC,CAAC,MAAM,CAAE,IAAI,CAAC,CAAC,GAAM,EAAS,CAAC,CAAC,MAAM,CAAE,IAAI,CAAC,CAAC,CAE/F,EAEA,MAAO,WAEN,OAAO,IAAI,GAAM,QAAQ,GAAG,IAAI,CAAE,IAAI,CAEvC,CAED,GAKA,GAAM,MAAM,CAAG,SAAW,CAAC,EAG1B,OADA,QAAQ,IAAI,CAAE,gEACP,CAER,EAKA,GAAM,EAAE,CAAG,SAAW,CAAC,CAAE,CAAC,EAGzB,OADA,QAAQ,IAAI,CAAE,4DACP,IAAI,GAAM,OAAO,CAAE,EAAG,EAE9B,EAKA,GAAM,KAAK,CAAG,SAAW,CAAS,EAEjC,IAAI,CAAC,SAAS,CAAG,AAAgB,KAAA,IAAhB,GAA8B,EAE/C,IAAI,CAAC,SAAS,CAAG,EACjB,IAAI,CAAC,OAAO,CAAG,EACf,IAAI,CAAC,WAAW,CAAG,EAEnB,IAAI,CAAC,OAAO,CAAG,CAAA,CAEhB,EAEA,GAAM,MAAM,CAAE,GAAM,KAAK,CAAC,SAAS,CAAE,CAEpC,MAAO,WAEN,IAAI,CAAC,SAAS,CAAG,AAAuB,KAAA,IAAvB,OAAO,WAAW,EAAkB,AAA2B,KAAA,IAA3B,OAAO,WAAW,CAAC,GAAG,CACtE,OAAO,WAAW,CAAC,GAAG,GACtB,KAAK,GAAG,GAEb,IAAI,CAAC,OAAO,CAAG,IAAI,CAAC,SAAS,CAC7B,IAAI,CAAC,OAAO,CAAG,CAAA,CAChB,EAEA,KAAM,WAEL,IAAI,CAAC,cAAc,GACnB,IAAI,CAAC,OAAO,CAAG,CAAA,CAEhB,EAEA,eAAgB,WAGf,OADA,IAAI,CAAC,QAAQ,GACN,IAAI,CAAC,WAAW,AAExB,EAEA,SAAU,WAET,IAAI,EAAO,EAQX,GANK,IAAI,CAAC,SAAS,EAAI,CAAE,IAAI,CAAC,OAAO,EAEpC,IAAI,CAAC,KAAK,GAIN,IAAI,CAAC,OAAO,CAAG,CAEnB,IAAI,EAAU,AAAuB,KAAA,IAAvB,OAAO,WAAW,EAAkB,AAA2B,KAAA,IAA3B,OAAO,WAAW,CAAC,GAAG,CACpE,OAAO,WAAW,CAAC,GAAG,GACtB,KAAK,GAAG,GAEZ,EAAO,KAAU,CAAA,EAAU,IAAI,CAAC,OAAO,AAAP,EAChC,IAAI,CAAC,OAAO,CAAG,EAEf,IAAI,CAAC,WAAW,EAAI,CAErB,CAEA,OAAO,CAER,CAED,GAKA,GAAM,eAAe,CAAG,WAEvB,IAAI,EAAY,CAAC,CAEjB,CAAA,IAAI,CAAC,gBAAgB,CAAG,SAAW,CAAI,CAAE,CAAQ,EAErB,KAAA,IAAtB,CAAS,CAAE,EAAM,EAErB,CAAA,CAAS,CAAE,EAAM,CAAG,EAAE,AAAF,EAI0B,KAA1C,CAAS,CAAE,EAAM,CAAC,OAAO,CAAE,IAE/B,CAAS,CAAE,EAAM,CAAC,IAAI,CAAE,EAI1B,EAEA,IAAI,CAAC,mBAAmB,CAAG,SAAW,CAAI,CAAE,CAAQ,EAEnD,IAAI,EAAQ,CAAS,CAAE,EAAM,CAAC,OAAO,CAAE,EAExB,CAAA,KAAV,GAEJ,CAAS,CAAE,EAAM,CAAC,MAAM,CAAE,EAAO,EAInC,EAEA,IAAI,CAAC,aAAa,CAAG,SAAW,CAAK,EAEpC,IAAI,EAAgB,CAAS,CAAE,EAAM,IAAI,CAAE,CAE3C,GAAK,AAAkB,KAAA,IAAlB,EAA8B,CAElC,EAAM,MAAM,CAAG,IAAI,CAEnB,IAAM,IAAI,EAAI,EAAG,EAAI,EAAc,MAAM,CAAE,EAAI,EAAG,IAEjD,CAAa,CAAE,EAAG,CAAC,IAAI,CAAE,IAAI,CAAE,EAIjC,CAED,CAED,EAQC,AAmOE,GAnOI,SAAS,CAAG,SAAW,CAAM,CAAE,CAAS,CAAE,CAAI,CAAE,CAAG,EAExD,IAAI,CAAC,GAAG,CAAG,IAAI,AAiOd,GAjOoB,GAAG,CAAE,EAAQ,GAG9B,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,QAAQ,GAAK,GAEnC,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,SAAS,GAI7B,IAAI,CAAC,IAAI,CAAG,GAAQ,EACpB,IAAI,CAAC,GAAG,CAAG,GAAO,GAEnB,EAEI,EAAS,IAAI,AAmNf,GAnNqB,MAAM,CACzB,EAAW,IAAI,AAkNjB,GAlNuB,GAAG,CACxB,EAAY,IAAI,AAiNlB,GAjNwB,KAAK,CAC3B,EAAiB,IAAI,AAgNvB,GAhN6B,OAAO,CAClC,EAAiB,IAAI,AA+MvB,GA/M6B,OAAO,CAElC,EAAgB,IAAI,AA6MtB,GA7M4B,OAAO,CAEjC,EAAW,SAAW,CAAC,CAAE,CAAC,EAE7B,OAAO,EAAE,QAAQ,CAAG,EAAE,QAAQ,AAE/B,EAEI,EAAkB,SAAW,CAAM,CAAE,CAAS,CAAE,CAAU,EAE7D,GAAK,aAAkB,AAmMtB,GAnM4B,QAAQ,CAAG,CAEvC,EAAe,qBAAqB,CAAE,EAAO,WAAW,EACxD,IAAI,EAAW,EAAU,GAAG,CAAC,eAAe,CAAE,GAE9C,GAAK,EAAW,EAAO,KAAK,CAAC,CAAC,CAE7B,OAAO,EAIR,EAAW,IAAI,CAAE,CAEhB,SAAU,EACV,MAAO,EAAO,QAAQ,CACtB,KAAM,KACN,OAAQ,CAET,EAED,MAAO,GAAK,aAAkB,AA+K7B,GA/KmC,IAAI,CAAG,CAQ1C,GALA,EAAe,qBAAqB,CAAE,EAAO,WAAW,EACxD,EAAO,GAAG,CACT,EACA,EAAO,QAAQ,CAAC,cAAc,CAAC,MAAM,CAAG,EAAO,WAAW,CAAC,iBAAiB,IAExE,CAAE,EAAU,GAAG,CAAC,oBAAoB,CAAE,GAE1C,OAAO,EAMR,IAQI,EAAG,EAAG,EAAG,EART,EAAW,EAAO,QAAQ,CAC1B,EAAW,EAAS,QAAQ,CAE5B,EAAiB,EAAO,QAAQ,YAAY,AA4JhD,GA5JsD,gBAAgB,CAClE,EAAkB,AAAmB,CAAA,IAAnB,EAA0B,EAAO,QAAQ,CAAC,SAAS,CAAG,KAExE,EAAO,EAAO,QAAQ,CAAC,IAAI,CAG3B,EAAY,EAAU,SAAS,CAEnC,EAAO,mBAAmB,CAAC,eAAe,CAAE,EAAO,WAAW,EAE9D,EAAc,UAAU,CAAE,EAAO,WAAW,EAE5C,EAAS,IAAI,CAAE,EAAU,GAAG,EAAG,YAAY,CAAE,GAE7C,IAAM,IAAI,EAAI,EAAG,EAAK,EAAS,KAAK,CAAC,MAAM,CAAE,EAAI,EAAI,IAAO,CAE3D,IAAI,EAAO,EAAS,KAAK,CAAE,EAAG,CAE1B,EAAW,AAAmB,CAAA,IAAnB,EAA0B,CAAe,CAAE,EAAK,aAAa,CAAE,CAAG,EAAO,QAAQ,CAEhG,GAAK,AAAa,KAAA,IAAb,GAEL,EAAU,6BAA6B,CAAE,EAAK,MAAM,CAAE,CAAQ,CAAC,EAAK,CAAC,CAAC,EAEtE,IAAI,EAAgB,EAAS,eAAe,CAAE,GAG9C,IAAK,CAAA,KAAK,GAAG,CAAE,GAAkB,CAAA,IAG5B,CAAA,EAAgB,CAAA,GAIrB,GAAI,AADJ,CAAA,EAAO,EAAS,IAAI,AAAJ,IACH,AA0Hd,GA1HoB,UAAU,CAAG,CAE/B,IAAI,EAAY,EAAS,SAAS,CAAC,GAAG,CAAE,EAAU,MAAM,EAExD,GAAI,CAAI,CAAA,IAAS,AAsHnB,GAtHyB,SAAS,CAAG,EAAY,EAAI,EAAY,CAAA,EAAM,QAEtE,CAGA,GAAK,CAAA,CAAA,EAAgB,EAAU,IAAI,AAAJ,IAAQ,CAAA,EAAgB,EAAU,GAAG,AAAH,GAIjE,GAFA,EAAiB,EAAS,EAAE,CAAE,EAAe,GAExC,aAAgB,AA6GtB,GA7G4B,KAAK,CAM/B,CAAA,GAJA,EAAI,CAAQ,CAAE,EAAK,CAAC,CAAE,CACtB,EAAI,CAAQ,CAAE,EAAK,CAAC,CAAE,CACtB,EAAI,CAAQ,CAAE,EAAK,CAAC,CAAE,CAEjB,CAAE,AAuGT,GAvGe,QAAQ,CAAC,aAAa,CAAE,EAAgB,EAAG,EAAG,GAAM,QAAjE,MAEM,GAAK,aAAgB,AAqG7B,GArGmC,KAAK,CAOtC,CAAA,GALA,EAAI,CAAQ,CAAE,EAAK,CAAC,CAAE,CACtB,EAAI,CAAQ,CAAE,EAAK,CAAC,CAAE,CACtB,EAAI,CAAQ,CAAE,EAAK,CAAC,CAAE,CACtB,EAAI,CAAQ,CAAE,EAAK,CAAC,CAAE,CAEf,CAAE,AA8FX,GA9FiB,QAAQ,CAAC,aAAa,CAAE,EAAgB,EAAG,EAAG,IACzD,CAAE,AA6FR,GA7Fc,QAAQ,CAAC,aAAa,CAAE,EAAgB,EAAG,EAAG,GAAQ,QADlE,MAOA,MAAM,MAAO,2BAId,EAAW,IAAI,CAAE,CAEhB,SAAU,EACV,MAAO,EAAU,GAAG,CAAC,EAAE,CAAE,GACzB,KAAM,EACN,UAAW,EACX,OAAQ,CAET,KAED,CAED,CAED,EAEI,EAAuB,SAAW,CAAM,CAAE,CAAS,CAAE,CAAU,EAIlE,IAAM,IAFF,EAAc,EAAO,cAAc,GAE7B,EAAI,EAAG,EAAI,EAAY,MAAM,CAAE,EAAI,EAAG,IAE/C,EAAiB,CAAW,CAAE,EAAG,CAAE,EAAW,EAGhD,EAIA,AAsDE,GAtDI,SAAS,CAAC,SAAS,CAAC,SAAS,CAAG,KAEtC,AAoDE,GApDI,SAAS,CAAC,SAAS,CAAC,GAAG,CAAG,SAAW,CAAM,CAAE,CAAS,EAE3D,IAAI,CAAC,GAAG,CAAC,GAAG,CAAE,EAAQ,GAGlB,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,MAAM,GAAK,GAEjC,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,SAAS,EAI9B,EAEA,AAuCE,GAvCI,SAAS,CAAC,SAAS,CAAC,eAAe,CAAG,SAAW,CAAM,CAAE,CAAS,EAEvE,IAAI,EAAa,EAAE,CAYnB,MAVmB,CAAA,IAAd,GAEJ,EAAsB,EAAQ,IAAI,CAAE,GAIrC,EAAiB,EAAQ,IAAI,CAAE,GAE/B,EAAW,IAAI,CAAE,GAEV,CAER,EAEA,AAqBE,GArBI,SAAS,CAAC,SAAS,CAAC,gBAAgB,CAAG,SAAW,CAAO,CAAE,CAAS,EAIzE,IAAM,IAFF,EAAa,EAAE,CAET,EAAI,EAAG,EAAI,EAAQ,MAAM,CAAE,EAAI,EAAG,IAE3C,EAAiB,CAAO,CAAE,EAAG,CAAE,IAAI,CAAE,GAElB,CAAA,IAAd,GAEJ,EAAsB,CAAO,CAAE,EAAG,CAAE,IAAI,CAAE,GAO5C,OAFA,EAAW,IAAI,CAAE,GAEV,CAER,EASD,GAAM,QAAQ,CAAG,WAEhB,IAAI,CAAC,EAAE,CAAG,GAAM,eAAe,GAE/B,IAAI,CAAC,IAAI,CAAG,GACZ,IAAI,CAAC,UAAU,CAAG,CAAC,EAEnB,IAAI,CAAC,MAAM,CAAG,KAAA,EACd,IAAI,CAAC,QAAQ,CAAG,EAAE,CAElB,IAAI,CAAC,EAAE,CAAG,IAAI,GAAM,OAAO,CAAE,EAAG,EAAG,GAEnC,IAAI,CAAC,QAAQ,CAAG,IAAI,GAAM,OAAO,CACjC,IAAI,CAAC,QAAQ,CAAG,IAAI,GAAM,OAAO,CACjC,IAAI,CAAC,UAAU,CAAG,GAAM,QAAQ,CAAC,iBAAiB,CAClD,IAAI,CAAC,KAAK,CAAG,IAAI,GAAM,OAAO,CAAE,EAAG,EAAG,GAEtC,IAAI,CAAC,WAAW,CAAG,KAEnB,IAAI,CAAC,kBAAkB,CAAG,CAAA,EAE1B,IAAI,CAAC,MAAM,CAAG,IAAI,GAAM,OAAO,CAC/B,IAAI,CAAC,WAAW,CAAG,IAAI,GAAM,OAAO,CACpC,IAAI,CAAC,mBAAmB,CAAG,IAAI,GAAM,OAAO,CAE5C,IAAI,CAAC,gBAAgB,CAAG,CAAA,EACxB,IAAI,CAAC,sBAAsB,CAAG,CAAA,EAE9B,IAAI,CAAC,UAAU,CAAG,IAAI,GAAM,UAAU,CACtC,IAAI,CAAC,aAAa,CAAG,CAAA,EAErB,IAAI,CAAC,OAAO,CAAG,CAAA,EAEf,IAAI,CAAC,UAAU,CAAG,CAAA,EAClB,IAAI,CAAC,aAAa,CAAG,CAAA,EAErB,IAAI,CAAC,aAAa,CAAG,CAAA,EAErB,IAAI,CAAC,OAAO,CAAG,IAAI,GAAM,OAAO,AAEjC,EAGA,GAAM,QAAQ,CAAC,SAAS,CAAG,CAE1B,YAAa,GAAM,QAAQ,CAE3B,YAAa,SAAW,CAAM,EAE7B,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAAE,EAAQ,IAAI,CAAC,MAAM,EAEjD,IAAI,CAAC,KAAK,CAAC,kBAAkB,CAAE,IAAI,CAAC,MAAM,EAE1C,IAAI,EAAM,IAAI,GAAM,OAAO,GAAG,eAAe,CAAE,IAAI,CAAC,MAAM,EAC1D,IAAI,CAAC,QAAQ,CAAC,0BAA0B,CAAE,EAAK,IAAI,CAAC,UAAU,EAE9D,IAAI,CAAC,QAAQ,CAAC,qBAAqB,CAAE,IAAI,CAAC,MAAM,CAEjD,EAEA,UAAW,SAAW,CAAQ,CAAE,CAAI,EAEnC,IAAI,CAAC,MAAM,CAAC,UAAU,CAAE,GACxB,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAE,EAAK,cAAc,CAAE,GAEzC,EAEA,WAAY,SAAW,CAAQ,EAE9B,IAAI,CAAC,SAAS,CAAE,EAAU,IAAI,CAAC,OAAO,CAAC,GAAG,CAAE,EAAG,EAAG,GAEnD,EAEA,WAAY,SAAW,CAAQ,EAE9B,IAAI,CAAC,SAAS,CAAE,EAAU,IAAI,CAAC,OAAO,CAAC,GAAG,CAAE,EAAG,EAAG,GAEnD,EAEA,WAAY,SAAW,CAAQ,EAE9B,IAAI,CAAC,SAAS,CAAE,EAAU,IAAI,CAAC,OAAO,CAAC,GAAG,CAAE,EAAG,EAAG,GAEnD,EAEA,aAAc,SAAW,CAAM,EAE9B,OAAO,EAAO,YAAY,CAAE,IAAI,CAAC,WAAW,CAE7C,EAEA,aAAc,SAAW,CAAM,EAE9B,OAAO,EAAO,YAAY,CAAE,GAAM,QAAQ,CAAC,IAAI,CAAC,UAAU,CAAE,IAAI,CAAC,WAAW,EAE7E,EAEA,OAAQ,SAAW,CAAM,EAIxB,IAAI,CAAC,MAAM,CAAC,MAAM,CAAE,EAAQ,IAAI,CAAC,QAAQ,CAAE,IAAI,CAAC,EAAE,EAE7C,IAAI,CAAC,kBAAkB,GAEtB,AAAuB,CAAA,IAAvB,IAAI,CAAC,aAAa,CAEtB,IAAI,CAAC,QAAQ,CAAC,0BAA0B,CAAE,IAAI,CAAC,MAAM,CAAE,IAAI,CAAC,UAAU,EAItE,IAAI,CAAC,UAAU,CAAC,IAAI,CAAE,IAAI,CAAC,MAAM,CAAC,SAAS,EAAE,CAAE,EAAG,EAMrD,EAEA,IAAK,SAAW,CAAM,EAErB,GAAK,IAAW,IAAI,CAAG,CAEtB,QAAQ,IAAI,CAAE,sEACd,MAED,CAEA,GAAK,aAAkB,GAAM,QAAQ,CAAG,CAEhB,KAAA,IAAlB,EAAO,MAAM,EAEjB,EAAO,MAAM,CAAC,MAAM,CAAE,GAIvB,EAAO,MAAM,CAAG,IAAI,CACpB,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAE,GAMpB,IAFA,IAAI,EAAQ,IAAI,CAER,AAAiB,KAAA,IAAjB,EAAM,MAAM,EAEnB,EAAQ,EAAM,MAAM,AAIN,MAAA,IAAV,GAAuB,aAAiB,GAAM,KAAK,EAEvD,EAAM,WAAW,CAAE,EAIrB,CAED,EAEA,OAAQ,SAAW,CAAM,EAExB,IAAI,EAAQ,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAE,GAEnC,GAAK,AAAU,KAAV,EAAgB,CAEpB,EAAO,MAAM,CAAG,KAAA,EAChB,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAE,EAAO,GAM7B,IAFA,IAAI,EAAQ,IAAI,CAER,AAAiB,KAAA,IAAjB,EAAM,MAAM,EAEnB,EAAQ,EAAM,MAAM,AAIN,MAAA,IAAV,GAAuB,aAAiB,GAAM,KAAK,EAEvD,EAAM,cAAc,CAAE,EAIxB,CAED,EAEA,SAAU,SAAW,CAAQ,EAE5B,EAAU,IAAI,EAEd,IAAM,IAAI,EAAI,EAAG,EAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAE,EAAI,EAAG,IAEjD,IAAI,CAAC,QAAQ,CAAE,EAAG,CAAC,QAAQ,CAAE,EAI/B,EAEA,eAAgB,SAAW,CAAI,CAAE,CAAS,EAEzC,IAAM,IAAI,EAAI,EAAG,EAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAE,EAAI,EAAG,IAAO,CAExD,IAAI,EAAQ,IAAI,CAAC,QAAQ,CAAE,EAAG,CAE9B,GAAK,EAAM,IAAI,GAAK,GAMf,AAAc,CAAA,IAAd,GAIC,AAAU,KAAA,IAFf,CAAA,EAAQ,EAAM,cAAc,CAAE,EAAM,EAApC,EANA,OAAO,CAgBT,CAID,EAEA,eAAgB,SAAW,CAAK,EAEhB,KAAA,IAAV,GAAsB,CAAA,EAAQ,EAAE,AAAF,EAEnC,MAAM,SAAS,CAAC,IAAI,CAAC,KAAK,CAAE,EAAO,IAAI,CAAC,QAAQ,EAEhD,IAAM,IAAI,EAAI,EAAG,EAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAE,EAAI,EAAG,IAEjD,IAAI,CAAC,QAAQ,CAAE,EAAG,CAAC,cAAc,CAAE,GAIpC,OAAO,CAER,EAEA,aAAc,WAEb,IAAI,CAAC,MAAM,CAAC,WAAW,CAAE,IAAI,CAAC,QAAQ,EAEjC,AAAuB,CAAA,IAAvB,IAAI,CAAC,aAAa,CAEtB,IAAI,CAAC,MAAM,CAAC,oBAAoB,CAAE,IAAI,CAAC,QAAQ,CAAE,IAAI,CAAC,UAAU,EAIhE,IAAI,CAAC,MAAM,CAAC,yBAAyB,CAAE,IAAI,CAAC,UAAU,EAIlD,CAAA,AAAiB,IAAjB,IAAI,CAAC,KAAK,CAAC,CAAC,EAAU,AAAiB,IAAjB,IAAI,CAAC,KAAK,CAAC,CAAC,EAAU,AAAiB,IAAjB,IAAI,CAAC,KAAK,CAAC,CAAC,AAAK,GAEjE,IAAI,CAAC,MAAM,CAAC,KAAK,CAAE,IAAI,CAAC,KAAK,EAI9B,IAAI,CAAC,sBAAsB,CAAG,CAAA,CAE/B,EAEA,kBAAmB,SAAW,CAAK,EAEH,CAAA,IAA1B,IAAI,CAAC,gBAAgB,EAAY,IAAI,CAAC,YAAY,GAElD,CAAA,AAAgC,CAAA,IAAhC,IAAI,CAAC,sBAAsB,EAAa,AAAU,CAAA,IAAV,CAAU,IAEjD,AAAgB,KAAA,IAAhB,IAAI,CAAC,MAAM,CAEf,IAAI,CAAC,WAAW,CAAC,IAAI,CAAE,IAAI,CAAC,MAAM,EAIlC,IAAI,CAAC,WAAW,CAAC,gBAAgB,CAAE,IAAI,CAAC,MAAM,CAAC,WAAW,CAAE,IAAI,CAAC,MAAM,EAIxE,IAAI,CAAC,sBAAsB,CAAG,CAAA,EAE9B,EAAQ,CAAA,GAMT,IAAM,IAAI,EAAI,EAAG,EAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAE,EAAI,EAAG,IAEjD,IAAI,CAAC,QAAQ,CAAE,EAAG,CAAC,iBAAiB,CAAE,EAIxC,EAEA,MAAO,SAAW,CAAM,EAEP,KAAA,IAAX,GAAuB,CAAA,EAAS,IAAI,GAAM,QAAQ,AAAvD,EAEA,EAAO,IAAI,CAAG,IAAI,CAAC,IAAI,CAEvB,EAAO,EAAE,CAAC,IAAI,CAAE,IAAI,CAAC,EAAE,EAEvB,EAAO,QAAQ,CAAC,IAAI,CAAE,IAAI,CAAC,QAAQ,EAC9B,EAAO,QAAQ,YAAY,GAAM,OAAO,EAAG,EAAO,QAAQ,CAAC,IAAI,CAAE,IAAI,CAAC,QAAQ,EACnF,EAAO,UAAU,CAAG,IAAI,CAAC,UAAU,CACnC,EAAO,KAAK,CAAC,IAAI,CAAE,IAAI,CAAC,KAAK,EAE7B,EAAO,WAAW,CAAG,IAAI,CAAC,WAAW,CAErC,EAAO,kBAAkB,CAAG,IAAI,CAAC,kBAAkB,CAEnD,EAAO,MAAM,CAAC,IAAI,CAAE,IAAI,CAAC,MAAM,EAC/B,EAAO,WAAW,CAAC,IAAI,CAAE,IAAI,CAAC,WAAW,EACzC,EAAO,mBAAmB,CAAC,IAAI,CAAE,IAAI,CAAC,mBAAmB,EAEzD,EAAO,gBAAgB,CAAG,IAAI,CAAC,gBAAgB,CAC/C,EAAO,sBAAsB,CAAG,IAAI,CAAC,sBAAsB,CAE3D,EAAO,UAAU,CAAC,IAAI,CAAE,IAAI,CAAC,UAAU,EACvC,EAAO,aAAa,CAAG,IAAI,CAAC,aAAa,CAEzC,EAAO,OAAO,CAAG,IAAI,CAAC,OAAO,CAE7B,EAAO,UAAU,CAAG,IAAI,CAAC,UAAU,CACnC,EAAO,aAAa,CAAG,IAAI,CAAC,aAAa,CAEzC,EAAO,aAAa,CAAG,IAAI,CAAC,aAAa,CAEzC,IAAM,IAAI,EAAI,EAAG,EAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAE,IAAO,CAEjD,IAAI,EAAQ,IAAI,CAAC,QAAQ,CAAE,EAAG,CAC9B,EAAO,GAAG,CAAE,EAAM,KAAK,GAExB,CAEA,OAAO,CAER,CAED,EAEA,GAAM,QAAQ,CAAC,IAAI,CAAG,IAAI,GAAM,OAAO,CACvC,GAAM,QAAQ,CAAC,iBAAiB,CAAG,MAEnC,GAAM,eAAe,CAAG,EAOxB,GAAM,SAAS,CAAG,WAEjB,IAAI,EAAS,EACb,EAAS,EACT,EAAO,EACP,EACA,EAAO,EACP,EAAW,EAeX,EApB2B,EAAc,EAAE,CAAE,EAAoB,EAC1C,EAAc,EAAE,CAAE,EAAoB,EACzC,EAAa,EAAE,CAAE,EAAmB,EAC3C,EAAa,EAAE,CAAE,EAAmB,EAC9B,EAAY,EAAE,CAAE,EAAkB,EAC1B,EAAgB,EAAE,CAAE,EAAsB,EAErE,EAAc,CAAE,QAAS,EAAE,CAAE,QAAS,EAAE,CAAE,OAAQ,EAAE,CAAE,SAAU,EAAE,AAAC,EAEnE,EAAW,IAAI,GAAM,OAAO,CAC5B,EAAW,IAAI,GAAM,OAAO,CAE5B,EAAW,IAAI,GAAM,IAAI,CAAE,IAAI,GAAM,OAAO,CAAE,GAAI,GAAI,IAAM,IAAI,GAAM,OAAO,CAAE,EAAG,EAAG,IACrF,EAAe,IAAI,GAAM,IAAI,CAC7B,EAAW,KAAW,CACtB,EAAW,MAAW,CAEtB,EAAc,IAAI,GAAM,OAAO,CAC/B,EAAwB,IAAI,GAAM,OAAO,CAGzC,EAA6B,IAAI,GAAM,OAAO,CAE9C,EAAgB,IAAI,GAAM,OAAO,CACjC,EAAoB,IAAI,GAAM,OAAO,CAErC,EAAY,IAAI,GAAM,OAAO,CAE7B,EAAW,IAAI,GAAM,OAAO,CAE5B,EAAgC,IAAI,GAAM,OAAO,CACjD,EAAgC,IAAI,GAAM,OAAO,AAEjD,CAAA,IAAI,CAAC,aAAa,CAAG,SAAW,CAAM,CAAE,CAAM,EAM7C,OAJA,EAAO,kBAAkB,CAAC,UAAU,CAAE,EAAO,WAAW,EAExD,EAAsB,gBAAgB,CAAE,EAAO,gBAAgB,CAAE,EAAO,kBAAkB,EAEnF,EAAO,eAAe,CAAE,EAEhC,EAEA,IAAI,CAAC,eAAe,CAAG,SAAW,CAAM,CAAE,CAAM,EAM/C,OAJA,EAAO,uBAAuB,CAAC,UAAU,CAAE,EAAO,gBAAgB,EAElE,EAAsB,gBAAgB,CAAE,EAAO,WAAW,CAAE,EAAO,uBAAuB,EAEnF,EAAO,eAAe,CAAE,EAEhC,EAEA,IAAI,CAAC,UAAU,CAAG,SAAW,CAAM,CAAE,CAAM,EAG1C,EAAO,CAAC,CAAG,GACX,IAAI,EAAM,IAAI,GAAM,OAAO,CAAE,EAAO,CAAC,CAAE,EAAO,CAAC,CAAE,GAQjD,OANA,IAAI,CAAC,eAAe,CAAE,EAAQ,GAC9B,IAAI,CAAC,eAAe,CAAE,EAAK,GAG3B,EAAI,GAAG,CAAE,GAAS,SAAS,GAEpB,IAAI,GAAM,SAAS,CAAE,EAAQ,EAErC,EAEA,IAAI,EAAe,SAAW,CAAI,CAAE,CAAW,EAE9C,EAAe,EAEf,EAAY,OAAO,CAAC,MAAM,CAAG,EAC7B,EAAY,OAAO,CAAC,MAAM,CAAG,EAC7B,EAAY,MAAM,CAAC,MAAM,CAAG,EAE5B,IAAI,EAAgB,SAAW,CAAM,EAEpC,IAAM,IAAI,EAAI,EAAG,EAAK,EAAO,QAAQ,CAAC,MAAM,CAAE,EAAI,EAAI,IAAO,CAE5D,IAAI,EAAS,EAAO,QAAQ,CAAE,EAAG,AAET,EAAA,IAAnB,EAAO,OAAO,GAEd,aAAkB,GAAM,KAAK,CAEjC,EAAY,MAAM,CAAC,IAAI,CAAE,GAEd,aAAkB,GAAM,IAAI,EAAI,aAAkB,GAAM,IAAI,CAElE,CAAA,AAAyB,CAAA,IAAzB,EAAO,aAAa,EAAc,AAAwC,CAAA,IAAxC,EAAS,gBAAgB,CAAE,EAAa,IAG9E,AADA,CAAA,EAAU,GAAV,EACQ,MAAM,CAAG,EAEZ,AAAuB,OAAvB,EAAO,WAAW,CAEtB,EAAQ,CAAC,CAAG,EAAO,WAAW,EAI9B,EAAS,qBAAqB,CAAE,EAAO,WAAW,EAClD,EAAS,eAAe,CAAE,GAC1B,EAAQ,CAAC,CAAG,EAAS,CAAC,EAIvB,EAAY,OAAO,CAAC,IAAI,CAAE,IAIhB,aAAkB,GAAM,MAAM,EAAI,aAAkB,GAAM,QAAQ,EAG7E,AADA,CAAA,EAAU,GAAV,EACQ,MAAM,CAAG,EAIZ,AAAuB,OAAvB,EAAO,WAAW,CAEtB,EAAQ,CAAC,CAAG,EAAO,WAAW,EAI9B,EAAS,qBAAqB,CAAE,EAAO,WAAW,EAClD,EAAS,eAAe,CAAE,GAC1B,EAAQ,CAAC,CAAG,EAAS,CAAC,EAIvB,EAAY,OAAO,CAAC,IAAI,CAAE,KAK1B,AADA,CAAA,EAAU,GAAV,EACQ,MAAM,CAAG,EAEZ,AAAuB,OAAvB,EAAO,WAAW,CAEtB,EAAQ,CAAC,CAAG,EAAO,WAAW,EAI9B,EAAS,qBAAqB,CAAE,EAAO,WAAW,EAClD,EAAS,eAAe,CAAE,GAC1B,EAAQ,CAAC,CAAG,EAAS,CAAC,EAIvB,EAAY,OAAO,CAAC,IAAI,CAAE,IAI3B,EAAe,GAEhB,CAED,EAMA,OAJA,EAAe,GAEM,CAAA,IAAhB,GAAuB,EAAY,OAAO,CAAC,IAAI,CAAE,GAE/C,CAER,EA0TA,SAAS,IAER,GAAK,IAAiB,EAAoB,CAEzC,IAAI,EAAS,IAAI,GAAM,gBAAgB,CAIvC,OAHA,EAAY,IAAI,CAAE,GAClB,IACA,IACO,CAER,CAEA,OAAO,CAAW,CAAE,IAAiB,AAEtC,CAEA,SAAS,IAER,GAAK,IAAiB,EAAoB,CAEzC,IAAI,EAAS,IAAI,GAAM,gBAAgB,CAIvC,OAHA,EAAY,IAAI,CAAE,GAClB,IACA,IACO,CAER,CAEA,OAAO,CAAW,CAAE,IAAiB,AAEtC,CAqEA,SAAS,EAAa,CAAC,CAAE,CAAC,EAEzB,OAAO,EAAE,CAAC,CAAG,EAAE,CAAC,AAEjB,CA/ZA,IAAI,CAAC,YAAY,CAAG,SAAW,CAAK,CAAE,CAAM,CAAE,CAAW,CAAE,CAAY,EAEtE,IACA,EAAG,EAAI,EAAG,EAAI,EAAG,EAAI,EAAG,EAAI,EAAG,EAAI,EAAG,EAAI,EAC1C,GAAU,GAAU,GAAO,GAAM,GAAmB,GAAe,GACnE,GAAI,GAAI,GAAI,GAAI,GAAgB,GAH5B,GAAU,CAAA,EA0Bd,IAAM,AArBN,EAAc,EACd,EAAc,EACd,EAAa,EACb,EAAiB,EAEjB,EAAY,QAAQ,CAAC,MAAM,CAAG,EAE9B,EAAM,iBAAiB,GAEA,KAAA,IAAlB,EAAO,MAAM,EAAiB,EAAO,iBAAiB,GAE3D,EAAY,IAAI,CAAE,EAAO,kBAAkB,CAAC,UAAU,CAAE,EAAO,WAAW,GAC1E,EAAsB,gBAAgB,CAAE,EAAO,gBAAgB,CAAE,GAEjE,EAAkB,UAAU,CAAE,GAC9B,EAAkB,SAAS,GAE3B,EAAS,aAAa,CAAE,GAIlB,EAAI,EAAG,EAAK,AAFlB,CAAA,EAAc,EAAc,EAAO,EAAnC,EAE8B,OAAO,CAAC,MAAM,CAAE,EAAI,EAAI,IAQrD,GAJA,EAAe,AAFf,CAAA,EAAS,EAAY,OAAO,CAAE,EAAG,CAAC,MAAM,AAAN,EAEZ,WAAW,CAEjC,EAAe,EAEV,aAAkB,GAAM,IAAI,CAAG,CAcnC,IAAM,AAVN,GAAW,AAFX,CAAA,GAAW,EAAO,QAAQ,AAAR,EAEE,QAAQ,CAC5B,GAAQ,GAAS,KAAK,CACtB,GAAgB,GAAS,aAAa,CAEtC,EAAc,UAAU,CAAE,GAC1B,EAAc,SAAS,GAGvB,GAAkB,AAAmB,CAAA,GADrC,CAAA,GAAiB,EAAO,QAAQ,YAAY,GAAM,gBAAgB,AAAhB,EACN,EAAO,QAAQ,CAAG,KAExD,EAAI,EAAG,EAAK,GAAS,MAAM,CAAE,EAAI,EAAI,IAI1C,AAFA,CAAA,EAAU,GAAV,EAEQ,aAAa,CAAC,IAAI,CAAE,EAAQ,CAAE,EAAG,EAAG,YAAY,CAAE,GAC1D,EAAQ,cAAc,CAAC,IAAI,CAAE,EAAQ,aAAa,EAAG,YAAY,CAAE,GAEnE,EAAQ,cAAc,CAAC,CAAC,EAAI,EAAQ,cAAc,CAAC,CAAC,CACpD,EAAQ,cAAc,CAAC,CAAC,EAAI,EAAQ,cAAc,CAAC,CAAC,CACpD,EAAQ,cAAc,CAAC,CAAC,EAAI,EAAQ,cAAc,CAAC,CAAC,CAEpD,EAAQ,OAAO,CAAG,CAAI,CAAA,EAAQ,cAAc,CAAC,CAAC,CAAG,IAAM,EAAQ,cAAc,CAAC,CAAC,CAAG,GAC1E,EAAQ,cAAc,CAAC,CAAC,CAAG,IAAM,EAAQ,cAAc,CAAC,CAAC,CAAG,GAC5D,EAAQ,cAAc,CAAC,CAAC,CAAG,IAAM,EAAQ,cAAc,CAAC,CAAC,CAAG,CAAA,EAIrE,IAAM,EAAI,EAAG,EAAK,GAAM,MAAM,CAAE,EAAI,EAAI,IAAO,CAE9C,GAAO,EAAK,CAAE,EAAG,CAEjB,IAAI,GAAW,AAAmB,CAAA,IAAnB,GACZ,GAAgB,SAAS,CAAE,GAAK,aAAa,CAAE,CAC/C,EAAO,QAAQ,CAElB,GAAK,AAAa,KAAA,IAAb,IAEL,IAAI,GAAO,GAAS,IAAI,CAExB,GAAK,cAAgB,GAAM,KAAK,CAAG,CAUlC,GARA,GAAK,CAAW,CAAE,GAAK,CAAC,CAAE,CAC1B,GAAK,CAAW,CAAE,GAAK,CAAC,CAAE,CAC1B,GAAK,CAAW,CAAE,GAAK,CAAC,CAAE,CAE1B,CAAQ,CAAE,EAAG,CAAG,GAAG,cAAc,CACjC,CAAQ,CAAE,EAAG,CAAG,GAAG,cAAc,CACjC,CAAQ,CAAE,EAAG,CAAG,GAAG,cAAc,EAE5B,CAAA,AAAe,CAAA,IAAf,GAAG,OAAO,EAAa,AAAe,CAAA,IAAf,GAAG,OAAO,EAAa,AAAe,CAAA,IAAf,GAAG,OAAO,EAC5D,EAAS,iBAAiB,CAAE,EAAa,aAAa,CAAE,GAAA,IAExD,GAAU,AAAI,CAAA,GAAG,cAAc,CAAC,CAAC,CAAG,GAAG,cAAc,CAAC,CAAA,AAAA,EAAQ,CAAA,GAAG,cAAc,CAAC,CAAC,CAAG,GAAG,cAAc,CAAC,CAAA,AAAA,EACrG,AAAE,CAAA,GAAG,cAAc,CAAC,CAAC,CAAG,GAAG,cAAc,CAAC,CAAA,AAAA,EAAQ,CAAA,GAAG,cAAc,CAAC,CAAC,CAAG,GAAG,cAAc,CAAC,CAAC,AAAD,EAAQ,EAE9F,KAAS,GAAM,UAAU,EAAI,KAAc,CAAA,KAAS,GAAM,SAAS,AAAT,GAgB/D,SAZC,AAFA,CAAA,EAAQ,AAuPf,WAEC,GAAK,IAAgB,EAAmB,CAEvC,IAAI,EAAO,IAAI,GAAM,eAAe,CAIpC,OAHA,EAAW,IAAI,CAAE,GACjB,IACA,IACO,CAER,CAEA,OAAO,CAAU,CAAE,IAAgB,AAGpC,GAtQO,EAEM,EAAE,CAAC,IAAI,CAAE,IACf,EAAM,EAAE,CAAC,IAAI,CAAE,IACf,EAAM,EAAE,CAAC,IAAI,CAAE,GAclB,MAAO,GAAK,cAAgB,GAAM,KAAK,CAAG,CAYzC,GAVA,GAAK,CAAW,CAAE,GAAK,CAAC,CAAE,CAC1B,GAAK,CAAW,CAAE,GAAK,CAAC,CAAE,CAC1B,GAAK,CAAW,CAAE,GAAK,CAAC,CAAE,CAC1B,GAAK,CAAW,CAAE,GAAK,CAAC,CAAE,CAE1B,CAAQ,CAAE,EAAG,CAAG,GAAG,cAAc,CACjC,CAAQ,CAAE,EAAG,CAAG,GAAG,cAAc,CACjC,CAAQ,CAAE,EAAG,CAAG,GAAG,cAAc,CACjC,CAAQ,CAAE,EAAG,CAAG,GAAG,cAAc,EAE5B,CAAA,AAAe,CAAA,IAAf,GAAG,OAAO,EAAa,AAAe,CAAA,IAAf,GAAG,OAAO,EAAa,AAAe,CAAA,IAAf,GAAG,OAAO,EAAa,AAAe,CAAA,IAAf,GAAG,OAAO,EACnF,EAAS,iBAAiB,CAAE,EAAa,aAAa,CAAE,GAAA,IAExD,GAAU,AAAE,CAAA,GAAG,cAAc,CAAC,CAAC,CAAG,GAAG,cAAc,CAAC,CAAC,AAAD,EAAQ,CAAA,GAAG,cAAc,CAAC,CAAC,CAAG,GAAG,cAAc,CAAC,CAAA,AAAA,EACjG,AAAA,CAAA,GAAG,cAAc,CAAC,CAAC,CAAG,GAAG,cAAc,CAAC,CAAA,AAAA,EAAQ,CAAA,GAAG,cAAc,CAAC,CAAC,CAAG,GAAG,cAAc,CAAC,CAAA,AAAA,EAAM,GAC9F,AAAA,CAAA,GAAG,cAAc,CAAC,CAAC,CAAG,GAAG,cAAc,CAAC,CAAA,AAAA,EAAQ,CAAA,GAAG,cAAc,CAAC,CAAC,CAAG,GAAG,cAAc,CAAC,CAAA,AAAA,EAC1F,AAAE,CAAA,GAAG,cAAc,CAAC,CAAC,CAAG,GAAG,cAAc,CAAC,CAAA,AAAA,EAAQ,CAAA,GAAG,cAAc,CAAC,CAAC,CAAG,GAAG,cAAc,CAAC,CAAC,AAAD,EAAM,EAG5F,KAAS,GAAM,UAAU,EAAI,KAAc,CAAA,KAAS,GAAM,SAAS,AAAT,GAiB/D,SAbC,AAFA,CAAA,EAAQ,AA+Nf,WAEC,GAAK,IAAgB,EAAmB,CAEvC,IAAI,EAAO,IAAI,GAAM,eAAe,CAIpC,OAHA,EAAW,IAAI,CAAE,GACjB,IACA,IACO,CAER,CAEA,OAAO,CAAU,CAAE,IAAgB,AAEpC,GA7OO,EAEM,EAAE,CAAC,IAAI,CAAE,IACf,EAAM,EAAE,CAAC,IAAI,CAAE,IACf,EAAM,EAAE,CAAC,IAAI,CAAE,IACf,EAAM,EAAE,CAAC,IAAI,CAAE,GAclB,CAkBA,IAAM,AAhBN,EAAM,WAAW,CAAC,IAAI,CAAE,GAAK,MAAM,EAElB,CAAA,IAAZ,IAAuB,CAAA,KAAS,GAAM,QAAQ,EAAI,KAAS,GAAM,UAAS,AAAT,GAErE,EAAM,WAAW,CAAC,MAAM,GAIzB,EAAM,WAAW,CAAC,YAAY,CAAE,GAAgB,SAAS,GAEzD,EAAM,eAAe,CAAC,IAAI,CAAE,EAAM,WAAW,EAAG,YAAY,CAAE,GAE9D,EAAM,aAAa,CAAC,IAAI,CAAE,GAAK,QAAQ,EAAG,YAAY,CAAE,GAIlD,EAAI,EAAG,EAAK,AAFlB,CAAA,GAAoB,GAAK,aAAa,AAAb,EAEW,MAAM,CAAE,EAAI,EAAI,IAAO,CAE1D,IAAI,GAAc,EAAM,kBAAkB,CAAE,EAAG,CAC/C,GAAY,IAAI,CAAE,EAAiB,CAAE,EAAG,EAEvB,CAAA,IAAZ,IAAuB,CAAA,KAAS,GAAM,QAAQ,EAAI,KAAS,GAAM,UAAS,AAAT,GAErE,GAAY,MAAM,GAInB,GAAY,YAAY,CAAE,GAAgB,SAAS,GAGnD,AADsB,EAAM,sBAAsB,CAAE,EAAG,CACvC,IAAI,CAAE,IAAc,YAAY,CAAE,EAEnD,CAIA,IAAM,EAAI,EAFV,EAAM,mBAAmB,CAAG,GAAkB,MAAM,CAEvC,EAAK,GAAc,MAAM,CAAE,EAAI,EAAI,IAI/C,GAAK,AAAQ,KAAA,IAFb,CAAA,GAAM,EAAa,CAAE,EAAG,CAAE,EAAG,AAAH,EAI1B,IAAM,EAAI,EAAG,EAAK,GAAI,MAAM,CAAE,EAAI,EAAI,IAErC,EAAM,GAAG,CAAE,EAAG,CAAE,EAAG,CAAG,EAAG,CAAE,EAAG,AAMhC,CAAA,EAAM,KAAK,CAAG,GAAK,KAAK,CACxB,EAAM,QAAQ,CAAG,GAEjB,EAAU,IAAI,CAAE,EAAM,aAAa,EAAG,eAAe,CAAE,GAEvD,EAAM,CAAC,CAAG,EAAU,CAAC,CAErB,EAAY,QAAQ,CAAC,IAAI,CAAE,GAE5B,CAED,MAAO,GAAK,aAAkB,GAAM,IAAI,CAAG,CAE1C,EAA2B,gBAAgB,CAAE,EAAuB,GAEpE,GAAW,EAAO,QAAQ,CAAC,QAAQ,CAGnC,AADA,CAAA,GAAK,GAAL,EACG,cAAc,CAAC,IAAI,CAAE,EAAQ,CAAE,EAAG,EAAG,YAAY,CAAE,GAGtD,IAAI,GAAO,EAAO,IAAI,GAAK,GAAM,UAAU,CAAG,EAAI,EAElD,IAAM,EAAI,EAAG,EAAK,GAAS,MAAM,CAAE,EAAI,EAAI,IAG1C,AADA,CAAA,GAAK,GAAL,EACG,cAAc,CAAC,IAAI,CAAE,EAAQ,CAAE,EAAG,EAAG,YAAY,CAAE,GAE/C,CAAA,EAAI,CAAA,EAAM,GAAO,IAExB,GAAK,CAAW,CAAE,EAAe,EAAG,CAEpC,EAA8B,IAAI,CAAE,GAAG,cAAc,EACrD,EAA8B,IAAI,CAAE,GAAG,cAAc,EAE6B,CAAA,IAA7E,AA6KT,SAAmB,CAAE,CAAE,CAAE,EAExB,IAAI,EAAS,EAAG,EAAS,EAIzB,EAAW,EAAG,CAAC,CAAG,EAAG,CAAC,CACtB,EAAW,EAAG,CAAC,CAAG,EAAG,CAAC,CACtB,EAAU,CAAE,EAAG,CAAC,CAAG,EAAG,CAAC,CACvB,EAAU,CAAE,EAAG,CAAC,CAAG,EAAG,CAAC,QAEvB,AAAK,GAAW,GAAK,GAAW,GAAK,GAAU,GAAK,GAAU,GAKvD,AAAK,CAAA,CAAA,CAAA,EAAY,CAAA,IAAK,CAAA,EAAU,CAAA,CAAA,GAAO,CAAA,CAAA,CAAA,EAAS,CAAA,IAAK,CAAA,EAAS,CAAA,CAAA,IAS/D,EAAU,EAGd,EAAS,KAAK,GAAG,CAAE,EAAQ,EAAY,CAAA,EAAU,CAAA,GAEtC,EAAU,GAGrB,CAAA,EAAS,KAAK,GAAG,CAAE,EAAQ,EAAY,CAAA,EAAU,CAAA,EAAjD,EAII,EAAS,EAGb,EAAS,KAAK,GAAG,CAAE,EAAQ,EAAW,CAAA,EAAS,CAAA,GAEpC,EAAS,GAGpB,CAAA,EAAS,KAAK,GAAG,CAAE,EAAQ,EAAW,CAAA,EAAS,CAAA,EAA/C,GAII,CAAA,EAAS,CAAA,IAUb,EAAG,IAAI,CAAE,EAAI,GACb,EAAG,IAAI,CAAE,EAAI,EAAI,GAEV,CAAA,GAMV,EAjPmB,EAA+B,KAG7C,EAA8B,cAAc,CAAE,EAAI,EAA8B,CAAC,EACjF,EAA8B,cAAc,CAAE,EAAI,EAA8B,CAAC,EAGjF,AADA,CAAA,EAAQ,AA+Hb,WAEC,GAAK,IAAe,EAAkB,CAErC,IAAI,EAAO,IAAI,GAAM,cAAc,CAInC,OAHA,EAAU,IAAI,CAAE,GAChB,IACA,IACO,CAER,CAEA,OAAO,CAAS,CAAE,IAAe,AAElC,GA7IK,EACM,EAAE,CAAC,cAAc,CAAC,IAAI,CAAE,GAC9B,EAAM,EAAE,CAAC,cAAc,CAAC,IAAI,CAAE,GAE9B,EAAM,CAAC,CAAG,KAAK,GAAG,CAAE,EAA8B,CAAC,CAAE,EAA8B,CAAC,EAEpF,EAAM,QAAQ,CAAG,EAAO,QAAQ,CAEhC,EAAY,QAAQ,CAAC,IAAI,CAAE,IAM9B,CAID,IAAM,EAAI,EAAG,EAAK,EAAY,OAAO,CAAC,MAAM,CAAE,EAAI,EAAI,IAIrD,EAAe,AAFf,CAAA,EAAS,EAAY,OAAO,CAAE,EAAG,CAAC,MAAM,AAAN,EAEZ,WAAW,CAE5B,aAAkB,GAAM,QAAQ,GAEpC,EAAS,GAAG,CAAE,EAAa,QAAQ,CAAC,GAAG,CAAE,EAAa,QAAQ,CAAC,GAAG,CAAE,EAAa,QAAQ,CAAC,GAAG,CAAE,GAC/F,EAAS,YAAY,CAAE,GAEvB,EAAS,CAAC,EAAI,EAAS,CAAC,CAEnB,EAAS,CAAC,CAAG,GAAK,EAAS,CAAC,CAAG,IAGnC,AADA,CAAA,EAAY,AA8GhB,WAEC,GAAK,IAAmB,EAAsB,CAE7C,IAAI,EAAW,IAAI,GAAM,kBAAkB,CAI3C,OAHA,EAAc,IAAI,CAAE,GACpB,IACA,IACO,CAER,CAEA,OAAO,CAAa,CAAE,IAAmB,AAE1C,GA5HI,EACU,MAAM,CAAG,EACnB,EAAU,CAAC,CAAG,EAAS,CAAC,CAAG,EAAS,CAAC,CACrC,EAAU,CAAC,CAAG,EAAS,CAAC,CAAG,EAAS,CAAC,CACrC,EAAU,CAAC,CAAG,EAAS,CAAC,CAExB,EAAU,QAAQ,CAAG,EAAO,QAAQ,CAAC,CAAC,CAEtC,EAAU,KAAK,CAAC,CAAC,CAAG,EAAO,KAAK,CAAC,CAAC,CAAG,KAAK,GAAG,CAAE,EAAU,CAAC,CAAK,AAAA,CAAA,EAAS,CAAC,CAAG,EAAO,gBAAgB,CAAC,QAAQ,CAAC,EAAC,AAAD,EAAS,CAAA,EAAS,CAAC,CAAG,EAAO,gBAAgB,CAAC,QAAQ,CAAC,GAAG,AAAH,GACpK,EAAU,KAAK,CAAC,CAAC,CAAG,EAAO,KAAK,CAAC,CAAC,CAAG,KAAK,GAAG,CAAE,EAAU,CAAC,CAAK,AAAA,CAAA,EAAS,CAAC,CAAG,EAAO,gBAAgB,CAAC,QAAQ,CAAC,EAAC,AAAD,EAAS,CAAA,EAAS,CAAC,CAAG,EAAO,gBAAgB,CAAC,QAAQ,CAAC,GAAG,AAAH,GAEpK,EAAU,QAAQ,CAAG,EAAO,QAAQ,CAEpC,EAAY,QAAQ,CAAC,IAAI,CAAE,KAU9B,MAFsB,CAAA,IAAjB,GAAwB,EAAY,QAAQ,CAAC,IAAI,CAAE,GAEjD,CAER,CAmLD,EAMA,GAAM,KAAK,CAAG,SAAW,CAAC,CAAE,CAAC,CAAE,CAAC,CAAE,CAAM,CAAE,CAAK,CAAE,CAAa,EAE7D,IAAI,CAAC,CAAC,CAAG,EACT,IAAI,CAAC,CAAC,CAAG,EACT,IAAI,CAAC,CAAC,CAAG,EAET,IAAI,CAAC,MAAM,CAAG,aAAkB,GAAM,OAAO,CAAG,EAAS,IAAI,GAAM,OAAO,CAC1E,IAAI,CAAC,aAAa,CAAG,aAAkB,MAAQ,EAAS,EAAG,CAE3D,IAAI,CAAC,KAAK,CAAG,aAAiB,GAAM,KAAK,CAAG,EAAQ,IAAI,GAAM,KAAK,CACnE,IAAI,CAAC,YAAY,CAAG,aAAiB,MAAQ,EAAQ,EAAE,CAEvD,IAAI,CAAC,cAAc,CAAG,EAAE,CAExB,IAAI,CAAC,aAAa,CAAG,AAAkB,KAAA,IAAlB,EAA8B,EAAgB,EAEnE,IAAI,CAAC,QAAQ,CAAG,IAAI,GAAM,OAAO,AAElC,EAEA,GAAM,KAAK,CAAC,SAAS,CAAG,CAEvB,YAAa,GAAM,KAAK,CAExB,MAAO,WAEN,IAQI,EAAG,EARH,EAAO,IAAI,GAAM,KAAK,CAAE,IAAI,CAAC,CAAC,CAAE,IAAI,CAAC,CAAC,CAAE,IAAI,CAAC,CAAC,EASlD,IAAM,AAPN,EAAK,MAAM,CAAC,IAAI,CAAE,IAAI,CAAC,MAAM,EAC7B,EAAK,KAAK,CAAC,IAAI,CAAE,IAAI,CAAC,KAAK,EAC3B,EAAK,QAAQ,CAAC,IAAI,CAAE,IAAI,CAAC,QAAQ,EAEjC,EAAK,aAAa,CAAG,IAAI,CAAC,aAAa,CAGjC,EAAI,EAAG,EAAK,IAAI,CAAC,aAAa,CAAC,MAAM,CAAE,EAAI,EAAI,IAAO,EAAK,aAAa,CAAE,EAAG,CAAG,IAAI,CAAC,aAAa,CAAE,EAAG,CAAC,KAAK,GACnH,IAAM,EAAI,EAAG,EAAK,IAAI,CAAC,YAAY,CAAC,MAAM,CAAE,EAAI,EAAI,IAAO,EAAK,YAAY,CAAE,EAAG,CAAG,IAAI,CAAC,YAAY,CAAE,EAAG,CAAC,KAAK,GAChH,IAAM,EAAI,EAAG,EAAK,IAAI,CAAC,cAAc,CAAC,MAAM,CAAE,EAAI,EAAI,IAAO,EAAK,cAAc,CAAE,EAAG,CAAG,IAAI,CAAC,cAAc,CAAE,EAAG,CAAC,KAAK,GAEtH,OAAO,CAER,CAED,EAMA,GAAM,KAAK,CAAG,SAAW,CAAC,CAAE,CAAC,CAAE,CAAC,CAAE,CAAC,CAAE,CAAM,CAAE,CAAK,CAAE,CAAa,EAEhE,IAAI,CAAC,CAAC,CAAG,EACT,IAAI,CAAC,CAAC,CAAG,EACT,IAAI,CAAC,CAAC,CAAG,EACT,IAAI,CAAC,CAAC,CAAG,EAET,IAAI,CAAC,MAAM,CAAG,aAAkB,GAAM,OAAO,CAAG,EAAS,IAAI,GAAM,OAAO,CAC1E,IAAI,CAAC,aAAa,CAAG,aAAkB,MAAQ,EAAS,EAAG,CAE3D,IAAI,CAAC,KAAK,CAAG,aAAiB,GAAM,KAAK,CAAG,EAAQ,IAAI,GAAM,KAAK,CACnE,IAAI,CAAC,YAAY,CAAG,aAAiB,MAAQ,EAAQ,EAAE,CAEvD,IAAI,CAAC,cAAc,CAAG,EAAE,CAExB,IAAI,CAAC,aAAa,CAAG,AAAkB,KAAA,IAAlB,EAA8B,EAAgB,EAEnE,IAAI,CAAC,QAAQ,CAAG,IAAI,GAAM,OAAO,AAElC,EAEA,GAAM,KAAK,CAAC,SAAS,CAAG,CAEvB,YAAa,GAAM,KAAK,CAExB,MAAO,WAEN,IAQI,EAAG,EARH,EAAO,IAAI,GAAM,KAAK,CAAE,IAAI,CAAC,CAAC,CAAE,IAAI,CAAC,CAAC,CAAE,IAAI,CAAC,CAAC,CAAE,IAAI,CAAC,CAAC,EAS1D,IAAM,AAPN,EAAK,MAAM,CAAC,IAAI,CAAE,IAAI,CAAC,MAAM,EAC7B,EAAK,KAAK,CAAC,IAAI,CAAE,IAAI,CAAC,KAAK,EAC3B,EAAK,QAAQ,CAAC,IAAI,CAAE,IAAI,CAAC,QAAQ,EAEjC,EAAK,aAAa,CAAG,IAAI,CAAC,aAAa,CAGjC,EAAI,EAAG,EAAK,IAAI,CAAC,aAAa,CAAC,MAAM,CAAE,EAAI,EAAI,IAAO,EAAK,aAAa,CAAE,EAAG,CAAG,IAAI,CAAC,aAAa,CAAE,EAAG,CAAC,KAAK,GACnH,IAAM,EAAI,EAAG,EAAK,IAAI,CAAC,YAAY,CAAC,MAAM,CAAE,EAAI,EAAI,IAAO,EAAK,YAAY,CAAE,EAAG,CAAG,IAAI,CAAC,YAAY,CAAE,EAAG,CAAC,KAAK,GAChH,IAAM,EAAI,EAAG,EAAK,IAAI,CAAC,cAAc,CAAC,MAAM,CAAE,EAAI,EAAI,IAAO,EAAK,cAAc,CAAE,EAAG,CAAG,IAAI,CAAC,cAAc,CAAE,EAAG,CAAC,KAAK,GAEtH,OAAO,CAER,CAED,EAUA,GAAM,QAAQ,CAAG,WAEhB,GAAM,eAAe,CAAC,IAAI,CAAE,IAAI,EAEhC,IAAI,CAAC,EAAE,CAAG,GAAM,eAAe,GAE/B,IAAI,CAAC,IAAI,CAAG,GAEZ,IAAI,CAAC,QAAQ,CAAG,EAAE,CAClB,IAAI,CAAC,MAAM,CAAG,EAAE,CAChB,IAAI,CAAC,OAAO,CAAG,EAAE,CAEjB,IAAI,CAAC,KAAK,CAAG,EAAE,CAEf,IAAI,CAAC,OAAO,CAAG,CAAC,EAAE,CAAC,CACnB,IAAI,CAAC,aAAa,CAAG,CAAC,EAAE,CAAC,CAEzB,IAAI,CAAC,YAAY,CAAG,EAAE,CACtB,IAAI,CAAC,WAAW,CAAG,EAAE,CACrB,IAAI,CAAC,YAAY,CAAG,EAAE,CAEtB,IAAI,CAAC,WAAW,CAAG,EAAE,CACrB,IAAI,CAAC,WAAW,CAAG,EAAE,CAErB,IAAI,CAAC,aAAa,CAAG,EAAE,CAEvB,IAAI,CAAC,WAAW,CAAG,KACnB,IAAI,CAAC,cAAc,CAAG,KAEtB,IAAI,CAAC,WAAW,CAAG,CAAA,EAEnB,IAAI,CAAC,OAAO,CAAG,CAAA,EAIf,IAAI,CAAC,kBAAkB,CAAG,CAAA,EAC1B,IAAI,CAAC,kBAAkB,CAAG,CAAA,EAC1B,IAAI,CAAC,aAAa,CAAG,CAAA,EACrB,IAAI,CAAC,iBAAiB,CAAG,CAAA,EACzB,IAAI,CAAC,kBAAkB,CAAG,CAAA,EAC1B,IAAI,CAAC,gBAAgB,CAAG,CAAA,EACxB,IAAI,CAAC,uBAAuB,CAAG,CAAA,EAE/B,IAAI,CAAC,iBAAiB,CAAG,CAAA,CAE1B,EAEA,GAAM,QAAQ,CAAC,SAAS,CAAG,CAE1B,YAAa,GAAM,QAAQ,CAE3B,YAAa,SAAW,CAAM,EAI7B,IAAM,IAFF,EAAe,IAAI,GAAM,OAAO,GAAG,UAAU,CAAE,GAAS,SAAS,GAE3D,EAAI,EAAG,EAAK,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAE,EAAI,EAAI,IAGnD,AADa,IAAI,CAAC,QAAQ,CAAE,EAAG,CACxB,YAAY,CAAE,GAItB,IAAM,IAAI,EAAI,EAAG,EAAK,IAAI,CAAC,KAAK,CAAC,MAAM,CAAE,EAAI,EAAI,IAAO,CAEvD,IAAI,EAAO,IAAI,CAAC,KAAK,CAAE,EAAG,CAC1B,EAAK,MAAM,CAAC,YAAY,CAAE,GAAe,SAAS,GAElD,IAAM,IAAI,EAAI,EAAG,EAAK,EAAK,aAAa,CAAC,MAAM,CAAE,EAAI,EAAI,IAExD,EAAK,aAAa,CAAE,EAAG,CAAC,YAAY,CAAE,GAAe,SAAS,GAI/D,EAAK,QAAQ,CAAC,YAAY,CAAE,EAE7B,CAED,EAEA,iBAAkB,WAEjB,IAAI,EAAG,EAAI,EAEX,IAAM,EAAI,EAAG,EAAK,IAAI,CAAC,KAAK,CAAC,MAAM,CAAE,EAAI,EAAI,IAG5C,AADA,CAAA,EAAO,IAAI,CAAC,KAAK,CAAE,EAAG,AAAH,EACd,QAAQ,CAAC,GAAG,CAAE,EAAG,EAAG,GAEpB,aAAgB,GAAM,KAAK,EAE/B,EAAK,QAAQ,CAAC,GAAG,CAAE,IAAI,CAAC,QAAQ,CAAE,EAAK,CAAC,CAAE,EAC1C,EAAK,QAAQ,CAAC,GAAG,CAAE,IAAI,CAAC,QAAQ,CAAE,EAAK,CAAC,CAAE,EAC1C,EAAK,QAAQ,CAAC,GAAG,CAAE,IAAI,CAAC,QAAQ,CAAE,EAAK,CAAC,CAAE,EAC1C,EAAK,QAAQ,CAAC,YAAY,CAAE,IAEjB,aAAgB,GAAM,KAAK,GAEtC,EAAK,QAAQ,CAAC,GAAG,CAAE,IAAI,CAAC,QAAQ,CAAE,EAAK,CAAC,CAAE,EAC1C,EAAK,QAAQ,CAAC,GAAG,CAAE,IAAI,CAAC,QAAQ,CAAE,EAAK,CAAC,CAAE,EAC1C,EAAK,QAAQ,CAAC,GAAG,CAAE,IAAI,CAAC,QAAQ,CAAE,EAAK,CAAC,CAAE,EAC1C,EAAK,QAAQ,CAAC,GAAG,CAAE,IAAI,CAAC,QAAQ,CAAE,EAAK,CAAC,CAAE,EAC1C,EAAK,QAAQ,CAAC,YAAY,CAAE,GAM/B,EAEA,mBAAoB,WAInB,IAAM,IAFF,EAAK,IAAI,GAAM,OAAO,CAAI,EAAK,IAAI,GAAM,OAAO,CAE1C,EAAI,EAAG,EAAK,IAAI,CAAC,KAAK,CAAC,MAAM,CAAE,EAAI,EAAI,IAAO,CAEvD,IAAI,EAAO,IAAI,CAAC,KAAK,CAAE,EAAG,CAEtB,EAAK,IAAI,CAAC,QAAQ,CAAE,EAAK,CAAC,CAAE,CAC5B,EAAK,IAAI,CAAC,QAAQ,CAAE,EAAK,CAAC,CAAE,CAC5B,EAAK,IAAI,CAAC,QAAQ,CAAE,EAAK,CAAC,CAAE,CAEhC,EAAG,UAAU,CAAE,EAAI,GACnB,EAAG,UAAU,CAAE,EAAI,GACnB,EAAG,KAAK,CAAE,GAEV,EAAG,SAAS,GAEZ,EAAK,MAAM,CAAC,IAAI,CAAE,EAEnB,CAED,EAEA,qBAAsB,SAAW,CAAY,EAE5C,IAAI,EAAG,EAAI,EAAG,EAAI,EAAM,EAKxB,GAAK,AAAuB,KAAA,IAAvB,IAAI,CAAC,aAAa,CAAiB,CAKvC,IAAM,EAAI,EAHV,IAAI,CAAC,aAAa,CAAG,AAAI,MAAO,IAAI,CAAC,QAAQ,CAAC,MAAM,EACpD,EAAW,IAAI,CAAC,aAAa,CAEhB,EAAK,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAE,EAAI,EAAI,IAE/C,CAAQ,CAAE,EAAG,CAAG,IAAI,GAAM,OAAO,CAIlC,IAAM,EAAI,EAAG,EAAK,IAAI,CAAC,KAAK,CAAC,MAAM,CAAE,EAAI,EAAI,IAIvC,AAFL,CAAA,EAAO,IAAI,CAAC,KAAK,CAAE,EAAG,AAAH,YAEE,GAAM,KAAK,CAE/B,EAAK,aAAa,CAAG,CAAE,IAAI,GAAM,OAAO,CAAI,IAAI,GAAM,OAAO,CAAI,IAAI,GAAM,OAAO,CAAI,CAE3E,aAAgB,GAAM,KAAK,EAEtC,CAAA,EAAK,aAAa,CAAG,CAAE,IAAI,GAAM,OAAO,CAAI,IAAI,GAAM,OAAO,CAAI,IAAI,GAAM,OAAO,CAAI,IAAI,GAAM,OAAO,CAAI,AAAA,CAM9G,MAIC,IAAM,EAAI,EAFV,EAAW,IAAI,CAAC,aAAa,CAEhB,EAAK,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAE,EAAI,EAAI,IAE/C,CAAQ,CAAE,EAAG,CAAC,GAAG,CAAE,EAAG,EAAG,GAM3B,GAAK,EAAe,CAMnB,IADI,EAAI,EAAI,EAAI,EACZ,EAAK,IAAI,GAAM,OAAO,CAAI,EAAK,IAAI,GAAM,OAAO,CACnD,EAAK,IAAI,GAAM,OAAO,CAAI,EAAK,IAAI,GAAM,OAAO,CAAI,EAAK,IAAI,GAAM,OAAO,CAE3E,IAAM,EAAI,EAAG,EAAK,IAAI,CAAC,KAAK,CAAC,MAAM,CAAE,EAAI,EAAI,IAIvC,AAFL,CAAA,EAAO,IAAI,CAAC,KAAK,CAAE,EAAG,AAAH,YAEE,GAAM,KAAK,EAE/B,EAAK,IAAI,CAAC,QAAQ,CAAE,EAAK,CAAC,CAAE,CAC5B,EAAK,IAAI,CAAC,QAAQ,CAAE,EAAK,CAAC,CAAE,CAC5B,EAAK,IAAI,CAAC,QAAQ,CAAE,EAAK,CAAC,CAAE,CAE5B,EAAG,UAAU,CAAE,EAAI,GACnB,EAAG,UAAU,CAAE,EAAI,GACnB,EAAG,KAAK,CAAE,GAEV,CAAQ,CAAE,EAAK,CAAC,CAAE,CAAC,GAAG,CAAE,GACxB,CAAQ,CAAE,EAAK,CAAC,CAAE,CAAC,GAAG,CAAE,GACxB,CAAQ,CAAE,EAAK,CAAC,CAAE,CAAC,GAAG,CAAE,IAEb,aAAgB,GAAM,KAAK,GAEtC,EAAK,IAAI,CAAC,QAAQ,CAAE,EAAK,CAAC,CAAE,CAC5B,EAAK,IAAI,CAAC,QAAQ,CAAE,EAAK,CAAC,CAAE,CAC5B,EAAK,IAAI,CAAC,QAAQ,CAAE,EAAK,CAAC,CAAE,CAC5B,EAAK,IAAI,CAAC,QAAQ,CAAE,EAAK,CAAC,CAAE,CAI5B,EAAG,UAAU,CAAE,EAAI,GACnB,EAAG,UAAU,CAAE,EAAI,GACnB,EAAG,KAAK,CAAE,GAEV,CAAQ,CAAE,EAAK,CAAC,CAAE,CAAC,GAAG,CAAE,GACxB,CAAQ,CAAE,EAAK,CAAC,CAAE,CAAC,GAAG,CAAE,GACxB,CAAQ,CAAE,EAAK,CAAC,CAAE,CAAC,GAAG,CAAE,GAIxB,EAAG,UAAU,CAAE,EAAI,GACnB,EAAG,UAAU,CAAE,EAAI,GACnB,EAAG,KAAK,CAAE,GAEV,CAAQ,CAAE,EAAK,CAAC,CAAE,CAAC,GAAG,CAAE,GACxB,CAAQ,CAAE,EAAK,CAAC,CAAE,CAAC,GAAG,CAAE,GACxB,CAAQ,CAAE,EAAK,CAAC,CAAE,CAAC,GAAG,CAAE,GAM3B,MAEC,IAAM,EAAI,EAAG,EAAK,IAAI,CAAC,KAAK,CAAC,MAAM,CAAE,EAAI,EAAI,IAIvC,AAFL,CAAA,EAAO,IAAI,CAAC,KAAK,CAAE,EAAG,AAAH,YAEE,GAAM,KAAK,EAE/B,CAAQ,CAAE,EAAK,CAAC,CAAE,CAAC,GAAG,CAAE,EAAK,MAAM,EACnC,CAAQ,CAAE,EAAK,CAAC,CAAE,CAAC,GAAG,CAAE,EAAK,MAAM,EACnC,CAAQ,CAAE,EAAK,CAAC,CAAE,CAAC,GAAG,CAAE,EAAK,MAAM,GAExB,aAAgB,GAAM,KAAK,GAEtC,CAAQ,CAAE,EAAK,CAAC,CAAE,CAAC,GAAG,CAAE,EAAK,MAAM,EACnC,CAAQ,CAAE,EAAK,CAAC,CAAE,CAAC,GAAG,CAAE,EAAK,MAAM,EACnC,CAAQ,CAAE,EAAK,CAAC,CAAE,CAAC,GAAG,CAAE,EAAK,MAAM,EACnC,CAAQ,CAAE,EAAK,CAAC,CAAE,CAAC,GAAG,CAAE,EAAK,MAAM,GAQtC,IAAM,EAAI,EAAG,EAAK,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAE,EAAI,EAAI,IAE/C,CAAQ,CAAE,EAAG,CAAC,SAAS,GAIxB,IAAM,EAAI,EAAG,EAAK,IAAI,CAAC,KAAK,CAAC,MAAM,CAAE,EAAI,EAAI,IAIvC,AAFL,CAAA,EAAO,IAAI,CAAC,KAAK,CAAE,EAAG,AAAH,YAEE,GAAM,KAAK,EAE/B,EAAK,aAAa,CAAE,EAAG,CAAC,IAAI,CAAE,CAAQ,CAAE,EAAK,CAAC,CAAE,EAChD,EAAK,aAAa,CAAE,EAAG,CAAC,IAAI,CAAE,CAAQ,CAAE,EAAK,CAAC,CAAE,EAChD,EAAK,aAAa,CAAE,EAAG,CAAC,IAAI,CAAE,CAAQ,CAAE,EAAK,CAAC,CAAE,GAErC,aAAgB,GAAM,KAAK,GAEtC,EAAK,aAAa,CAAE,EAAG,CAAC,IAAI,CAAE,CAAQ,CAAE,EAAK,CAAC,CAAE,EAChD,EAAK,aAAa,CAAE,EAAG,CAAC,IAAI,CAAE,CAAQ,CAAE,EAAK,CAAC,CAAE,EAChD,EAAK,aAAa,CAAE,EAAG,CAAC,IAAI,CAAE,CAAQ,CAAE,EAAK,CAAC,CAAE,EAChD,EAAK,aAAa,CAAE,EAAG,CAAC,IAAI,CAAE,CAAQ,CAAE,EAAK,CAAC,CAAE,EAMnD,EAEA,oBAAqB,WAQpB,IAAM,EAAI,EAAG,EAAK,IAAI,CAAC,KAAK,CAAC,MAAM,CAAE,EAAI,EAAI,IAgB5C,IAAM,AAZC,AAFP,CAAA,EAAO,IAAI,CAAC,KAAK,CAAE,EAAG,AAAH,EAEP,oBAAoB,CAM/B,EAAK,oBAAoB,CAAC,IAAI,CAAE,EAAK,MAAM,EAJ3C,EAAK,oBAAoB,CAAG,EAAK,MAAM,CAAC,KAAK,GAQvC,EAAK,uBAAuB,EAAG,CAAA,EAAK,uBAAuB,CAAG,EAAE,AAAF,EAE/D,EAAI,EAAG,EAAK,EAAK,aAAa,CAAC,MAAM,CAAE,EAAI,EAAI,IAE7C,EAAK,uBAAuB,CAAE,EAAG,CAMvC,EAAK,uBAAuB,CAAE,EAAG,CAAC,IAAI,CAAE,EAAK,aAAa,CAAE,EAAG,EAJ/D,EAAK,uBAAuB,CAAE,EAAG,CAAG,EAAK,aAAa,CAAE,EAAG,CAAC,KAAK,GAcpE,IAAI,EAAS,IAAI,GAAM,QAAQ,CAG/B,IAAM,EAAI,EAFV,EAAO,KAAK,CAAG,IAAI,CAAC,KAAK,CAEZ,EAAK,IAAI,CAAC,YAAY,CAAC,MAAM,CAAE,EAAI,EAAI,IAAO,CAI1D,GAAK,CAAE,IAAI,CAAC,YAAY,CAAE,EAAG,CAAG,CAE/B,IAAI,CAAC,YAAY,CAAE,EAAG,CAAG,CAAC,EAC1B,IAAI,CAAC,YAAY,CAAE,EAAG,CAAC,WAAW,CAAG,EAAE,CACvC,IAAI,CAAC,YAAY,CAAE,EAAG,CAAC,aAAa,CAAG,EAAE,CAEzC,IArDE,EAAG,EAAI,EAAG,EAAI,EAwDZ,EAAY,EAHZ,EAAiB,IAAI,CAAC,YAAY,CAAE,EAAG,CAAC,WAAW,CACnD,EAAmB,IAAI,CAAC,YAAY,CAAE,EAAG,CAAC,aAAa,CAI3D,IAAM,EAAI,EAAG,EAAK,IAAI,CAAC,KAAK,CAAC,MAAM,CAAE,EAAI,EAAI,IAE5C,EAAO,IAAI,CAAC,KAAK,CAAE,EAAG,CAEtB,EAAa,IAAI,GAAM,OAAO,CAI7B,EAFI,aAAgB,GAAM,KAAK,CAEf,CAAE,EAAG,IAAI,GAAM,OAAO,CAAI,EAAG,IAAI,GAAM,OAAO,CAAI,EAAG,IAAI,GAAM,OAAO,AAAG,EAIzE,CAAE,EAAG,IAAI,GAAM,OAAO,CAAI,EAAG,IAAI,GAAM,OAAO,CAAI,EAAG,IAAI,GAAM,OAAO,CAAI,EAAG,IAAI,GAAM,OAAO,AAAG,EAIlH,EAAe,IAAI,CAAE,GACrB,EAAiB,IAAI,CAAE,EAIzB,CAEA,IAAI,EAAe,IAAI,CAAC,YAAY,CAAE,EAAG,CAezC,IAAM,AAXN,EAAO,QAAQ,CAAG,IAAI,CAAC,YAAY,CAAE,EAAG,CAAC,QAAQ,CAIjD,EAAO,kBAAkB,GACzB,EAAO,oBAAoB,GAMrB,EAAI,EAAG,EAAK,IAAI,CAAC,KAAK,CAAC,MAAM,CAAE,EAAI,EAAI,IAE5C,EAAO,IAAI,CAAC,KAAK,CAAE,EAAG,CAEtB,EAAa,EAAa,WAAW,CAAE,EAAG,CAC1C,EAAgB,EAAa,aAAa,CAAE,EAAG,CAE/C,EAAW,IAAI,CAAE,EAAK,MAAM,EAEvB,aAAgB,GAAM,KAAK,EAE/B,EAAc,CAAC,CAAC,IAAI,CAAE,EAAK,aAAa,CAAE,EAAG,EAC7C,EAAc,CAAC,CAAC,IAAI,CAAE,EAAK,aAAa,CAAE,EAAG,EAC7C,EAAc,CAAC,CAAC,IAAI,CAAE,EAAK,aAAa,CAAE,EAAG,IAI7C,EAAc,CAAC,CAAC,IAAI,CAAE,EAAK,aAAa,CAAE,EAAG,EAC7C,EAAc,CAAC,CAAC,IAAI,CAAE,EAAK,aAAa,CAAE,EAAG,EAC7C,EAAc,CAAC,CAAC,IAAI,CAAE,EAAK,aAAa,CAAE,EAAG,EAC7C,EAAc,CAAC,CAAC,IAAI,CAAE,EAAK,aAAa,CAAE,EAAG,EAMhD,CAIA,IAAM,EAAI,EAAG,EAAK,IAAI,CAAC,KAAK,CAAC,MAAM,CAAE,EAAI,EAAI,IAI5C,AAFA,CAAA,EAAO,IAAI,CAAC,KAAK,CAAE,EAAG,AAAH,EAEd,MAAM,CAAG,EAAK,oBAAoB,CACvC,EAAK,aAAa,CAAG,EAAK,uBAAuB,AAInD,EAEA,gBAAiB,WAKhB,IAAI,EAAG,EAAI,EAAG,EAAI,EAAO,EACxB,EAAM,EAAI,EAAI,EAAI,EAAI,EAAK,EAAK,EAChC,EAAI,EAAI,EAAI,EAAI,EAAI,EACpB,EAAI,EAAI,EAAI,EAAI,EAAG,EAIM,EAHzB,EAAO,EAAE,CAAE,EAAO,EAAE,CACpB,EAAO,IAAI,GAAM,OAAO,CAAI,EAAO,IAAI,GAAM,OAAO,CACpD,EAAM,IAAI,GAAM,OAAO,CAAI,EAAO,IAAI,GAAM,OAAO,CACnD,EAAI,IAAI,GAAM,OAAO,CAEtB,IAAM,EAAI,EAAG,EAAK,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAE,EAAI,EAAI,IAE/C,CAAI,CAAE,EAAG,CAAG,IAAI,GAAM,OAAO,CAC7B,CAAI,CAAE,EAAG,CAAG,IAAI,GAAM,OAAO,CAI9B,SAAS,EAAgB,CAAO,CAAE,CAAC,CAAE,CAAC,CAAE,CAAC,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,EAEpD,EAAK,EAAQ,QAAQ,CAAE,EAAG,CAC1B,EAAK,EAAQ,QAAQ,CAAE,EAAG,CAC1B,EAAK,EAAQ,QAAQ,CAAE,EAAG,CAE1B,EAAM,CAAE,CAAE,EAAI,CACd,EAAM,CAAE,CAAE,EAAI,CACd,EAAM,CAAE,CAAE,EAAI,CAEd,EAAK,EAAG,CAAC,CAAG,EAAG,CAAC,CAChB,EAAK,EAAG,CAAC,CAAG,EAAG,CAAC,CAChB,EAAK,EAAG,CAAC,CAAG,EAAG,CAAC,CAChB,EAAK,EAAG,CAAC,CAAG,EAAG,CAAC,CAChB,EAAK,EAAG,CAAC,CAAG,EAAG,CAAC,CAChB,EAAK,EAAG,CAAC,CAAG,EAAG,CAAC,CAEhB,EAAK,EAAI,CAAC,CAAG,EAAI,CAAC,CAClB,EAAK,EAAI,CAAC,CAAG,EAAI,CAAC,CAClB,EAAK,EAAI,CAAC,CAAG,EAAI,CAAC,CAGlB,EAAI,EAAQ,CAAA,EAFZ,CAAA,EAAK,EAAI,CAAC,CAAG,EAAI,CAAC,AAAD,EAEK,EAAK,CAAA,EAC3B,EAAK,GAAG,CAAE,AAAE,CAAA,EAAK,EAAK,EAAK,CAAA,EAAO,EAC5B,AAAA,CAAA,EAAK,EAAK,EAAK,CAAA,EAAO,EACtB,AAAA,CAAA,EAAK,EAAK,EAAK,CAAA,EAAO,GAC5B,EAAK,GAAG,CAAE,AAAE,CAAA,EAAK,EAAK,EAAK,CAAA,EAAO,EAC5B,AAAA,CAAA,EAAK,EAAK,EAAK,CAAA,EAAO,EACtB,AAAA,CAAA,EAAK,EAAK,EAAK,CAAA,EAAO,GAE5B,CAAI,CAAE,EAAG,CAAC,GAAG,CAAE,GACf,CAAI,CAAE,EAAG,CAAC,GAAG,CAAE,GACf,CAAI,CAAE,EAAG,CAAC,GAAG,CAAE,GAEf,CAAI,CAAE,EAAG,CAAC,GAAG,CAAE,GACf,CAAI,CAAE,EAAG,CAAC,GAAG,CAAE,GACf,CAAI,CAAE,EAAG,CAAC,GAAG,CAAE,EAEhB,CAEA,IAAM,EAAI,EAAG,EAAK,IAAI,CAAC,KAAK,CAAC,MAAM,CAAE,EAAI,EAAI,IAE5C,EAAO,IAAI,CAAC,KAAK,CAAE,EAAG,CACtB,EAAK,IAAI,CAAC,aAAa,CAAE,EAAG,CAAE,EAAG,CAE5B,aAAgB,GAAM,KAAK,CAE/B,EAAgB,IAAI,CAAE,EAAK,CAAC,CAAE,EAAK,CAAC,CAAE,EAAK,CAAC,CAAE,EAAG,EAAG,GAEzC,aAAgB,GAAM,KAAK,GAEtC,EAAgB,IAAI,CAAE,EAAK,CAAC,CAAE,EAAK,CAAC,CAAE,EAAK,CAAC,CAAE,EAAG,EAAG,GACpD,EAAgB,IAAI,CAAE,EAAK,CAAC,CAAE,EAAK,CAAC,CAAE,EAAK,CAAC,CAAE,EAAG,EAAG,IAMtD,IAAI,EAAY,CAAE,IAAK,IAAK,IAAK,IAAK,CAEtC,IAAM,EAAI,EAAG,EAAK,IAAI,CAAC,KAAK,CAAC,MAAM,CAAE,EAAI,EAAI,IAI5C,IAAM,EAAI,EAFV,EAAO,IAAI,CAAC,KAAK,CAAE,EAAG,CAET,EAAI,EAAK,aAAa,CAAC,MAAM,CAAE,IAE3C,EAAE,IAAI,CAAE,EAAK,aAAa,CAAE,EAAG,EAI/B,EAAI,CAAI,CAFR,EAAc,CAAI,CAAE,CAAS,CAAE,EAAG,CAAE,CAEb,CAIvB,EAAI,IAAI,CAAE,GACV,EAAI,GAAG,CAAE,EAAE,cAAc,CAAE,EAAE,GAAG,CAAE,KAAQ,SAAS,GAInD,EAAK,YAAY,CAAE,EAAK,aAAa,CAAE,EAAG,CAAE,GAE5C,EAAI,AAAQ,EADL,EAAK,GAAG,CAAE,CAAI,CAAE,EAAa,EACjB,GAAO,EAE1B,EAAK,cAAc,CAAE,EAAG,CAAG,IAAI,GAAM,OAAO,CAAE,EAAI,CAAC,CAAE,EAAI,CAAC,CAAE,EAAI,CAAC,CAAE,EAMrE,CAAA,IAAI,CAAC,WAAW,CAAG,CAAA,CAEpB,EAEA,qBAAsB,WAKrB,IAAM,IAHF,EAAI,EACJ,EAAW,IAAI,CAAC,QAAQ,CAElB,EAAI,EAAG,EAAK,EAAS,MAAM,CAAE,EAAI,EAAI,IAEzC,EAAI,GAER,CAAA,GAAK,CAAQ,CAAE,EAAG,CAAC,UAAU,CAAE,CAAQ,CAAE,EAAI,EAAG,CAAA,EAIjD,IAAI,CAAC,aAAa,CAAE,EAAG,CAAG,CAI5B,EAEA,mBAAoB,WAEO,OAArB,IAAI,CAAC,WAAW,EAEpB,CAAA,IAAI,CAAC,WAAW,CAAG,IAAI,GAAM,IAAI,AAFlC,EAMA,IAAI,CAAC,WAAW,CAAC,aAAa,CAAE,IAAI,CAAC,QAAQ,CAE9C,EAEA,sBAAuB,WAEO,OAAxB,IAAI,CAAC,cAAc,EAEvB,CAAA,IAAI,CAAC,cAAc,CAAG,IAAI,GAAM,MAAM,AAFvC,EAMA,IAAI,CAAC,cAAc,CAAC,sBAAsB,CAAE,IAAI,CAAC,cAAc,CAAC,MAAM,CAAE,IAAI,CAAC,QAAQ,CAEtF,EAQA,cAAe,WAEd,IAGI,EAAG,EAGH,EAAE,EAAI,EACN,EAAY,EAAG,EAAI,EAPnB,EAAc,CAAC,EACf,EAAS,EAAE,CAAE,EAAU,EAAE,CAW7B,IAAM,EAAI,EAFV,IAAI,CAAC,aAAa,CAAG,KAAA,EAER,EAAK,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAE,EAAI,EAAI,IAK1C,AAAuB,KAAA,IAAvB,CAAW,CAFhB,EAAM,CAAE,KAAK,KAAK,CAAE,AAVL,IAUK,AADpB,CAAA,EAAI,IAAI,CAAC,QAAQ,CAAE,EAAG,AAAH,EACG,CAAC,EAAgB,KAAK,KAAK,CAAE,AAVpC,IAUoC,EAAE,CAAC,EAAgB,KAAK,KAAK,CAAE,AAVnE,IAUmE,EAAE,CAAC,EAAgB,CAAC,IAAI,CAAE,KAErF,EAEtB,CAAW,CAAE,EAAK,CAAG,EACrB,EAAO,IAAI,CAAE,IAAI,CAAC,QAAQ,CAAE,EAAG,EAC/B,CAAO,CAAE,EAAG,CAAG,EAAO,MAAM,CAAG,GAK/B,CAAO,CAAE,EAAG,CAAG,CAAO,CAAE,CAAW,CAAE,EAAK,CAAE,CAS9C,IAAI,EAAsB,EAAE,CAE5B,IAAK,EAAI,EAAG,EAAK,IAAI,CAAC,KAAK,CAAC,MAAM,CAAE,EAAI,EAAI,IAI3C,GAAK,AAFL,CAAA,EAAO,IAAI,CAAC,KAAK,CAAE,EAAG,AAAH,YAEE,GAAM,KAAK,CAAG,CAElC,EAAK,CAAC,CAAG,CAAO,CAAE,EAAK,CAAC,CAAE,CAC1B,EAAK,CAAC,CAAG,CAAO,CAAE,EAAK,CAAC,CAAE,CAC1B,EAAK,CAAC,CAAG,CAAO,CAAE,EAAK,CAAC,CAAE,CAE1B,EAAU,CAAE,EAAK,CAAC,CAAE,EAAK,CAAC,CAAE,EAAK,CAAC,CAAE,CAMpC,IAAM,IAJF,EAAW,GAIL,EAAI,EAAG,EAAI,EAAG,IACvB,GAAK,CAAO,CAAE,EAAG,EAAI,CAAO,CAAE,AAAE,CAAA,EAAI,CAAA,EAAM,EAAG,CAAG,CAE/C,EAAW,EACX,EAAoB,IAAI,CAAE,GAC1B,KAED,CAGF,MAAO,GAAK,aAAgB,GAAM,KAAK,CAAG,CAEzC,EAAK,CAAC,CAAG,CAAO,CAAE,EAAK,CAAC,CAAE,CAC1B,EAAK,CAAC,CAAG,CAAO,CAAE,EAAK,CAAC,CAAE,CAC1B,EAAK,CAAC,CAAG,CAAO,CAAE,EAAK,CAAC,CAAE,CAC1B,EAAK,CAAC,CAAG,CAAO,CAAE,EAAK,CAAC,CAAE,CAI1B,EAAU,CAAE,EAAK,CAAC,CAAE,EAAK,CAAC,CAAE,EAAK,CAAC,CAAE,EAAK,CAAC,CAAE,CAI5C,IAAM,IAFF,EAAW,GAEL,EAAI,EAAG,EAAI,EAAG,IAElB,CAAO,CAAE,EAAG,EAAI,CAAO,CAAE,AAAE,CAAA,EAAI,CAAA,EAAM,EAAG,GAKvC,GAAY,GAEhB,EAAoB,IAAI,CAAE,GAI3B,EAAW,GAKb,GAAK,GAAY,EAAI,CAEpB,EAAQ,MAAM,CAAE,EAAU,GAE1B,IAAI,EAAU,IAAI,GAAM,KAAK,CAAE,CAAO,CAAC,EAAE,CAAE,CAAO,CAAC,EAAE,CAAE,CAAO,CAAC,EAAE,CAAE,EAAK,MAAM,CAAE,EAAK,KAAK,CAAE,EAAK,aAAa,EAE9G,IAAM,EAAI,EAAG,EAAK,IAAI,CAAC,aAAa,CAAC,MAAM,CAAE,EAAI,EAAI,IAEpD,CAAA,EAAI,IAAI,CAAC,aAAa,CAAE,EAAG,CAAE,EAAG,AAAH,GAG5B,EAAE,MAAM,CAAE,EAAU,EAKlB,CAAA,EAAK,aAAa,EAAI,EAAK,aAAa,CAAC,MAAM,CAAG,IAErD,EAAQ,aAAa,CAAG,EAAK,aAAa,CAC1C,EAAQ,aAAa,CAAC,MAAM,CAAE,EAAU,IAIrC,EAAK,YAAY,EAAI,EAAK,YAAY,CAAC,MAAM,CAAG,IAEnD,EAAQ,YAAY,CAAG,EAAK,YAAY,CACxC,EAAQ,YAAY,CAAC,MAAM,CAAE,EAAU,IAGxC,IAAI,CAAC,KAAK,CAAE,EAAG,CAAG,CACnB,CAED,CAID,IAAM,EAAI,EAAoB,MAAM,CAAG,EAAG,GAAK,EAAG,IAIjD,IAAM,AAFN,IAAI,CAAC,KAAK,CAAC,MAAM,CAAE,EAAG,GAEhB,EAAI,EAAG,EAAK,IAAI,CAAC,aAAa,CAAC,MAAM,CAAE,EAAI,EAAI,IAEpD,IAAI,CAAC,aAAa,CAAE,EAAG,CAAC,MAAM,CAAE,EAAG,GAQrC,IAAI,EAAO,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAG,EAAO,MAAM,CAE/C,OADA,IAAI,CAAC,QAAQ,CAAG,EACT,CAER,EAEA,MAAO,WAMN,IAAM,IAJF,EAAW,IAAI,GAAM,QAAQ,CAE7B,EAAW,IAAI,CAAC,QAAQ,CAElB,EAAI,EAAG,EAAK,EAAS,MAAM,CAAE,EAAI,EAAI,IAE9C,EAAS,QAAQ,CAAC,IAAI,CAAE,CAAQ,CAAE,EAAG,CAAC,KAAK,IAM5C,IAAM,IAFF,EAAQ,IAAI,CAAC,KAAK,CAEZ,EAAI,EAAG,EAAK,EAAM,MAAM,CAAE,EAAI,EAAI,IAE3C,EAAS,KAAK,CAAC,IAAI,CAAE,CAAK,CAAE,EAAG,CAAC,KAAK,IAMtC,IAAM,IAFF,EAAM,IAAI,CAAC,aAAa,CAAE,EAAG,CAEvB,EAAI,EAAG,EAAK,EAAI,MAAM,CAAE,EAAI,EAAI,IAAO,CAIhD,IAAM,IAFF,EAAK,CAAG,CAAE,EAAG,CAAE,EAAS,EAAE,CAEpB,EAAI,EAAG,EAAK,EAAG,MAAM,CAAE,EAAI,EAAI,IAExC,EAAO,IAAI,CAAE,IAAI,GAAM,OAAO,CAAE,CAAE,CAAE,EAAG,CAAC,CAAC,CAAE,CAAE,CAAE,EAAG,CAAC,CAAC,GAIrD,EAAS,aAAa,CAAE,EAAG,CAAC,IAAI,CAAE,EAEnC,CAEA,OAAO,CAER,EAEA,QAAS,WAER,IAAI,CAAC,aAAa,CAAE,CAAE,KAAM,SAAU,EAEvC,CAED,EAEA,GAAM,eAAe,CAAG,EAKxB,GAAM,cAAc,CAAG,WAEtB,GAAM,eAAe,CAAC,IAAI,CAAE,IAAI,EAEhC,IAAI,CAAC,EAAE,CAAG,GAAM,eAAe,GAI/B,IAAI,CAAC,UAAU,CAAG,CAAC,EAInB,IAAI,CAAC,OAAO,CAAG,CAAA,EAIf,IAAI,CAAC,OAAO,CAAG,EAAE,CAIjB,IAAI,CAAC,WAAW,CAAG,KACnB,IAAI,CAAC,cAAc,CAAG,KAEtB,IAAI,CAAC,WAAW,CAAG,CAAA,EAInB,IAAI,CAAC,YAAY,CAAG,EAAE,AAEvB,EAEA,GAAM,cAAc,CAAC,SAAS,CAAG,CAEhC,YAAc,GAAM,cAAc,CAElC,YAAa,SAAW,CAAM,EAe7B,GAVK,IAAI,CAAC,UAAU,CAAE,QAAY,EAAG,CAAA,EAAgB,IAAI,CAAC,UAAU,CAAE,QAAY,CAAC,KAAK,AAAL,EAC9E,IAAI,CAAC,UAAU,CAAE,MAAU,EAAG,CAAA,EAAc,IAAI,CAAC,UAAU,CAAE,MAAU,CAAC,KAAK,AAAL,EAEtD,KAAA,IAAlB,IAEJ,EAAO,oBAAoB,CAAE,GAC7B,IAAI,CAAC,kBAAkB,CAAG,CAAA,GAItB,AAAgB,KAAA,IAAhB,EAA4B,CAEhC,IAfG,EACA,EAcC,EAAe,IAAI,GAAM,OAAO,CACpC,EAAa,UAAU,CAAE,GAAS,SAAS,GAE3C,EAAa,oBAAoB,CAAE,GAEnC,IAAI,CAAC,gBAAgB,GAErB,IAAI,CAAC,iBAAiB,CAAG,CAAA,CAE1B,CAED,EAEA,mBAAoB,WAEO,OAArB,IAAI,CAAC,WAAW,EAEpB,CAAA,IAAI,CAAC,WAAW,CAAG,IAAI,GAAM,IAAI,AAFlC,EAMA,IAAI,EAAY,IAAI,CAAC,UAAU,CAAE,QAAY,CAAC,KAAK,CAEnD,GAAK,EAAY,CAEhB,IACI,EAAG,EAAG,EADN,EAAK,IAAI,CAAC,WAAW,AAGrB,CAAA,EAAU,MAAM,EAAI,IACvB,EAAG,GAAG,CAAC,CAAC,CAAG,EAAG,GAAG,CAAC,CAAC,CAAG,CAAS,CAAE,EAAG,CACpC,EAAG,GAAG,CAAC,CAAC,CAAG,EAAG,GAAG,CAAC,CAAC,CAAG,CAAS,CAAE,EAAG,CACpC,EAAG,GAAG,CAAC,CAAC,CAAG,EAAG,GAAG,CAAC,CAAC,CAAG,CAAS,CAAE,EAAG,EAGrC,IAAM,IAAI,EAAI,EAAG,EAAK,EAAU,MAAM,CAAE,EAAI,EAAI,GAAK,EAEpD,EAAI,CAAS,CAAE,EAAG,CAClB,EAAI,CAAS,CAAE,EAAI,EAAG,CACtB,EAAI,CAAS,CAAE,EAAI,EAAG,CAIjB,EAAI,EAAG,GAAG,CAAC,CAAC,CAEhB,EAAG,GAAG,CAAC,CAAC,CAAG,EAEA,EAAI,EAAG,GAAG,CAAC,CAAC,EAEvB,CAAA,EAAG,GAAG,CAAC,CAAC,CAAG,CAAA,EAIP,EAAI,EAAG,GAAG,CAAC,CAAC,CAEhB,EAAG,GAAG,CAAC,CAAC,CAAG,EAEA,EAAI,EAAG,GAAG,CAAC,CAAC,EAEvB,CAAA,EAAG,GAAG,CAAC,CAAC,CAAG,CAAA,EAIP,EAAI,EAAG,GAAG,CAAC,CAAC,CAEhB,EAAG,GAAG,CAAC,CAAC,CAAG,EAEA,EAAI,EAAG,GAAG,CAAC,CAAC,EAEvB,CAAA,EAAG,GAAG,CAAC,CAAC,CAAG,CAAA,CAMd,CAEK,CAAA,AAAc,KAAA,IAAd,GAA2B,AAAqB,IAArB,EAAU,MAAM,AAAK,IAEpD,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,GAAG,CAAE,EAAG,EAAG,GAChC,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,GAAG,CAAE,EAAG,EAAG,GAIlC,EAEA,sBAAuB,WAEO,OAAxB,IAAI,CAAC,cAAc,EAEvB,CAAA,IAAI,CAAC,cAAc,CAAG,IAAI,GAAM,MAAM,AAFvC,EAMA,IAAI,EAAY,IAAI,CAAC,UAAU,CAAE,QAAY,CAAC,KAAK,CAEnD,GAAK,EAAY,CAKhB,IAAM,IAFF,EAAG,EAAG,EADN,EAAU,EAAc,EAGlB,EAAI,EAAG,EAAK,EAAU,MAAM,CAAE,EAAI,EAAI,GAAK,EAMpD,CAAA,EAAY,AAJZ,CAAA,EAAI,CAAS,CAAE,EAAG,AAAH,EAIC,EAAI,AAHpB,CAAA,EAAI,CAAS,CAAE,EAAI,EAAG,AAAH,EAGK,EAAI,AAF5B,CAAA,EAAI,CAAS,CAAE,EAAI,EAAG,AAAH,EAEa,CAAA,EAChB,GAAc,CAAA,EAAc,CAA5C,CAID,CAAA,IAAI,CAAC,cAAc,CAAC,MAAM,CAAG,KAAK,IAAI,CAAE,EAEzC,CAED,EAEA,qBAAsB,WAErB,GAAK,IAAI,CAAC,UAAU,CAAE,QAAY,CAAG,CAKpC,IAAI,EAAkB,IAAI,CAAC,UAAU,CAAE,QAAY,CAAC,KAAK,CAAC,MAAM,CAEhE,GAAK,AAAgC,KAAA,IAAhC,IAAI,CAAC,UAAU,CAAE,MAAU,CAE/B,IAAI,CAAC,UAAU,CAAE,MAAU,CAAG,CAE7B,SAAU,EACV,MAAO,IAAI,aAAc,GACzB,SAAU,CAEX,OAMA,IAAM,EAAI,EAAG,EAAK,IAAI,CAAC,UAAU,CAAE,MAAU,CAAC,KAAK,CAAC,MAAM,CAAE,EAAI,EAAI,IAEnE,IAAI,CAAC,UAAU,CAAE,MAAU,CAAC,KAAK,CAAE,EAAG,CAAG,EAM3C,IA3BI,EAAG,EACH,EAAG,EA6BH,EAAI,EAAI,EAAI,EAAG,EAAG,EAHlB,EAAY,IAAI,CAAC,UAAU,CAAE,QAAY,CAAC,KAAK,CAC/C,EAAU,IAAI,CAAC,UAAU,CAAE,MAAU,CAAC,KAAK,CAI/C,EAAK,IAAI,GAAM,OAAO,CACtB,EAAK,IAAI,GAAM,OAAO,CACtB,EAAK,IAAI,GAAM,OAAO,CAEtB,EAAK,IAAI,GAAM,OAAO,CACtB,EAAK,IAAI,GAAM,OAAO,CAItB,GAAK,IAAI,CAAC,UAAU,CAAE,KAAS,CAAG,CAEjC,IAAI,EAAU,IAAI,CAAC,UAAU,CAAE,KAAS,CAAC,KAAK,CAE1C,EAAU,IAAI,CAAC,OAAO,CAE1B,IAAM,EAAI,EAAG,EAAK,EAAQ,MAAM,CAAE,EAAI,EAAI,EAAG,EAAI,CAEhD,IAAI,EAAQ,CAAO,CAAE,EAAG,CAAC,KAAK,CAC1B,EAAQ,CAAO,CAAE,EAAG,CAAC,KAAK,CAC1B,EAAQ,CAAO,CAAE,EAAG,CAAC,KAAK,CAE9B,IAAM,EAAI,EAAO,EAAK,EAAQ,EAAO,EAAI,EAAI,GAAK,EAEjD,EAAK,EAAQ,CAAO,CAAE,EAAG,CACzB,EAAK,EAAQ,CAAO,CAAE,EAAI,EAAG,CAC7B,EAAK,EAAQ,CAAO,CAAE,EAAI,EAAG,CAE7B,EAAI,CAAS,CAAE,AAAK,EAAL,EAAQ,CACvB,EAAI,CAAS,CAAE,AAAK,EAAL,EAAS,EAAG,CAC3B,EAAI,CAAS,CAAE,AAAK,EAAL,EAAS,EAAG,CAC3B,EAAG,GAAG,CAAE,EAAG,EAAG,GAEd,EAAI,CAAS,CAAE,AAAK,EAAL,EAAQ,CACvB,EAAI,CAAS,CAAE,AAAK,EAAL,EAAS,EAAG,CAC3B,EAAI,CAAS,CAAE,AAAK,EAAL,EAAS,EAAG,CAC3B,EAAG,GAAG,CAAE,EAAG,EAAG,GAEd,EAAI,CAAS,CAAE,AAAK,EAAL,EAAQ,CACvB,EAAI,CAAS,CAAE,AAAK,EAAL,EAAS,EAAG,CAC3B,EAAI,CAAS,CAAE,AAAK,EAAL,EAAS,EAAG,CAC3B,EAAG,GAAG,CAAE,EAAG,EAAG,GAEd,EAAG,UAAU,CAAE,EAAI,GACnB,EAAG,UAAU,CAAE,EAAI,GACnB,EAAG,KAAK,CAAE,GAEV,CAAO,CAAE,AAAK,EAAL,EAAQ,EAAQ,EAAG,CAAC,CAC7B,CAAO,CAAE,AAAK,EAAL,EAAS,EAAG,EAAI,EAAG,CAAC,CAC7B,CAAO,CAAE,AAAK,EAAL,EAAS,EAAG,EAAI,EAAG,CAAC,CAE7B,CAAO,CAAE,AAAK,EAAL,EAAQ,EAAQ,EAAG,CAAC,CAC7B,CAAO,CAAE,AAAK,EAAL,EAAS,EAAG,EAAI,EAAG,CAAC,CAC7B,CAAO,CAAE,AAAK,EAAL,EAAS,EAAG,EAAI,EAAG,CAAC,CAE7B,CAAO,CAAE,AAAK,EAAL,EAAQ,EAAQ,EAAG,CAAC,CAC7B,CAAO,CAAE,AAAK,EAAL,EAAS,EAAG,EAAI,EAAG,CAAC,CAC7B,CAAO,CAAE,AAAK,EAAL,EAAS,EAAG,EAAI,EAAG,CAAC,AAI/B,CAID,MAEC,IAAM,EAAI,EAAG,EAAK,EAAU,MAAM,CAAE,EAAI,EAAI,GAAK,EAEhD,EAAI,CAAS,CAAE,EAAG,CAClB,EAAI,CAAS,CAAE,EAAI,EAAG,CACtB,EAAI,CAAS,CAAE,EAAI,EAAG,CACtB,EAAG,GAAG,CAAE,EAAG,EAAG,GAEd,EAAI,CAAS,CAAE,EAAI,EAAG,CACtB,EAAI,CAAS,CAAE,EAAI,EAAG,CACtB,EAAI,CAAS,CAAE,EAAI,EAAG,CACtB,EAAG,GAAG,CAAE,EAAG,EAAG,GAEd,EAAI,CAAS,CAAE,EAAI,EAAG,CACtB,EAAI,CAAS,CAAE,EAAI,EAAG,CACtB,EAAI,CAAS,CAAE,EAAI,EAAG,CACtB,EAAG,GAAG,CAAE,EAAG,EAAG,GAEd,EAAG,UAAU,CAAE,EAAI,GACnB,EAAG,UAAU,CAAE,EAAI,GACnB,EAAG,KAAK,CAAE,GAEV,CAAO,CAAE,EAAG,CAAK,EAAG,CAAC,CACrB,CAAO,CAAE,EAAI,EAAG,CAAG,EAAG,CAAC,CACvB,CAAO,CAAE,EAAI,EAAG,CAAG,EAAG,CAAC,CAEvB,CAAO,CAAE,EAAI,EAAG,CAAG,EAAG,CAAC,CACvB,CAAO,CAAE,EAAI,EAAG,CAAG,EAAG,CAAC,CACvB,CAAO,CAAE,EAAI,EAAG,CAAG,EAAG,CAAC,CAEvB,CAAO,CAAE,EAAI,EAAG,CAAG,EAAG,CAAC,CACvB,CAAO,CAAE,EAAI,EAAG,CAAG,EAAG,CAAC,CACvB,CAAO,CAAE,EAAI,EAAG,CAAG,EAAG,CAAC,CAMzB,IAAI,CAAC,gBAAgB,GAErB,IAAI,CAAC,iBAAiB,CAAG,CAAA,CAE1B,CAED,EAEA,iBAAkB,WAMjB,IAAM,IAFF,EAAG,EAAG,EAAG,EAFT,EAAU,IAAI,CAAC,UAAU,CAAE,MAAU,CAAC,KAAK,CAIrC,EAAI,EAAG,EAAK,EAAQ,MAAM,CAAE,EAAI,EAAI,GAAK,EAMlD,EAAI,EAAM,KAAK,IAAI,CAAE,AAJrB,CAAA,EAAI,CAAO,CAAE,EAAG,AAAH,EAIY,EAAI,AAH7B,CAAA,EAAI,CAAO,CAAE,EAAI,EAAG,AAAH,EAGgB,EAAI,AAFrC,CAAA,EAAI,CAAO,CAAE,EAAI,EAAG,AAAH,EAEwB,GAEzC,CAAO,CAAE,EAAG,EAAM,EAClB,CAAO,CAAE,EAAI,EAAG,EAAI,EACpB,CAAO,CAAE,EAAI,EAAG,EAAI,CAItB,EAEA,gBAAiB,WAKhB,GAAK,AAA+B,KAAA,IAA/B,IAAI,CAAC,UAAU,CAAE,KAAS,EAC7B,AAAkC,KAAA,IAAlC,IAAI,CAAC,UAAU,CAAE,QAAY,EAC7B,AAAgC,KAAA,IAAhC,IAAI,CAAC,UAAU,CAAE,MAAU,EAC3B,AAA4B,KAAA,IAA5B,IAAI,CAAC,UAAU,CAAE,EAAM,CAAiB,CAEzC,QAAQ,IAAI,CAAE,mGACd,MAED,CAEA,IAgCI,EAAI,EAAI,EACX,EAAI,EAAI,EACR,EAAI,EAAI,EAER,EAAI,EACJ,EAAI,EACJ,EAAI,EAEJ,EAAI,EAAI,EAAI,EAAI,EAAI,EACpB,EAAI,EAAI,EAAI,EAAI,EAkEb,EAAG,EACH,EAAG,EACH,EAAI,EAAI,EAwBR,EAAG,EArIH,EAAU,IAAI,CAAC,UAAU,CAAE,KAAS,CAAC,KAAK,CAC1C,EAAY,IAAI,CAAC,UAAU,CAAE,QAAY,CAAC,KAAK,CAC/C,EAAU,IAAI,CAAC,UAAU,CAAE,MAAU,CAAC,KAAK,CAC3C,EAAM,IAAI,CAAC,UAAU,CAAE,EAAM,CAAC,KAAK,CAEnC,EAAY,EAAU,MAAM,CAAG,EAEnC,GAAK,AAAiC,KAAA,IAAjC,IAAI,CAAC,UAAU,CAAE,OAAW,CAAiB,CAEjD,IAAI,EAAmB,EAAI,CAE3B,CAAA,IAAI,CAAC,UAAU,CAAE,OAAW,CAAG,CAE9B,SAAU,EACV,MAAO,IAAI,aAAc,GACzB,SAAU,CAEX,CAED,CAMA,IAAM,IAJF,EAAW,IAAI,CAAC,UAAU,CAAE,OAAW,CAAC,KAAK,CAE7C,EAAO,EAAE,CAAE,EAAO,EAAE,CAEd,EAAI,EAAG,EAAI,EAAW,IAE/B,CAAI,CAAE,EAAG,CAAG,IAAI,GAAM,OAAO,CAC7B,CAAI,CAAE,EAAG,CAAG,IAAI,GAAM,OAAO,CAP9B,IAsBI,EAAO,IAAI,GAAM,OAAO,CAAI,EAAO,IAAI,GAAM,OAAO,CAoEpD,EAAU,IAAI,CAAC,OAAO,CAE1B,IAAM,EAAI,EAAG,EAAK,EAAQ,MAAM,CAAE,EAAI,EAAI,EAAG,EAAI,CAEhD,IAtEwB,EAAG,EAAG,EAsE1B,EAAQ,CAAO,CAAE,EAAG,CAAC,KAAK,CAC1B,EAAQ,CAAO,CAAE,EAAG,CAAC,KAAK,CAC1B,EAAQ,CAAO,CAAE,EAAG,CAAC,KAAK,CAE9B,IAAM,EAAI,EAAO,EAAK,EAAQ,EAAO,EAAI,EAAI,GAAK,EAEjD,EAAK,EAAQ,CAAO,CAAE,EAAG,CACzB,EAAK,EAAQ,CAAO,CAAE,EAAI,EAAG,CAC7B,EAAK,EAAQ,CAAO,CAAE,EAAI,EAAG,CA9EN,EAgFP,EAhFU,EAgFN,EAhFS,EAgFL,EA9EzB,EAAK,CAAS,CAAE,AAAI,EAAJ,EAAO,CACvB,EAAK,CAAS,CAAE,AAAI,EAAJ,EAAQ,EAAG,CAC3B,EAAK,CAAS,CAAE,AAAI,EAAJ,EAAQ,EAAG,CAE3B,EAAK,CAAS,CAAE,AAAI,EAAJ,EAAO,CACvB,EAAK,CAAS,CAAE,AAAI,EAAJ,EAAQ,EAAG,CAC3B,EAAK,CAAS,CAAE,AAAI,EAAJ,EAAQ,EAAG,CAE3B,EAAK,CAAS,CAAE,AAAI,EAAJ,EAAO,CACvB,EAAK,CAAS,CAAE,AAAI,EAAJ,EAAQ,EAAG,CAC3B,EAAK,CAAS,CAAE,AAAI,EAAJ,EAAQ,EAAG,CAE3B,EAAK,CAAG,CAAE,AAAI,EAAJ,EAAO,CACjB,EAAK,CAAG,CAAE,AAAI,EAAJ,EAAQ,EAAG,CAErB,EAAK,CAAG,CAAE,AAAI,EAAJ,EAAO,CACjB,EAAK,CAAG,CAAE,AAAI,EAAJ,EAAQ,EAAG,CAErB,EAAK,CAAG,CAAE,AAAI,EAAJ,EAAO,CACjB,EAAK,CAAG,CAAE,AAAI,EAAJ,EAAQ,EAAG,CAErB,EAAK,EAAK,EACV,EAAK,EAAK,EAEV,EAAK,EAAK,EACV,EAAK,EAAK,EAEV,EAAK,EAAK,EACV,EAAK,EAAK,EAEV,EAAK,EAAK,EACV,EAAK,EAAK,EAEV,EAAK,EAAK,EAGV,EAAI,EAAQ,CAAA,EAFZ,CAAA,EAAK,EAAK,CAAV,EAEsB,EAAK,CAAA,EAE3B,EAAK,GAAG,CACP,AAAE,CAAA,EAAK,EAAK,EAAK,CAAA,EAAO,EACtB,AAAA,CAAA,EAAK,EAAK,EAAK,CAAA,EAAO,EACtB,AAAA,CAAA,EAAK,EAAK,EAAK,CAAA,EAAO,GAGzB,EAAK,GAAG,CACP,AAAE,CAAA,EAAK,EAAK,EAAK,CAAA,EAAO,EACtB,AAAA,CAAA,EAAK,EAAK,EAAK,CAAA,EAAO,EACtB,AAAA,CAAA,EAAK,EAAK,EAAK,CAAA,EAAO,GAGzB,CAAI,CAAE,EAAG,CAAC,GAAG,CAAE,GACf,CAAI,CAAE,EAAG,CAAC,GAAG,CAAE,GACf,CAAI,CAAE,EAAG,CAAC,GAAG,CAAE,GAEf,CAAI,CAAE,EAAG,CAAC,GAAG,CAAE,GACf,CAAI,CAAE,EAAG,CAAC,GAAG,CAAE,GACf,CAAI,CAAE,EAAG,CAAC,GAAG,CAAE,EA0BhB,CAEA,IAAI,GAAM,IAAI,GAAM,OAAO,CAAI,GAAO,IAAI,GAAM,OAAO,CACnD,GAAI,IAAI,GAAM,OAAO,CAAI,GAAK,IAAI,GAAM,OAAO,CAGnD,SAAS,GAAc,CAAC,EAEvB,GAAE,CAAC,CAAG,CAAO,CAAE,AAAI,EAAJ,EAAO,CACtB,GAAE,CAAC,CAAG,CAAO,CAAE,AAAI,EAAJ,EAAQ,EAAG,CAC1B,GAAE,CAAC,CAAG,CAAO,CAAE,AAAI,EAAJ,EAAQ,EAAG,CAE1B,GAAG,IAAI,CAAE,IAET,EAAI,CAAI,CAAE,EAAG,CAIb,GAAI,IAAI,CAAE,GACV,GAAI,GAAG,CAAE,GAAE,cAAc,CAAE,GAAE,GAAG,CAAE,KAAQ,SAAS,GAInD,GAAK,YAAY,CAAE,GAAI,GAEvB,EAAI,AAAS,EADN,GAAK,GAAG,CAAE,CAAI,CAAE,EAAG,EACL,GAAO,EAE5B,CAAQ,CAAE,AAAI,EAAJ,EAAO,CAAM,GAAI,CAAC,CAC5B,CAAQ,CAAE,AAAI,EAAJ,EAAQ,EAAG,CAAG,GAAI,CAAC,CAC7B,CAAQ,CAAE,AAAI,EAAJ,EAAQ,EAAG,CAAG,GAAI,CAAC,CAC7B,CAAQ,CAAE,AAAI,EAAJ,EAAQ,EAAG,CAAG,CAEzB,CAEA,IAAM,EAAI,EAAG,EAAK,EAAQ,MAAM,CAAE,EAAI,EAAI,EAAG,EAAI,CAEhD,IAAI,EAAQ,CAAO,CAAE,EAAG,CAAC,KAAK,CAC1B,EAAQ,CAAO,CAAE,EAAG,CAAC,KAAK,CAC1B,EAAQ,CAAO,CAAE,EAAG,CAAC,KAAK,CAE9B,IAAM,EAAI,EAAO,EAAK,EAAQ,EAAO,EAAI,EAAI,GAAK,EAEjD,EAAK,EAAQ,CAAO,CAAE,EAAG,CACzB,EAAK,EAAQ,CAAO,CAAE,EAAI,EAAG,CAC7B,EAAK,EAAQ,CAAO,CAAE,EAAI,EAAG,CAE7B,GAAc,GACd,GAAc,GACd,GAAc,EAIhB,CAEA,IAAI,CAAC,WAAW,CAAG,CAAA,EACnB,IAAI,CAAC,kBAAkB,CAAG,CAAA,CAE3B,EAEA,QAAS,WAER,IAAI,CAAC,aAAa,CAAE,CAAE,KAAM,SAAU,EAEvC,CAED,EAOA,GAAM,MAAM,CAAG,WAEd,GAAM,QAAQ,CAAC,IAAI,CAAE,IAAI,EAEzB,IAAI,CAAC,kBAAkB,CAAG,IAAI,GAAM,OAAO,CAE3C,IAAI,CAAC,gBAAgB,CAAG,IAAI,GAAM,OAAO,CACzC,IAAI,CAAC,uBAAuB,CAAG,IAAI,GAAM,OAAO,AAEjD,EAEA,GAAM,MAAM,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,QAAQ,CAAC,SAAS,EAEhE,GAAM,MAAM,CAAC,SAAS,CAAC,MAAM,CAAG,SAAW,CAAM,EAIhD,IAAI,CAAC,MAAM,CAAC,MAAM,CAAE,IAAI,CAAC,QAAQ,CAAE,EAAQ,IAAI,CAAC,EAAE,EAEjB,CAAA,IAA5B,IAAI,CAAC,kBAAkB,GAEtB,AAAuB,CAAA,IAAvB,IAAI,CAAC,aAAa,CAEtB,IAAI,CAAC,QAAQ,CAAC,0BAA0B,CAAE,IAAI,CAAC,MAAM,CAAE,IAAI,CAAC,UAAU,EAItE,IAAI,CAAC,UAAU,CAAC,IAAI,CAAE,IAAI,CAAC,MAAM,CAAC,SAAS,EAAE,CAAE,EAAG,EAMrD,EAKA,GAAM,kBAAkB,CAAG,SAAW,CAAI,CAAE,CAAK,CAAE,CAAG,CAAE,CAAM,CAAE,CAAI,CAAE,CAAG,EAExE,GAAM,MAAM,CAAC,IAAI,CAAE,IAAI,EAEvB,IAAI,CAAC,IAAI,CAAG,EACZ,IAAI,CAAC,KAAK,CAAG,EACb,IAAI,CAAC,GAAG,CAAG,EACX,IAAI,CAAC,MAAM,CAAG,EAEd,IAAI,CAAC,IAAI,CAAG,AAAW,KAAA,IAAX,EAAyB,EAAO,GAC5C,IAAI,CAAC,GAAG,CAAG,AAAU,KAAA,IAAV,EAAwB,EAAM,IAEzC,IAAI,CAAC,sBAAsB,EAE5B,EAEA,GAAM,kBAAkB,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,MAAM,CAAC,SAAS,EAE1E,GAAM,kBAAkB,CAAC,SAAS,CAAC,sBAAsB,CAAG,WAE3D,IAAI,CAAC,gBAAgB,CAAC,gBAAgB,CAAE,IAAI,CAAC,IAAI,CAAE,IAAI,CAAC,KAAK,CAAE,IAAI,CAAC,GAAG,CAAE,IAAI,CAAC,MAAM,CAAE,IAAI,CAAC,IAAI,CAAE,IAAI,CAAC,GAAG,CAE1G,EAOA,GAAM,iBAAiB,CAAG,SAAW,CAAG,CAAE,CAAM,CAAE,CAAI,CAAE,CAAG,EAE1D,GAAM,MAAM,CAAC,IAAI,CAAE,IAAI,EAEvB,IAAI,CAAC,GAAG,CAAG,AAAQ,KAAA,IAAR,EAAoB,EAAM,GACrC,IAAI,CAAC,MAAM,CAAG,AAAW,KAAA,IAAX,EAAuB,EAAS,EAC9C,IAAI,CAAC,IAAI,CAAG,AAAS,KAAA,IAAT,EAAqB,EAAO,GACxC,IAAI,CAAC,GAAG,CAAG,AAAQ,KAAA,IAAR,EAAoB,EAAM,IAErC,IAAI,CAAC,sBAAsB,EAE5B,EAEA,GAAM,iBAAiB,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,MAAM,CAAC,SAAS,EASzE,GAAM,iBAAiB,CAAC,SAAS,CAAC,OAAO,CAAG,SAAW,CAAW,CAAE,CAAW,EAEzD,KAAA,IAAhB,GAA4B,CAAA,EAAc,EAA/C,EAEA,IAAI,CAAC,GAAG,CAAG,EAAI,GAAM,IAAI,CAAC,QAAQ,CAAE,KAAK,IAAI,CAAE,EAAgB,CAAA,AAAc,EAAd,CAAc,IAC7E,IAAI,CAAC,sBAAsB,EAE5B,EAuCA,GAAM,iBAAiB,CAAC,SAAS,CAAC,aAAa,CAAG,SAAW,CAAS,CAAE,CAAU,CAAE,CAAC,CAAE,CAAC,CAAE,CAAK,CAAE,CAAM,EAEtG,IAAI,CAAC,SAAS,CAAG,EACjB,IAAI,CAAC,UAAU,CAAG,EAClB,IAAI,CAAC,CAAC,CAAG,EACT,IAAI,CAAC,CAAC,CAAG,EACT,IAAI,CAAC,KAAK,CAAG,EACb,IAAI,CAAC,MAAM,CAAG,EAEd,IAAI,CAAC,sBAAsB,EAE5B,EAGA,GAAM,iBAAiB,CAAC,SAAS,CAAC,sBAAsB,CAAG,WAE1D,GAAK,IAAI,CAAC,SAAS,CAAG,CAErB,IAAI,EAAS,IAAI,CAAC,SAAS,CAAG,IAAI,CAAC,UAAU,CACzC,EAAM,KAAK,GAAG,CAAE,GAAM,IAAI,CAAC,QAAQ,CAAE,AAAW,GAAX,IAAI,CAAC,GAAG,GAAa,IAAI,CAAC,IAAI,CACnE,EAAS,CAAC,EACV,EAAO,EAAS,EAEhB,EAAQ,KAAK,GAAG,CAAE,AADV,EAAS,EACS,GAC1B,EAAS,KAAK,GAAG,CAAE,EAAM,GAE7B,IAAI,CAAC,gBAAgB,CAAC,WAAW,CAChC,EAAO,IAAI,CAAC,CAAC,CAAG,EAAQ,IAAI,CAAC,SAAS,CACtC,EAAO,AAAE,CAAA,IAAI,CAAC,CAAC,CAAG,IAAI,CAAC,KAAK,AAAL,EAAU,EAAQ,IAAI,CAAC,SAAS,CACvD,EAAM,AAAE,CAAA,IAAI,CAAC,CAAC,CAAG,IAAI,CAAC,MAAM,AAAN,EAAW,EAAS,IAAI,CAAC,UAAU,CACzD,EAAM,IAAI,CAAC,CAAC,CAAG,EAAS,IAAI,CAAC,UAAU,CACvC,IAAI,CAAC,IAAI,CACT,IAAI,CAAC,GAAG,CAGV,MAEC,IAAI,CAAC,gBAAgB,CAAC,eAAe,CAAE,IAAI,CAAC,GAAG,CAAE,IAAI,CAAC,MAAM,CAAE,IAAI,CAAC,IAAI,CAAE,IAAI,CAAC,GAAG,CAInF,EAMA,GAAM,KAAK,CAAG,SAAW,CAAG,EAE3B,GAAM,QAAQ,CAAC,IAAI,CAAE,IAAI,EAEzB,IAAI,CAAC,KAAK,CAAG,IAAI,GAAM,KAAK,CAAE,EAE/B,EAEA,GAAM,KAAK,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,QAAQ,CAAC,SAAS,EAK/D,GAAM,YAAY,CAAG,SAAW,CAAG,EAElC,GAAM,KAAK,CAAC,IAAI,CAAE,IAAI,CAAE,EAEzB,EAEA,GAAM,YAAY,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,KAAK,CAAC,SAAS,EAMnE,GAAM,SAAS,CAAG,SAAW,CAAG,CAAE,CAAS,EAE1C,GAAM,KAAK,CAAC,IAAI,CAAE,IAAI,CAAE,GAExB,IAAI,CAAC,MAAM,CAAG,IAAI,GAAM,OAAO,CAAE,EAAG,GAAI,GACxC,IAAI,CAAC,KAAK,CAAG,IAAI,GAAM,OAAO,CAAE,EAAG,EAAG,GAEtC,IAAI,CAAC,SAAS,CAAG,AAAgB,KAAA,IAAhB,EAA8B,EAAY,EAE3D,IAAI,CAAC,KAAK,CAAG,EACb,IAAI,CAAC,MAAM,CAAG,EAEd,IAAI,CAAC,mBAAmB,CAAG,IAC3B,IAAI,CAAC,iBAAiB,CAAG,GACzB,IAAI,CAAC,oBAAoB,CAAG,EAE7B,EAEA,GAAM,SAAS,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,KAAK,CAAC,SAAS,EAOhE,GAAM,gBAAgB,CAAG,SAAW,CAAG,CAAE,CAAS,EAEjD,GAAM,KAAK,CAAC,IAAI,CAAE,IAAI,CAAE,GAExB,IAAI,CAAC,QAAQ,CAAG,IAAI,GAAM,OAAO,CAAE,EAAG,EAAG,GACzC,IAAI,CAAC,MAAM,CAAG,IAAI,GAAM,QAAQ,CAEhC,IAAI,CAAC,SAAS,CAAG,AAAgB,KAAA,IAAhB,EAA8B,EAAY,EAE3D,IAAI,CAAC,UAAU,CAAG,CAAA,EAClB,IAAI,CAAC,UAAU,CAAG,CAAA,EAIlB,IAAI,CAAC,gBAAgB,CAAG,GACxB,IAAI,CAAC,eAAe,CAAG,IAEvB,IAAI,CAAC,gBAAgB,CAAG,KACxB,IAAI,CAAC,iBAAiB,CAAG,IACzB,IAAI,CAAC,eAAe,CAAG,IACvB,IAAI,CAAC,kBAAkB,CAAG,KAE1B,IAAI,CAAC,mBAAmB,CAAG,CAAA,EAE3B,IAAI,CAAC,UAAU,CAAG,EAClB,IAAI,CAAC,cAAc,CAAG,GAEtB,IAAI,CAAC,cAAc,CAAG,IACtB,IAAI,CAAC,eAAe,CAAG,IAIvB,IAAI,CAAC,aAAa,CAAG,CAAA,EAErB,IAAI,CAAC,mBAAmB,CAAG,IAAI,GAAM,OAAO,CAAE,EAAG,EAAG,MACpD,IAAI,CAAC,kBAAkB,CAAG,EAE1B,IAAI,CAAC,iBAAiB,CAAG,CAAE,EAAG,EAAG,EAAG,CACpC,IAAI,CAAC,kBAAkB,CAAG,CAAE,IAAK,IAAK,IAAK,CAC3C,IAAI,CAAC,mBAAmB,CAAG,CAAE,IAAK,IAAK,IAAK,CAE5C,IAAI,CAAC,kBAAkB,CAAG,CAAE,GAAQ,IAAO,KAAO,CAClD,IAAI,CAAC,iBAAiB,CAAI,CAAG,IAAO,KAAO,EAAO,CAElD,IAAI,CAAC,kBAAkB,CAAG,EAAE,CAI5B,IAAI,CAAC,SAAS,CAAG,KACjB,IAAI,CAAC,aAAa,CAAG,KACrB,IAAI,CAAC,YAAY,CAAG,KACpB,IAAI,CAAC,YAAY,CAAG,IAErB,EAEA,GAAM,gBAAgB,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,KAAK,CAAC,SAAS,EAKvE,GAAM,eAAe,CAAG,SAAW,CAAW,CAAE,CAAc,CAAE,CAAS,EAExE,GAAM,KAAK,CAAC,IAAI,CAAE,IAAI,CAAE,GAExB,IAAI,CAAC,WAAW,CAAG,IAAI,GAAM,KAAK,CAAE,GAEpC,IAAI,CAAC,QAAQ,CAAG,IAAI,GAAM,OAAO,CAAE,EAAG,IAAK,GAE3C,IAAI,CAAC,SAAS,CAAG,AAAgB,KAAA,IAAhB,EAA8B,EAAY,CAE5D,EAEA,GAAM,eAAe,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,KAAK,CAAC,SAAS,EAKtE,GAAM,UAAU,CAAG,SAAW,CAAG,CAAE,CAAS,CAAE,CAAQ,EAErD,GAAM,KAAK,CAAC,IAAI,CAAE,IAAI,CAAE,GAExB,IAAI,CAAC,QAAQ,CAAG,IAAI,GAAM,OAAO,CAAE,EAAG,EAAG,GACzC,IAAI,CAAC,SAAS,CAAG,AAAgB,KAAA,IAAhB,EAA8B,EAAY,EAC3D,IAAI,CAAC,QAAQ,CAAG,AAAe,KAAA,IAAf,EAA6B,EAAW,CAEzD,EAEA,GAAM,UAAU,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,KAAK,CAAC,SAAS,EAKjE,GAAM,SAAS,CAAG,SAAW,CAAG,CAAE,CAAS,CAAE,CAAQ,CAAE,CAAK,CAAE,CAAQ,EAErE,GAAM,KAAK,CAAC,IAAI,CAAE,IAAI,CAAE,GAExB,IAAI,CAAC,QAAQ,CAAG,IAAI,GAAM,OAAO,CAAE,EAAG,EAAG,GACzC,IAAI,CAAC,MAAM,CAAG,IAAI,GAAM,QAAQ,CAEhC,IAAI,CAAC,SAAS,CAAG,AAAgB,KAAA,IAAhB,EAA8B,EAAY,EAC3D,IAAI,CAAC,QAAQ,CAAG,AAAe,KAAA,IAAf,EAA6B,EAAW,EACxD,IAAI,CAAC,KAAK,CAAK,AAAU,KAAA,IAAV,EAAwB,EAAQ,KAAK,EAAE,CAAG,EACzD,IAAI,CAAC,QAAQ,CAAG,AAAe,KAAA,IAAf,EAA6B,EAAW,GAExD,IAAI,CAAC,UAAU,CAAG,CAAA,EAClB,IAAI,CAAC,UAAU,CAAG,CAAA,EAIlB,IAAI,CAAC,gBAAgB,CAAG,GACxB,IAAI,CAAC,eAAe,CAAG,IACvB,IAAI,CAAC,eAAe,CAAG,GAEvB,IAAI,CAAC,mBAAmB,CAAG,CAAA,EAE3B,IAAI,CAAC,UAAU,CAAG,EAClB,IAAI,CAAC,cAAc,CAAG,GAEtB,IAAI,CAAC,cAAc,CAAG,IACtB,IAAI,CAAC,eAAe,CAAG,IAIvB,IAAI,CAAC,SAAS,CAAG,KACjB,IAAI,CAAC,aAAa,CAAG,KACrB,IAAI,CAAC,YAAY,CAAG,KACpB,IAAI,CAAC,YAAY,CAAG,IAErB,EAEA,GAAM,SAAS,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,KAAK,CAAC,SAAS,EAKhE,GAAM,MAAM,CAAG,SAAW,CAAU,EAEnC,IAAI,CAAC,UAAU,CAAG,EAClB,IAAI,CAAC,gBAAgB,CAAG,EAAa,GAAM,MAAM,CAAC,SAAS,CAAC,gBAAgB,GAAK,KAEjF,IAAI,CAAC,WAAW,CAAG,WAAa,EAChC,IAAI,CAAC,cAAc,CAAG,WAAa,EACnC,IAAI,CAAC,cAAc,CAAG,WAAa,CAEpC,EAEA,GAAM,MAAM,CAAC,SAAS,CAAG,CAExB,YAAa,GAAM,MAAM,CAEzB,YAAa,YAEb,iBAAkB,WAEjB,IAAI,EAAI,SAAS,aAAa,CAAE,OAehC,OAbA,EAAE,KAAK,CAAC,QAAQ,CAAG,WACnB,EAAE,KAAK,CAAC,KAAK,CAAG,MAChB,EAAE,KAAK,CAAC,GAAG,CAAG,MACd,EAAE,KAAK,CAAC,QAAQ,CAAG,QACnB,EAAE,KAAK,CAAC,SAAS,CAAG,OACpB,EAAE,KAAK,CAAC,UAAU,CAAG,mBACrB,EAAE,KAAK,CAAC,KAAK,CAAG,OAChB,EAAE,KAAK,CAAC,KAAK,CAAG,QAChB,EAAE,KAAK,CAAC,OAAO,CAAG,0BAClB,EAAE,KAAK,CAAC,MAAM,CAAG,IAEjB,EAAE,SAAS,CAAG,cAEP,CAER,EAEA,eAAgB,SAAW,CAAQ,EAElC,IAAI,EAAU,SAET,CAAA,EAAS,KAAK,CAElB,GAAa,AAAA,CAAA,IAAM,EAAS,MAAM,CAAG,EAAS,KAAI,AAAJ,EAAQ,OAAO,CAAC,GAAK,IAKnE,GAAW,AAAE,CAAA,EAAS,MAAM,CAAG,GAAA,EAAO,OAAO,CAAC,GAAK,MAIpD,IAAI,CAAC,gBAAgB,CAAC,SAAS,CAAG,CAEnC,EAEA,eAAgB,SAAW,CAAG,EAE7B,IAAI,EAAQ,EAAI,KAAK,CAAE,KAEvB,OADA,EAAM,GAAG,GACF,AAAE,CAAA,EAAM,MAAM,CAAG,EAAI,IAAM,EAAM,IAAI,CAAE,IAAA,EAAU,GAEzD,EAEA,cAAe,SAAW,CAAS,CAAE,CAAW,EAI/C,IAAM,IAFF,EAAQ,EAAE,CAEJ,EAAI,EAAG,EAAI,EAAU,MAAM,CAAE,EAAG,EAEzC,CAAK,CAAE,EAAG,CAAG,GAAM,MAAM,CAAC,SAAS,CAAC,cAAc,CAAE,CAAS,CAAE,EAAG,CAAE,GAIrE,OAAO,CAER,EAEA,cAAe,SAAW,CAAS,EAElC,IAAK,IAAI,EAAI,EAAG,EAAK,EAAU,MAAM,CAAE,EAAI,EAAI,IAI9C,GAAK,AAFG,CAAS,CAAE,EAAG,WAEJ,GAAM,cAAc,CAAG,MAAO,CAAA,EAIjD,MAAO,CAAA,CAER,EAEA,eAAgB,SAAW,CAAC,CAAE,CAAW,EAExC,IAAI,EAAQ,IAAI,CAEhB,SAAS,EAAS,CAAC,EAElB,IAAI,EAAI,KAAK,GAAG,CAAE,GAAM,KAAK,GAAG,CAChC,OAAO,KAAK,KAAK,CAAE,IAAO,CAE3B,CAEA,SAAS,EAAc,CAAC,EAGvB,OAAO,KAAK,GAAG,CAAE,EAAG,KAAK,KAAK,CADtB,KAAK,GAAG,CAAE,GAAM,KAAK,GAAG,EAGjC,CAgCA,SAAS,EAAgB,CAAK,CAAE,CAAI,CAAE,CAAU,CAAE,CAAM,CAAE,CAAM,CAAE,CAAI,CAAE,CAAU,EAEjF,IAhCoB,EAEhB,EA8BA,EAAe,UAAU,IAAI,CAAE,GAC/B,EAAW,EAAc,IAAM,EAEnC,GAAK,EAAe,CAEnB,IAAI,EAAU,GAAM,UAAU,CAAC,qBAAqB,CAAE,EAEtD,CAAA,CAAK,CAAE,EAAM,CAAG,CAEjB,KAAO,CAEN,IAAI,EAAU,SAAS,aAAa,CAAE,SAEtC,CAAA,CAAK,CAAE,EAAM,CAAG,IAAI,GAAM,OAAO,CAAE,EAEpC,CAmBA,GAjBA,CAAK,CAAE,EAAM,CAAC,UAAU,CAAG,EAEvB,IAEH,CAAK,CAAE,EAAM,CAAC,MAAM,CAAC,GAAG,CAAE,CAAM,CAAE,EAAG,CAAE,CAAM,CAAE,EAAG,EAE7B,IAAhB,CAAM,CAAE,EAAG,EAAS,CAAA,CAAK,CAAE,EAAM,CAAC,KAAK,CAAG,GAAM,cAAc,AAAd,EAChC,IAAhB,CAAM,CAAE,EAAG,EAAS,CAAA,CAAK,CAAE,EAAM,CAAC,KAAK,CAAG,GAAM,cAAc,AAAd,GAIjD,GAEJ,CAAK,CAAE,EAAM,CAAC,MAAM,CAAC,GAAG,CAAE,CAAM,CAAE,EAAG,CAAE,CAAM,CAAE,EAAG,EAI9C,EAAO,CAEX,IAAI,EAAU,CACb,OAAU,GAAM,cAAc,CAC9B,OAAU,GAAM,sBAAsB,AACvC,CAE8B,MAAA,IAAzB,CAAO,CAAE,CAAI,CAAE,EAAG,CAAE,EAAiB,CAAA,CAAK,CAAE,EAAM,CAAC,KAAK,CAAG,CAAO,CAAE,CAAI,CAAE,EAAG,CAAE,AAAF,EACpD,KAAA,IAAzB,CAAO,CAAE,CAAI,CAAE,EAAG,CAAE,EAAiB,CAAA,CAAK,CAAE,EAAM,CAAC,KAAK,CAAG,CAAO,CAAE,CAAI,CAAE,EAAG,CAAE,AAAF,CAEnF,CAEK,GAEJ,CAAA,CAAK,CAAE,EAAM,CAAC,UAAU,CAAG,CAF5B,EAMO,IApFa,EAsFP,CAAK,CAAE,EAAM,CAlF1B,CAFI,EAAQ,IAAI,OAEV,MAAM,CAAG,WAEd,GAAK,AAAC,EAAS,IAAI,CAAC,KAAK,GAAO,EAAS,IAAI,CAAC,MAAM,EAWnD,EAAM,KAAK,CAAG,IAAI,KAXsC,CAExD,IAAI,EAAQ,EAAc,IAAI,CAAC,KAAK,EAChC,EAAS,EAAc,IAAI,CAAC,MAAM,CAEtC,CAAA,EAAM,KAAK,CAAC,KAAK,CAAG,EACpB,EAAM,KAAK,CAAC,MAAM,CAAG,EACrB,EAAM,KAAK,CAAC,UAAU,CAAE,MAAO,SAAS,CAAE,IAAI,CAAE,EAAG,EAAG,EAAO,EAE9D,CAMA,EAAM,WAAW,CAAG,CAAA,CAErB,EAEA,EAAM,WAAW,CAAG,EAAM,WAAW,CACrC,EAAM,GAAG,CA4DmB,EAI7B,CAEA,SAAS,EAAS,CAAG,EAEpB,MAAS,AAAA,CAAA,AAAW,IAAX,CAAG,CAAE,EAAG,EAAU,EAAA,EAAS,CAAA,AAAW,IAAX,CAAG,CAAE,EAAG,EAAU,CAAA,EAAM,AAAW,IAAX,CAAG,CAAE,EAAG,AAErE,CAIA,IAAI,EAAQ,sBACR,EAAQ,CAAE,MAAO,SAAU,QAAS,EAAK,IAAK,KAAM,SAAU,KAAM,UAAW,KAAM,QAAS,KAAM,UAAW,CAAA,CAAM,EAIzH,GAAK,EAAE,OAAO,CAAG,CAEhB,IAAI,EAAU,EAAE,OAAO,CAAC,WAAW,EAE9B,AAAY,CAAA,UAAZ,EAAsB,EAAQ,oBACb,UAAZ,GAAsB,CAAA,EAAQ,mBAAnC,CAEN,CAgJA,GA9IoB,KAAA,IAAf,EAAE,QAAQ,EAAkB,AAAwB,KAAA,IAAxB,EAAK,CAAE,EAAE,QAAQ,CAAE,EAEnD,CAAA,EAAM,QAAQ,CAAG,EAAK,CAAE,EAAE,QAAQ,CAAE,AAAF,EAI9B,CAAA,AAAkB,KAAA,IAAlB,EAAE,WAAW,EAAkB,EAAE,OAAO,CAAG,CAAA,GAE/C,CAAA,EAAM,WAAW,CAAG,EAAE,WAAW,AAAX,EAIF,KAAA,IAAhB,EAAE,SAAS,EAEf,CAAA,EAAM,SAAS,CAAG,EAAE,SAAS,AAAT,EAIC,KAAA,IAAjB,EAAE,UAAU,EAEhB,CAAA,EAAM,UAAU,CAAG,EAAE,UAAU,AAAV,EAIH,KAAA,IAAd,EAAE,OAAO,EAEb,CAAA,EAAM,OAAO,CAAG,EAAE,OAAO,AAAP,EAIE,KAAA,IAAhB,EAAE,SAAS,EAEf,CAAA,EAAM,IAAI,CAAG,GAAM,QAAQ,AAAR,EAIG,KAAA,IAAlB,EAAE,WAAW,EAEjB,CAAA,EAAM,IAAI,CAAG,GAAM,UAAU,AAAV,EAIC,KAAA,IAAhB,EAAE,SAAS,EAEf,CAAA,EAAM,SAAS,CAAG,EAAE,SAAS,AAAT,EAIG,KAAA,IAAnB,EAAE,YAAY,GAEb,AAAmB,SAAnB,EAAE,YAAY,CAElB,EAAM,YAAY,CAAG,GAAM,UAAU,CAE1B,EAAE,YAAY,EAEzB,CAAA,EAAM,YAAY,CAAG,GAAM,YAAY,AAAZ,GAQxB,EAAE,YAAY,CAElB,EAAM,KAAK,CAAG,EAAS,EAAE,YAAY,EAE1B,EAAE,QAAQ,EAErB,CAAA,EAAM,KAAK,CAAG,EAAE,QAAQ,AAAR,EAIZ,EAAE,aAAa,EAEnB,CAAA,EAAM,QAAQ,CAAG,EAAS,EAAE,aAAa,CAAA,EAIrC,EAAE,YAAY,EAElB,CAAA,EAAM,OAAO,CAAG,EAAS,EAAE,YAAY,CAAA,EAMnC,EAAE,YAAY,EAElB,CAAA,EAAM,OAAO,CAAG,EAAE,YAAY,AAAZ,EAId,EAAE,YAAY,EAElB,CAAA,EAAM,SAAS,CAAG,EAAE,YAAY,AAAZ,EAMhB,EAAE,UAAU,EAAI,GAEpB,EAAgB,EAAO,MAAO,EAAE,UAAU,CAAE,EAAE,gBAAgB,CAAE,EAAE,gBAAgB,CAAE,EAAE,cAAc,CAAE,EAAE,oBAAoB,EAIxH,EAAE,QAAQ,EAAI,GAElB,EAAgB,EAAO,WAAY,EAAE,QAAQ,CAAE,EAAE,cAAc,CAAE,EAAE,cAAc,CAAE,EAAE,YAAY,CAAE,EAAE,kBAAkB,EAInH,EAAE,OAAO,EAAI,GAEjB,EAAgB,EAAO,UAAW,EAAE,OAAO,CAAE,EAAE,aAAa,CAAE,EAAE,aAAa,CAAE,EAAE,WAAW,CAAE,EAAE,iBAAiB,EAI7G,EAAE,SAAS,EAAI,GAEnB,EAAgB,EAAO,YAAa,EAAE,SAAS,CAAE,EAAE,eAAe,CAAE,EAAE,eAAe,CAAE,EAAE,aAAa,CAAE,EAAE,mBAAmB,EAIzH,EAAE,WAAW,EAAI,GAErB,EAAgB,EAAO,cAAe,EAAE,WAAW,CAAE,EAAE,iBAAiB,CAAE,EAAE,iBAAiB,CAAE,EAAE,eAAe,CAAE,EAAE,qBAAqB,EAMrI,EAAE,YAAY,EAElB,CAAA,EAAM,SAAS,CAAG,EAAE,YAAY,AAAZ,EAMhB,EAAE,SAAS,CAAG,CAElB,IAAI,EAAS,GAAM,SAAS,CAAE,SAAa,CACvC,EAAW,GAAM,aAAa,CAAC,KAAK,CAAE,EAAO,QAAQ,CAEzD,CAAA,EAAU,OAAW,CAAC,KAAK,CAAG,EAAM,SAAS,CAExC,EAAE,eAAe,EAErB,EAAU,YAAgB,CAAC,KAAK,CAAC,GAAG,CAAE,EAAE,eAAe,CAAE,EAAE,eAAe,EAItE,EAAM,GAAG,GAEb,EAAU,QAAY,CAAC,KAAK,CAAG,EAAM,GAAG,CACxC,EAAU,aAAiB,CAAC,KAAK,CAAG,CAAA,GAIhC,EAAM,WAAW,GAErB,EAAU,SAAa,CAAC,KAAK,CAAG,EAAM,WAAW,CACjD,EAAU,cAAkB,CAAC,KAAK,CAAG,CAAA,GAIjC,EAAM,QAAQ,GAElB,EAAU,GAAO,CAAC,KAAK,CAAG,EAAM,QAAQ,CACxC,EAAU,QAAY,CAAC,KAAK,CAAG,CAAA,GAMhC,EAAU,aAAiB,CAAC,KAAK,CAAC,MAAM,CAAE,EAAM,KAAK,EACrD,EAAU,cAAkB,CAAC,KAAK,CAAC,MAAM,CAAE,EAAM,QAAQ,EACzD,EAAU,aAAiB,CAAC,KAAK,CAAC,MAAM,CAAE,EAAM,OAAO,EAEvD,EAAU,UAAc,CAAC,KAAK,CAAG,EAAM,SAAS,CAEzB,KAAA,IAAlB,EAAM,OAAO,EAEjB,CAAA,EAAU,QAAY,CAAC,KAAK,CAAG,EAAM,OAAO,AAAP,EAItC,IAAI,EAAa,CAAE,eAAgB,EAAO,cAAc,CAAE,aAAc,EAAO,YAAY,CAAE,SAAU,EAAU,OAAQ,CAAA,EAAM,IAAK,CAAA,CAAK,EACrI,EAAW,IAAI,GAAM,cAAc,CAAE,EAEpC,CAAA,EAAM,WAAW,EAErB,CAAA,EAAS,WAAW,CAAG,CAAA,CAFxB,CAMD,MAEC,IAAI,EAAW,IAAI,EAAK,CAAE,EAAO,CAAE,GAMpC,OAFmB,KAAA,IAAd,EAAE,OAAO,EAAiB,CAAA,EAAS,IAAI,CAAG,EAAE,OAAO,AAAP,EAE1C,CAER,CAED,EAKA,GAAM,WAAW,CAAG,WAEnB,GAAM,eAAe,CAAC,IAAI,CAAE,IAAI,EAEhC,IAAI,CAAC,WAAW,CAAG,IAEpB,EAEA,GAAM,WAAW,CAAC,SAAS,CAAG,CAE7B,YAAa,GAAM,WAAW,CAE9B,KAAM,SAAW,CAAG,CAAE,CAAK,EAE1B,IAAI,EAAQ,IAAI,AAED,MAAA,IAAV,GAAsB,CAAA,EAAQ,IAAI,KAAvC,EAEA,EAAM,gBAAgB,CAAE,OAAQ,WAE/B,EAAM,aAAa,CAAE,CAAE,KAAM,OAAQ,QAAS,CAAM,EAErD,EAAG,CAAA,GAEH,EAAM,gBAAgB,CAAE,QAAS,WAEhC,EAAM,aAAa,CAAE,CAAE,KAAM,QAAS,QAAS,sBAAyB,EAAM,GAAI,EAEnF,EAAG,CAAA,GAEE,EAAM,WAAW,EAAG,CAAA,EAAM,WAAW,CAAG,EAAM,WAAW,AAAX,EAEnD,EAAM,GAAG,CAAG,CAEb,CAED,EAMA,GAAM,UAAU,CAAG,SAAW,CAAU,EAEvC,GAAM,MAAM,CAAC,IAAI,CAAE,IAAI,CAAE,GAEzB,IAAI,CAAC,eAAe,CAAG,CAAA,CAExB,EAEA,GAAM,UAAU,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,MAAM,CAAC,SAAS,EAElE,GAAM,UAAU,CAAC,SAAS,CAAC,IAAI,CAAG,SAAW,CAAG,CAAE,CAAQ,CAAE,CAAW,EAMtE,EAAc,GAAiB,AAAuB,UAAvB,OAAO,EAA6B,EAAc,IAAI,CAAC,cAAc,CAAE,GAEtG,IAAI,CAAC,WAAW,GAChB,IAAI,CAAC,YAAY,CAAE,IAAI,CAAE,EAAK,EAAU,EAEzC,EAEA,GAAM,UAAU,CAAC,SAAS,CAAC,YAAY,CAAG,SAAW,CAAO,CAAE,CAAG,CAAE,CAAQ,CAAE,CAAW,CAAE,CAAgB,EAEzG,IAAI,EAAM,IAAI,eAEV,EAAS,CAEb,CAAA,EAAI,kBAAkB,CAAG,WAExB,GAAK,EAAI,UAAU,GAAK,EAAI,IAAI,EAE/B,GAAK,AAAe,MAAf,EAAI,MAAM,EAAY,AAAe,IAAf,EAAI,MAAM,CAAS,CAE7C,GAAK,EAAI,YAAY,CAAG,CAEvB,IAAI,EAAO,KAAK,KAAK,CAAE,EAAI,YAAY,EACvC,EAAQ,WAAW,CAAE,EAAM,EAAU,EAEtC,MAEC,QAAQ,IAAI,CAAE,sBAAwB,EAAM,oDAQ7C,EAAQ,cAAc,EAEvB,MAEC,QAAQ,KAAK,CAAE,oCAAsC,EAAM,MAAQ,EAAI,MAAM,CAAG,UAItE,EAAI,UAAU,GAAK,EAAI,OAAO,CAEpC,IAEY,IAAX,GAEJ,CAAA,EAAS,EAAI,iBAAiB,CAAE,iBAFjC,EAMA,EAAkB,CAAE,MAAO,EAAQ,OAAQ,EAAI,YAAY,CAAC,MAAM,AAAC,IAIzD,EAAI,UAAU,GAAK,EAAI,gBAAgB,EAElD,CAAA,EAAS,EAAI,iBAAiB,CAAE,iBAJhC,CAQF,EAEA,EAAI,IAAI,CAAE,MAAO,EAAK,CAAA,GACtB,EAAI,eAAe,CAAG,IAAI,CAAC,eAAe,CAC1C,EAAI,IAAI,CAAE,KAEX,EAEA,GAAM,UAAU,CAAC,SAAS,CAAC,WAAW,CAAG,SAAW,CAAI,CAAE,CAAQ,CAAE,CAAW,EAE9E,IACA,EAAW,IAAI,GAAM,QAAQ,CAC7B,EAAQ,AAAiB,KAAA,IAAjB,EAAO,KAAK,CAAmB,EAAM,EAAK,KAAK,CAAG,EAE1D,AAQA,CAAA,SAAqB,CAAK,EAQzB,IAAI,EAAG,EAAG,EAEV,EAAQ,EAAS,EAEjB,EAAY,EAAa,EAAS,EAElC,EACA,EACA,EACA,EAAW,EACX,EAAe,EACf,EAAc,EAEd,EAAQ,EAAM,EAAO,EAErB,EAAS,EAAK,EAAG,EAEjB,EAAQ,EAAK,KAAK,CAClB,EAAW,EAAK,QAAQ,CACxB,EAAU,EAAK,OAAO,CACtB,EAAS,EAAK,MAAM,CAEpB,EAAY,EAIZ,IAAM,EAAI,EAAG,EAAI,EAAK,GAAG,CAAC,MAAM,CAAE,IAE5B,EAAK,GAAG,CAAE,EAAG,CAAC,MAAM,EAAG,IAI7B,IAAM,EAAI,EAAG,EAAI,EAAW,IAE3B,EAAS,OAAO,CAAE,EAAG,CAAG,EAAE,CAC1B,EAAS,aAAa,CAAE,EAAG,CAAG,EAAE,CAOjC,IAHA,EAAS,EACT,EAAU,EAAS,MAAM,CAEjB,EAAS,GAIhB,AAFA,CAAA,EAAS,IAAI,GAAM,OAAO,AAA1B,EAEO,CAAC,CAAG,CAAQ,CAAE,IAAW,CAAG,EACnC,EAAO,CAAC,CAAG,CAAQ,CAAE,IAAW,CAAG,EACnC,EAAO,CAAC,CAAG,CAAQ,CAAE,IAAW,CAAG,EAEnC,EAAS,QAAQ,CAAC,IAAI,CAAE,GAOzB,IAHA,EAAS,EACT,EAAU,EAAM,MAAM,CAEd,EAAS,GAAU,CAkD1B,GA7CA,EAlEO,AAAU,EA+DjB,CAAA,EAAO,CAAK,CAAE,IAAW,AAAX,EAId,EAnEO,AAAU,EAmEe,EAChC,EApEO,AAAU,EAoEe,EAChC,EArEO,AAAU,EAqEe,EAChC,EAtEO,AAAU,GAsEe,EAChC,EAvEO,AAAU,GAuEe,EAChC,EAxEO,AAAU,GAwEY,EAC7B,EAzEO,AAAU,IAyEe,EAI3B,GAIJ,AAFA,CAAA,EAAO,IAAI,GAAM,KAAK,AAAtB,EAEK,CAAC,CAAG,CAAK,CAAE,IAAW,CAC3B,EAAK,CAAC,CAAG,CAAK,CAAE,IAAW,CAC3B,EAAK,CAAC,CAAG,CAAK,CAAE,IAAW,CAC3B,EAAK,CAAC,CAAG,CAAK,CAAE,IAAW,CAE3B,EAAY,IAMZ,AAFA,CAAA,EAAO,IAAI,GAAM,KAAK,AAAtB,EAEK,CAAC,CAAG,CAAK,CAAE,IAAW,CAC3B,EAAK,CAAC,CAAG,CAAK,CAAE,IAAW,CAC3B,EAAK,CAAC,CAAG,CAAK,CAAE,IAAW,CAE3B,EAAY,GAIR,IAEJ,EAAgB,CAAK,CAAE,IAAW,CAClC,EAAK,aAAa,CAAG,GAMtB,EAAK,EAAS,KAAK,CAAC,MAAM,CAErB,EAEJ,IAAM,EAAI,EAAG,EAAI,EAAW,IAM3B,EAAI,AAJJ,CAAA,EAAU,EAAK,GAAG,CAAE,EAAG,AAAH,CAIT,CAAE,AAAU,EAFvB,CAAA,EAAU,CAAK,CAAE,IAAW,AAAX,EAES,CAC1B,EAAI,CAAO,CAAE,AAAU,EAAV,EAAc,EAAG,CAE9B,EAAS,OAAO,CAAE,EAAG,CAAE,EAAI,CAAG,IAAI,GAAM,OAAO,CAAE,EAAG,GAMtD,GAAK,EAEJ,IAAM,EAAI,EAAG,EAAI,EAAW,IAAM,CAMjC,IAAM,EAAI,EAJV,EAAU,EAAK,GAAG,CAAE,EAAG,CAEvB,EAAM,EAAE,CAEK,EAAI,EAAW,IAI3B,EAAI,CAAO,CAAE,AAAU,EAFvB,CAAA,EAAU,CAAK,CAAE,IAAW,AAAX,EAES,CAC1B,EAAI,CAAO,CAAE,AAAU,EAAV,EAAc,EAAG,CAE9B,CAAG,CAAE,EAAG,CAAG,IAAI,GAAM,OAAO,CAAE,EAAG,EAIlC,CAAA,EAAS,aAAa,CAAE,EAAG,CAAE,EAAI,CAAG,CAErC,CAkBD,GAdK,IAEJ,EAAc,AAAqB,EAArB,CAAK,CAAE,IAAW,CAIhC,AAFA,CAAA,EAAS,IAAI,GAAM,OAAO,AAA1B,EAEO,CAAC,CAAG,CAAO,CAAE,IAAgB,CACpC,EAAO,CAAC,CAAG,CAAO,CAAE,IAAgB,CACpC,EAAO,CAAC,CAAG,CAAO,CAAE,EAAa,CAEjC,EAAK,MAAM,CAAG,GAIV,EAEJ,IAAM,EAAI,EAAG,EAAI,EAAW,IAE3B,EAAc,AAAqB,EAArB,CAAK,CAAE,IAAW,CAIhC,AAFA,CAAA,EAAS,IAAI,GAAM,OAAO,AAA1B,EAEO,CAAC,CAAG,CAAO,CAAE,IAAgB,CACpC,EAAO,CAAC,CAAG,CAAO,CAAE,IAAgB,CACpC,EAAO,CAAC,CAAG,CAAO,CAAE,EAAa,CAEjC,EAAK,aAAa,CAAC,IAAI,CAAE,GAiB3B,GAVK,IAEJ,EAAa,CAAK,CAAE,IAAW,CAE/B,EAAQ,IAAI,GAAM,KAAK,CAAE,CAAM,CAAE,EAAY,EAC7C,EAAK,KAAK,CAAG,GAKT,EAEJ,IAAM,EAAI,EAAG,EAAI,EAAW,IAE3B,EAAa,CAAK,CAAE,IAAW,CAE/B,EAAQ,IAAI,GAAM,KAAK,CAAE,CAAM,CAAE,EAAY,EAC7C,EAAK,YAAY,CAAC,IAAI,CAAE,GAM1B,EAAS,KAAK,CAAC,IAAI,CAAE,EAEtB,CAED,CAAA,EAjOY,GAEZ,AAiOA,WAEC,IAAI,EAAG,EAAG,EAAG,EAAS,EAAG,EAEzB,GAAK,EAAK,WAAW,CAEpB,IAAM,EAAI,EAAG,EAAI,EAAK,WAAW,CAAC,MAAM,CAAE,EAAI,EAAG,GAAK,EAErD,EAAI,EAAK,WAAW,CAAE,EAAO,CAC7B,EAAI,EAAK,WAAW,CAAE,EAAI,EAAG,CAI7B,EAAS,WAAW,CAAC,IAAI,CAAE,IAAI,GAAM,OAAO,CAAE,EAAG,EAH7C,EACA,IAQN,GAAK,EAAK,WAAW,CAEpB,IAAM,EAAI,EAAG,EAAI,EAAK,WAAW,CAAC,MAAM,CAAE,EAAI,EAAG,GAAK,EAErD,EAAI,EAAK,WAAW,CAAE,EAAO,CAC7B,EAAI,EAAK,WAAW,CAAE,EAAI,EAAG,CAI7B,EAAS,WAAW,CAAC,IAAI,CAAE,IAAI,GAAM,OAAO,CAAE,EAAG,EAH7C,EACA,GAQN,CAAA,EAAS,KAAK,CAAG,EAAK,KAAK,CAC3B,EAAS,SAAS,CAAG,EAAK,SAAS,AAEpC,IArQA,AAuQA,SAAwB,CAAK,EAE5B,GAAK,AAAsB,KAAA,IAAtB,EAAK,YAAY,CAIrB,IAAM,EAAI,EAAG,EAAI,EAAK,YAAY,CAAC,MAAM,CAAE,EAAI,EAAG,IASjD,IAAK,EAAI,EAPT,EAAS,YAAY,CAAE,EAAG,CAAG,CAAC,EAC9B,EAAS,YAAY,CAAE,EAAG,CAAC,IAAI,CAAG,EAAK,YAAY,CAAE,EAAG,CAAC,IAAI,CAC7D,EAAS,YAAY,CAAE,EAAG,CAAC,QAAQ,CAAG,EAAE,CAExC,EAAc,EAAS,YAAY,CAAE,EAAG,CAAC,QAAQ,CAGrC,EAAK,AAFjB,CAAA,EAAc,EAAK,YAAa,CAAE,EAAG,CAAC,QAAQ,AAAR,EAET,MAAM,CAAE,EAAI,EAAI,GAAK,EAAI,CAErD,IAbQ,EAAG,EAAI,EAAa,EA4B1B,EAAG,EAAG,EAAG,EAAI,EAAW,EAAW,EAfjC,EAAS,IAAI,GAAM,OAAO,AAC9B,CAAA,EAAO,CAAC,CAAG,CAAW,CAAE,EAAG,CAAG,EAC9B,EAAO,CAAC,CAAG,CAAW,CAAE,EAAI,EAAG,CAAG,EAClC,EAAO,CAAC,CAAG,CAAW,CAAE,EAAI,EAAG,CAAG,EAElC,EAAY,IAAI,CAAE,EAEnB,CAMF,GAAK,AAAqB,KAAA,IAArB,EAAK,WAAW,CAIpB,IAAM,EAAI,EAAG,EAAI,EAAK,WAAW,CAAC,MAAM,CAAE,EAAI,EAAG,IAShD,IAAM,EAAI,EAPV,EAAS,WAAW,CAAE,EAAG,CAAG,CAAC,EAC7B,EAAS,WAAW,CAAE,EAAG,CAAC,IAAI,CAAG,EAAK,WAAW,CAAE,EAAG,CAAC,IAAI,CAC3D,EAAS,WAAW,CAAE,EAAG,CAAC,MAAM,CAAG,EAAE,CAErC,EAAY,EAAS,WAAW,CAAE,EAAG,CAAC,MAAM,CAG/B,EAAK,AAFlB,CAAA,EAAY,EAAK,WAAY,CAAE,EAAG,CAAC,MAAM,AAAN,EAEP,MAAM,CAAE,EAAI,EAAI,GAAK,EAGhD,AADA,CAAA,EAAQ,IAAI,GAAM,KAAK,CAAE,SAAzB,EACM,MAAM,CAAE,CAAS,CAAE,EAAG,CAAE,CAAS,CAAE,EAAI,EAAG,CAAE,CAAS,CAAE,EAAI,EAAG,EACpE,EAAU,IAAI,CAAE,EAQpB,EA9Te,GAEf,EAAS,gBAAgB,GACzB,EAAS,kBAAkB,GA6T3B,IAAI,EAAY,IAAI,CAAC,aAAa,CAAE,EAAK,SAAS,CAAE,GAE/C,IAAI,CAAC,aAAa,CAAE,IAAc,EAAS,eAAe,GAE/D,EAAU,EAAU,EAErB,EAKA,GAAM,cAAc,CAAG,WAEtB,GAAM,eAAe,CAAC,IAAI,CAAE,IAAI,EAEhC,IAAI,EAAQ,IAAI,CAEZ,EAAS,EACT,EAAQ,EAER,EAAS,SAAW,CAAK,EAE5B,IAEA,EAAM,aAAa,CAAE,CAAE,KAAM,WAAY,OAAQ,EAAQ,MAAO,CAAM,GAEjE,IAAW,GAEf,EAAM,aAAa,CAAE,CAAE,KAAM,MAAO,EAItC,CAEA,CAAA,IAAI,CAAC,GAAG,CAAG,SAAW,CAAM,EAE3B,IAEA,EAAO,gBAAgB,CAAE,OAAQ,EAAQ,CAAA,EAE1C,CAED,EAKA,GAAM,WAAW,CAAG,WAEnB,IAAI,CAAC,WAAW,CAAG,WAAa,EAChC,IAAI,CAAC,cAAc,CAAG,WAAY,EAClC,IAAI,CAAC,cAAc,CAAG,WAAa,EAEnC,IAAI,CAAC,YAAY,CAAG,WAAa,EACjC,IAAI,CAAC,gBAAgB,CAAG,WAAa,EAErC,IAAI,CAAC,kBAAkB,CAAG,CAAC,EAC3B,IAAI,CAAC,mBAAmB,CAAG,CAAC,EAE5B,IAAI,CAAC,kBAAkB,CAAE,QAAS,GAAM,UAAU,CAEnD,EAEA,GAAM,WAAW,CAAC,SAAS,CAAC,WAAW,CAAG,GAAM,WAAW,CAE3D,GAAM,WAAW,CAAC,SAAS,CAAC,IAAI,CAAG,SAAW,CAAG,CAAE,CAAgB,EAElE,IAAI,EAAQ,IAAI,CAEZ,EAAM,IAAI,cAEd,CAAA,EAAI,kBAAkB,CAAG,WAExB,GAAK,AAAmB,IAAnB,EAAI,UAAU,EAElB,GAAK,AAAe,MAAf,EAAI,MAAM,EAAY,AAAe,IAAf,EAAI,MAAM,CAAS,CAE7C,IAAI,EAAO,KAAK,KAAK,CAAE,EAAI,YAAY,EACvC,EAAM,KAAK,CAAE,EAAM,EAAkB,EAEtC,MAEC,QAAQ,KAAK,CAAE,qCAAuC,EAAM,MAAQ,EAAI,MAAM,CAAG,KAMpF,EAEA,EAAI,IAAI,CAAE,MAAO,EAAK,CAAA,GACtB,EAAI,IAAI,CAAE,KAEX,EAEA,GAAM,WAAW,CAAC,SAAS,CAAC,kBAAkB,CAAG,SAAW,CAAM,CAAE,CAAW,EAE9E,IAAI,CAAC,kBAAkB,CAAE,EAAQ,CAAG,CAAE,YAAe,CAAY,CAElE,EAEA,GAAM,WAAW,CAAC,SAAS,CAAC,mBAAmB,CAAG,SAAW,CAAM,CAAE,CAAW,EAE/E,IAAI,CAAC,mBAAmB,CAAE,EAAQ,CAAG,CAAE,YAAe,CAAY,CAEnE,EAEA,GAAM,WAAW,CAAC,SAAS,CAAC,KAAK,CAAG,SAAW,CAAI,CAAE,CAAgB,CAAE,CAAG,EAEzE,IAII,EAAU,EAAU,EAAQ,EAC/B,EAAiB,EACjB,EAAO,EAAK,EACZ,EAAgB,EAChB,EAAc,EACd,EAioBG,EAAO,EA6BP,EAAO,EAkBP,EAAO,EA6FP,EAAW,EA0HX,EAAO,EACP,EAj5BA,EAAQ,IAAI,CAEZ,EAAU,GAAM,MAAM,CAAC,SAAS,CAAC,cAAc,CAAE,GASjD,EAAe,EAAE,CAMrB,IAAM,IAAI,KAAU,IAAI,CAAC,kBAAkB,CAAG,CAE7C,IAAI,EAAc,IAAI,CAAC,kBAAkB,CAAE,EAAQ,CAAE,WAAe,AACpE,CAAA,IAAI,CAAC,kBAAkB,CAAE,EAAQ,CAAE,YAAgB,CAAG,IAAI,CAE3D,CAIA,IAAM,IAAI,KAAU,IAAI,CAAC,mBAAmB,CAAG,CAE9C,IAAI,EAAc,IAAI,CAAC,mBAAmB,CAAE,EAAQ,CAAE,WAAe,AACrE,CAAA,IAAI,CAAC,mBAAmB,CAAE,EAAQ,CAAE,YAAgB,CAAG,IAAI,CAE5D,CAqBA,GAnBA,EAAiB,EACjB,EAAmB,EAEnB,EAAS,CAER,MAAO,IAAI,GAAM,KAAK,CACtB,WAAY,CAAC,EACb,eAAgB,CAAC,EACjB,UAAW,CAAC,EACZ,SAAU,CAAC,EACX,QAAS,CAAC,EACV,QAAS,CAAC,EACV,OAAQ,CAAC,EACT,KAAM,CAAC,EACP,QAAS,CAAC,EACV,OAAQ,CAAC,CAEV,EAEK,AAvCM,EAuCD,SAAS,CAAG,CAErB,IAAI,EAAW,AAzCL,EAyCU,SAAS,CAAC,QAAQ,CACrC,EAAW,AA1CF,EA0CO,SAAS,CAAC,QAAQ,CAClC,EAAQ,AA3CC,EA2CI,SAAS,CAAC,KAAK,CAExB,GACJ,EAAO,KAAK,CAAC,QAAQ,CAAC,GAAG,CAAE,CAAQ,CAAE,EAAG,CAAE,CAAQ,CAAE,EAAG,CAAE,CAAS,CAAE,EAAG,EAEnE,GACJ,EAAO,KAAK,CAAC,QAAQ,CAAC,GAAG,CAAE,CAAQ,CAAE,EAAG,CAAE,CAAQ,CAAE,EAAG,CAAE,CAAS,CAAE,EAAG,EAEnE,GACJ,EAAO,KAAK,CAAC,KAAK,CAAC,GAAG,CAAE,CAAK,CAAE,EAAG,CAAE,CAAK,CAAE,EAAG,CAAE,CAAM,CAAE,EAAG,EAEvD,CAAA,GAAY,GAAY,CAAA,IAE5B,EAAO,KAAK,CAAC,YAAY,GACzB,EAAO,KAAK,CAAC,iBAAiB,GAIhC,CAEA,SAAS,EAAS,CAAU,CAAE,CAAQ,QAErC,AAAK,AAAY,kBAAZ,EAEG,EAIA,EAAU,IAAM,CAIzB,CAIA,SAAS,IAER,AAMD,CAAA,SAAS,EAAiB,CAAM,CAAE,CAAQ,EAEzC,IAAI,EAAK,EAAK,EAAK,EAAK,EAAK,EAE7B,IAAM,IAAI,KAAS,EAKlB,GAAK,AAA4B,KAAA,IAA5B,EAAO,OAAO,CAAE,EAAO,CAAiB,CAE5C,IAAI,EAAU,CAAQ,CAAE,EAAO,CAE3B,EAAS,KAIb,GAAK,EAAQ,IAAI,EAAM,EAAQ,IAAI,IAAI,EAAM,mBAAmB,CAE/D,CAAA,GAAK,AAAoB,KAAA,IAApB,EAAQ,OAAO,CAAiB,CAEpC,IAAI,EAAgB,CAAE,KAAQ,EAAG,IAAO,EAAG,SAAY,EAChD,SAAY,EAAG,SAAY,EAAG,MAAU,EACxC,QAAW,EAAG,SAAY,EAAG,WAAc,EAC3C,KAAQ,EAAG,MAAS,EAAG,aAAgB,EAAG,SAAY,CAAE,EAE3D,EAAmB,CAAC,EAExB,IAAM,IAAI,KAAW,EAEX,KAAW,GAEnB,CAAA,CAAgB,CAAE,EAAS,CAAG,CAAO,CAAE,EAAS,AAAT,EAMzC,EAAW,EAAO,SAAS,CAAE,EAAQ,QAAQ,CAAE,CAE/C,EAAQ,OAAO,CAAG,CAAA,EAElB,IAAI,EAAS,EAAM,mBAAmB,CAAE,EAAQ,IAAI,CAAE,CAAE,YAAgB,AAInE,CAAA,EAAO,OAAO,CAElB,EAAO,IAAI,CAAE,EAAS,EAAQ,GAAG,CAAE,AAvI9B,EAuImC,WAAW,EAAI,EAA0B,EAAO,EAAQ,EAAU,IAO1G,EAAO,IAAI,CAAE,EAAS,EAAQ,GAAG,CAAE,AA9I9B,EA8ImC,WAAW,EAAI,EAA0B,EAAO,EAAQ,EAAU,GAAW,EAIvH,CAAA,MAEM,GAAK,AAAqB,KAAA,IAArB,EAAQ,QAAQ,CAM3B,CAAA,GAJA,EAAW,EAAO,UAAU,CAAE,EAAQ,QAAQ,CAAE,CAIhC,CAEf,IAAI,EAAgB,CAAA,EA8BpB,GA3BA,EAAgB,AADhB,CAAA,EAAW,EAAO,SAAS,CAAE,EAAQ,QAAQ,CAAE,AAAF,YACT,GAAM,cAAc,CAExD,EAAM,EAAQ,QAAQ,CACtB,EAAM,EAAQ,QAAQ,CACtB,EAAM,EAAQ,KAAK,CACnB,EAAM,EAAQ,MAAM,CACpB,EAAO,EAAQ,UAAU,CAKlB,EAAQ,QAAQ,EAEtB,CAAA,EAAW,IAAI,GAAM,gBAAgB,CAAE,EAAO,cAAc,CAAE,EAAQ,QAAQ,CAAE,CAAA,EAQ5E,aAAsB,GAAM,gBAAgB,EAAM,AAA8B,IAA9B,EAAS,SAAS,CAAC,MAAM,EAE/E,CAAA,EAAW,IAAI,GAAM,gBAAgB,CAAE,EAAO,cAAc,CAAE,EAAQ,QAAQ,CAAE,CAAA,EAI5E,aAAoB,GAAM,gBAAgB,CAE9C,IAAM,IAAI,EAAI,EAAG,EAAI,EAAS,SAAS,CAAC,MAAM,CAAE,IAE/C,EAAgB,GAAmB,EAAS,SAAS,CAAE,EAAG,WAAY,GAAM,cAAc,CAMvF,GAEJ,EAAS,eAAe,GAIpB,EAAQ,IAAI,CAEhB,EAAS,IAAI,GAAM,WAAW,CAAE,EAAU,GAE/B,EAAQ,KAAK,EAExB,EAAS,IAAI,GAAM,aAAa,CAAE,EAAU,GAElB,KAAA,IAArB,EAAQ,QAAQ,EAEpB,CAAA,EAAO,QAAQ,CAAG,EAAQ,QAAQ,AAAR,EAIL,KAAA,IAAjB,EAAQ,IAAI,EAEhB,CAAA,EAAO,IAAI,CAAG,EAAQ,IAAI,AAAJ,EAIO,KAAA,IAAzB,EAAQ,YAAY,EAExB,CAAA,EAAO,YAAY,CAAG,EAAQ,YAAY,AAAZ,EAI1B,EAAS,YAAY,EAEzB,EAAS,mBAAmB,IAM7B,EAAS,IAAI,GAAM,IAAI,CAAE,EAAU,GAIpC,EAAO,IAAI,CAAG,EAET,GAEJ,EAAO,gBAAgB,CAAG,CAAA,EAC1B,EAAO,MAAM,CAAC,GAAG,CAChB,CAAG,CAAC,EAAE,CAAG,CAAG,CAAC,EAAE,CAAG,CAAG,CAAC,EAAE,CAAG,CAAG,CAAC,EAAE,CACjC,CAAG,CAAC,EAAE,CAAG,CAAG,CAAC,EAAE,CAAG,CAAG,CAAC,EAAE,CAAG,CAAG,CAAC,EAAE,CACjC,CAAG,CAAC,EAAE,CAAG,CAAG,CAAC,EAAE,CAAG,CAAG,CAAC,GAAG,CAAE,CAAG,CAAC,GAAG,CAClC,CAAG,CAAC,GAAG,CAAE,CAAG,CAAC,GAAG,CAAE,CAAG,CAAC,GAAG,CAAE,CAAG,CAAC,GAAG,IAKnC,EAAO,QAAQ,CAAC,GAAG,CAAE,CAAG,CAAC,EAAE,CAAE,CAAG,CAAC,EAAE,CAAE,CAAG,CAAC,EAAE,EAEtC,GAEJ,EAAO,UAAU,CAAC,GAAG,CAAE,CAAI,CAAC,EAAE,CAAE,CAAI,CAAC,EAAE,CAAE,CAAI,CAAC,EAAE,CAAE,CAAI,CAAC,EAAE,EACzD,EAAO,aAAa,CAAG,CAAA,GAIvB,EAAO,QAAQ,CAAC,GAAG,CAAE,CAAG,CAAC,EAAE,CAAE,CAAG,CAAC,EAAE,CAAE,CAAG,CAAC,EAAE,EAI5C,EAAO,KAAK,CAAC,GAAG,CAAE,CAAG,CAAC,EAAE,CAAE,CAAG,CAAC,EAAE,CAAE,CAAG,CAAC,EAAE,GAIzC,EAAO,OAAO,CAAG,EAAQ,OAAO,CAChC,EAAO,UAAU,CAAG,EAAQ,UAAU,CACtC,EAAO,aAAa,CAAG,EAAQ,aAAa,CAE5C,EAAO,GAAG,CAAE,GAEZ,EAAO,OAAO,CAAE,EAAO,CAAG,CAE3B,CAAA,KAIW,AAAiB,qBAAjB,EAAQ,IAAI,EAA2B,AAAiB,eAAjB,EAAQ,IAAI,EAAqB,AAAiB,iBAAjB,EAAQ,IAAI,EAE/F,EAAQ,AAAkB,KAAA,IAAlB,EAAQ,KAAK,CAAmB,EAAQ,KAAK,CAAG,SACxD,EAAc,AAAsB,KAAA,IAAtB,EAAQ,SAAS,CAAmB,EAAQ,SAAS,CAAG,EAEjE,AAAiB,qBAAjB,EAAQ,IAAI,EAEhB,EAAM,EAAQ,SAAS,CAGvB,AADA,CAAA,EAAQ,IAAI,GAAM,gBAAgB,CAAE,EAAK,EAAzC,EACM,QAAQ,CAAC,GAAG,CAAE,CAAG,CAAC,EAAE,CAAE,CAAG,CAAC,EAAE,CAAE,CAAG,CAAC,EAAE,EAErC,EAAQ,MAAM,GAElB,EAAa,IAAI,CAAE,CAAE,OAAU,EAAO,WAAe,EAAQ,MAAM,AAAC,GAKpE,EAAM,MAAM,CAAG,OAIL,AAAiB,eAAjB,EAAQ,IAAI,EAEvB,EAAM,EAAQ,QAAQ,CACtB,EAAM,EAAQ,QAAQ,CAGtB,AADA,CAAA,EAAQ,IAAI,GAAM,UAAU,CAAE,EAAK,EAAW,EAA9C,EACM,QAAQ,CAAC,GAAG,CAAE,CAAG,CAAC,EAAE,CAAE,CAAG,CAAC,EAAE,CAAE,CAAG,CAAC,EAAE,GAEd,iBAAjB,EAAQ,IAAI,EAEvB,CAAA,EAAQ,IAAI,GAAM,YAAY,CAAE,EAFjC,EAMA,EAAO,GAAG,CAAE,GAEZ,EAAM,IAAI,CAAG,EACb,EAAO,MAAM,CAAE,EAAO,CAAG,EACzB,EAAO,OAAO,CAAE,EAAO,CAAG,GAIf,AAAiB,sBAAjB,EAAQ,IAAI,EAA4B,AAAiB,uBAAjB,EAAQ,IAAI,EAE1D,AAAiB,sBAAjB,EAAQ,IAAI,CAEhB,EAAS,IAAI,GAAM,iBAAiB,CAAE,EAAQ,GAAG,CAAE,EAAQ,MAAM,CAAE,EAAQ,IAAI,CAAE,EAAQ,GAAG,EAEhE,uBAAjB,EAAQ,IAAI,EAEvB,CAAA,EAAS,IAAI,GAAM,kBAAkB,CAAE,EAAQ,IAAI,CAAE,EAAQ,KAAK,CAAE,EAAQ,GAAG,CAAE,EAAQ,MAAM,CAAE,EAAQ,IAAI,CAAE,EAAQ,GAAG,CAAA,EAI3H,EAAM,EAAQ,QAAQ,CACtB,EAAO,QAAQ,CAAC,GAAG,CAAE,CAAG,CAAC,EAAE,CAAE,CAAG,CAAC,EAAE,CAAE,CAAG,CAAC,EAAE,EAC3C,EAAO,GAAG,CAAE,GAEZ,EAAO,IAAI,CAAG,EACd,EAAO,OAAO,CAAE,EAAO,CAAG,EAC1B,EAAO,OAAO,CAAE,EAAO,CAAG,IAM1B,EAAM,EAAQ,QAAQ,CACtB,EAAM,EAAQ,QAAQ,CACtB,EAAM,EAAQ,KAAK,CACnB,EAAO,EAAQ,UAAU,CAGzB,AADA,CAAA,EAAS,IAAI,GAAM,QAAQ,AAA3B,EACO,IAAI,CAAG,EACd,EAAO,QAAQ,CAAC,GAAG,CAAE,CAAG,CAAC,EAAE,CAAE,CAAG,CAAC,EAAE,CAAE,CAAG,CAAC,EAAE,EAEtC,GAEJ,EAAO,UAAU,CAAC,GAAG,CAAE,CAAI,CAAC,EAAE,CAAE,CAAI,CAAC,EAAE,CAAE,CAAI,CAAC,EAAE,CAAE,CAAI,CAAC,EAAE,EACzD,EAAO,aAAa,CAAG,CAAA,GAIvB,EAAO,QAAQ,CAAC,GAAG,CAAE,CAAG,CAAC,EAAE,CAAE,CAAG,CAAC,EAAE,CAAE,CAAG,CAAC,EAAE,EAI5C,EAAO,KAAK,CAAC,GAAG,CAAE,CAAG,CAAC,EAAE,CAAE,CAAG,CAAC,EAAE,CAAE,CAAG,CAAC,EAAE,EACxC,EAAO,OAAO,CAAG,AAAsB,KAAA,IAAtB,EAAU,OAAO,EAAmB,EAAQ,OAAO,CAEpE,EAAO,GAAG,CAAE,GAEZ,EAAO,OAAO,CAAE,EAAO,CAAG,EAC1B,EAAO,OAAO,CAAE,EAAO,CAAG,GAI3B,GAAK,EAAS,CAEb,GAAK,AAAuB,KAAA,IAAvB,EAAQ,UAAU,CAEtB,IAAM,IAAI,KAAO,EAAQ,UAAU,CAAG,CAErC,IAAI,EAAQ,EAAQ,UAAU,CAAE,EAAK,AACrC,CAAA,EAAO,UAAU,CAAE,EAAK,CAAG,CAE5B,CAID,GAAK,AAAmB,KAAA,IAAnB,EAAQ,MAAM,CAElB,IAAM,IAAI,EAAI,EAAG,EAAI,EAAQ,MAAM,CAAC,MAAM,CAAE,IAAO,CAElD,IAAI,EAAU,EAAQ,MAAM,CAAE,EAAG,AAEC,MAAA,IAA7B,EAAO,MAAM,CAAE,EAAS,EAE5B,CAAA,EAAO,MAAM,CAAE,EAAS,CAAG,EAAE,AAAF,EAI5B,EAAO,MAAM,CAAE,EAAS,CAAC,IAAI,CAAE,EAEhC,CAIyB,KAAA,IAArB,EAAQ,QAAQ,EAEpB,EAAiB,EAAQ,EAAQ,QAAQ,CAI3C,CAED,CAIF,CAAA,EAxVkB,EAAO,KAAK,CAAE,AAjFrB,EAiF0B,OAAO,CAE5C,CAuaA,SAAS,EAA0B,CAAE,CAAE,CAAM,CAAE,CAAQ,CAAE,CAAG,EAE3D,OAAO,SAAU,CAAK,MAzEI,EAEtB,EACA,EACA,EACA,EAiCA,EAtCsB,EA+EpB,EAAM,OAAO,CAER,EAAM,OAAO,CAIX,EAAM,GAAG,CAEX,EAAM,KAAK,CAOX,EA5FP,EAAI,AAgGyC,EAhGrC,QAAQ,CAChB,EAAI,AA+FyC,EA/FrC,QAAQ,CAChB,EAAI,AA8FyC,EA9FrC,UAAU,CAClB,EAAI,AA6FyC,EA7FrC,KAAK,CAEjB,EAAK,QAAQ,CAAC,GAAG,CAAE,CAAC,CAAC,EAAE,CAAE,CAAC,CAAC,EAAE,CAAE,CAAC,CAAC,EAAE,EAE9B,GAEJ,EAAK,UAAU,CAAC,GAAG,CAAE,CAAC,CAAC,EAAE,CAAE,CAAC,CAAC,EAAE,CAAE,CAAC,CAAC,EAAE,CAAE,CAAC,CAAC,EAAE,EAC3C,EAAK,aAAa,CAAG,CAAA,GAIrB,EAAK,QAAQ,CAAC,GAAG,CAAE,CAAC,CAAC,EAAE,CAAE,CAAC,CAAC,EAAE,CAAE,CAAC,CAAC,EAAE,EAIpC,EAAK,KAAK,CAAC,GAAG,CAAE,CAAC,CAAC,EAAE,CAAE,CAAC,CAAC,EAAE,CAAE,CAAC,CAAC,EAAE,EA8EO,GAvEtC,EAAK,QAAQ,CAAE,SAAW,CAAK,EAE9B,EAAM,QAAQ,CAqEuB,CAnEtC,GAOG,EAAU,AAAkB,KAAA,IAAlB,AA4DmC,EA5D7B,OAAO,EAAmB,AA4DG,EA5DC,OAAO,CAEzD,EAAK,QAAQ,CAAE,SAAW,CAAK,EAE9B,EAAM,OAAO,CAAG,CAEjB,GAEA,AAoD+B,EApDxB,GAAG,CAAE,GAEZ,EAAK,IAAI,CAkDkB,EAhD3B,EAAO,OAAO,CAgDa,EAhDP,CAAG,EACvB,IAiDC,GAAkB,EAElB,EAAM,cAAc,GAEpB,GAED,CAED,CAaA,SAAS,IAER,IAAI,EAAW,CAEd,YAAc,EACd,cAAgB,EAChB,aAAe,EAAe,EAC9B,eAAiB,EAAiB,CAEnC,EAEA,EAAM,gBAAgB,CAAE,EAAU,GAElC,EAAM,cAAc,GAEI,IAAnB,GAAwB,AAAqB,IAArB,IAE5B,AAOF,WAIC,IAAM,IAAI,EAAI,EAAG,EAAI,EAAa,MAAM,CAAE,IAAO,CAEhD,IAAI,EAAK,CAAY,CAAE,EAAG,CAEtB,EAAS,EAAO,OAAO,CAAE,EAAG,UAAU,CAAE,CAEvC,EAEJ,EAAG,MAAM,CAAC,MAAM,CAAG,GAQnB,EAAG,MAAM,CAAC,MAAM,CAAG,IAAI,GAAM,QAAQ,CACrC,EAAO,KAAK,CAAC,GAAG,CAAE,EAAG,MAAM,CAAC,MAAM,GAInC,EAAG,MAAM,CAAC,MAAM,CAAC,UAAU,CAAC,aAAa,CAAG,EAAG,MAAM,AAEtD,CAED,IAnCE,EAAkB,GAIpB,CAiCA,IAAI,EAAkB,SAAW,CAAK,EAErC,GAAoB,EACpB,IAEA,EAAM,cAAc,EAErB,EAKI,EAA0B,SAAW,CAAK,EAE7C,OAAO,WAEN,EAAiB,EAElB,CAED,EAQA,IAAM,KAAS,AA/nBJ,EA+nBS,IAAI,CAIlB,AAAiB,WAAjB,AAFL,CAAA,EAAU,AAjoBA,EAioBK,IAAI,CAAE,EAAO,AAAP,EAER,IAAI,CAEhB,EAAM,IAAI,GAAM,GAAG,CAAE,EAAU,EAAQ,IAAI,CAAE,EAAQ,GAAG,EAE5B,SAAjB,EAAQ,IAAI,EAEvB,CAAA,EAAM,IAAI,GAAM,OAAO,CAAE,EAAU,EAAQ,OAAO,CAAA,EAInD,EAAQ,EAAQ,KAAK,CACrB,EAAI,KAAK,CAAC,MAAM,CAAE,CAAK,CAAC,EAAE,CAAE,CAAK,CAAC,EAAE,CAAE,CAAK,CAAC,EAAE,EAE9C,EAAO,IAAI,CAAE,EAAO,CAAG,EAYxB,IAAM,KAAS,AA5pBJ,EA4pBS,UAAU,CAIxB,AAFL,CAAA,EAAU,AA9pBA,EA8pBK,UAAU,CAAE,EAAO,AAAP,EAEd,IAAI,IAAI,IAAI,CAAC,kBAAkB,GAE3C,GAAkB,EAElB,EAAM,WAAW,IAUnB,IAAM,KAAS,AA9qBJ,EA8qBS,OAAO,CAIrB,AAFL,CAAA,EAAU,AAhrBA,EAgrBK,OAAO,CAAE,EAAO,AAAP,EAEX,IAAI,EAAM,EAAQ,IAAI,IAAI,IAAI,CAAC,mBAAmB,GAE9D,GAAkB,EAElB,EAAM,WAAW,IAQnB,IAAM,KAFN,EAAe,EAEA,AA9rBJ,EA8rBS,UAAU,CAI7B,GAAK,AAAiB,SAAjB,AAFL,CAAA,EAAU,AAhsBA,EAgsBK,UAAU,CAAE,EAAO,AAAP,EAEd,IAAI,CAEhB,EAAW,IAAI,GAAM,YAAY,CAAE,EAAQ,KAAK,CAAE,EAAQ,MAAM,CAAE,EAAQ,KAAK,CAAE,EAAQ,aAAa,CAAE,EAAQ,cAAc,CAAE,EAAQ,aAAa,EACrJ,EAAO,UAAU,CAAE,EAAO,CAAG,OAEvB,GAAK,AAAiB,UAAjB,EAAQ,IAAI,CAEvB,EAAW,IAAI,GAAM,aAAa,CAAE,EAAQ,KAAK,CAAE,EAAQ,MAAM,CAAE,EAAQ,aAAa,CAAE,EAAQ,cAAc,EAChH,EAAO,UAAU,CAAE,EAAO,CAAG,OAEvB,GAAK,AAAiB,WAAjB,EAAQ,IAAI,CAEvB,EAAW,IAAI,GAAM,cAAc,CAAE,EAAQ,MAAM,CAAE,EAAQ,aAAa,CAAE,EAAQ,cAAc,EAClG,EAAO,UAAU,CAAE,EAAO,CAAG,OAEvB,GAAK,AAAiB,aAAjB,EAAQ,IAAI,CAEvB,EAAW,IAAI,GAAM,gBAAgB,CAAE,EAAQ,MAAM,CAAE,EAAQ,MAAM,CAAE,EAAQ,MAAM,CAAE,EAAQ,OAAO,CAAE,EAAQ,UAAU,EAC1H,EAAO,UAAU,CAAE,EAAO,CAAG,OAEvB,GAAK,AAAiB,UAAjB,EAAQ,IAAI,CAEvB,EAAW,IAAI,GAAM,aAAa,CAAE,EAAQ,MAAM,CAAE,EAAQ,IAAI,CAAE,EAAQ,SAAS,CAAE,EAAQ,SAAS,EACtG,EAAO,UAAU,CAAE,EAAO,CAAG,OAEvB,GAAK,AAAiB,gBAAjB,EAAQ,IAAI,CAEvB,EAAW,IAAI,GAAM,mBAAmB,CAAE,EAAQ,MAAM,CAAE,EAAQ,YAAY,EAC9E,EAAO,UAAU,CAAE,EAAO,CAAG,OAEvB,GAAK,EAAQ,IAAI,IAAI,IAAI,CAAC,kBAAkB,CAAG,CAErD,IAAI,EAAmB,CAAC,EAExB,IAAM,IAAI,KAAW,EAEH,SAAZ,GAAsB,AAAY,QAAZ,GAE1B,CAAA,CAAgB,CAAE,EAAS,CAAG,CAAO,CAAE,EAAS,AAAT,EAOzC,AADa,IAAI,CAAC,kBAAkB,CAAE,EAAQ,IAAI,CAAE,CAAE,YAAgB,CAC/D,IAAI,CAAE,EAAS,EAAQ,GAAG,CAAE,AA/uB1B,EA+uB+B,WAAW,EAAI,AArQzD,SAAmC,CAAE,EAEpC,OAAO,SAAU,CAAG,CAAE,CAAG,EA/DzB,EAAO,UAAU,CAiEO,EAjED,CAiET,EAhEd,EAAO,cAAc,CAgEG,EAhEG,CAgER,EA/DnB,IAiEC,GAAkB,EAElB,EAAM,cAAc,GAEpB,GAED,CAED,EAuPmF,GAAS,EAE3F,MAAO,GAAK,AAAiB,aAAjB,EAAQ,IAAI,CAAkB,CAEzC,IAAI,EAAY,AAnvBP,EAmvBY,MAAM,CAAE,EAAQ,EAAE,CAAE,AAKzC,CAAA,EAAU,QAAQ,CAAG,AAxvBZ,EAwvBiB,QAAQ,CAE7B,GAGJ,AADiB,IAAI,CAAC,kBAAkB,CAAE,KAAS,CAAE,YAAgB,CAC1D,WAAW,CAAE,EAAW,AA5NtC,SAAgC,CAAE,EAEjC,OAAO,SAAU,CAAG,CAAE,CAAG,EAExB,EAAO,UAAU,CAAE,EAAI,CAAG,EAC1B,EAAO,cAAc,CAAE,EAAI,CAAG,CAE/B,CAED,EAmN6D,GAT3C,GAajB,CAUD,IAAM,KAAa,AA3wBR,EA2wBa,QAAQ,CAI/B,GAAK,AAFL,CAAA,EAAc,AA7wBJ,EA6wBS,QAAQ,CAAE,EAAW,AAAX,EAEZ,GAAG,YAAY,MAAQ,CAEvC,GAAoB,EAAY,GAAG,CAAC,MAAM,CAE1C,IAAK,IAAI,EAAI,EAAG,EAAI,EAAY,GAAG,CAAC,MAAM,CAAE,IAE3C,EAAM,WAAW,EAInB,MAEC,GAAoB,EAEpB,EAAM,WAAW,GAQnB,IAAM,KAFN,EAAiB,EAEE,AAryBR,EAqyBa,QAAQ,CAAG,CAUlC,GAN6B,KAAA,IAAxB,AAFL,CAAA,EAAc,AAvyBJ,EAuyBS,QAAQ,CAAE,EAAW,AAAX,EAEZ,OAAO,EAAkB,AAAiC,KAAA,IAAjC,EAAK,CAAE,EAAY,OAAO,CAAE,EAErE,CAAA,EAAY,OAAO,CAAG,IAAI,EAAK,CAAE,EAAY,OAAO,CAAE,AAFvD,EAMK,EAAY,GAAG,YAAY,MAAQ,CAKvC,IAAK,IAHD,EAAQ,EAAY,GAAG,CAAC,MAAM,CAC9B,EAAY,EAAE,CAET,EAAI,EAAG,EAAI,EAAO,IAE1B,CAAS,CAAE,EAAG,CAAG,EAAS,EAAY,GAAG,CAAE,EAAG,CAAE,AAtzBxC,EAszB6C,WAAW,EALjE,IASI,EAAe,UAAU,IAAI,CAAE,CAAS,CAAE,EAAG,EAIhD,EAFI,EAEM,GAAM,UAAU,CAAC,yBAAyB,CAAE,EAAW,EAAY,OAAO,CAAE,EAAyB,IAIrG,GAAM,UAAU,CAAC,eAAe,CAAE,EAAW,EAAY,OAAO,CAAE,EAAyB,GAIvG,KAAO,CAEN,IAAI,EAAe,UAAU,IAAI,CAAE,EAAY,GAAG,EAC9C,EAAU,EAAS,EAAY,GAAG,CAAE,AAz0B/B,EAy0BoC,WAAW,EACpD,EAAkB,EAAyB,GAqC/C,GAjCC,EAFI,EAEM,GAAM,UAAU,CAAC,qBAAqB,CAAE,EAAS,EAAY,OAAO,CAAE,GAItE,GAAM,UAAU,CAAC,WAAW,CAAE,EAAS,EAAY,OAAO,CAAE,GAI/B,KAAA,IAAnC,EAAK,CAAE,EAAY,SAAS,CAAE,EAClC,CAAA,EAAQ,SAAS,CAAG,EAAK,CAAE,EAAY,SAAS,CAAE,AAAF,EAET,KAAA,IAAnC,EAAK,CAAE,EAAY,SAAS,CAAE,EAClC,CAAA,EAAQ,SAAS,CAAG,EAAK,CAAE,EAAY,SAAS,CAAE,AAAF,EAE5C,EAAY,UAAU,EAAG,CAAA,EAAQ,UAAU,CAAG,EAAY,UAAU,AAAV,EAE1D,EAAY,MAAM,GAEtB,EAAQ,MAAM,CAAC,GAAG,CAAE,EAAY,MAAM,CAAE,EAAG,CAAE,EAAY,MAAM,CAAE,EAAG,EAEnC,IAA5B,EAAY,MAAM,CAAE,EAAG,EAAS,CAAA,EAAQ,KAAK,CAAG,GAAM,cAAc,AAAd,EAC1B,IAA5B,EAAY,MAAM,CAAE,EAAG,EAAS,CAAA,EAAQ,KAAK,CAAG,GAAM,cAAc,AAAd,GAIvD,EAAY,MAAM,EAEtB,EAAQ,MAAM,CAAC,GAAG,CAAE,EAAY,MAAM,CAAE,EAAG,CAAE,EAAY,MAAM,CAAE,EAAG,EAMhE,EAAY,IAAI,CAAG,CAEvB,IAAI,EAAU,CACd,OAAY,GAAM,cAAc,CAChC,OAAW,GAAM,sBAAsB,AACvC,CAE0C,MAAA,IAArC,CAAO,CAAE,EAAY,IAAI,CAAE,EAAG,CAAE,EAAiB,CAAA,EAAQ,KAAK,CAAG,CAAO,CAAE,EAAY,IAAI,CAAE,EAAG,CAAE,AAAF,EAC1D,KAAA,IAArC,CAAO,CAAE,EAAY,IAAI,CAAE,EAAG,CAAE,EAAiB,CAAA,EAAQ,KAAK,CAAG,CAAO,CAAE,EAAY,IAAI,CAAE,EAAG,CAAE,AAAF,CAErG,CAED,CAEA,EAAO,QAAQ,CAAE,EAAW,CAAG,CAEhC,CAOA,IAAM,KAAS,AAt4BJ,EAs4BS,SAAS,CAAG,CAI/B,IAAM,IAAS,AAFf,CAAA,EAAU,AAx4BA,EAw4BK,SAAS,CAAE,EAAO,AAAP,EAEH,UAAU,CAEhC,GAAK,AAAU,WAAV,GAAsB,AAAU,QAAV,GAAmB,AAAU,aAAV,GAAwB,AAAU,YAAV,EAErE,EAAQ,UAAU,CAAE,EAAO,CAAG,EAAO,QAAQ,CAAE,EAAQ,UAAU,CAAE,EAAO,CAAE,MAEtE,GAAK,AAAU,YAAV,EAEX,EAAQ,UAAU,CAAE,EAAO,CAAG,AAAkC,SAAlC,EAAU,UAAU,CAAE,EAAO,CAAgB,GAAM,WAAW,CAAG,GAAM,aAAa,MAE5G,GAAK,AAAU,SAAV,EAEN,AAA+B,UAA/B,EAAQ,UAAU,CAAE,EAAO,CAE/B,EAAQ,UAAU,CAAE,EAAO,CAAG,GAAM,UAAU,CAEnC,AAA+B,QAA/B,EAAQ,UAAU,CAAE,EAAO,CAEtC,EAAQ,UAAU,CAAE,EAAO,CAAG,GAAM,QAAQ,CAI5C,EAAQ,UAAU,CAAE,EAAO,CAAG,GAAM,SAAS,MAIxC,GAAK,AAAU,aAAV,EAEX,EAAQ,UAAU,CAAE,EAAO,CAAG,EAAQ,UAAU,CAAE,EAAO,GAAI,GAAQ,EAAK,CAAE,EAAQ,UAAU,CAAE,EAAO,CAAE,CAAG,GAAM,cAAc,MAE1H,GAAK,AAAU,YAAV,EAEX,EAAQ,UAAU,CAAE,EAAO,CAAG,EAAQ,UAAU,CAAE,EAAO,GAAI,GAAQ,EAAK,CAAE,EAAQ,UAAU,CAAE,EAAO,CAAE,CAAG,GAAM,iBAAiB,MAE7H,GAAK,AAAU,iBAAV,EAEN,AAA+B,QAA/B,EAAQ,UAAU,CAAE,EAAO,CAE/B,EAAQ,UAAU,CAAE,EAAO,CAAG,GAAM,UAAU,CAInC,EAAQ,UAAU,CAAE,EAAO,EAEtC,CAAA,EAAQ,UAAU,CAAE,EAAO,CAAG,GAAM,YAAY,AAAZ,OAI/B,GAAK,AAAU,YAAV,EAAsB,CAEjC,IAAI,EAAK,EAAQ,UAAU,CAAE,EAAO,AACpC,CAAA,EAAQ,UAAU,CAAE,EAAO,CAAG,IAAI,GAAM,OAAO,CAAE,CAAE,CAAE,EAAG,CAAE,CAAE,CAAE,EAAG,CAAE,CAAE,CAAE,EAAG,CAE3E,CAUD,GANoC,KAAA,IAA/B,EAAQ,UAAU,CAAC,OAAO,EAAkB,EAAQ,UAAU,CAAC,OAAO,CAAG,GAE7E,CAAA,EAAQ,UAAU,CAAC,WAAW,CAAG,CAAA,CAFlC,EAMK,EAAQ,UAAU,CAAC,SAAS,CAAG,CAEnC,IAAI,GAAS,GAAM,SAAS,CAAE,SAAa,CACvC,GAAW,GAAM,aAAa,CAAC,KAAK,CAAE,GAAO,QAAQ,EAErD,GAAU,EAAQ,UAAU,CAAC,KAAK,CAClC,GAAW,EAAQ,UAAU,CAAC,QAAQ,CACtC,GAAU,EAAQ,UAAU,CAAC,OAAO,CACpC,GAAY,EAAQ,UAAU,CAAC,SAAS,AAE5C,CAAA,GAAU,OAAW,CAAC,KAAK,CAAG,EAAO,QAAQ,CAAE,EAAQ,UAAU,CAAC,SAAS,CAAE,CAExE,EAAQ,UAAU,CAAC,WAAW,EAElC,GAAU,YAAgB,CAAC,KAAK,CAAC,GAAG,CAAE,EAAQ,UAAU,CAAC,WAAW,CAAE,EAAG,CAAE,EAAQ,UAAU,CAAC,WAAW,CAAE,EAAG,EAI1G,EAAQ,UAAU,CAAC,GAAG,GAE1B,GAAU,QAAY,CAAC,KAAK,CAAG,EAAQ,UAAU,CAAC,GAAG,CACrD,GAAU,aAAiB,CAAC,KAAK,CAAG,CAAA,GAIhC,EAAQ,UAAU,CAAC,MAAM,GAE7B,GAAU,KAAS,CAAC,KAAK,CAAG,EAAQ,UAAU,CAAC,MAAM,CACrD,GAAU,gBAAoB,CAAC,KAAK,CAAG,CAAA,EACvC,GAAU,aAAiB,CAAC,KAAK,CAAG,EAAQ,UAAU,CAAC,YAAY,EAI/D,EAAQ,UAAU,CAAC,QAAQ,GAE/B,GAAU,GAAO,CAAC,KAAK,CAAG,EAAQ,UAAU,CAAC,QAAQ,CACrD,GAAU,QAAY,CAAC,KAAK,CAAG,CAAA,GAI3B,EAAQ,UAAU,CAAC,WAAW,GAElC,GAAU,SAAa,CAAC,KAAK,CAAG,EAAO,QAAQ,CAAE,EAAQ,UAAU,CAAC,WAAW,CAAE,CACjF,GAAU,cAAkB,CAAC,KAAK,CAAG,CAAA,GAIjC,EAAQ,UAAU,CAAC,eAAe,GAEtC,GAAU,aAAiB,CAAC,KAAK,CAAG,EAAO,QAAQ,CAAE,EAAQ,UAAU,CAAC,eAAe,CAAE,CACzF,GAAU,kBAAsB,CAAC,KAAK,CAAG,CAAA,EAEzC,GAAU,iBAAqB,CAAC,KAAK,CAAG,EAAQ,UAAU,CAAC,gBAAgB,CAC3E,GAAU,kBAAsB,CAAC,KAAK,CAAG,EAAQ,UAAU,CAAC,iBAAiB,EAI9E,GAAU,aAAiB,CAAC,KAAK,CAAC,MAAM,CAAE,IAC1C,GAAU,cAAkB,CAAC,KAAK,CAAC,MAAM,CAAE,IAC3C,GAAU,aAAiB,CAAC,KAAK,CAAC,MAAM,CAAE,IAE1C,GAAU,UAAc,CAAC,KAAK,CAAG,GAE5B,EAAQ,UAAU,CAAC,OAAO,EAE9B,CAAA,GAAU,QAAY,CAAC,KAAK,CAAG,EAAQ,UAAU,CAAC,OAAO,AAAP,EAInD,IAAI,GAAa,CAAE,eAAgB,GAAO,cAAc,CAAE,aAAc,GAAO,YAAY,CAAE,SAAU,GAAU,OAAQ,CAAA,EAAM,IAAK,CAAA,CAAK,EAEzI,EAAW,IAAI,GAAM,cAAc,CAAE,GAEtC,MAEC,EAAW,IAAI,EAAK,CAAE,EAAQ,IAAI,CAAE,CAAE,EAAQ,UAAU,CAIzD,CAAA,EAAO,SAAS,CAAE,EAAO,CAAG,CAE7B,CAKA,IAAM,KAAS,AA/hCJ,EA+hCS,SAAS,CAI5B,GAAK,AAFL,CAAA,EAAU,AAjiCA,EAiiCK,SAAS,CAAE,EAAO,AAAP,EAEb,UAAU,CAAC,SAAS,CAAG,CAInC,IAAM,IAFF,GAAgB,EAAE,CAEZ,EAAI,EAAG,EAAI,EAAQ,UAAU,CAAC,SAAS,CAAC,MAAM,CAAE,IAAO,CAEhE,IAAI,GAAQ,EAAQ,UAAU,CAAC,SAAS,CAAE,EAAG,CAC7C,GAAc,IAAI,CAAE,EAAO,SAAS,CAAE,GAAO,CAE9C,CAEA,EAAO,SAAS,CAAE,EAAO,CAAC,SAAS,CAAG,EAEvC,CAMD,IAIK,EAAO,OAAO,EAAI,AA1jCZ,EA0jCiB,QAAQ,CAAC,MAAM,EAE1C,CAAA,EAAO,aAAa,CAAG,EAAO,OAAO,CAAE,AA5jC7B,EA4jCkC,QAAQ,CAAC,MAAM,CAAE,AAAF,EAIvD,EAAO,IAAI,EAAI,AAhkCT,EAgkCc,QAAQ,CAAC,GAAG,EAEpC,CAAA,EAAO,KAAK,CAAC,GAAG,CAAG,EAAO,IAAI,CAAE,AAlkCtB,EAkkC2B,QAAQ,CAAC,GAAG,CAAE,AAAF,EAMlD,EAAM,YAAY,CAAE,GAIpB,GAED,EAKA,GAAM,aAAa,CAAG,WAErB,GAAM,eAAe,CAAC,IAAI,CAAE,IAAI,EAEhC,IAAI,CAAC,WAAW,CAAG,IAEpB,EAEA,GAAM,aAAa,CAAC,SAAS,CAAG,CAE/B,YAAa,GAAM,aAAa,CAEhC,KAAM,SAAW,CAAG,EAEnB,IAAI,EAAQ,IAAI,CAEZ,EAAQ,IAAI,MAEhB,EAAM,gBAAgB,CAAE,OAAQ,WAE/B,IAAI,EAAU,IAAI,GAAM,OAAO,CAAE,EACjC,CAAA,EAAQ,WAAW,CAAG,CAAA,EAEtB,EAAM,aAAa,CAAE,CAAE,KAAM,OAAQ,QAAS,CAAQ,EAEvD,EAAG,CAAA,GAEH,EAAM,gBAAgB,CAAE,QAAS,WAEhC,EAAM,aAAa,CAAE,CAAE,KAAM,QAAS,QAAS,sBAAyB,EAAM,GAAI,EAEnF,EAAG,CAAA,GAEE,EAAM,WAAW,EAAG,CAAA,EAAM,WAAW,CAAG,EAAM,WAAW,AAAX,EAEnD,EAAM,GAAG,CAAG,CAEb,CAED,EAMA,GAAM,QAAQ,CAAG,WAEhB,GAAM,eAAe,CAAC,IAAI,CAAE,IAAI,EAEhC,IAAI,CAAC,EAAE,CAAG,GAAM,eAAe,GAE/B,IAAI,CAAC,IAAI,CAAG,GAEZ,IAAI,CAAC,IAAI,CAAG,GAAM,SAAS,CAE3B,IAAI,CAAC,OAAO,CAAG,EACf,IAAI,CAAC,WAAW,CAAG,CAAA,EAEnB,IAAI,CAAC,QAAQ,CAAG,GAAM,cAAc,CAEpC,IAAI,CAAC,QAAQ,CAAG,GAAM,cAAc,CACpC,IAAI,CAAC,QAAQ,CAAG,GAAM,sBAAsB,CAC5C,IAAI,CAAC,aAAa,CAAG,GAAM,WAAW,CAEtC,IAAI,CAAC,SAAS,CAAG,CAAA,EACjB,IAAI,CAAC,UAAU,CAAG,CAAA,EAElB,IAAI,CAAC,aAAa,CAAG,CAAA,EACrB,IAAI,CAAC,mBAAmB,CAAG,EAC3B,IAAI,CAAC,kBAAkB,CAAG,EAE1B,IAAI,CAAC,SAAS,CAAG,EAEjB,IAAI,CAAC,QAAQ,CAAG,CAAA,EAEhB,IAAI,CAAC,OAAO,CAAG,CAAA,EAEf,IAAI,CAAC,WAAW,CAAG,CAAA,CAEpB,EAEA,GAAM,QAAQ,CAAC,SAAS,CAAC,SAAS,CAAG,SAAW,CAAM,EAErD,GAAK,AAAW,KAAA,IAAX,EAEL,IAAM,IAAI,KAAO,EAAS,CAEzB,IAAI,EAAW,CAAM,CAAE,EAAK,CAE5B,GAAK,AAAa,KAAA,IAAb,EAAyB,CAE7B,QAAQ,IAAI,CAAE,oBAAuB,EAAM,6BAC3C,QAED,CAEA,GAAK,KAAO,IAAI,CAAG,CAElB,IAAI,EAAe,IAAI,CAAE,EAAK,AAEzB,CAAA,aAAwB,GAAM,KAAK,EAAI,aAAoB,GAAM,KAAK,CAE1E,EAAa,IAAI,CAAE,GAER,aAAwB,GAAM,KAAK,CAE9C,EAAa,GAAG,CAAE,GAEP,aAAwB,GAAM,OAAO,EAAI,aAAoB,GAAM,OAAO,CAErF,EAAa,IAAI,CAAE,GAInB,IAAI,CAAE,EAAK,CAAG,CAIhB,CAED,CAED,EAEA,GAAM,QAAQ,CAAC,SAAS,CAAC,KAAK,CAAG,SAAW,CAAQ,EA8BnD,OA5BkB,KAAA,IAAb,GAAyB,CAAA,EAAW,IAAI,GAAM,QAAQ,AAA3D,EAEA,EAAS,IAAI,CAAG,IAAI,CAAC,IAAI,CAEzB,EAAS,IAAI,CAAG,IAAI,CAAC,IAAI,CAEzB,EAAS,OAAO,CAAG,IAAI,CAAC,OAAO,CAC/B,EAAS,WAAW,CAAG,IAAI,CAAC,WAAW,CAEvC,EAAS,QAAQ,CAAG,IAAI,CAAC,QAAQ,CAEjC,EAAS,QAAQ,CAAG,IAAI,CAAC,QAAQ,CACjC,EAAS,QAAQ,CAAG,IAAI,CAAC,QAAQ,CACjC,EAAS,aAAa,CAAG,IAAI,CAAC,aAAa,CAE3C,EAAS,SAAS,CAAG,IAAI,CAAC,SAAS,CACnC,EAAS,UAAU,CAAG,IAAI,CAAC,UAAU,CAErC,EAAS,aAAa,CAAG,IAAI,CAAC,aAAa,CAC3C,EAAS,mBAAmB,CAAG,IAAI,CAAC,mBAAmB,CACvD,EAAS,kBAAkB,CAAG,IAAI,CAAC,kBAAkB,CAErD,EAAS,SAAS,CAAG,IAAI,CAAC,SAAS,CAEnC,EAAS,QAAQ,CAAG,IAAI,CAAC,QAAQ,CAEjC,EAAS,OAAO,CAAG,IAAI,CAAC,OAAO,CAExB,CAER,EAEA,GAAM,QAAQ,CAAC,SAAS,CAAC,OAAO,CAAG,WAElC,IAAI,CAAC,aAAa,CAAE,CAAE,KAAM,SAAU,EAEvC,EAEA,GAAM,eAAe,CAAG,EAuBxB,GAAM,iBAAiB,CAAG,SAAW,CAAU,EAE9C,GAAM,QAAQ,CAAC,IAAI,CAAE,IAAI,EAEzB,IAAI,CAAC,KAAK,CAAG,IAAI,GAAM,KAAK,CAAE,UAE9B,IAAI,CAAC,SAAS,CAAG,EACjB,IAAI,CAAC,OAAO,CAAG,QACf,IAAI,CAAC,QAAQ,CAAG,QAEhB,IAAI,CAAC,YAAY,CAAG,CAAA,EAEpB,IAAI,CAAC,GAAG,CAAG,CAAA,EAEX,IAAI,CAAC,SAAS,CAAE,EAEjB,EAEA,GAAM,iBAAiB,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,QAAQ,CAAC,SAAS,EAE3E,GAAM,iBAAiB,CAAC,SAAS,CAAC,KAAK,CAAG,WAEzC,IAAI,EAAW,IAAI,GAAM,iBAAiB,CAc1C,OAZA,GAAM,QAAQ,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAE,IAAI,CAAE,GAE3C,EAAS,KAAK,CAAC,IAAI,CAAE,IAAI,CAAC,KAAK,EAE/B,EAAS,SAAS,CAAG,IAAI,CAAC,SAAS,CACnC,EAAS,OAAO,CAAG,IAAI,CAAC,OAAO,CAC/B,EAAS,QAAQ,CAAG,IAAI,CAAC,QAAQ,CAEjC,EAAS,YAAY,CAAG,IAAI,CAAC,YAAY,CAEzC,EAAS,GAAG,CAAG,IAAI,CAAC,GAAG,CAEhB,CAER,EAwBA,GAAM,kBAAkB,CAAG,SAAW,CAAU,EAE/C,GAAM,QAAQ,CAAC,IAAI,CAAE,IAAI,EAEzB,IAAI,CAAC,KAAK,CAAG,IAAI,GAAM,KAAK,CAAE,UAE9B,IAAI,CAAC,SAAS,CAAG,EAEjB,IAAI,CAAC,KAAK,CAAG,EACb,IAAI,CAAC,QAAQ,CAAG,EAChB,IAAI,CAAC,OAAO,CAAG,EAEf,IAAI,CAAC,YAAY,CAAG,CAAA,EAEpB,IAAI,CAAC,GAAG,CAAG,CAAA,EAEX,IAAI,CAAC,SAAS,CAAE,EAEjB,EAEA,GAAM,kBAAkB,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,QAAQ,CAAC,SAAS,EAE5E,GAAM,kBAAkB,CAAC,SAAS,CAAC,KAAK,CAAG,WAE1C,IAAI,EAAW,IAAI,GAAM,kBAAkB,CAgB3C,OAdA,GAAM,QAAQ,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAE,IAAI,CAAE,GAE3C,EAAS,KAAK,CAAC,IAAI,CAAE,IAAI,CAAC,KAAK,EAE/B,EAAS,SAAS,CAAG,IAAI,CAAC,SAAS,CAEnC,EAAS,KAAK,CAAG,IAAI,CAAC,KAAK,CAC3B,EAAS,QAAQ,CAAG,IAAI,CAAC,QAAQ,CACjC,EAAS,OAAO,CAAG,IAAI,CAAC,OAAO,CAE/B,EAAS,YAAY,CAAG,IAAI,CAAC,YAAY,CAEzC,EAAS,GAAG,CAAG,IAAI,CAAC,GAAG,CAEhB,CAER,EAoCA,GAAM,iBAAiB,CAAG,SAAW,CAAU,EAE9C,GAAM,QAAQ,CAAC,IAAI,CAAE,IAAI,EAEzB,IAAI,CAAC,KAAK,CAAG,IAAI,GAAM,KAAK,CAAE,UAE9B,IAAI,CAAC,GAAG,CAAG,KAEX,IAAI,CAAC,QAAQ,CAAG,KAEhB,IAAI,CAAC,WAAW,CAAG,KAEnB,IAAI,CAAC,MAAM,CAAG,KACd,IAAI,CAAC,OAAO,CAAG,GAAM,iBAAiB,CACtC,IAAI,CAAC,YAAY,CAAG,EACpB,IAAI,CAAC,eAAe,CAAG,IAEvB,IAAI,CAAC,GAAG,CAAG,CAAA,EAEX,IAAI,CAAC,OAAO,CAAG,GAAM,aAAa,CAElC,IAAI,CAAC,SAAS,CAAG,CAAA,EACjB,IAAI,CAAC,kBAAkB,CAAG,EAC1B,IAAI,CAAC,gBAAgB,CAAG,QACxB,IAAI,CAAC,iBAAiB,CAAG,QAEzB,IAAI,CAAC,YAAY,CAAG,GAAM,QAAQ,CAElC,IAAI,CAAC,QAAQ,CAAG,CAAA,EAChB,IAAI,CAAC,YAAY,CAAG,CAAA,EAEpB,IAAI,CAAC,SAAS,CAAE,EAEjB,EAEA,GAAM,iBAAiB,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,QAAQ,CAAC,SAAS,EAE3E,GAAM,iBAAiB,CAAC,SAAS,CAAC,KAAK,CAAG,WAEzC,IAAI,EAAW,IAAI,GAAM,iBAAiB,CA+B1C,OA7BA,GAAM,QAAQ,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAE,IAAI,CAAE,GAE3C,EAAS,KAAK,CAAC,IAAI,CAAE,IAAI,CAAC,KAAK,EAE/B,EAAS,GAAG,CAAG,IAAI,CAAC,GAAG,CAEvB,EAAS,QAAQ,CAAG,IAAI,CAAC,QAAQ,CAEjC,EAAS,WAAW,CAAG,IAAI,CAAC,WAAW,CAEvC,EAAS,MAAM,CAAG,IAAI,CAAC,MAAM,CAC7B,EAAS,OAAO,CAAG,IAAI,CAAC,OAAO,CAC/B,EAAS,YAAY,CAAG,IAAI,CAAC,YAAY,CACzC,EAAS,eAAe,CAAG,IAAI,CAAC,eAAe,CAE/C,EAAS,GAAG,CAAG,IAAI,CAAC,GAAG,CAEvB,EAAS,OAAO,CAAG,IAAI,CAAC,OAAO,CAE/B,EAAS,SAAS,CAAG,IAAI,CAAC,SAAS,CACnC,EAAS,kBAAkB,CAAG,IAAI,CAAC,kBAAkB,CACrD,EAAS,gBAAgB,CAAG,IAAI,CAAC,gBAAgB,CACjD,EAAS,iBAAiB,CAAG,IAAI,CAAC,iBAAiB,CAEnD,EAAS,YAAY,CAAG,IAAI,CAAC,YAAY,CAEzC,EAAS,QAAQ,CAAG,IAAI,CAAC,QAAQ,CACjC,EAAS,YAAY,CAAG,IAAI,CAAC,YAAY,CAElC,CAER,EAwCA,GAAM,mBAAmB,CAAG,SAAW,CAAU,EAEhD,GAAM,QAAQ,CAAC,IAAI,CAAE,IAAI,EAEzB,IAAI,CAAC,KAAK,CAAG,IAAI,GAAM,KAAK,CAAE,UAC9B,IAAI,CAAC,OAAO,CAAG,IAAI,GAAM,KAAK,CAAE,UAChC,IAAI,CAAC,QAAQ,CAAG,IAAI,GAAM,KAAK,CAAE,GAEjC,IAAI,CAAC,UAAU,CAAG,CAAA,EAClB,IAAI,CAAC,OAAO,CAAG,IAAI,GAAM,OAAO,CAAE,EAAG,EAAG,GAExC,IAAI,CAAC,GAAG,CAAG,KAEX,IAAI,CAAC,QAAQ,CAAG,KAEhB,IAAI,CAAC,WAAW,CAAG,KAEnB,IAAI,CAAC,MAAM,CAAG,KACd,IAAI,CAAC,OAAO,CAAG,GAAM,iBAAiB,CACtC,IAAI,CAAC,YAAY,CAAG,EACpB,IAAI,CAAC,eAAe,CAAG,IAEvB,IAAI,CAAC,GAAG,CAAG,CAAA,EAEX,IAAI,CAAC,OAAO,CAAG,GAAM,aAAa,CAElC,IAAI,CAAC,SAAS,CAAG,CAAA,EACjB,IAAI,CAAC,kBAAkB,CAAG,EAC1B,IAAI,CAAC,gBAAgB,CAAG,QACxB,IAAI,CAAC,iBAAiB,CAAG,QAEzB,IAAI,CAAC,YAAY,CAAG,GAAM,QAAQ,CAElC,IAAI,CAAC,QAAQ,CAAG,CAAA,EAChB,IAAI,CAAC,YAAY,CAAG,CAAA,EACpB,IAAI,CAAC,YAAY,CAAG,CAAA,EAEpB,IAAI,CAAC,SAAS,CAAE,EAEjB,EAEA,GAAM,mBAAmB,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,QAAQ,CAAC,SAAS,EAE7E,GAAM,mBAAmB,CAAC,SAAS,CAAC,KAAK,CAAG,WAE3C,IAAI,EAAW,IAAI,GAAM,mBAAmB,CAqC5C,OAnCA,GAAM,QAAQ,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAE,IAAI,CAAE,GAE3C,EAAS,KAAK,CAAC,IAAI,CAAE,IAAI,CAAC,KAAK,EAC/B,EAAS,OAAO,CAAC,IAAI,CAAE,IAAI,CAAC,OAAO,EACnC,EAAS,QAAQ,CAAC,IAAI,CAAE,IAAI,CAAC,QAAQ,EAErC,EAAS,UAAU,CAAG,IAAI,CAAC,UAAU,CACrC,EAAS,OAAO,CAAC,IAAI,CAAE,IAAI,CAAC,OAAO,EAEnC,EAAS,GAAG,CAAG,IAAI,CAAC,GAAG,CAEvB,EAAS,QAAQ,CAAG,IAAI,CAAC,QAAQ,CAEjC,EAAS,WAAW,CAAG,IAAI,CAAC,WAAW,CAEvC,EAAS,MAAM,CAAG,IAAI,CAAC,MAAM,CAC7B,EAAS,OAAO,CAAG,IAAI,CAAC,OAAO,CAC/B,EAAS,YAAY,CAAG,IAAI,CAAC,YAAY,CACzC,EAAS,eAAe,CAAG,IAAI,CAAC,eAAe,CAE/C,EAAS,GAAG,CAAG,IAAI,CAAC,GAAG,CAEvB,EAAS,OAAO,CAAG,IAAI,CAAC,OAAO,CAE/B,EAAS,SAAS,CAAG,IAAI,CAAC,SAAS,CACnC,EAAS,kBAAkB,CAAG,IAAI,CAAC,kBAAkB,CACrD,EAAS,gBAAgB,CAAG,IAAI,CAAC,gBAAgB,CACjD,EAAS,iBAAiB,CAAG,IAAI,CAAC,iBAAiB,CAEnD,EAAS,YAAY,CAAG,IAAI,CAAC,YAAY,CAEzC,EAAS,QAAQ,CAAG,IAAI,CAAC,QAAQ,CACjC,EAAS,YAAY,CAAG,IAAI,CAAC,YAAY,CACzC,EAAS,YAAY,CAAG,IAAI,CAAC,YAAY,CAElC,CAER,EAgDA,GAAM,iBAAiB,CAAG,SAAW,CAAU,EAE9C,GAAM,QAAQ,CAAC,IAAI,CAAE,IAAI,EAEzB,IAAI,CAAC,KAAK,CAAG,IAAI,GAAM,KAAK,CAAE,UAC9B,IAAI,CAAC,OAAO,CAAG,IAAI,GAAM,KAAK,CAAE,UAChC,IAAI,CAAC,QAAQ,CAAG,IAAI,GAAM,KAAK,CAAE,GACjC,IAAI,CAAC,QAAQ,CAAG,IAAI,GAAM,KAAK,CAAE,SACjC,IAAI,CAAC,SAAS,CAAG,GAEjB,IAAI,CAAC,KAAK,CAAG,CAAA,EACb,IAAI,CAAC,QAAQ,CAAG,CAAA,EAEhB,IAAI,CAAC,UAAU,CAAG,CAAA,EAClB,IAAI,CAAC,OAAO,CAAG,IAAI,GAAM,OAAO,CAAE,EAAG,EAAG,GAExC,IAAI,CAAC,GAAG,CAAG,KAEX,IAAI,CAAC,QAAQ,CAAG,KAEhB,IAAI,CAAC,OAAO,CAAG,KACf,IAAI,CAAC,SAAS,CAAG,EAEjB,IAAI,CAAC,SAAS,CAAG,KACjB,IAAI,CAAC,WAAW,CAAG,IAAI,GAAM,OAAO,CAAE,EAAG,GAEzC,IAAI,CAAC,WAAW,CAAG,KAEnB,IAAI,CAAC,MAAM,CAAG,KACd,IAAI,CAAC,OAAO,CAAG,GAAM,iBAAiB,CACtC,IAAI,CAAC,YAAY,CAAG,EACpB,IAAI,CAAC,eAAe,CAAG,IAEvB,IAAI,CAAC,GAAG,CAAG,CAAA,EAEX,IAAI,CAAC,OAAO,CAAG,GAAM,aAAa,CAElC,IAAI,CAAC,SAAS,CAAG,CAAA,EACjB,IAAI,CAAC,kBAAkB,CAAG,EAC1B,IAAI,CAAC,gBAAgB,CAAG,QACxB,IAAI,CAAC,iBAAiB,CAAG,QAEzB,IAAI,CAAC,YAAY,CAAG,GAAM,QAAQ,CAElC,IAAI,CAAC,QAAQ,CAAG,CAAA,EAChB,IAAI,CAAC,YAAY,CAAG,CAAA,EACpB,IAAI,CAAC,YAAY,CAAG,CAAA,EAEpB,IAAI,CAAC,SAAS,CAAE,EAEjB,EAEA,GAAM,iBAAiB,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,QAAQ,CAAC,SAAS,EAE3E,GAAM,iBAAiB,CAAC,SAAS,CAAC,KAAK,CAAG,WAEzC,IAAI,EAAW,IAAI,GAAM,iBAAiB,CAgD1C,OA9CA,GAAM,QAAQ,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAE,IAAI,CAAE,GAE3C,EAAS,KAAK,CAAC,IAAI,CAAE,IAAI,CAAC,KAAK,EAC/B,EAAS,OAAO,CAAC,IAAI,CAAE,IAAI,CAAC,OAAO,EACnC,EAAS,QAAQ,CAAC,IAAI,CAAE,IAAI,CAAC,QAAQ,EACrC,EAAS,QAAQ,CAAC,IAAI,CAAE,IAAI,CAAC,QAAQ,EACrC,EAAS,SAAS,CAAG,IAAI,CAAC,SAAS,CAEnC,EAAS,KAAK,CAAG,IAAI,CAAC,KAAK,CAC3B,EAAS,QAAQ,CAAG,IAAI,CAAC,QAAQ,CAEjC,EAAS,UAAU,CAAG,IAAI,CAAC,UAAU,CACrC,EAAS,OAAO,CAAC,IAAI,CAAE,IAAI,CAAC,OAAO,EAEnC,EAAS,GAAG,CAAG,IAAI,CAAC,GAAG,CAEvB,EAAS,QAAQ,CAAG,IAAI,CAAC,QAAQ,CAEjC,EAAS,OAAO,CAAG,IAAI,CAAC,OAAO,CAC/B,EAAS,SAAS,CAAG,IAAI,CAAC,SAAS,CAEnC,EAAS,SAAS,CAAG,IAAI,CAAC,SAAS,CACnC,EAAS,WAAW,CAAC,IAAI,CAAE,IAAI,CAAC,WAAW,EAE3C,EAAS,WAAW,CAAG,IAAI,CAAC,WAAW,CAEvC,EAAS,MAAM,CAAG,IAAI,CAAC,MAAM,CAC7B,EAAS,OAAO,CAAG,IAAI,CAAC,OAAO,CAC/B,EAAS,YAAY,CAAG,IAAI,CAAC,YAAY,CACzC,EAAS,eAAe,CAAG,IAAI,CAAC,eAAe,CAE/C,EAAS,GAAG,CAAG,IAAI,CAAC,GAAG,CAEvB,EAAS,OAAO,CAAG,IAAI,CAAC,OAAO,CAE/B,EAAS,SAAS,CAAG,IAAI,CAAC,SAAS,CACnC,EAAS,kBAAkB,CAAG,IAAI,CAAC,kBAAkB,CACrD,EAAS,gBAAgB,CAAG,IAAI,CAAC,gBAAgB,CACjD,EAAS,iBAAiB,CAAG,IAAI,CAAC,iBAAiB,CAEnD,EAAS,YAAY,CAAG,IAAI,CAAC,YAAY,CAEzC,EAAS,QAAQ,CAAG,IAAI,CAAC,QAAQ,CACjC,EAAS,YAAY,CAAG,IAAI,CAAC,YAAY,CACzC,EAAS,YAAY,CAAG,IAAI,CAAC,YAAY,CAElC,CAER,EAiBA,GAAM,iBAAiB,CAAG,SAAW,CAAU,EAE9C,GAAM,QAAQ,CAAC,IAAI,CAAE,IAAI,EAEzB,IAAI,CAAC,SAAS,CAAG,CAAA,EACjB,IAAI,CAAC,kBAAkB,CAAG,EAE1B,IAAI,CAAC,SAAS,CAAE,EAEjB,EAEA,GAAM,iBAAiB,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,QAAQ,CAAC,SAAS,EAE3E,GAAM,iBAAiB,CAAC,SAAS,CAAC,KAAK,CAAG,WAEzC,IAAI,EAAW,IAAI,GAAM,iBAAiB,CAO1C,OALA,GAAM,QAAQ,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAE,IAAI,CAAE,GAE3C,EAAS,SAAS,CAAG,IAAI,CAAC,SAAS,CACnC,EAAS,kBAAkB,CAAG,IAAI,CAAC,kBAAkB,CAE9C,CAER,EAiBA,GAAM,kBAAkB,CAAG,SAAW,CAAU,EAE/C,GAAM,QAAQ,CAAC,IAAI,CAAE,IAAI,CAAE,GAE3B,IAAI,CAAC,OAAO,CAAG,GAAM,WAAW,CAEhC,IAAI,CAAC,SAAS,CAAG,CAAA,EACjB,IAAI,CAAC,kBAAkB,CAAG,EAE1B,IAAI,CAAC,SAAS,CAAE,EAEjB,EAEA,GAAM,kBAAkB,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,QAAQ,CAAC,SAAS,EAE5E,GAAM,kBAAkB,CAAC,SAAS,CAAC,KAAK,CAAG,WAE1C,IAAI,EAAW,IAAI,GAAM,kBAAkB,CAS3C,OAPA,GAAM,QAAQ,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAE,IAAI,CAAE,GAE3C,EAAS,OAAO,CAAG,IAAI,CAAC,OAAO,CAE/B,EAAS,SAAS,CAAG,IAAI,CAAC,SAAS,CACnC,EAAS,kBAAkB,CAAG,IAAI,CAAC,kBAAkB,CAE9C,CAER,EAKA,GAAM,gBAAgB,CAAG,SAAW,CAAS,EAE5C,IAAI,CAAC,SAAS,CAAG,aAAqB,MAAQ,EAAY,EAAE,AAE7D,EAEA,GAAM,gBAAgB,CAAC,SAAS,CAAC,KAAK,CAAG,WAExC,OAAO,IAAI,GAAM,gBAAgB,CAAE,IAAI,CAAC,SAAS,CAAC,KAAK,CAAE,GAE1D,EAsBA,GAAM,qBAAqB,CAAG,SAAW,CAAU,EAElD,GAAM,QAAQ,CAAC,IAAI,CAAE,IAAI,EAEzB,IAAI,CAAC,KAAK,CAAG,IAAI,GAAM,KAAK,CAAE,UAE9B,IAAI,CAAC,GAAG,CAAG,KAEX,IAAI,CAAC,IAAI,CAAG,EACZ,IAAI,CAAC,eAAe,CAAG,CAAA,EAEvB,IAAI,CAAC,YAAY,CAAG,CAAA,EAEpB,IAAI,CAAC,GAAG,CAAG,CAAA,EAEX,IAAI,CAAC,SAAS,CAAE,EAEjB,EAEA,GAAM,qBAAqB,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,QAAQ,CAAC,SAAS,EAE/E,GAAM,qBAAqB,CAAC,SAAS,CAAC,KAAK,CAAG,WAE7C,IAAI,EAAW,IAAI,GAAM,qBAAqB,CAe9C,OAbA,GAAM,QAAQ,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAE,IAAI,CAAE,GAE3C,EAAS,KAAK,CAAC,IAAI,CAAE,IAAI,CAAC,KAAK,EAE/B,EAAS,GAAG,CAAG,IAAI,CAAC,GAAG,CAEvB,EAAS,IAAI,CAAG,IAAI,CAAC,IAAI,CACzB,EAAS,eAAe,CAAG,IAAI,CAAC,eAAe,CAE/C,EAAS,YAAY,CAAG,IAAI,CAAC,YAAY,CAEzC,EAAS,GAAG,CAAG,IAAI,CAAC,GAAG,CAEhB,CAER,EAYA,GAAM,sBAAsB,CAAG,SAAW,CAAU,EAEnD,GAAM,QAAQ,CAAC,IAAI,CAAE,IAAI,EAEzB,IAAI,CAAC,KAAK,CAAG,IAAI,GAAM,KAAK,CAAE,UAC9B,IAAI,CAAC,OAAO,CAAG,SAAW,CAAO,CAAE,CAAK,EAAI,EAE5C,IAAI,CAAC,SAAS,CAAE,EAEjB,EAEA,GAAM,sBAAsB,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,QAAQ,CAAC,SAAS,EAEhF,GAAM,sBAAsB,CAAC,SAAS,CAAC,KAAK,CAAG,WAE9C,IAAI,EAAW,IAAI,GAAM,sBAAsB,CAO/C,OALA,GAAM,QAAQ,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAE,IAAI,CAAE,GAE3C,EAAS,KAAK,CAAC,IAAI,CAAE,IAAI,CAAC,KAAK,EAC/B,EAAS,OAAO,CAAG,IAAI,CAAC,OAAO,CAExB,CAER,EAgCA,GAAM,cAAc,CAAG,SAAW,CAAU,EAE3C,GAAM,QAAQ,CAAC,IAAI,CAAE,IAAI,EAEzB,IAAI,CAAC,cAAc,CAAG,iBACtB,IAAI,CAAC,YAAY,CAAG,iBACpB,IAAI,CAAC,QAAQ,CAAG,CAAC,EACjB,IAAI,CAAC,OAAO,CAAG,CAAC,EAChB,IAAI,CAAC,UAAU,CAAG,KAElB,IAAI,CAAC,OAAO,CAAG,GAAM,aAAa,CAElC,IAAI,CAAC,SAAS,CAAG,CAAA,EACjB,IAAI,CAAC,kBAAkB,CAAG,EAE1B,IAAI,CAAC,GAAG,CAAG,CAAA,EAEX,IAAI,CAAC,MAAM,CAAG,CAAA,EAEd,IAAI,CAAC,YAAY,CAAG,GAAM,QAAQ,CAElC,IAAI,CAAC,QAAQ,CAAG,CAAA,EAEhB,IAAI,CAAC,YAAY,CAAG,CAAA,EACpB,IAAI,CAAC,YAAY,CAAG,CAAA,EAEpB,IAAI,CAAC,SAAS,CAAE,EAEjB,EAEA,GAAM,cAAc,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,QAAQ,CAAC,SAAS,EAExE,GAAM,cAAc,CAAC,SAAS,CAAC,KAAK,CAAG,WAEtC,IAAI,EAAW,IAAI,GAAM,cAAc,CA4BvC,OA1BA,GAAM,QAAQ,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAE,IAAI,CAAE,GAE3C,EAAS,cAAc,CAAG,IAAI,CAAC,cAAc,CAC7C,EAAS,YAAY,CAAG,IAAI,CAAC,YAAY,CAEzC,EAAS,QAAQ,CAAG,GAAM,aAAa,CAAC,KAAK,CAAE,IAAI,CAAC,QAAQ,EAE5D,EAAS,UAAU,CAAG,IAAI,CAAC,UAAU,CACrC,EAAS,OAAO,CAAG,IAAI,CAAC,OAAO,CAE/B,EAAS,OAAO,CAAG,IAAI,CAAC,OAAO,CAE/B,EAAS,SAAS,CAAG,IAAI,CAAC,SAAS,CACnC,EAAS,kBAAkB,CAAG,IAAI,CAAC,kBAAkB,CAErD,EAAS,GAAG,CAAG,IAAI,CAAC,GAAG,CAEvB,EAAS,MAAM,CAAG,IAAI,CAAC,MAAM,CAE7B,EAAS,YAAY,CAAG,IAAI,CAAC,YAAY,CAEzC,EAAS,QAAQ,CAAG,IAAI,CAAC,QAAQ,CAEjC,EAAS,YAAY,CAAG,IAAI,CAAC,YAAY,CACzC,EAAS,YAAY,CAAG,IAAI,CAAC,YAAY,CAElC,CAER,EAyBA,GAAM,cAAc,CAAG,SAAW,CAAU,EAE3C,GAAM,QAAQ,CAAC,IAAI,CAAE,IAAI,EAIzB,IAAI,CAAC,KAAK,CAAG,IAAI,GAAM,KAAK,CAAE,UAC9B,IAAI,CAAC,GAAG,CAAG,IAAI,GAAM,OAAO,CAE5B,IAAI,CAAC,oBAAoB,CAAG,CAAA,EAC5B,IAAI,CAAC,SAAS,CAAG,CAAC,IAAI,CAAC,oBAAoB,CAC3C,IAAI,CAAC,eAAe,CAAG,CAAC,IAAI,CAAC,oBAAoB,CACjD,IAAI,CAAC,eAAe,CAAG,CAAC,IAAI,CAAC,eAAe,CAC5C,IAAI,CAAC,SAAS,CAAG,GAAM,eAAe,CAAC,MAAM,CAAC,KAAK,GAEnD,IAAI,CAAC,GAAG,CAAG,CAAA,EAEX,IAAI,CAAC,QAAQ,CAAG,IAAI,GAAM,OAAO,CAAE,EAAG,GACtC,IAAI,CAAC,OAAO,CAAI,IAAI,GAAM,OAAO,CAAE,EAAG,GAItC,IAAI,CAAC,SAAS,CAAE,GAMc,KAAA,IAAzB,AAFL,CAAA,EAAa,GAAc,CAAC,CAAA,EAEZ,SAAS,EAAiB,CAAA,IAAI,CAAC,SAAS,CAAG,CAAC,IAAI,CAAC,oBAAoB,AAApB,EAC7B,KAAA,IAA/B,EAAW,eAAe,EAAiB,CAAA,IAAI,CAAC,eAAe,CAAG,CAAC,IAAI,CAAC,oBAAoB,AAApB,EACzC,KAAA,IAA/B,EAAW,eAAe,EAAiB,CAAA,IAAI,CAAC,eAAe,CAAG,CAAC,IAAI,CAAC,eAAe,AAAf,CAE9E,EAEA,GAAM,cAAc,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,QAAQ,CAAC,SAAS,EAExE,GAAM,cAAc,CAAC,SAAS,CAAC,KAAK,CAAG,WAEtC,IAAI,EAAW,IAAI,GAAM,cAAc,CAiBvC,OAfA,GAAM,QAAQ,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAE,IAAI,CAAE,GAE3C,EAAS,KAAK,CAAC,IAAI,CAAE,IAAI,CAAC,KAAK,EAC/B,EAAS,GAAG,CAAG,IAAI,CAAC,GAAG,CAEvB,EAAS,oBAAoB,CAAG,IAAI,CAAC,oBAAoB,CACzD,EAAS,eAAe,CAAG,IAAI,CAAC,eAAe,CAC/C,EAAS,eAAe,CAAG,IAAI,CAAC,eAAe,CAC/C,EAAS,SAAS,CAAC,IAAI,CAAE,IAAI,CAAC,SAAS,EAEvC,EAAS,QAAQ,CAAC,IAAI,CAAE,IAAI,CAAC,QAAQ,EACrC,EAAS,OAAO,CAAC,IAAI,CAAE,IAAI,CAAC,OAAO,EAEnC,EAAS,GAAG,CAAG,IAAI,CAAC,GAAG,CAEhB,CAER,EAIA,GAAM,eAAe,CAAG,CAAC,EACzB,GAAM,eAAe,CAAC,OAAO,CAAG,IAAI,GAAM,OAAO,CAAE,EAAG,IACtD,GAAM,eAAe,CAAC,SAAS,CAAG,IAAI,GAAM,OAAO,CAAE,EAAG,IACxD,GAAM,eAAe,CAAC,QAAQ,CAAG,IAAI,GAAM,OAAO,CAAE,GAAI,IACxD,GAAM,eAAe,CAAC,UAAU,CAAG,IAAI,GAAM,OAAO,CAAE,EAAG,GACzD,GAAM,eAAe,CAAC,MAAM,CAAG,IAAI,GAAM,OAAO,CAAE,EAAG,GACrD,GAAM,eAAe,CAAC,WAAW,CAAG,IAAI,GAAM,OAAO,CAAE,GAAI,GAC3D,GAAM,eAAe,CAAC,UAAU,CAAG,IAAI,GAAM,OAAO,CAAE,EAAG,GACzD,GAAM,eAAe,CAAC,YAAY,CAAG,IAAI,GAAM,OAAO,CAAE,EAAG,GAC3D,GAAM,eAAe,CAAC,WAAW,CAAG,IAAI,GAAM,OAAO,CAAE,GAAI,GAO3D,GAAM,OAAO,CAAG,SAAW,CAAK,CAAE,CAAO,CAAE,CAAK,CAAE,CAAK,CAAE,CAAS,CAAE,CAAS,CAAE,CAAM,CAAE,CAAI,CAAE,CAAU,EAEtG,GAAM,eAAe,CAAC,IAAI,CAAE,IAAI,EAEhC,IAAI,CAAC,EAAE,CAAG,GAAM,cAAc,GAE9B,IAAI,CAAC,IAAI,CAAG,GAEZ,IAAI,CAAC,KAAK,CAAG,EACb,IAAI,CAAC,OAAO,CAAG,EAAE,CAEjB,IAAI,CAAC,OAAO,CAAG,AAAY,KAAA,IAAZ,EAAwB,EAAU,IAAI,GAAM,SAAS,CAEpE,IAAI,CAAC,KAAK,CAAG,AAAU,KAAA,IAAV,EAAsB,EAAQ,GAAM,mBAAmB,CACpE,IAAI,CAAC,KAAK,CAAG,AAAU,KAAA,IAAV,EAAsB,EAAQ,GAAM,mBAAmB,CAEpE,IAAI,CAAC,SAAS,CAAG,AAAc,KAAA,IAAd,EAA0B,EAAY,GAAM,YAAY,CACzE,IAAI,CAAC,SAAS,CAAG,AAAc,KAAA,IAAd,EAA0B,EAAY,GAAM,wBAAwB,CAErF,IAAI,CAAC,UAAU,CAAG,AAAe,KAAA,IAAf,EAA2B,EAAa,EAE1D,IAAI,CAAC,MAAM,CAAG,AAAW,KAAA,IAAX,EAAuB,EAAS,GAAM,UAAU,CAC9D,IAAI,CAAC,IAAI,CAAG,AAAS,KAAA,IAAT,EAAqB,EAAO,GAAM,gBAAgB,CAE9D,IAAI,CAAC,MAAM,CAAG,IAAI,GAAM,OAAO,CAAE,EAAG,GACpC,IAAI,CAAC,MAAM,CAAG,IAAI,GAAM,OAAO,CAAE,EAAG,GAEpC,IAAI,CAAC,eAAe,CAAG,CAAA,EACvB,IAAI,CAAC,gBAAgB,CAAG,CAAA,EACxB,IAAI,CAAC,KAAK,CAAG,CAAA,EACb,IAAI,CAAC,eAAe,CAAG,EAEvB,IAAI,CAAC,WAAW,CAAG,CAAA,EACnB,IAAI,CAAC,QAAQ,CAAG,IAEjB,EAEA,GAAM,OAAO,CAAC,SAAS,CAAG,CAEzB,YAAa,GAAM,OAAO,CAE1B,MAAO,SAAW,CAAO,EA4BxB,OA1BiB,KAAA,IAAZ,GAAwB,CAAA,EAAU,IAAI,GAAM,OAAO,AAAxD,EAEA,EAAQ,KAAK,CAAG,IAAI,CAAC,KAAK,CAC1B,EAAQ,OAAO,CAAG,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,GAErC,EAAQ,OAAO,CAAG,IAAI,CAAC,OAAO,CAE9B,EAAQ,KAAK,CAAG,IAAI,CAAC,KAAK,CAC1B,EAAQ,KAAK,CAAG,IAAI,CAAC,KAAK,CAE1B,EAAQ,SAAS,CAAG,IAAI,CAAC,SAAS,CAClC,EAAQ,SAAS,CAAG,IAAI,CAAC,SAAS,CAElC,EAAQ,UAAU,CAAG,IAAI,CAAC,UAAU,CAEpC,EAAQ,MAAM,CAAG,IAAI,CAAC,MAAM,CAC5B,EAAQ,IAAI,CAAG,IAAI,CAAC,IAAI,CAExB,EAAQ,MAAM,CAAC,IAAI,CAAE,IAAI,CAAC,MAAM,EAChC,EAAQ,MAAM,CAAC,IAAI,CAAE,IAAI,CAAC,MAAM,EAEhC,EAAQ,eAAe,CAAG,IAAI,CAAC,eAAe,CAC9C,EAAQ,gBAAgB,CAAG,IAAI,CAAC,gBAAgB,CAChD,EAAQ,KAAK,CAAG,IAAI,CAAC,KAAK,CAC1B,EAAQ,eAAe,CAAG,IAAI,CAAC,eAAe,CAEvC,CAER,EAEA,QAAS,WAER,IAAI,CAAC,aAAa,CAAE,CAAE,KAAM,SAAU,EAEvC,CAED,EAEA,GAAM,cAAc,CAAG,EAKvB,GAAM,iBAAiB,CAAG,SAAW,CAAO,CAAE,CAAK,CAAE,CAAM,CAAE,CAAM,CAAE,CAAI,CAAE,CAAO,CAAE,CAAK,CAAE,CAAK,CAAE,CAAS,CAAE,CAAS,CAAE,CAAU,EAEjI,GAAM,OAAO,CAAC,IAAI,CAAE,IAAI,CAAE,KAAM,EAAS,EAAO,EAAO,EAAW,EAAW,EAAQ,EAAM,GAE3F,IAAI,CAAC,KAAK,CAAG,CAAE,MAAO,EAAO,OAAQ,CAAO,EAC5C,IAAI,CAAC,OAAO,CAAG,EAEf,IAAI,CAAC,eAAe,CAAG,CAAA,CAExB,EAEA,GAAM,iBAAiB,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,OAAO,CAAC,SAAS,EAE1E,GAAM,iBAAiB,CAAC,SAAS,CAAC,KAAK,CAAG,WAEzC,IAAI,EAAU,IAAI,GAAM,iBAAiB,CAIzC,OAFA,GAAM,OAAO,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAE,IAAI,CAAE,GAEnC,CAER,EAKA,GAAM,WAAW,CAAG,SAAW,CAAI,CAAE,CAAK,CAAE,CAAM,CAAE,CAAM,CAAE,CAAI,CAAE,CAAO,CAAE,CAAK,CAAE,CAAK,CAAE,CAAS,CAAE,CAAS,CAAE,CAAU,EAExH,GAAM,OAAO,CAAC,IAAI,CAAE,IAAI,CAAE,KAAM,EAAS,EAAO,EAAO,EAAW,EAAW,EAAQ,EAAM,GAE3F,IAAI,CAAC,KAAK,CAAG,CAAE,KAAM,EAAM,MAAO,EAAO,OAAQ,CAAO,CAEzD,EAEA,GAAM,WAAW,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,OAAO,CAAC,SAAS,EAEpE,GAAM,WAAW,CAAC,SAAS,CAAC,KAAK,CAAG,WAEnC,IAAI,EAAU,IAAI,GAAM,WAAW,CAInC,OAFA,GAAM,OAAO,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAE,IAAI,CAAE,GAEnC,CAER,EAKA,GAAM,QAAQ,CAAG,SAAW,CAAQ,EAEnC,GAAM,QAAQ,CAAC,IAAI,CAAE,IAAI,EAEzB,IAAI,CAAC,QAAQ,CAAG,CAEjB,EAEA,GAAM,QAAQ,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,QAAQ,CAAC,SAAS,EAElE,GAAM,QAAQ,CAAC,SAAS,CAAC,KAAK,CAAG,SAAW,CAAM,EAMjD,OAJgB,KAAA,IAAX,GAAuB,CAAA,EAAS,IAAI,GAAM,QAAQ,CAAE,IAAI,CAAC,QAAQ,CAAA,EAEtE,GAAM,QAAQ,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAE,IAAI,CAAE,GAEpC,CAER,EAKA,GAAM,cAAc,CAAG,SAAW,CAAQ,CAAE,CAAQ,EAEnD,GAAM,QAAQ,CAAC,IAAI,CAAE,IAAI,EAEzB,IAAI,CAAC,QAAQ,CAAG,EAChB,IAAI,CAAC,QAAQ,CAAK,AAAa,KAAA,IAAb,EAA2B,EAAW,IAAI,GAAM,qBAAqB,CAAE,CAAE,MAAO,AAAgB,SAAhB,KAAK,MAAM,EAAc,GAE3H,IAAI,CAAC,aAAa,CAAG,CAAA,EAEhB,IAAI,CAAC,QAAQ,EAIb,AAAiC,OAAjC,IAAI,CAAC,QAAQ,CAAC,cAAc,EAE/B,IAAI,CAAC,QAAQ,CAAC,qBAAqB,GAMrC,IAAI,CAAC,aAAa,CAAG,CAAA,CAEtB,EAEA,GAAM,cAAc,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,QAAQ,CAAC,SAAS,EAExE,GAAM,cAAc,CAAC,SAAS,CAAC,KAAK,CAAG,SAAW,CAAM,EAOvD,OALgB,KAAA,IAAX,GAAuB,CAAA,EAAS,IAAI,GAAM,cAAc,CAAE,IAAI,CAAC,QAAQ,CAAE,IAAI,CAAC,QAAQ,CAAA,EAC3F,EAAO,aAAa,CAAG,IAAI,CAAC,aAAa,CAEzC,GAAM,QAAQ,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAE,IAAI,CAAE,GAEpC,CAER,EAKA,GAAM,IAAI,CAAG,SAAW,CAAQ,CAAE,CAAQ,CAAE,CAAI,EAE/C,GAAM,QAAQ,CAAC,IAAI,CAAE,IAAI,EAEzB,IAAI,CAAC,QAAQ,CAAG,EAChB,IAAI,CAAC,QAAQ,CAAK,AAAa,KAAA,IAAb,EAA2B,EAAW,IAAI,GAAM,iBAAiB,CAAE,CAAE,MAAO,AAAgB,SAAhB,KAAK,MAAM,EAAc,GACvH,IAAI,CAAC,IAAI,CAAK,AAAS,KAAA,IAAT,EAAuB,EAAO,GAAM,SAAS,CAEtD,IAAI,CAAC,QAAQ,EAEZ,CAAE,IAAI,CAAC,QAAQ,CAAC,cAAc,EAElC,IAAI,CAAC,QAAQ,CAAC,qBAAqB,EAMtC,EAEA,GAAM,SAAS,CAAG,EAClB,GAAM,UAAU,CAAG,EAEnB,GAAM,IAAI,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,QAAQ,CAAC,SAAS,EAE9D,GAAM,IAAI,CAAC,SAAS,CAAC,KAAK,CAAG,SAAW,CAAM,EAM7C,OAJgB,KAAA,IAAX,GAAuB,CAAA,EAAS,IAAI,GAAM,IAAI,CAAE,IAAI,CAAC,QAAQ,CAAE,IAAI,CAAC,QAAQ,CAAE,IAAI,CAAC,IAAI,CAAA,EAE5F,GAAM,QAAQ,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAE,IAAI,CAAE,GAEpC,CAER,EAQA,GAAM,IAAI,CAAG,SAAW,CAAQ,CAAE,CAAQ,EAEzC,GAAM,QAAQ,CAAC,IAAI,CAAE,IAAI,EAEzB,IAAI,CAAC,QAAQ,CAAG,EAChB,IAAI,CAAC,QAAQ,CAAK,AAAa,KAAA,IAAb,EAA2B,EAAW,IAAI,GAAM,iBAAiB,CAAE,CAAE,MAAO,AAAgB,SAAhB,KAAK,MAAM,GAAe,UAAW,CAAA,CAAK,GAEjH,KAAA,IAAlB,IAAI,CAAC,QAAQ,GAEqB,OAAjC,IAAI,CAAC,QAAQ,CAAC,cAAc,EAEhC,IAAI,CAAC,QAAQ,CAAC,qBAAqB,GAIpC,IAAI,CAAC,kBAAkB,GAIzB,EAEA,GAAM,IAAI,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,QAAQ,CAAC,SAAS,EAE9D,GAAM,IAAI,CAAC,SAAS,CAAC,kBAAkB,CAAG,WAEzC,GAAK,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,MAAM,CAAG,EAAI,CAE5C,IAAI,CAAC,eAAe,CAAG,GACvB,IAAI,CAAC,sBAAsB,CAAG,EAAE,CAChC,IAAI,CAAC,qBAAqB,CAAG,EAAE,CAC/B,IAAI,CAAC,qBAAqB,CAAG,CAAC,EAE9B,IAAM,IAAI,EAAI,EAAG,EAAK,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,MAAM,CAAE,EAAI,EAAI,IAEhE,IAAI,CAAC,qBAAqB,CAAC,IAAI,CAAE,GACjC,IAAI,CAAC,qBAAqB,CAAE,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAE,EAAG,CAAC,IAAI,CAAE,CAAG,CAIvE,CAED,EAEA,GAAM,IAAI,CAAC,SAAS,CAAC,yBAAyB,CAAG,SAAW,CAAI,SAE/D,AAAK,AAAuC,KAAA,IAAvC,IAAI,CAAC,qBAAqB,CAAE,EAAM,CAE/B,IAAI,CAAC,qBAAqB,CAAE,EAAM,EAI1C,QAAQ,GAAG,CAAE,sDAAwD,EAAO,iCAErE,EAER,EAEA,GAAM,IAAI,CAAC,SAAS,CAAC,KAAK,CAAG,SAAW,CAAM,EAM7C,OAJgB,KAAA,IAAX,GAAuB,CAAA,EAAS,IAAI,GAAM,IAAI,CAAE,IAAI,CAAC,QAAQ,CAAE,IAAI,CAAC,QAAQ,CAAA,EAEjF,GAAM,QAAQ,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAE,IAAI,CAAE,GAEpC,CAER,EAMA,GAAM,IAAI,CAAG,SAAU,CAAa,EAEnC,GAAM,QAAQ,CAAC,IAAI,CAAE,IAAI,EAEzB,IAAI,CAAC,IAAI,CAAG,EACZ,IAAI,CAAC,UAAU,CAAG,IAAI,GAAM,OAAO,AAEpC,EAEA,GAAM,IAAI,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,QAAQ,CAAC,SAAS,EAE9D,GAAM,IAAI,CAAC,SAAS,CAAC,MAAM,CAAG,SAAW,CAAgB,CAAE,CAAW,EAIhE,IAAI,CAAC,gBAAgB,EAEzB,CAAA,GAAe,IAAI,CAAC,YAAY,EAFjC,EAQK,CAAA,GAAe,IAAI,CAAC,sBAAsB,AAAtB,IAEpB,EAEH,IAAI,CAAC,UAAU,CAAC,gBAAgB,CAAE,EAAkB,IAAI,CAAC,MAAM,EAI/D,IAAI,CAAC,UAAU,CAAC,IAAI,CAAE,IAAI,CAAC,MAAM,EAIlC,IAAI,CAAC,sBAAsB,CAAG,CAAA,EAC9B,EAAc,CAAA,GAMf,IAAW,EAAG,EAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,CAEtC,IAAM,EAAI,EAAG,EAAI,EAAG,IAEnB,IAAI,CAAC,QAAQ,CAAE,EAAG,CAAC,MAAM,CAAE,IAAI,CAAC,UAAU,CAAE,EAI9C,EAOA,GAAM,WAAW,CAAG,SAAW,CAAQ,CAAE,CAAQ,CAAE,CAAgB,EAiBlE,GAfA,GAAM,IAAI,CAAC,IAAI,CAAE,IAAI,CAAE,EAAU,GAIjC,IAAI,CAAC,gBAAgB,CAAG,AAAqB,KAAA,IAArB,GAAiC,EAIzD,IAAI,CAAC,cAAc,CAAG,IAAI,GAAM,OAAO,CAEvC,IAAI,CAAC,KAAK,CAAG,EAAE,CACf,IAAI,CAAC,YAAY,CAAG,EAAE,CAIjB,IAAI,CAAC,QAAQ,EAAI,AAAwB,KAAA,IAAxB,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAiB,CAEzD,IAAM,EAAI,EAAG,EAAI,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,MAAM,CAAE,IAI5C,EAAI,AAFJ,CAAA,EAAQ,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAE,EAAG,AAAH,EAEnB,GAAG,CACb,EAAI,EAAM,IAAI,CACd,EAAI,EAAM,GAAG,CAIb,AAFA,CAAA,EAAO,IAAI,CAAC,OAAO,EAAnB,EAEK,IAAI,CAAG,EAAM,IAAI,CACtB,EAAK,QAAQ,CAAC,GAAG,CAAE,CAAC,CAAC,EAAE,CAAE,CAAC,CAAC,EAAE,CAAE,CAAC,CAAC,EAAE,EACnC,EAAK,UAAU,CAAC,GAAG,CAAE,CAAC,CAAC,EAAE,CAAE,CAAC,CAAC,EAAE,CAAE,CAAC,CAAC,EAAE,CAAE,CAAC,CAAC,EAAE,EAC3C,EAAK,aAAa,CAAG,CAAA,EAEhB,AAAM,KAAA,IAAN,EAEJ,EAAK,KAAK,CAAC,GAAG,CAAE,CAAC,CAAC,EAAE,CAAE,CAAC,CAAC,EAAE,CAAE,CAAC,CAAC,EAAE,EAIhC,EAAK,KAAK,CAAC,GAAG,CAAE,EAAG,EAAG,GAMxB,IAAM,EAAI,EAAG,EAAI,IAAI,CAAC,KAAK,CAAC,MAAM,CAAE,IAEnC,EAAQ,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAE,EAAG,CAChC,EAAO,IAAI,CAAC,KAAK,CAAE,EAAG,CAEjB,AAAiB,KAAjB,EAAM,MAAM,CAEhB,IAAI,CAAC,GAAG,CAAE,GAIV,IAAI,CAAC,KAAK,CAAE,EAAM,MAAM,CAAE,CAAC,GAAG,CAAE,GAQlC,IAlDG,EAAG,EAAM,EAAO,EAAG,EAAG,EA6DpB,EAXD,EAAS,IAAI,CAAC,KAAK,CAAC,MAAM,AAEzB,CAAA,IAAI,CAAC,gBAAgB,EAYxB,EADI,EAAS,IACN,GACE,EAAS,GACX,GACE,EAAS,GACX,GAEA,EAER,IAAI,CAAC,gBAAgB,CAAG,EACxB,IAAI,CAAC,iBAAiB,CAAG,EAEzB,IAAI,CAAC,YAAY,CAAG,IAAI,aAAc,IAAI,CAAC,gBAAgB,CAAG,IAAI,CAAC,iBAAiB,CAAG,GACvF,IAAI,CAAC,WAAW,CAAG,IAAI,GAAM,WAAW,CAAE,IAAI,CAAC,YAAY,CAAE,IAAI,CAAC,gBAAgB,CAAE,IAAI,CAAC,iBAAiB,CAAE,GAAM,UAAU,CAAE,GAAM,SAAS,EAC7I,IAAI,CAAC,WAAW,CAAC,SAAS,CAAG,GAAM,aAAa,CAChD,IAAI,CAAC,WAAW,CAAC,SAAS,CAAG,GAAM,aAAa,CAChD,IAAI,CAAC,WAAW,CAAC,eAAe,CAAG,CAAA,EACnC,IAAI,CAAC,WAAW,CAAC,KAAK,CAAG,CAAA,GAIzB,IAAI,CAAC,YAAY,CAAG,IAAI,aAAc,GAAK,GAI5C,IAAI,CAAC,IAAI,EAEV,CAED,EAEA,GAAM,WAAW,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,IAAI,CAAC,SAAS,EAEjE,GAAM,WAAW,CAAC,SAAS,CAAC,OAAO,CAAG,SAAU,CAAI,EAUnD,OARc,KAAA,IAAT,GAEJ,CAAA,EAAO,IAAI,GAAM,IAAI,CAAE,IAAI,CAAA,EAI5B,IAAI,CAAC,KAAK,CAAC,IAAI,CAAE,GAEV,CAER,EAEA,GAAM,WAAW,CAAC,SAAS,CAAC,iBAAiB,CAAG,SAAW,CAAK,EAE/D,IAAI,CAAC,gBAAgB,EAAI,IAAI,CAAC,YAAY,GAIrC,CAAA,IAAI,CAAC,sBAAsB,EAAI,CAAA,IAE9B,IAAI,CAAC,MAAM,CAEf,IAAI,CAAC,WAAW,CAAC,gBAAgB,CAAE,IAAI,CAAC,MAAM,CAAC,WAAW,CAAE,IAAI,CAAC,MAAM,EAIvE,IAAI,CAAC,WAAW,CAAC,IAAI,CAAE,IAAI,CAAC,MAAM,EAInC,IAAI,CAAC,sBAAsB,CAAG,CAAA,EAE9B,EAAQ,CAAA,GAMT,IAAM,IAAI,EAAI,EAAG,EAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAE,EAAI,EAAG,IAAO,CAExD,IAAI,EAAQ,IAAI,CAAC,QAAQ,CAAE,EAAG,AAEzB,CAAA,aAAiB,GAAM,IAAI,CAE/B,EAAM,MAAM,CAAE,IAAI,CAAC,cAAc,CAAE,CAAA,GAInC,EAAM,iBAAiB,CAAE,CAAA,EAI3B,CAIA,GAAK,AAAqB,KAAA,GAArB,IAAI,CAAC,YAAY,CAAgB,CAErC,IAAI,CAAC,YAAY,CAAG,EAAE,CAEtB,IAAM,IAAI,EAAI,EAAG,EAAK,IAAI,CAAC,KAAK,CAAC,MAAM,CAAE,EAAI,EAAI,IAAO,CAEvD,IAAI,EAAU,IAAI,GAAM,OAAO,CAE/B,EAAQ,UAAU,CAAE,IAAI,CAAC,KAAK,CAAE,EAAG,CAAC,UAAU,EAE9C,IAAI,CAAC,YAAY,CAAC,IAAI,CAAE,EAEzB,CAED,CAIA,IAAM,IAAI,EAAI,EAAG,EAAK,IAAI,CAAC,KAAK,CAAC,MAAM,CAAE,EAAI,EAAI,IAQhD,GAAM,WAAW,CAAC,YAAY,CAAC,gBAAgB,CAAE,IAAI,CAAC,KAAK,CAAE,EAAG,CAAC,UAAU,CAAE,IAAI,CAAC,YAAY,CAAE,EAAG,EAEnG,GAAM,WAAW,CAAC,YAAY,CAAC,oBAAoB,CAAE,IAAI,CAAC,YAAY,CAAE,AAAI,GAAJ,EAIpE,CAAA,IAAI,CAAC,gBAAgB,EAEzB,CAAA,IAAI,CAAC,WAAW,CAAC,WAAW,CAAG,CAAA,CAFhC,CAMD,EAEA,GAAM,WAAW,CAAC,SAAS,CAAC,IAAI,CAAG,WAElC,IAAI,CAAC,iBAAiB,CAAE,CAAA,GAExB,IAAM,IAAI,EAAI,EAAG,EAAI,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,MAAM,CAAE,IAAO,CAI7D,IAAI,EAAK,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAE,EAAG,CAEnC,EAAQ,EAAM,EAAG,eAAe,EAE/B,CAAA,IAAU,IAEd,EAAG,cAAc,CAAE,GAInB,EAAG,GAAG,CAAE,EAIV,CAED,EAEA,GAAM,WAAW,CAAC,SAAS,CAAC,KAAK,CAAG,SAAW,CAAM,EAMpD,OAJgB,KAAA,IAAX,GAAuB,CAAA,EAAS,IAAI,GAAM,WAAW,CAAE,IAAI,CAAC,QAAQ,CAAE,IAAI,CAAC,QAAQ,CAAE,IAAI,CAAC,gBAAgB,CAAA,EAE/G,GAAM,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAE,IAAI,CAAE,GAEhC,CAER,EAEA,GAAM,WAAW,CAAC,YAAY,CAAG,IAAI,GAAM,OAAO,CAKlD,GAAM,aAAa,CAAG,SAAW,CAAQ,CAAE,CAAQ,EAElD,GAAM,IAAI,CAAC,IAAI,CAAE,IAAI,CAAE,EAAU,GAIjC,IAAI,CAAC,QAAQ,CAAG,IAChB,IAAI,CAAC,YAAY,CAAG,CAAA,EACpB,IAAI,CAAC,IAAI,CAAG,EAIZ,IAAI,CAAC,YAAY,CAAG,EACpB,IAAI,CAAC,eAAe,CAAG,EAEvB,IAAI,CAAC,SAAS,CAAG,EACjB,IAAI,CAAC,kBAAkB,CAAG,CAAA,EAE1B,IAAI,CAAC,aAAa,CAAE,EAAG,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,MAAM,CAAG,EAE5D,EAEA,GAAM,aAAa,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,IAAI,CAAC,SAAS,EAEnE,GAAM,aAAa,CAAC,SAAS,CAAC,aAAa,CAAG,SAAW,CAAK,CAAE,CAAG,EAElE,IAAI,CAAC,aAAa,CAAG,EACrB,IAAI,CAAC,WAAW,CAAG,EAEnB,IAAI,CAAC,MAAM,CAAG,IAAI,CAAC,WAAW,CAAG,IAAI,CAAC,aAAa,CAAG,CAEvD,EAEA,GAAM,aAAa,CAAC,SAAS,CAAC,mBAAmB,CAAG,WAEnD,IAAI,CAAC,SAAS,CAAG,EACjB,IAAI,CAAC,kBAAkB,CAAG,CAAA,CAE3B,EAEA,GAAM,aAAa,CAAC,SAAS,CAAC,oBAAoB,CAAG,WAEpD,IAAI,CAAC,SAAS,CAAG,GACjB,IAAI,CAAC,kBAAkB,CAAG,CAAA,CAE3B,EAEA,GAAM,aAAa,CAAC,SAAS,CAAC,eAAe,CAAG,WAE/C,IAAI,EAAW,IAAI,CAAC,QAAQ,AAErB,CAAA,EAAS,UAAU,EAAG,CAAA,EAAS,UAAU,CAAG,CAAC,CAAA,EAMpD,IAAM,IAJF,EAAgB,EAAa,EAAS,UAAU,CAEhD,EAAU,gBAEJ,EAAI,EAAG,EAAK,EAAS,YAAY,CAAC,MAAM,CAAE,EAAI,EAAI,IAAO,CAGlE,IAAI,EAAQ,AADA,EAAS,YAAY,CAAE,EAAG,CACpB,IAAI,CAAC,KAAK,CAAE,GAE9B,GAAK,GAAS,EAAM,MAAM,CAAG,EAAI,CAEhC,IAAI,EAAQ,CAAK,CAAE,EAAG,AACZ,CAAA,CAAK,CAAE,EAAG,CAEb,CAAU,CAAE,EAAO,EAAG,CAAA,CAAU,CAAE,EAAO,CAAG,CAAE,MAAO,IAAU,IAAK,CAAC,GAAS,CAAA,EAErF,IAAI,EAAY,CAAU,CAAE,EAAO,CAE9B,EAAI,EAAU,KAAK,EAAG,CAAA,EAAU,KAAK,CAAG,CAAA,EACxC,EAAI,EAAU,GAAG,EAAG,CAAA,EAAU,GAAG,CAAG,CAAA,EAElC,GAAiB,CAAA,EAAiB,CAAzC,CAED,CAED,CAEA,EAAS,cAAc,CAAG,CAE3B,EAEA,GAAM,aAAa,CAAC,SAAS,CAAC,iBAAiB,CAAG,SAAW,CAAK,CAAE,CAAK,CAAE,CAAG,EAEtE,IAAI,CAAC,QAAQ,CAAC,UAAU,EAAG,CAAA,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAG,CAAC,CAAA,EAE9D,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAE,EAAO,CAAG,CAAE,MAAO,EAAO,IAAK,CAAI,CAE9D,EAEA,GAAM,aAAa,CAAC,SAAS,CAAC,aAAa,CAAG,SAAW,CAAK,CAAE,CAAG,EAElE,IAAI,EAAY,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAE,EAAO,CAE5C,GAEJ,IAAI,CAAC,aAAa,CAAE,EAAU,KAAK,CAAE,EAAU,GAAG,EAClD,IAAI,CAAC,QAAQ,CAAG,AAAW,CAAA,EAAU,GAAG,CAAG,EAAU,KAAK,AAAL,EAAU,EAA/C,IAChB,IAAI,CAAC,IAAI,CAAG,GAIZ,QAAQ,IAAI,CAAE,aAAe,EAAQ,cAIvC,EAEA,GAAM,aAAa,CAAC,SAAS,CAAC,eAAe,CAAG,SAAW,CAAK,EAE/D,IAAI,EAAY,IAAI,CAAC,QAAQ,CAAG,IAAI,CAAC,MAAM,AAE3C,CAAA,IAAI,CAAC,IAAI,EAAI,IAAI,CAAC,SAAS,CAAG,EAEzB,IAAI,CAAC,YAAY,CAEhB,CAAA,IAAI,CAAC,IAAI,CAAG,IAAI,CAAC,QAAQ,EAAI,IAAI,CAAC,IAAI,CAAG,CAAA,IAE7C,IAAI,CAAC,SAAS,EAAI,GAEb,IAAI,CAAC,IAAI,CAAG,IAAI,CAAC,QAAQ,GAE7B,IAAI,CAAC,IAAI,CAAG,IAAI,CAAC,QAAQ,CACzB,IAAI,CAAC,kBAAkB,CAAG,CAAA,GAItB,IAAI,CAAC,IAAI,CAAG,IAEhB,IAAI,CAAC,IAAI,CAAG,EACZ,IAAI,CAAC,kBAAkB,CAAG,CAAA,KAQ5B,IAAI,CAAC,IAAI,CAAG,IAAI,CAAC,IAAI,CAAG,IAAI,CAAC,QAAQ,CAEhC,IAAI,CAAC,IAAI,CAAG,GAAI,CAAA,IAAI,CAAC,IAAI,EAAI,IAAI,CAAC,QAAQ,AAAR,GAIxC,IAAI,EAAW,IAAI,CAAC,aAAa,CAAG,GAAM,IAAI,CAAC,KAAK,CAAE,KAAK,KAAK,CAAE,IAAI,CAAC,IAAI,CAAG,GAAa,EAAG,IAAI,CAAC,MAAM,CAAG,GAEvG,IAAa,IAAI,CAAC,eAAe,GAErC,IAAI,CAAC,qBAAqB,CAAE,IAAI,CAAC,YAAY,CAAE,CAAG,EAClD,IAAI,CAAC,qBAAqB,CAAE,IAAI,CAAC,eAAe,CAAE,CAAG,EAErD,IAAI,CAAC,qBAAqB,CAAE,EAAU,CAAG,EAEzC,IAAI,CAAC,YAAY,CAAG,IAAI,CAAC,eAAe,CACxC,IAAI,CAAC,eAAe,CAAG,GAIxB,IAAI,EAAM,IAAM,CAAC,IAAI,CAAG,EAAc,CAEjC,CAAA,IAAI,CAAC,kBAAkB,EAE3B,CAAA,EAAM,EAAI,CAFX,EAMA,IAAI,CAAC,qBAAqB,CAAE,IAAI,CAAC,eAAe,CAAE,CAAG,EACrD,IAAI,CAAC,qBAAqB,CAAE,IAAI,CAAC,YAAY,CAAE,CAAG,EAAI,CAEvD,EAEA,GAAM,aAAa,CAAC,SAAS,CAAC,KAAK,CAAG,SAAW,CAAM,EAgBtD,OAdgB,KAAA,IAAX,GAAuB,CAAA,EAAS,IAAI,GAAM,aAAa,CAAE,IAAI,CAAC,QAAQ,CAAE,IAAI,CAAC,QAAQ,CAAA,EAE1F,EAAO,QAAQ,CAAG,IAAI,CAAC,QAAQ,CAC/B,EAAO,YAAY,CAAG,IAAI,CAAC,YAAY,CACvC,EAAO,IAAI,CAAG,IAAI,CAAC,IAAI,CAEvB,EAAO,YAAY,CAAG,IAAI,CAAC,YAAY,CACvC,EAAO,eAAe,CAAG,IAAI,CAAC,eAAe,CAE7C,EAAO,SAAS,CAAG,IAAI,CAAC,SAAS,CACjC,EAAO,kBAAkB,CAAG,IAAI,CAAC,kBAAkB,CAEnD,GAAM,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAE,IAAI,CAAE,GAEhC,CAER,EAKA,GAAM,MAAM,CAAG,SAAW,CAAQ,CAAE,CAAQ,EAE3C,GAAM,QAAQ,CAAC,IAAI,CAAE,IAAI,EAEzB,IAAI,CAAC,QAAQ,CAAG,EAChB,IAAI,CAAC,QAAQ,CAAG,CAEjB,EAEA,GAAM,MAAM,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,QAAQ,CAAC,SAAS,EAEhE,GAAM,MAAM,CAAC,SAAS,CAAC,KAAK,CAAG,SAAW,CAAM,EAM/C,OAJgB,KAAA,IAAX,GAAuB,CAAA,EAAS,IAAI,GAAM,MAAM,CAAE,IAAI,CAAC,QAAQ,CAAE,IAAI,CAAC,QAAQ,CAAA,EAEnF,GAAM,QAAQ,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAE,IAAI,CAAE,GAEpC,CAER,EAOA,GAAM,GAAG,CAAG,WAEX,GAAM,QAAQ,CAAC,IAAI,CAAE,IAAI,EAEzB,IAAI,CAAC,IAAI,CAAG,EAAE,AAEf,EAGA,GAAM,GAAG,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,QAAQ,CAAC,SAAS,EAE7D,GAAM,GAAG,CAAC,SAAS,CAAC,QAAQ,CAAG,SAAW,CAAQ,CAAE,CAAiB,EAEzC,KAAA,IAAtB,GAEJ,CAAA,EAAoB,CAAA,EAIrB,EAAoB,KAAK,GAAG,CAAE,GAE9B,IAAM,IAAI,EAAI,EAEb,AAFgB,EAAI,IAAI,CAAC,IAAI,CAAC,MAAM,GAE/B,CAAA,EAAoB,IAAI,CAAC,IAAI,CAAE,EAAG,CAAC,iBAAiB,AAAjB,EAFF,KAUvC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAE,EAAG,EAAG,CAAE,kBAAmB,EAAmB,SAAU,CAAS,GACnF,IAAI,CAAC,GAAG,CAAE,EAEX,EAEA,GAAM,GAAG,CAAC,SAAS,CAAC,MAAM,CAAG,SAAW,CAAM,EAE7C,GAAK,IAAI,CAAC,IAAI,CAAC,MAAM,CAAG,EAAI,CAE3B,EAAO,kBAAkB,CAAC,UAAU,CAAE,EAAO,WAAW,EAExD,IAAI,EAAW,EAAO,kBAAkB,CACpC,EAAW,CAAG,CAAA,EAAQ,QAAQ,CAAC,EAAE,CAAG,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,GAAG,CAAG,EAAQ,QAAQ,CAAC,EAAE,CAAG,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,GAAG,CAAG,EAAQ,QAAQ,CAAC,GAAG,CAAG,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,GAAG,CAAG,EAAQ,QAAQ,CAAC,GAAE,AAAF,CAEtM,CAAA,IAAI,CAAC,IAAI,CAAE,EAAG,CAAC,QAAQ,CAAC,OAAO,CAAG,CAAA,EAElC,IAAM,IAAI,EAAI,EAEb,AAFgB,EAAI,IAAI,CAAC,IAAI,CAAC,MAAM,EAEhC,GAAY,IAAI,CAAC,IAAI,CAAE,EAAG,CAAC,iBAAiB,CAFV,IAIrC,IAAI,CAAC,IAAI,CAAE,EAAI,EAAG,CAAC,QAAQ,CAAC,OAAO,CAAG,CAAA,EACtC,IAAI,CAAC,IAAI,CAAE,EAAO,CAAC,QAAQ,CAAC,OAAO,CAAG,CAAA,EAUxC,KAAO,EAAI,IAAI,CAAC,IAAI,CAAC,MAAM,CAAE,IAE5B,IAAI,CAAC,IAAI,CAAE,EAAG,CAAC,QAAQ,CAAC,OAAO,CAAG,CAAA,CAIpC,CAED,EAEA,GAAM,GAAG,CAAC,SAAS,CAAC,KAAK,CAAG,WAI5B,EAMA,GAAM,MAAM,CAAG,SAAW,CAAQ,EAEjC,GAAM,QAAQ,CAAC,IAAI,CAAE,IAAI,EAEzB,IAAI,CAAC,QAAQ,CAAK,AAAa,KAAA,IAAb,EAA2B,EAAW,IAAI,GAAM,cAAc,CAEhF,IAAI,CAAC,UAAU,CAAG,IAAI,CAAC,QAAQ,CAC/B,IAAI,CAAC,QAAQ,CAAG,CAEjB,EAEA,GAAM,MAAM,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,QAAQ,CAAC,SAAS,EAMhE,GAAM,MAAM,CAAC,SAAS,CAAC,YAAY,CAAG,WAErC,IAAI,CAAC,MAAM,CAAC,WAAW,CAAE,IAAI,CAAC,QAAQ,EAEtC,IAAI,CAAC,UAAU,CAAC,GAAG,CAAE,EAAG,EAAG,IAAI,CAAC,QAAQ,EACxC,IAAI,CAAC,MAAM,CAAC,oBAAoB,CAAE,IAAI,CAAC,UAAU,EAE5C,CAAA,AAAiB,IAAjB,IAAI,CAAC,KAAK,CAAC,CAAC,EAAU,AAAiB,IAAjB,IAAI,CAAC,KAAK,CAAC,CAAC,AAAK,GAE3C,IAAI,CAAC,MAAM,CAAC,KAAK,CAAE,IAAI,CAAC,KAAK,EAI9B,IAAI,CAAC,sBAAsB,CAAG,CAAA,CAE/B,EAEA,GAAM,MAAM,CAAC,SAAS,CAAC,KAAK,CAAG,SAAW,CAAM,EAM/C,OAJgB,KAAA,IAAX,GAAuB,CAAA,EAAS,IAAI,GAAM,MAAM,CAAE,IAAI,CAAC,QAAQ,CAAA,EAEpE,GAAM,QAAQ,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAE,IAAI,CAAE,GAEpC,CAER,EAMA,GAAM,KAAK,CAAG,WAEb,GAAM,QAAQ,CAAC,IAAI,CAAE,IAAI,EAEzB,IAAI,CAAC,GAAG,CAAG,KACX,IAAI,CAAC,gBAAgB,CAAG,KAExB,IAAI,CAAC,gBAAgB,CAAG,CAAA,EAExB,IAAI,CAAC,SAAS,CAAG,EAAE,CACnB,IAAI,CAAC,QAAQ,CAAG,EAAE,CAElB,IAAI,CAAC,cAAc,CAAG,EAAE,CACxB,IAAI,CAAC,gBAAgB,CAAG,EAAE,AAE3B,EAEA,GAAM,KAAK,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,QAAQ,CAAC,SAAS,EAE/D,GAAM,KAAK,CAAC,SAAS,CAAC,WAAW,CAAG,SAAW,CAAM,EAEpD,GAAK,aAAkB,GAAM,KAAK,CAEQ,KAApC,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAE,IAE3B,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAE,GAIhB,EAAO,MAAM,EAAI,AAAyB,KAAA,IAAzB,EAAO,MAAM,CAAC,MAAM,EAEzC,IAAI,CAAC,GAAG,CAAE,EAAO,MAAM,OAIlB,GAAK,CAAG,CAAA,aAAkB,GAAM,MAAM,EAAI,aAAkB,GAAM,IAAI,AAAJ,GAEnE,AAAqC,KAArC,IAAI,CAAC,SAAS,CAAC,OAAO,CAAE,GAAmB,CAE/C,IAAI,CAAC,SAAS,CAAC,IAAI,CAAE,GACrB,IAAI,CAAC,cAAc,CAAC,IAAI,CAAE,GAI1B,IAAI,EAAI,IAAI,CAAC,gBAAgB,CAAC,OAAO,CAAE,EAE5B,CAAA,KAAN,GAEJ,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAE,EAAG,EAInC,CAID,IAAM,IAAI,EAAI,EAAG,EAAI,EAAO,QAAQ,CAAC,MAAM,CAAE,IAE5C,IAAI,CAAC,WAAW,CAAE,EAAO,QAAQ,CAAE,EAAG,CAIxC,EAEA,GAAM,KAAK,CAAC,SAAS,CAAC,cAAc,CAAG,SAAW,CAAM,EAEvD,GAAK,aAAkB,GAAM,KAAK,CAAG,CAEpC,IAAI,EAAI,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAE,EAEpB,CAAA,KAAN,GAEJ,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAE,EAAG,EAI3B,MAAO,GAAK,CAAG,CAAA,aAAkB,GAAM,MAAK,AAAL,EAAW,CAEjD,IAAI,EAAI,IAAI,CAAC,SAAS,CAAC,OAAO,CAAE,GAEhC,GAAI,AAAM,KAAN,EAAW,CAEd,IAAI,CAAC,SAAS,CAAC,MAAM,CAAE,EAAG,GAC1B,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAE,GAI5B,IAAI,EAAK,IAAI,CAAC,cAAc,CAAC,OAAO,CAAE,EAE1B,CAAA,KAAP,GAEJ,IAAI,CAAC,cAAc,CAAC,MAAM,CAAE,EAAI,EAIlC,CAED,CAEA,IAAM,IAAI,EAAI,EAAG,EAAI,EAAO,QAAQ,CAAC,MAAM,CAAE,IAE5C,IAAI,CAAC,cAAc,CAAE,EAAO,QAAQ,CAAE,EAAG,CAI3C,EAMA,GAAM,GAAG,CAAG,SAAW,CAAG,CAAE,CAAI,CAAE,CAAG,EAEpC,IAAI,CAAC,IAAI,CAAG,GAEZ,IAAI,CAAC,KAAK,CAAG,IAAI,GAAM,KAAK,CAAE,GAE9B,IAAI,CAAC,IAAI,CAAG,AAAW,KAAA,IAAX,EAAyB,EAAO,EAC5C,IAAI,CAAC,GAAG,CAAG,AAAU,KAAA,IAAV,EAAwB,EAAM,GAE1C,EAEA,GAAM,GAAG,CAAC,SAAS,CAAC,KAAK,CAAG,WAE3B,OAAO,IAAI,GAAM,GAAG,CAAE,IAAI,CAAC,KAAK,CAAC,MAAM,GAAI,IAAI,CAAC,IAAI,CAAE,IAAI,CAAC,GAAG,CAE/D,EAMA,GAAM,OAAO,CAAG,SAAW,CAAG,CAAE,CAAO,EAEtC,IAAI,CAAC,IAAI,CAAG,GACZ,IAAI,CAAC,KAAK,CAAG,IAAI,GAAM,KAAK,CAAE,GAC9B,IAAI,CAAC,OAAO,CAAG,AAAc,KAAA,IAAd,EAA4B,EAAU,KAEtD,EAEA,GAAM,OAAO,CAAC,SAAS,CAAC,KAAK,CAAG,WAE/B,OAAO,IAAI,GAAM,OAAO,CAAE,IAAI,CAAC,KAAK,CAAC,MAAM,GAAI,IAAI,CAAC,OAAO,CAE5D,EAKA,GAAM,cAAc,CAAG,SAAW,CAAU,EAE3C,QAAQ,GAAG,CAAE,uBAAwB,GAAM,QAAQ,EAEnD,IAAI,EAAa,GAAM,IAAI,CAAC,UAAU,CAEtC,EAAa,GAAc,CAAC,EAE5B,IACA,EAAa,EAAW,EAOxB,EAAc,EAAe,EAAkB,EAgB/C,EAAK,EAAK,EAAK,EAIf,EAAM,EAAM,EAAM,EAAM,EAAM,EAC9B,EAAM,EAAM,EAAM,EAAM,EAAM,EAe9B,EAAO,EAEP,EAAQ,EACR,EAAO,EAAO,EAAO,EAAO,EAAO,EAanC,EAAW,EAAkB,EAAgB,EAC7C,EAAc,EA7DV,EAAQ,IAAI,CAEhB,EAAa,IAAI,GAAM,SAAS,CAEhC,EAAU,AAAsB,KAAA,IAAtB,EAAW,MAAM,CACvB,EAAW,MAAM,CACjB,SAAS,aAAa,CAAE,UAG5B,EAAW,EAAQ,UAAU,CAAE,MAE/B,EAAc,IAAI,GAAM,KAAK,CAAE,GAC/B,EAAgB,EAEhB,EAAsB,EACtB,EAAmC,EACnC,EAAsB,KACtB,EAAoB,KACpB,EAAoB,KACpB,EAAkB,KAClB,EAAmB,KACnB,GAAmB,KACnB,GAAkB,EAGlB,GAAM,IAAI,GAAM,gBAAgB,CAChC,GAAM,IAAI,GAAM,gBAAgB,CAKhC,GAAS,IAAI,GAAM,KAAK,CACxB,GAAU,IAAI,GAAM,KAAK,CACzB,GAAU,IAAI,GAAM,KAAK,CACzB,GAAU,IAAI,GAAM,KAAK,CACzB,GAAU,IAAI,GAAM,KAAK,CAEzB,GAAgB,IAAI,GAAM,KAAK,CAC/B,GAAiB,IAAI,GAAM,KAAK,CAEhC,GAAc,IAAI,GAAM,KAAK,CAE7B,GAAY,CAAC,EAAG,GAAc,CAAC,EAO/B,GAAW,IAAI,GAAM,IAAI,CACzB,GAAY,IAAI,GAAM,IAAI,CAC1B,GAAW,IAAI,GAAM,IAAI,CAEzB,GAAkB,CAAA,EAClB,GAAgB,IAAI,GAAM,KAAK,CAC/B,GAAqB,IAAI,GAAM,KAAK,CACpC,GAAe,IAAI,GAAM,KAAK,CAE9B,GAAW,IAAI,GAAM,OAAO,CAGO,GAAsB,GA2lCzD,SAAS,GAAY,CAAK,EAEpB,IAAwB,IAE5B,EAAS,WAAW,CAAG,EACvB,EAAsB,EAIxB,CAEA,SAAS,GAAa,CAAK,EAErB,IAAqC,IAEpC,IAAU,GAAM,cAAc,CAElC,EAAS,wBAAwB,CAAG,cAEzB,IAAU,GAAM,gBAAgB,CAE3C,EAAS,wBAAwB,CAAG,UAEzB,IAAU,GAAM,mBAAmB,EAE9C,CAAA,EAAS,wBAAwB,CAAG,QAF9B,EAMP,EAAmC,EAIrC,CAEA,SAAS,GAAc,CAAK,EAEtB,IAAsB,IAE1B,EAAS,SAAS,CAAG,EACrB,EAAoB,EAItB,CAEA,SAAS,GAAY,CAAK,EAIpB,IAAoB,IAExB,EAAS,OAAO,CAAG,EACnB,EAAkB,EAIpB,CAEA,SAAS,GAAa,CAAK,EAIrB,IAAqB,IAEzB,EAAS,QAAQ,CAAG,EACpB,EAAmB,EAIrB,CAEA,SAAS,GAAgB,CAAK,EAExB,IAAwB,IAE5B,EAAS,WAAW,CAAG,EACvB,EAAsB,EAIxB,CAEA,SAAS,GAAc,CAAK,EAEtB,IAAsB,IAE1B,EAAS,SAAS,CAAG,EACrB,EAAoB,EAItB,CAEA,SAAS,GAAe,CAAa,CAAE,CAAY,EAE7C,CAAA,KAAqB,GAAiB,KAAoB,CAAA,IAE9D,EAAS,WAAW,CAAE,CAAE,EAAe,EAAc,EACrD,GAAmB,EACnB,GAAkB,EAIpB,CAhsCA,AADA,CAAA,EAAY,SAAS,aAAa,CAAE,SAApC,EACU,KAAK,CAAG,EAAU,MAAM,CAAG,EAGrC,AADA,CAAA,EAAmB,EAAU,UAAU,CAAE,KAAzC,EACiB,SAAS,CAAG,gBAC7B,EAAiB,QAAQ,CAAE,EAAG,EAAG,EAAG,GAGpC,EAAgB,AADhB,CAAA,EAAiB,EAAiB,YAAY,CAAE,EAAG,EAAG,EAAG,EAAzD,EAC+B,IAAI,CAGnC,AADA,CAAA,EAAe,SAAS,aAAa,CAAE,SAAvC,EACa,KAAK,CAAG,EAAa,MAAM,CAAG,GAG3C,AADA,CAAA,EAAsB,EAAa,UAAU,CAAE,KAA/C,EACoB,SAAS,CAAE,CAAE,GAAsB,EAAG,CAAE,GAAsB,GAClF,EAAoB,KAAK,CAAE,GAAqB,IAEhD,KAI8B,KAAA,IAAzB,EAAS,WAAW,GAEnB,AAAqB,KAAA,IAArB,EAAS,OAAO,CAEpB,EAAS,WAAW,CAAG,SAAW,CAAM,EAEvC,EAAS,OAAO,CAAG,AAAgB,OAAhB,CAAM,CAAE,EAAG,CAAY,EAAS,IAEpD,EAIA,EAAS,WAAW,CAAG,WAAa,GAMtC,IAAI,CAAC,UAAU,CAAG,EAElB,IAAI,CAAC,gBAAgB,CAAG,AAAgC,KAAA,IAAhC,EAAW,gBAAgB,CAC9C,EAAW,gBAAgB,CAC3B,AAA4B,KAAA,IAA5B,OAAO,gBAAgB,CACtB,OAAO,gBAAgB,CACvB,EAEN,IAAI,CAAC,SAAS,CAAG,CAAA,EACjB,IAAI,CAAC,WAAW,CAAG,CAAA,EACnB,IAAI,CAAC,YAAY,CAAG,CAAA,EAEpB,IAAI,CAAC,IAAI,CAAG,CAEX,OAAQ,CAEP,SAAU,EACV,MAAO,CAER,CAED,EAIA,IAAI,CAAC,sBAAsB,CAAG,WAAa,EAC3C,IAAI,CAAC,cAAc,CAAG,WAAa,EAEnC,IAAI,CAAC,OAAO,CAAG,SAAW,CAAK,CAAE,CAAM,EAEtC,EAAe,EAAQ,IAAI,CAAC,gBAAgB,CAC5C,EAAgB,EAAS,IAAI,CAAC,gBAAgB,CAE9C,EAAmB,KAAK,KAAK,CAAE,EAAe,GAC9C,EAAoB,KAAK,KAAK,CAAE,EAAgB,GAEhD,EAAQ,KAAK,CAAG,EAChB,EAAQ,MAAM,CAAG,EAEjB,EAAQ,KAAK,CAAC,KAAK,CAAG,EAAQ,KAC9B,EAAQ,KAAK,CAAC,MAAM,CAAG,EAAS,KAEhC,GAAS,GAAG,CACX,IAAI,GAAM,OAAO,CAAE,CAAE,EAAkB,CAAE,GACzC,IAAI,GAAM,OAAO,CAAE,EAAkB,IAGtC,GAAU,GAAG,CACZ,IAAI,GAAM,OAAO,CAAE,CAAE,EAAkB,CAAE,GACzC,IAAI,GAAM,OAAO,CAAE,EAAkB,IAGtC,EAAsB,EACtB,EAAmC,EACnC,EAAsB,KACtB,EAAoB,KACpB,EAAoB,KACpB,EAAkB,KAClB,EAAmB,IAEpB,EAEA,IAAI,CAAC,aAAa,CAAG,SAAW,CAAK,CAAE,CAAO,EAE7C,EAAY,IAAI,CAAE,GAClB,EAAgB,AAAY,KAAA,IAAZ,EAAwB,EAAU,EAElD,GAAU,GAAG,CACZ,IAAI,GAAM,OAAO,CAAE,CAAE,EAAkB,CAAE,GACzC,IAAI,GAAM,OAAO,CAAE,EAAkB,GAGvC,EAEA,IAAI,CAAC,gBAAgB,CAAG,SAAW,CAAG,CAAE,CAAO,EAE9C,EAAY,MAAM,CAAE,GACpB,EAAgB,AAAY,KAAA,IAAZ,EAAwB,EAAU,EAElD,GAAU,GAAG,CACZ,IAAI,GAAM,OAAO,CAAE,CAAE,EAAkB,CAAE,GACzC,IAAI,GAAM,OAAO,CAAE,EAAkB,GAGvC,EAEA,IAAI,CAAC,gBAAgB,CAAI,WAExB,OAAO,CAER,EAEA,IAAI,CAAC,KAAK,CAAG,WAEZ,EAAS,YAAY,CAAE,EAAG,EAAG,EAAG,GAAK,EAAkB,GAE5B,CAAA,IAAtB,GAAU,KAAK,KAEnB,GAAU,SAAS,CAAE,IACrB,GAAU,cAAc,CAAE,GAErB,EAAgB,GAEpB,EAAS,SAAS,CACjB,AAAkB,EAAlB,GAAU,GAAG,CAAC,CAAC,CACf,AAAkB,EAAlB,GAAU,GAAG,CAAC,CAAC,CACb,GAAU,GAAG,CAAC,CAAC,CAAG,GAAU,GAAG,CAAC,CAAC,CAAK,EACxC,GAAY,GAAG,CAAC,CAAC,CAAG,GAAU,GAAG,CAAC,CAAC,CAAK,GAKrC,EAAgB,IAEpB,GAAa,GAAM,cAAc,EACjC,GAAY,GAEZ,GAAc,QAAU,KAAK,KAAK,CAAE,AAAgB,IAAhB,EAAY,CAAC,EAAW,IAAM,KAAK,KAAK,CAAE,AAAgB,IAAhB,EAAY,CAAC,EAAW,IAAM,KAAK,KAAK,CAAE,AAAgB,IAAhB,EAAY,CAAC,EAAW,IAAM,EAAgB,KAEtK,EAAS,QAAQ,CAChB,AAAkB,EAAlB,GAAU,GAAG,CAAC,CAAC,CACf,AAAkB,EAAlB,GAAU,GAAG,CAAC,CAAC,CACb,GAAU,GAAG,CAAC,CAAC,CAAG,GAAU,GAAG,CAAC,CAAC,CAAK,EACxC,GAAY,GAAG,CAAC,CAAC,CAAG,GAAU,GAAG,CAAC,CAAC,CAAK,IAK1C,GAAU,SAAS,GAKrB,EAEA,IAAI,CAAC,MAAM,CAAG,SAAW,CAAK,CAAE,CAAM,EAErC,GAAK,aAAkB,GAAM,MAAM,EAAK,CAAA,EAAQ,CAE/C,QAAQ,KAAK,CAAE,2EACf,MAED,CAEwB,CAAA,IAAnB,IAAI,CAAC,SAAS,EAElB,IAAI,CAAC,KAAK,GAIX,EAAS,YAAY,CAAE,EAAG,EAAG,EAAG,GAAK,EAAkB,GAEvD,EAAM,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAG,EAC7B,EAAM,IAAI,CAAC,MAAM,CAAC,KAAK,CAAG,EAG1B,EAAY,AADZ,CAAA,EAAc,EAAW,YAAY,CAAE,EAAO,EAAQ,IAAI,CAAC,WAAW,CAAE,IAAI,CAAC,YAAY,CAAA,EACjE,QAAQ,CAUP,CAAA,GAFzB,CAAA,GAAkB,AAPlB,CAAA,EAAU,EAAY,MAAM,AAAN,EAOI,MAAM,CAAG,CAAA,GAIjC,AAkHF,WAEC,GAAc,MAAM,CAAE,EAAG,EAAG,GAC5B,GAAmB,MAAM,CAAE,EAAG,EAAG,GACjC,GAAa,MAAM,CAAE,EAAG,EAAG,GAE3B,IAAM,IAAI,EAAI,EAAG,EAAK,EAAQ,MAAM,CAAE,EAAI,EAAI,IAAO,CAEpD,IAAI,EAAQ,CAAO,CAAE,EAAG,CACpB,EAAa,EAAM,KAAK,AAEvB,CAAA,aAAiB,GAAM,YAAY,CAEvC,GAAc,GAAG,CAAE,GAER,aAAiB,GAAM,gBAAgB,CAIlD,GAAmB,GAAG,CAAE,GAEb,aAAiB,GAAM,UAAU,EAI5C,GAAa,GAAG,CAAE,EAIpB,CAED,IA7IA,IAAM,IAAI,EAAI,EAAG,EAAK,EAAU,MAAM,CAAE,EAAI,EAAI,IAAM,CAErD,IAuSoB,EAAI,EAvSpB,EAAU,CAAS,CAAE,EAAG,CAExB,EAAW,EAAQ,QAAQ,CAE/B,GAAK,AAAa,KAAA,IAAb,GAA0B,AAAqB,CAAA,IAArB,EAAS,OAAO,EAI/C,GAFA,GAAS,SAAS,GAEb,aAAmB,GAAM,kBAAkB,CAE/C,EAAM,EACN,EAAI,CAAC,EAAI,EAAkB,EAAI,CAAC,EAAI,EAEpC,AA0KF,SAAyB,CAAE,CAAE,CAAO,CAAE,CAAQ,MAKzC,EAAO,EAAQ,EAAQ,EAC3B,EAAQ,EAAa,EAErB,GANA,GAAY,EAAS,OAAO,EAC5B,GAAa,EAAS,QAAQ,EAKzB,aAAoB,GAAM,qBAAqB,EAEnD,GAAK,AAAiB,OAAjB,EAAS,GAAG,CAAY,CAa5B,GAXA,EAAS,EAAQ,MAAM,CAAC,KAAK,CAAC,CAAC,CAC/B,EAAS,EAAQ,MAAM,CAAC,KAAK,CAAC,CAAC,CAI/B,GAAU,EAAQ,KAAK,CAAC,CAAC,CAAG,EAC5B,GAAU,EAAQ,KAAK,CAAC,CAAC,CAAG,EAE5B,GAAS,GAAG,CAAC,GAAG,CAAE,EAAG,CAAC,CAAG,EAAQ,EAAG,CAAC,CAAG,GACxC,GAAS,GAAG,CAAC,GAAG,CAAE,EAAG,CAAC,CAAG,EAAQ,EAAG,CAAC,CAAG,GAEnC,AAA2C,CAAA,IAA3C,GAAS,iBAAiB,CAAE,IAEhC,OAID,GAAc,EAAS,KAAK,CAAC,QAAQ,IAErC,EAAS,IAAI,GACb,EAAS,SAAS,CAAE,EAAG,CAAC,CAAE,EAAG,CAAC,EAC9B,EAAS,MAAM,CAAE,CAAE,EAAQ,QAAQ,EACnC,EAAS,KAAK,CAAE,EAAQ,GACxB,EAAS,QAAQ,CAAE,GAAI,GAAI,EAAG,GAC9B,EAAS,OAAO,EAEjB,KAAO,CAiBN,GAdA,EAAc,AADd,CAAA,EAAS,EAAS,GAAG,CAAC,KAAK,AAAL,EACD,KAAK,EAAI,EAC9B,EAAe,EAAO,MAAM,EAAI,EAEhC,EAAS,EAAQ,KAAK,CAAC,CAAC,CAAG,EAC3B,EAAS,EAAQ,KAAK,CAAC,CAAC,CAAG,EAE3B,EAAQ,EAAS,EACjB,EAAS,EAAS,EAIlB,GAAS,GAAG,CAAC,GAAG,CAAE,EAAG,CAAC,CAAG,EAAO,EAAG,CAAC,CAAG,GACvC,GAAS,GAAG,CAAC,GAAG,CAAE,EAAG,CAAC,CAAG,EAAO,EAAG,CAAC,CAAG,GAElC,AAA2C,CAAA,IAA3C,GAAS,iBAAiB,CAAE,IAEhC,OAID,EAAS,IAAI,GACb,EAAS,SAAS,CAAE,EAAG,CAAC,CAAE,EAAG,CAAC,EAC9B,EAAS,MAAM,CAAE,CAAE,EAAQ,QAAQ,EACnC,EAAS,KAAK,CAAE,EAAQ,CAAE,GAE1B,EAAS,SAAS,CAAE,CAAE,EAAa,CAAE,GACrC,EAAS,SAAS,CAAE,EAAQ,EAAG,GAC/B,EAAS,OAAO,EAEjB,OAYM,GAAK,aAAoB,GAAM,sBAAsB,CAAG,CAQ9D,GANA,EAAQ,EAAQ,KAAK,CAAC,CAAC,CAAG,EAC1B,EAAS,EAAQ,KAAK,CAAC,CAAC,CAAG,EAE3B,GAAS,GAAG,CAAC,GAAG,CAAE,EAAG,CAAC,CAAG,EAAO,EAAG,CAAC,CAAG,GACvC,GAAS,GAAG,CAAC,GAAG,CAAE,EAAG,CAAC,CAAG,EAAO,EAAG,CAAC,CAAG,GAElC,AAA2C,CAAA,IAA3C,GAAS,iBAAiB,CAAE,IAEhC,OAID,GAAgB,EAAS,KAAK,CAAC,QAAQ,IACvC,GAAc,EAAS,KAAK,CAAC,QAAQ,IAErC,EAAS,IAAI,GACb,EAAS,SAAS,CAAE,EAAG,CAAC,CAAE,EAAG,CAAC,EAC9B,EAAS,MAAM,CAAE,CAAE,EAAQ,QAAQ,EACnC,EAAS,KAAK,CAAE,EAAO,GAEvB,EAAS,OAAO,CAAE,GAElB,EAAS,OAAO,EAEjB,CAED,EAxRkB,EAAK,EAAS,QAExB,GAAK,aAAmB,GAAM,cAAc,CAElD,EAAM,EAAQ,EAAE,CAAE,EAAM,EAAQ,EAAE,CAElC,EAAI,cAAc,CAAC,CAAC,EAAI,EAAkB,EAAI,cAAc,CAAC,CAAC,EAAI,EAClE,EAAI,cAAc,CAAC,CAAC,EAAI,EAAkB,EAAI,cAAc,CAAC,CAAC,EAAI,EAElE,GAAS,aAAa,CAAE,CAAE,EAAI,cAAc,CAAE,EAAI,cAAc,CAAE,EAElB,CAAA,IAA3C,GAAS,iBAAiB,CAAE,MA+Qd,EA7QN,EA6QU,EA7QL,EA+QnB,GAAY,AA/QqB,EA+QZ,OAAO,EAC5B,GAAa,AAhRoB,EAgRX,QAAQ,EAE9B,EAAS,SAAS,GAClB,EAAS,MAAM,CAAE,EAAG,cAAc,CAAC,CAAC,CAAE,EAAG,cAAc,CAAC,CAAC,EACzD,EAAS,MAAM,CAAE,EAAG,cAAc,CAAC,CAAC,CAAE,EAAG,cAAc,CAAC,CAAC,EAEpD,AAtR4B,aAsRR,GAAM,iBAAiB,EAE/C,GAAc,AAxRkB,EAwRT,SAAS,EAChC,GAAY,AAzRoB,EAyRX,OAAO,EAC5B,GAAa,AA1RmB,EA0RV,QAAQ,EAC9B,GAAgB,AA3RgB,EA2RP,KAAK,CAAC,QAAQ,IACvC,GAAe,KAAM,MAErB,EAAS,MAAM,GACf,GAAS,cAAc,CAAE,AAAqB,EAArB,AA/RO,EA+RE,SAAS,GA/RX,aAiSD,GAAM,kBAAkB,GAEvD,GAAc,AAnSkB,EAmST,SAAS,EAChC,GAAY,AApSoB,EAoSX,OAAO,EAC5B,GAAa,AArSmB,EAqSV,QAAQ,EAC9B,GAAgB,AAtSgB,EAsSP,KAAK,CAAC,QAAQ,IACvC,GAAe,AAvSiB,EAuSR,QAAQ,CAAE,AAvSF,EAuSW,OAAO,EAElD,EAAS,MAAM,GACf,GAAS,cAAc,CAAE,AAAqB,EAArB,AA1SO,EA0SE,SAAS,SAtSrC,GAAK,aAAmB,GAAM,eAAe,CAAG,CAItD,GAFA,EAAM,EAAQ,EAAE,CAAE,EAAM,EAAQ,EAAE,CAAE,EAAM,EAAQ,EAAE,CAE/C,EAAI,cAAc,CAAC,CAAC,CAAG,IAAM,EAAI,cAAc,CAAC,CAAC,CAAG,GACpD,EAAI,cAAc,CAAC,CAAC,CAAG,IAAM,EAAI,cAAc,CAAC,CAAC,CAAG,GACpD,EAAI,cAAc,CAAC,CAAC,CAAG,IAAM,EAAI,cAAc,CAAC,CAAC,CAAG,EAFI,QAI7D,CAAA,EAAI,cAAc,CAAC,CAAC,EAAI,EAAkB,EAAI,cAAc,CAAC,CAAC,EAAI,EAClE,EAAI,cAAc,CAAC,CAAC,EAAI,EAAkB,EAAI,cAAc,CAAC,CAAC,EAAI,EAClE,EAAI,cAAc,CAAC,CAAC,EAAI,EAAkB,EAAI,cAAc,CAAC,CAAC,EAAI,EAEvC,CAAA,IAAtB,EAAS,QAAQ,GAErB,GAAQ,EAAI,cAAc,CAAE,EAAI,cAAc,EAC9C,GAAQ,EAAI,cAAc,CAAE,EAAI,cAAc,EAC9C,GAAQ,EAAI,cAAc,CAAE,EAAI,cAAc,GAI/C,GAAS,aAAa,CAAE,CAAE,EAAI,cAAc,CAAE,EAAI,cAAc,CAAE,EAAI,cAAc,CAAE,EAEtF,EAAa,EAAK,EAAK,EAAK,EAAG,EAAG,EAAG,EAAS,EAE/C,MAAO,GAAK,aAAmB,GAAM,eAAe,CAAG,CAItD,GAFA,EAAM,EAAQ,EAAE,CAAE,EAAM,EAAQ,EAAE,CAAE,EAAM,EAAQ,EAAE,CAAE,EAAM,EAAQ,EAAE,CAEjE,EAAI,cAAc,CAAC,CAAC,CAAG,IAAM,EAAI,cAAc,CAAC,CAAC,CAAG,GACpD,EAAI,cAAc,CAAC,CAAC,CAAG,IAAM,EAAI,cAAc,CAAC,CAAC,CAAG,GACpD,EAAI,cAAc,CAAC,CAAC,CAAG,IAAM,EAAI,cAAc,CAAC,CAAC,CAAG,GACpD,EAAI,cAAc,CAAC,CAAC,CAAG,IAAM,EAAI,cAAc,CAAC,CAAC,CAAG,EAHI,QAK7D,CAAA,EAAI,cAAc,CAAC,CAAC,EAAI,EAAkB,EAAI,cAAc,CAAC,CAAC,EAAI,EAClE,EAAI,cAAc,CAAC,CAAC,EAAI,EAAkB,EAAI,cAAc,CAAC,CAAC,EAAI,EAClE,EAAI,cAAc,CAAC,CAAC,EAAI,EAAkB,EAAI,cAAc,CAAC,CAAC,EAAI,EAClE,EAAI,cAAc,CAAC,CAAC,EAAI,EAAkB,EAAI,cAAc,CAAC,CAAC,EAAI,EAElE,GAAI,cAAc,CAAC,IAAI,CAAE,EAAI,cAAc,EAC3C,GAAI,cAAc,CAAC,IAAI,CAAE,EAAI,cAAc,EAEhB,CAAA,IAAtB,EAAS,QAAQ,GAErB,GAAQ,EAAI,cAAc,CAAE,EAAI,cAAc,EAC9C,GAAQ,EAAI,cAAc,CAAE,EAAI,cAAc,EAC9C,GAAQ,EAAI,cAAc,CAAE,EAAI,cAAc,EAE9C,GAAQ,EAAI,cAAc,CAAE,GAAI,cAAc,EAC9C,GAAQ,EAAI,cAAc,CAAE,GAAI,cAAc,GAI/C,GAAS,aAAa,CAAE,CAAE,EAAI,cAAc,CAAE,EAAI,cAAc,CAAE,EAAI,cAAc,CAAE,EAAI,cAAc,CAAE,EAE1G,AAkaF,SAAsB,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAO,CAAE,CAAQ,EAQ9D,GANA,EAAM,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAI,EAC9B,EAAM,IAAI,CAAC,MAAM,CAAC,KAAK,GAEvB,GAAY,EAAS,OAAO,EAC5B,GAAa,EAAS,QAAQ,EAEvB,AAAiB,KAAA,IAAjB,EAAS,GAAG,EAAkB,AAAiB,OAAjB,EAAS,GAAG,EAAiB,AAAoB,KAAA,IAApB,EAAS,MAAM,EAAkB,AAAoB,OAApB,EAAS,MAAM,CAAc,CAI/H,EAAa,EAAI,EAAI,EAAI,EAAG,EAAG,EAAG,EAAS,GAC3C,EAAa,EAAI,EAAI,EAAI,EAAG,EAAG,EAAG,EAAS,GAE3C,MAED,CASA,GAPA,EAAO,EAAG,cAAc,CAAC,CAAC,CAAE,EAAO,EAAG,cAAc,CAAC,CAAC,CACtD,EAAO,EAAG,cAAc,CAAC,CAAC,CAAE,EAAO,EAAG,cAAc,CAAC,CAAC,CACtD,EAAO,EAAG,cAAc,CAAC,CAAC,CAAE,EAAO,EAAG,cAAc,CAAC,CAAC,CACtD,EAAO,EAAG,cAAc,CAAC,CAAC,CAAE,EAAO,EAAG,cAAc,CAAC,CAAC,CACtD,EAAO,EAAG,cAAc,CAAC,CAAC,CAAE,EAAO,EAAG,cAAc,CAAC,CAAC,CACtD,EAAO,EAAG,cAAc,CAAC,CAAC,CAAE,EAAO,EAAG,cAAc,CAAC,CAAC,CAEjD,aAAoB,GAAM,mBAAmB,EAAI,aAAoB,GAAM,iBAAiB,CAEhG,GAAc,IAAI,CAAE,EAAS,KAAK,EAClC,GAAe,IAAI,CAAE,EAAS,QAAQ,EAEjC,EAAS,YAAY,GAAK,GAAM,UAAU,EAE9C,GAAc,QAAQ,CAAE,EAAQ,KAAK,EAIjC,AAAoB,CAAA,IAApB,GAEC,AAAuB,CAAA,IAAvB,EAAS,SAAS,EAAc,EAAS,OAAO,EAAI,GAAM,aAAa,EAAI,AAA+B,GAA/B,EAAQ,mBAAmB,EAE1G,GAAQ,IAAI,CAAE,IACd,GAAQ,IAAI,CAAE,IACd,GAAQ,IAAI,CAAE,IACd,GAAQ,IAAI,CAAE,IAEd,EAAgB,EAAQ,EAAE,CAAC,aAAa,CAAE,EAAQ,kBAAkB,CAAE,EAAG,CAAE,IAC3E,EAAgB,EAAQ,EAAE,CAAC,aAAa,CAAE,EAAQ,kBAAkB,CAAE,EAAG,CAAE,IAC3E,EAAgB,EAAQ,EAAE,CAAC,aAAa,CAAE,EAAQ,kBAAkB,CAAE,EAAG,CAAE,IAC3E,EAAgB,EAAQ,EAAE,CAAC,aAAa,CAAE,EAAQ,kBAAkB,CAAE,EAAG,CAAE,IAE3E,GAAQ,QAAQ,CAAE,IAAgB,GAAG,CAAE,IACvC,GAAQ,QAAQ,CAAE,IAAgB,GAAG,CAAE,IACvC,GAAQ,QAAQ,CAAE,IAAgB,GAAG,CAAE,IACvC,GAAQ,QAAQ,CAAE,IAAgB,GAAG,CAAE,IAEvC,EAAS,GAAoB,GAAS,GAAS,GAAS,IAIxD,EAAc,EAAM,EAAM,EAAM,EAAM,EAAM,GAC5C,GAAW,EAAM,EAAM,EAAM,EAAM,EAAM,EAAM,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAEjE,EAAc,EAAM,EAAM,EAAM,EAAM,EAAM,GAC5C,GAAW,EAAM,EAAM,EAAM,EAAM,EAAM,EAAM,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,KAIjE,GAAO,IAAI,CAAE,IAEb,EAAgB,EAAQ,aAAa,CAAE,EAAQ,WAAW,CAAE,IAE5D,GAAO,QAAQ,CAAE,IAAgB,GAAG,CAAE,IAEtC,EAAU,EAAM,EAAM,EAAM,EAAM,EAAM,EAAM,EAAM,GAEpD,AAAuB,CAAA,IAAvB,EAAS,SAAS,CACf,EAAY,GAAQ,EAAS,kBAAkB,CAAE,EAAS,gBAAgB,CAAE,EAAS,iBAAiB,EACtG,GAAU,MAMd,GAAO,SAAS,CAAE,GAAe,IAEjC,EAAU,EAAM,EAAM,EAAM,EAAM,EAAM,EAAM,EAAM,GAEpD,AAAuB,CAAA,IAAvB,EAAS,SAAS,CACf,EAAY,GAAQ,EAAS,kBAAkB,CAAE,EAAS,gBAAgB,CAAE,EAAS,iBAAiB,EACtG,GAAU,UAIR,GAAK,aAAoB,GAAM,iBAAiB,CAEtD,GAAO,IAAI,CAAE,EAAS,KAAK,EAEtB,EAAS,YAAY,GAAK,GAAM,UAAU,EAE9C,GAAO,QAAQ,CAAE,EAAQ,KAAK,EAI/B,EAAU,EAAM,EAAM,EAAM,EAAM,EAAM,EAAM,EAAM,GAEpD,AAAuB,CAAA,IAAvB,EAAS,SAAS,CACf,EAAY,GAAQ,EAAS,kBAAkB,CAAE,EAAS,gBAAgB,CAAE,EAAS,iBAAiB,EACtG,GAAU,SAEP,GAAK,aAAoB,GAAM,kBAAkB,CAAG,CAE1D,IAAI,CAEC,CAAA,EAAS,OAAO,EAAI,GAAM,WAAW,EAEzC,EAAS,EAAQ,eAAe,CAChC,GAAO,MAAM,CAAE,EAAO,CAAC,CAAE,EAAO,CAAC,CAAE,EAAO,CAAC,EAAG,cAAc,CAAE,IAAM,SAAS,CAAE,IAE/E,EAAU,EAAM,EAAM,EAAM,EAAM,EAAM,EAAM,EAAM,GAEpD,AAAuB,CAAA,IAAvB,EAAS,SAAS,CACf,EAAY,GAAQ,EAAS,kBAAkB,CAAE,EAAS,gBAAgB,CAAE,EAAS,iBAAiB,EACtG,GAAU,KAEF,EAAS,OAAO,EAAI,GAAM,aAAa,GAElD,EAAS,EAAQ,sBAAsB,CAAE,EAAG,CAC5C,GAAQ,MAAM,CAAE,EAAO,CAAC,CAAE,EAAO,CAAC,CAAE,EAAO,CAAC,EAAG,cAAc,CAAE,IAAM,SAAS,CAAE,IAEhF,EAAS,EAAQ,sBAAsB,CAAE,EAAG,CAC5C,GAAQ,MAAM,CAAE,EAAO,CAAC,CAAE,EAAO,CAAC,CAAE,EAAO,CAAC,EAAG,cAAc,CAAE,IAAM,SAAS,CAAE,IAEhF,EAAS,EAAQ,sBAAsB,CAAE,EAAG,CAC5C,GAAQ,MAAM,CAAE,EAAO,CAAC,CAAE,EAAO,CAAC,CAAE,EAAO,CAAC,EAAG,cAAc,CAAE,IAAM,SAAS,CAAE,IAEhF,EAAS,EAAQ,sBAAsB,CAAE,EAAG,CAC5C,GAAQ,MAAM,CAAE,EAAO,CAAC,CAAE,EAAO,CAAC,CAAE,EAAO,CAAC,EAAG,cAAc,CAAE,IAAM,SAAS,CAAE,IAEhF,EAAS,GAAoB,GAAS,GAAS,GAAS,IAExD,EAAc,EAAM,EAAM,EAAM,EAAM,EAAM,GAC5C,GAAW,EAAM,EAAM,EAAM,EAAM,EAAM,EAAM,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAEjE,EAAc,EAAM,EAAM,EAAM,EAAM,EAAM,GAC5C,GAAW,EAAM,EAAM,EAAM,EAAM,EAAM,EAAM,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAMnE,MAAY,aAAoB,GAAM,iBAAiB,GAEtD,EAAQ,EAAO,IAAI,CACnB,EAAO,EAAO,GAAG,CAEjB,GAAQ,CAAC,CAAG,GAAQ,CAAC,CAAG,GAAQ,CAAC,CAAG,EAAI,EAAY,EAAG,cAAc,CAAC,CAAC,CAAG,EAAG,cAAc,CAAC,CAAC,CAAE,EAAO,GACtG,GAAQ,CAAC,CAAG,GAAQ,CAAC,CAAG,GAAQ,CAAC,CAAG,EAAI,EAAY,EAAG,cAAc,CAAC,CAAC,CAAG,EAAG,cAAc,CAAC,CAAC,CAAE,EAAO,GACtG,GAAQ,CAAC,CAAG,GAAQ,CAAC,CAAG,GAAQ,CAAC,CAAG,EAAI,EAAY,EAAG,cAAc,CAAC,CAAC,CAAG,EAAG,cAAc,CAAC,CAAC,CAAE,EAAO,GACtG,GAAQ,CAAC,CAAG,GAAQ,CAAC,CAAG,GAAQ,CAAC,CAAG,EAAI,EAAY,EAAG,cAAc,CAAC,CAAC,CAAG,EAAG,cAAc,CAAC,CAAC,CAAE,EAAO,GAEtG,EAAS,GAAoB,GAAS,GAAS,GAAS,IAIxD,EAAc,EAAM,EAAM,EAAM,EAAM,EAAM,GAC5C,GAAW,EAAM,EAAM,EAAM,EAAM,EAAM,EAAM,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAEjE,EAAc,EAAM,EAAM,EAAM,EAAM,EAAM,GAC5C,GAAW,EAAM,EAAM,EAAM,EAAM,EAAM,EAAM,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAInE,EA/kBe,EAAK,EAAK,EAAK,EAAK,GAAK,GAAK,EAAS,EAAU,EAE/D,CAQA,GAAU,KAAK,CAAE,IAElB,CA6CA,SAAS,EAAgB,CAAQ,CAAE,CAAM,CAAE,CAAK,EAE/C,IAAM,IAAI,EAAI,EAAG,EAAK,EAAQ,MAAM,CAAE,EAAI,EAAI,IAAO,CAEpD,IAAI,EAAQ,CAAO,CAAE,EAAG,CAIxB,GAFA,GAAY,IAAI,CAAE,EAAM,KAAK,EAExB,aAAiB,GAAM,gBAAgB,CAAG,CAE9C,IAAI,EAAgB,GAAS,qBAAqB,CAAE,EAAM,WAAW,EAAG,SAAS,GAE7E,EAAS,EAAO,GAAG,CAAE,GAEzB,GAAK,GAAU,EAAI,SAEnB,GAAU,EAAM,SAAS,CAEzB,EAAM,GAAG,CAAE,GAAY,cAAc,CAAE,GAExC,MAAO,GAAK,aAAiB,GAAM,UAAU,CAAG,CAE/C,IAAI,EAAgB,GAAS,qBAAqB,CAAE,EAAM,WAAW,EAEjE,EAAS,EAAO,GAAG,CAAE,GAAS,UAAU,CAAE,EAAe,GAAW,SAAS,IAEjF,GAAK,GAAU,GAIV,AAAU,GAFf,CAAA,GAAU,AAAkB,GAAlB,EAAM,QAAQ,CAAQ,EAAI,EAAI,KAAK,GAAG,CAAE,EAAS,UAAU,CAAE,GAAkB,EAAM,QAAQ,CAAE,EAAzG,EAFmB,SAMnB,GAAU,EAAM,SAAS,CAEzB,EAAM,GAAG,CAAE,GAAY,cAAc,CAAE,GAExC,CAED,CAED,CAqJA,SAAS,EAAa,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAG,CAAE,CAAG,CAAE,CAAG,CAAE,CAAO,CAAE,CAAQ,EAcjE,GAZA,EAAM,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAI,EAC9B,EAAM,IAAI,CAAC,MAAM,CAAC,KAAK,GAEvB,GAAY,EAAS,OAAO,EAC5B,GAAa,EAAS,QAAQ,EAE9B,EAAO,EAAG,cAAc,CAAC,CAAC,CAAE,EAAO,EAAG,cAAc,CAAC,CAAC,CACtD,EAAO,EAAG,cAAc,CAAC,CAAC,CAAE,EAAO,EAAG,cAAc,CAAC,CAAC,CACtD,EAAO,EAAG,cAAc,CAAC,CAAC,CAAE,EAAO,EAAG,cAAc,CAAC,CAAC,CAEtD,EAAc,EAAM,EAAM,EAAM,EAAM,EAAM,GAErC,AAAA,CAAA,aAAoB,GAAM,mBAAmB,EAAI,aAAoB,GAAM,iBAAgB,AAAhB,GAAuB,AAAiB,OAAjB,EAAS,GAAG,CAEpH,GAAc,IAAI,CAAE,EAAS,KAAK,EAClC,GAAe,IAAI,CAAE,EAAS,QAAQ,EAEjC,EAAS,YAAY,GAAK,GAAM,UAAU,EAE9C,GAAc,QAAQ,CAAE,EAAQ,KAAK,EAIjC,AAAoB,CAAA,IAApB,GAEC,AAAuB,CAAA,IAAvB,EAAS,SAAS,EAAc,EAAS,OAAO,EAAI,GAAM,aAAa,EAAI,AAA+B,GAA/B,EAAQ,mBAAmB,EAE1G,GAAQ,IAAI,CAAE,IACd,GAAQ,IAAI,CAAE,IACd,GAAQ,IAAI,CAAE,IAEd,EAAgB,EAAQ,EAAE,CAAC,aAAa,CAAE,EAAQ,kBAAkB,CAAE,EAAG,CAAE,IAC3E,EAAgB,EAAQ,EAAE,CAAC,aAAa,CAAE,EAAQ,kBAAkB,CAAE,EAAG,CAAE,IAC3E,EAAgB,EAAQ,EAAE,CAAC,aAAa,CAAE,EAAQ,kBAAkB,CAAE,EAAG,CAAE,IAE3E,GAAQ,QAAQ,CAAE,IAAgB,GAAG,CAAE,IACvC,GAAQ,QAAQ,CAAE,IAAgB,GAAG,CAAE,IACvC,GAAQ,QAAQ,CAAE,IAAgB,GAAG,CAAE,IACvC,GAAQ,SAAS,CAAE,GAAS,IAAU,cAAc,CAAE,IAEtD,EAAS,GAAoB,GAAS,GAAS,GAAS,IAExD,GAAW,EAAM,EAAM,EAAM,EAAM,EAAM,EAAM,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,KAIjE,GAAO,IAAI,CAAE,IAEb,EAAgB,EAAQ,aAAa,CAAE,EAAQ,WAAW,CAAE,IAE5D,GAAO,QAAQ,CAAE,IAAgB,GAAG,CAAE,IAEtC,AAAuB,CAAA,IAAvB,EAAS,SAAS,CACf,EAAY,GAAQ,EAAS,kBAAkB,CAAE,EAAS,gBAAgB,CAAE,EAAS,iBAAiB,EACtG,GAAU,KAMd,AAAuB,CAAA,IAAvB,EAAS,SAAS,CACf,EAAY,EAAS,KAAK,CAAE,EAAS,kBAAkB,CAAE,EAAS,gBAAgB,CAAE,EAAS,iBAAiB,EAC9G,GAAU,EAAS,KAAK,OAItB,GAAK,aAAoB,GAAM,iBAAiB,EAAI,aAAoB,GAAM,mBAAmB,EAAI,aAAoB,GAAM,iBAAiB,CAEjJ,AAAiB,OAAjB,EAAS,GAAG,CAEX,EAAS,GAAG,CAAC,OAAO,YAAY,GAAM,SAAS,GAEnD,EAAO,EAAQ,GAAG,CAAE,EAAG,CACvB,GAAa,EAAM,EAAM,EAAM,EAAM,EAAM,EAAM,CAAI,CAAE,EAAK,CAAC,CAAC,CAAE,CAAI,CAAE,EAAK,CAAC,CAAC,CAAE,CAAI,CAAE,EAAK,CAAC,CAAC,CAAE,CAAI,CAAE,EAAK,CAAC,CAAC,CAAE,CAAI,CAAE,EAAK,CAAC,CAAC,CAAE,CAAI,CAAE,EAAK,CAAC,CAAC,CAAE,EAAS,GAAG,GAK7I,AAAoB,OAApB,EAAS,MAAM,CAErB,EAAS,MAAM,CAAC,OAAO,YAAY,GAAM,0BAA0B,GAEvE,GAAS,IAAI,CAAE,EAAQ,sBAAsB,CAAE,EAAK,EACpD,EAAQ,GAAM,GAAS,CAAC,CAAG,GAC3B,EAAQ,GAAM,GAAS,CAAC,CAAG,GAE3B,GAAS,IAAI,CAAE,EAAQ,sBAAsB,CAAE,EAAK,EACpD,EAAQ,GAAM,GAAS,CAAC,CAAG,GAC3B,EAAQ,GAAM,GAAS,CAAC,CAAG,GAE3B,GAAS,IAAI,CAAE,EAAQ,sBAAsB,CAAE,EAAK,EACpD,EAAQ,GAAM,GAAS,CAAC,CAAG,GAC3B,EAAQ,GAAM,GAAS,CAAC,CAAG,GAE3B,GAAa,EAAM,EAAM,EAAM,EAAM,EAAM,EAAM,EAAO,EAAO,EAAO,EAAO,EAAO,EAAO,EAAS,MAAM,IAW3G,GAAO,IAAI,CAAE,EAAS,KAAK,EAEtB,EAAS,YAAY,GAAK,GAAM,UAAU,EAE9C,GAAO,QAAQ,CAAE,EAAQ,KAAK,EAI/B,AAAuB,CAAA,IAAvB,EAAS,SAAS,CACf,EAAY,GAAQ,EAAS,kBAAkB,CAAE,EAAS,gBAAgB,CAAE,EAAS,iBAAiB,EACtG,GAAU,UAIR,GAAK,aAAoB,GAAM,iBAAiB,CAEtD,EAAQ,EAAO,IAAI,CACnB,EAAO,EAAO,GAAG,CAEjB,GAAQ,CAAC,CAAG,GAAQ,CAAC,CAAG,GAAQ,CAAC,CAAG,EAAI,EAAY,EAAG,cAAc,CAAC,CAAC,CAAG,EAAG,cAAc,CAAC,CAAC,CAAE,EAAO,GACtG,GAAQ,CAAC,CAAG,GAAQ,CAAC,CAAG,GAAQ,CAAC,CAAG,EAAI,EAAY,EAAG,cAAc,CAAC,CAAC,CAAG,EAAG,cAAc,CAAC,CAAC,CAAE,EAAO,GACtG,GAAQ,CAAC,CAAG,GAAQ,CAAC,CAAG,GAAQ,CAAC,CAAG,EAAI,EAAY,EAAG,cAAc,CAAC,CAAC,CAAG,EAAG,cAAc,CAAC,CAAC,CAAE,EAAO,GACtG,GAAQ,SAAS,CAAE,GAAS,IAAU,cAAc,CAAE,IAEtD,EAAS,GAAoB,GAAS,GAAS,GAAS,IAExD,GAAW,EAAM,EAAM,EAAM,EAAM,EAAM,EAAM,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,QAE3D,GAAK,aAAoB,GAAM,kBAAkB,CAAG,CAE1D,IAAI,CAEC,CAAA,EAAS,OAAO,EAAI,GAAM,WAAW,EAEzC,EAAS,EAAQ,eAAe,CAEhC,GAAO,MAAM,CAAE,EAAO,CAAC,CAAE,EAAO,CAAC,CAAE,EAAO,CAAC,EAAG,cAAc,CAAE,IAAM,SAAS,CAAE,IAE/E,AAAuB,CAAA,IAAvB,EAAS,SAAS,CACf,EAAY,GAAQ,EAAS,kBAAkB,CAAE,EAAS,gBAAgB,CAAE,EAAS,iBAAiB,EACtG,GAAU,KAEF,EAAS,OAAO,EAAI,GAAM,aAAa,GAElD,EAAS,EAAQ,sBAAsB,CAAE,EAAK,CAC9C,GAAQ,MAAM,CAAE,EAAO,CAAC,CAAE,EAAO,CAAC,CAAE,EAAO,CAAC,EAAG,cAAc,CAAE,IAAM,SAAS,CAAE,IAEhF,EAAS,EAAQ,sBAAsB,CAAE,EAAK,CAC9C,GAAQ,MAAM,CAAE,EAAO,CAAC,CAAE,EAAO,CAAC,CAAE,EAAO,CAAC,EAAG,cAAc,CAAE,IAAM,SAAS,CAAE,IAEhF,EAAS,EAAQ,sBAAsB,CAAE,EAAK,CAC9C,GAAQ,MAAM,CAAE,EAAO,CAAC,CAAE,EAAO,CAAC,CAAE,EAAO,CAAC,EAAG,cAAc,CAAE,IAAM,SAAS,CAAE,IAEhF,GAAQ,SAAS,CAAE,GAAS,IAAU,cAAc,CAAE,IAEtD,EAAS,GAAoB,GAAS,GAAS,GAAS,IAExD,GAAW,EAAM,EAAM,EAAM,EAAM,EAAM,EAAM,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAInE,CAED,CAmLA,SAAS,EAAc,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,EAE5C,EAAS,SAAS,GAClB,EAAS,MAAM,CAAE,EAAI,GACrB,EAAS,MAAM,CAAE,EAAI,GACrB,EAAS,MAAM,CAAE,EAAI,GACrB,EAAS,SAAS,EAEnB,CAEA,SAAS,EAAU,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,EAEhD,EAAS,SAAS,GAClB,EAAS,MAAM,CAAE,EAAI,GACrB,EAAS,MAAM,CAAE,EAAI,GACrB,EAAS,MAAM,CAAE,EAAI,GACrB,EAAS,MAAM,CAAE,EAAI,GACrB,EAAS,SAAS,EAEnB,CAEA,SAAS,EAAY,CAAK,CAAE,CAAS,CAAE,CAAO,CAAE,CAAQ,EAEvD,GAAc,GACd,GAAY,GACZ,GAAa,GACb,GAAgB,EAAM,QAAQ,IAE9B,EAAS,MAAM,GAEf,GAAS,cAAc,CAAE,AAAY,EAAZ,EAE1B,CAEA,SAAS,GAAU,CAAK,EAEvB,GAAc,EAAM,QAAQ,IAC5B,EAAS,IAAI,EAEd,CAEA,SAAS,GAAa,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAO,EAE5E,GAAK,CAAA,CAAA,aAAmB,GAAM,WAAW,AAAX,GAAe,AAAkB,KAAA,IAAlB,EAAQ,KAAK,EAAkB,AAAuB,GAAvB,EAAQ,KAAK,CAAC,KAAK,EAE/F,GAAK,AAAwB,CAAA,IAAxB,EAAQ,WAAW,CAAY,CAEnC,IAAI,EAAU,EAAQ,KAAK,EAAI,GAAM,cAAc,CAC/C,EAAU,EAAQ,KAAK,EAAI,GAAM,cAAc,AAEnD,CAAA,EAAS,CAAE,EAAQ,EAAE,CAAE,CAAG,EAAS,aAAa,CAC/C,EAAQ,KAAK,CAAE,AAAY,CAAA,IAAZ,GAAoB,AAAY,CAAA,IAAZ,EAChC,SACA,AAAY,CAAA,IAAZ,GAAoB,AAAY,CAAA,IAAZ,EACnB,WACA,AAAY,CAAA,IAAZ,GAAqB,AAAY,CAAA,IAAZ,EACpB,WACA,aAGN,EAAQ,WAAW,CAAG,CAAA,CAEvB,CAEA,AAA4B,KAAA,IAA5B,EAAS,CAAE,EAAQ,EAAE,CAAE,CACpB,GAAc,iBACd,GAAc,EAAS,CAAE,EAAQ,EAAE,CAAE,EAIxC,IAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAK,EAC3B,EAAU,EAAQ,MAAM,CAAC,CAAC,CAAG,EAAQ,MAAM,CAAC,CAAC,CAC7C,EAAU,EAAQ,MAAM,CAAC,CAAC,CAAG,EAAQ,MAAM,CAAC,CAAC,CAC7C,EAAQ,EAAQ,KAAK,CAAC,KAAK,CAAG,EAAQ,MAAM,CAAC,CAAC,CAC9C,EAAS,EAAQ,KAAK,CAAC,MAAM,CAAG,EAAQ,MAAM,CAAC,CAAC,CAmBhD,GAjBA,EAAK,AAAE,CAAA,EAAK,CAAA,EAAY,EACxB,EAAO,AAAA,CAAA,EAAM,EAAK,CAAA,EAAY,EAE9B,EAAK,AAAE,CAAA,EAAK,CAAA,EAAY,EACxB,EAAO,AAAA,CAAA,EAAM,EAAK,CAAA,EAAY,EAE9B,EAAK,AAAE,CAAA,EAAK,CAAA,EAAY,EACxB,EAAO,AAAA,CAAA,EAAM,EAAK,CAAA,EAAY,EAE9B,GAAM,EAAI,GAAM,EAChB,GAAM,EAAI,GAAM,EAEhB,GAAM,EAAI,GAAM,EAChB,GAAM,EAAI,GAAM,EAIX,AAAQ,GAFb,CAAA,EAAM,EAAK,EAAK,EAAK,CAArB,EAEiB,CAEhB,GAAK,AAA8B,KAAA,IAA9B,EAAW,CAAE,EAAQ,EAAE,CAAE,CAAiB,CAE9C,IAAI,EAAS,SAAS,aAAa,CAAE,SACrC,CAAA,EAAO,KAAK,CAAG,EAAQ,KAAK,CAAC,KAAK,CAClC,EAAO,MAAM,CAAG,EAAQ,KAAK,CAAC,MAAM,CAEpC,IAAI,EAAU,EAAO,UAAU,CAAE,MACjC,EAAQ,SAAS,CAAE,EAAQ,KAAK,CAAE,EAAG,GAErC,EAAW,CAAE,EAAQ,EAAE,CAAE,CAAG,EAAQ,YAAY,CAAE,EAAG,EAAG,EAAQ,KAAK,CAAC,KAAK,CAAE,EAAQ,KAAK,CAAC,MAAM,EAAG,IAAI,AAEzG,CAEA,IAAI,EAAO,EAAW,CAAE,EAAQ,EAAE,CAAE,CAChC,EAAQ,AAAE,CAAA,KAAK,KAAK,CAAE,GAAO,KAAK,KAAK,CAAE,GAAO,EAAQ,KAAK,CAAC,KAAI,AAAJ,EAAU,EAE5E,GAAO,MAAM,CAAE,CAAI,CAAE,EAAO,CAAG,IAAK,CAAI,CAAE,EAAQ,EAAG,CAAG,IAAK,CAAI,CAAE,EAAQ,EAAG,CAAG,KACjF,GAAU,IAEV,MAED,CAIA,EAAM,AAAA,CAAA,EAAK,EAAK,EAAK,CAAA,EAFrB,CAAA,EAAO,EAAI,CAAX,EAGA,EAAM,AAAA,CAAA,EAAK,EAAK,EAAK,CAAA,EAAO,EAC5B,EAAM,AAAA,CAAA,EAAK,EAAK,EAAK,CAAA,EAAO,EAC5B,EAAM,AAAA,CAAA,EAAK,EAAK,EAAK,CAAA,EAAO,EAE5B,EAAI,EAAK,EAAI,EAAK,EAAI,EACtB,EAAI,EAAK,EAAI,EAAK,EAAI,EAEtB,EAAS,IAAI,GACb,EAAS,SAAS,CAAE,EAAG,EAAG,EAAG,EAAG,EAAG,GACnC,EAAS,IAAI,GACb,EAAS,OAAO,GAEjB,CAEA,SAAS,GAAW,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAK,EAIxE,IAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAQ,EAC3B,EAAQ,EAAM,KAAK,CAAG,EACtB,EAAS,EAAM,MAAM,CAAG,EAExB,GAAM,EAAO,GAAM,EACnB,GAAM,EAAO,GAAM,EACnB,GAAM,EAAO,GAAM,EAEnB,GAAM,EAAI,GAAM,EAChB,GAAM,EAAI,GAAM,EAEhB,GAAM,EAAI,GAAM,EAChB,GAAM,EAAI,GAAM,EAIhB,EAAO,EAFD,CAAA,EAAK,EAAK,EAAK,CAArB,EAIA,EAAM,AAAA,CAAA,EAAK,EAAK,EAAK,CAAA,EAAO,EAC5B,EAAM,AAAA,CAAA,EAAK,EAAK,EAAK,CAAA,EAAO,EAC5B,EAAM,AAAA,CAAA,EAAK,EAAK,EAAK,CAAA,EAAO,EAC5B,EAAM,AAAA,CAAA,EAAK,EAAK,EAAK,CAAA,EAAO,EAE5B,EAAI,EAAK,EAAI,EAAK,EAAI,EACtB,EAAI,EAAK,EAAI,EAAK,EAAI,EAEtB,EAAS,IAAI,GACb,EAAS,SAAS,CAAE,EAAG,EAAG,EAAG,EAAG,EAAG,GACnC,EAAS,IAAI,GACb,EAAS,SAAS,CAAE,EAAO,EAAG,GAC9B,EAAS,OAAO,EAEjB,CAEA,SAAS,GAAoB,CAAM,CAAE,CAAM,CAAE,CAAM,CAAE,CAAM,EAuB1D,OAnBA,CAAa,CAAE,EAAG,CAAK,AAAW,IAAX,EAAO,CAAC,CAAW,EAC1C,CAAa,CAAE,EAAG,CAAK,AAAW,IAAX,EAAO,CAAC,CAAW,EAC1C,CAAa,CAAE,EAAG,CAAK,AAAW,IAAX,EAAO,CAAC,CAAW,EAE1C,CAAa,CAAE,EAAG,CAAK,AAAW,IAAX,EAAO,CAAC,CAAW,EAC1C,CAAa,CAAE,EAAG,CAAK,AAAW,IAAX,EAAO,CAAC,CAAW,EAC1C,CAAa,CAAE,EAAG,CAAK,AAAW,IAAX,EAAO,CAAC,CAAW,EAE1C,CAAa,CAAE,EAAG,CAAK,AAAW,IAAX,EAAO,CAAC,CAAW,EAC1C,CAAa,CAAE,EAAG,CAAK,AAAW,IAAX,EAAO,CAAC,CAAW,EAC1C,CAAa,CAAE,GAAI,CAAK,AAAW,IAAX,EAAO,CAAC,CAAW,EAE3C,CAAa,CAAE,GAAI,CAAK,AAAW,IAAX,EAAO,CAAC,CAAW,EAC3C,CAAa,CAAE,GAAI,CAAK,AAAW,IAAX,EAAO,CAAC,CAAW,EAC3C,CAAa,CAAE,GAAI,CAAK,AAAW,IAAX,EAAO,CAAC,CAAW,EAE3C,EAAiB,YAAY,CAAE,EAAgB,EAAG,GAClD,EAAoB,SAAS,CAAE,EAAW,EAAG,GAEtC,CAER,CAIA,SAAS,GAAQ,CAAE,CAAE,CAAE,EAEtB,IACqB,EADjB,EAAI,EAAG,CAAC,CAAG,EAAG,CAAC,CAAE,EAAK,EAAG,CAAC,CAAG,EAAG,CAAC,CACrC,EAAM,EAAI,EAAI,EAAI,CAEL,CAAA,IAAR,IAIL,GAFA,EAAO,EAAI,KAAK,IAAI,CAAE,GAEX,GAAK,EAEhB,EAAG,CAAC,EAAI,EAAG,EAAG,CAAC,EAAI,EACnB,EAAG,CAAC,EAAI,EAAG,EAAG,CAAC,EAAI,EAEpB,CAvxBA,EAAS,YAAY,CAAE,EAAG,EAAG,EAAG,EAAG,EAAG,EAwxBvC,CA8GD,EAOA,GAAM,WAAW,CAAG,CAInB,kBAAmB,2JAqBnB,aAAc,gZA0Bd,qBAAsB,gSAwBtB,gBAAiB,+hCA6DjB,mBAAoB,gLAapB,gBAAkB,wbA0BlB,cAAgB,udAyBhB,2BAA4B,iDAW5B,sBAAuB,0HAYvB,gBAAiB,oKAWjB,kBAAmB,wLAgBnB,WAAY,oKAUZ,aAAc,6KAoBd,uBAAwB,+EAWxB,qBAAsB,kDAUtB,kBAAmB,0FAUnB,gBAAiB,2CAYjB,sBAAuB,mvBA+CvB,wBAAyB,2iBAkCzB,0BAA2B,iEAU3B,qBAAsB,oLAmBtB,2BAA4B,4hCAkD5B,sBAAuB,qgJAiNvB,yBAA0B,gfAiC1B,oBAAqB,44BAgDrB,2BAA4B,6wCAyE5B,sBAAuB,6mPAsVvB,oBAAqB,iDAWrB,eAAgB,mFAUhB,kBAAmB,iDAWnB,aAAc,wGAoBd,qBAAsB,uyBA+CtB,gBAAiB,4HAWjB,gBAAiB,qQAuBjB,wBAAyB,iKAkBzB,mBAAoB,uqBAyBpB,eAAiB,gYA0BjB,mBAAoB,2YAiBpB,kBAAmB,kRAqBnB,qBAAsB,yYAsCtB,wBAAyB,udAwBzB,mBAAoB,01LAiPpB,sBAAuB,qHAWvB,iBAAkB,qIAgBlB,mBAAoB,uEAYpB,yBAA0B,2EAW3B,EAEA,GAAM,aAAa,CAAG,CAErB,MAAO,SAAW,CAAQ,EAEzB,IAAI,EAAG,EAAG,EAAK,EAAS,CAAC,EAEzB,IAAM,EAAI,EAAG,EAAI,EAAS,MAAM,CAAE,IAIjC,IAAM,KAFN,EAAM,IAAI,CAAC,KAAK,CAAE,CAAQ,CAAE,EAAG,EAI9B,CAAM,CAAE,EAAG,CAAG,CAAG,CAAE,EAAG,CAMxB,OAAO,CAER,EAEA,MAAO,SAAW,CAAY,EAE7B,IAAI,EAAG,EAAc,EAAe,EAAe,CAAC,EAEpD,IAAM,KAAK,EAIV,IAAM,KAFN,CAAY,CAAE,EAAG,CAAG,CAAC,EAEV,CAAY,CAAE,EAAG,CAItB,AAFL,CAAA,EAAgB,CAAY,CAAE,EAAG,CAAE,EAAG,AAAH,YAEL,GAAM,KAAK,EACvC,aAAyB,GAAM,OAAO,EACtC,aAAyB,GAAM,OAAO,EACtC,aAAyB,GAAM,OAAO,EACtC,aAAyB,GAAM,OAAO,EACtC,aAAyB,GAAM,OAAO,CAEvC,CAAY,CAAE,EAAG,CAAE,EAAG,CAAG,EAAc,KAAK,GAEjC,aAAyB,MAEpC,CAAY,CAAE,EAAG,CAAE,EAAG,CAAG,EAAc,KAAK,GAI5C,CAAY,CAAE,EAAG,CAAE,EAAG,CAAG,EAQ5B,OAAO,CAER,CAED,EAEA,GAAM,WAAW,CAAG,CAEnB,OAAQ,CAEP,QAAY,CAAE,KAAM,IAAK,MAAO,IAAI,GAAM,KAAK,CAAE,SAAW,EAC5D,QAAY,CAAE,KAAM,IAAK,MAAO,CAAI,EAEpC,IAAQ,CAAE,KAAM,IAAK,MAAO,IAAK,EACjC,aAAiB,CAAE,KAAM,KAAM,MAAO,IAAI,GAAM,OAAO,CAAE,EAAG,EAAG,EAAG,EAAI,EAEtE,SAAa,CAAE,KAAM,IAAK,MAAO,IAAK,EACtC,YAAgB,CAAE,KAAM,IAAK,MAAO,IAAK,EAEzC,OAAW,CAAE,KAAM,IAAK,MAAO,IAAK,EACpC,WAAe,CAAE,KAAM,IAAK,MAAO,EAAG,EACtC,WAAe,CAAE,KAAM,IAAK,MAAO,CAAE,EACrC,aAAiB,CAAE,KAAM,IAAK,MAAO,CAAI,EACzC,gBAAoB,CAAE,KAAM,IAAK,MAAO,GAAK,EAC7C,QAAY,CAAE,KAAM,IAAK,MAAO,CAAE,EAElC,sBAA0B,CAAE,KAAM,IAAK,MAAO,CAAE,CAEjD,EAEA,KAAM,CAEL,QAAY,CAAE,KAAM,IAAK,MAAO,IAAK,EACrC,UAAc,CAAE,KAAM,IAAK,MAAO,CAAE,CAErC,EAEA,UAAW,CAEV,UAAc,CAAE,KAAM,IAAK,MAAO,IAAK,EACvC,YAAgB,CAAE,KAAM,KAAM,MAAO,IAAI,GAAM,OAAO,CAAE,EAAG,EAAI,CAChE,EAEA,IAAM,CAEL,WAAe,CAAE,KAAM,IAAK,MAAO,KAAQ,EAC3C,QAAY,CAAE,KAAM,IAAK,MAAO,CAAE,EAClC,OAAW,CAAE,KAAM,IAAK,MAAO,GAAK,EACpC,SAAa,CAAE,KAAM,IAAK,MAAO,IAAI,GAAM,KAAK,CAAE,SAAW,CAE9D,EAEA,OAAQ,CAEP,kBAAsB,CAAE,KAAM,KAAM,MAAO,EAAE,AAAC,EAE9C,0BAA8B,CAAE,KAAM,KAAM,MAAO,EAAE,AAAC,EACtD,sBAA0B,CAAE,KAAM,KAAM,MAAO,EAAE,AAAC,EAElD,yBAA6B,CAAE,KAAM,KAAM,MAAO,EAAE,AAAC,EACrD,wBAA4B,CAAE,KAAM,KAAM,MAAO,EAAE,AAAC,EACpD,2BAA+B,CAAE,KAAM,KAAM,MAAO,EAAE,AAAC,EAEvD,gBAAoB,CAAE,KAAM,KAAM,MAAO,EAAE,AAAC,EAC5C,mBAAuB,CAAE,KAAM,KAAM,MAAO,EAAE,AAAC,EAC/C,mBAAuB,CAAE,KAAM,MAAO,MAAO,EAAE,AAAC,EAEhD,eAAmB,CAAE,KAAM,KAAM,MAAO,EAAE,AAAC,EAC3C,kBAAsB,CAAE,KAAM,KAAM,MAAO,EAAE,AAAC,EAC9C,mBAAuB,CAAE,KAAM,KAAM,MAAO,EAAE,AAAC,EAC/C,kBAAsB,CAAE,KAAM,MAAO,MAAO,EAAE,AAAC,EAC/C,kBAAsB,CAAE,KAAM,MAAO,MAAO,EAAE,AAAC,EAC/C,kBAAsB,CAAE,KAAM,MAAO,MAAO,EAAE,AAAC,CAEhD,EAEA,SAAU,CAET,QAAY,CAAE,KAAM,IAAK,MAAO,IAAI,GAAM,KAAK,CAAE,SAAW,EAC5D,QAAY,CAAE,KAAM,IAAK,MAAO,CAAI,EACpC,KAAS,CAAE,KAAM,IAAK,MAAO,CAAI,EACjC,MAAU,CAAE,KAAM,IAAK,MAAO,CAAI,EAClC,IAAQ,CAAE,KAAM,IAAK,MAAO,IAAK,EAEjC,WAAe,CAAE,KAAM,IAAK,MAAO,KAAQ,EAC3C,QAAY,CAAE,KAAM,IAAK,MAAO,CAAE,EAClC,OAAW,CAAE,KAAM,IAAK,MAAO,GAAK,EACpC,SAAa,CAAE,KAAM,IAAK,MAAO,IAAI,GAAM,KAAK,CAAE,SAAW,CAE9D,EAEA,UAAW,CAEV,UAAa,CAAE,KAAM,KAAM,MAAO,EAAE,AAAC,EACrC,cAAiB,CAAE,KAAM,MAAO,MAAO,EAAE,AAAC,EAE1C,WAAe,CAAE,KAAM,MAAO,MAAO,EAAE,AAAC,EACxC,eAAkB,CAAE,KAAM,MAAO,MAAO,EAAE,AAAC,EAE3C,aAAiB,CAAE,KAAM,MAAO,MAAO,EAAE,AAAC,CAE3C,CAED,EAEA,GAAM,SAAS,CAAG,CAEjB,MAAS,CAER,SAAU,GAAM,aAAa,CAAC,KAAK,CAAE,CAEpC,GAAM,WAAW,CAAE,MAAU,CAC7B,GAAM,WAAW,CAAE,GAAO,CAC1B,GAAM,WAAW,CAAE,SAAa,CAEhC,EAED,aAAc,CAEb,GAAM,WAAW,CAAE,eAAmB,CACtC,GAAM,WAAW,CAAE,oBAAwB,CAC3C,GAAM,WAAW,CAAE,kBAAsB,CACzC,GAAM,WAAW,CAAE,iBAAqB,CACxC,GAAM,WAAW,CAAE,uBAA2B,CAC9C,GAAM,WAAW,CAAE,oBAAwB,CAC3C,GAAM,WAAW,CAAE,qBAAyB,CAE5C,gBAEC,GAAM,WAAW,CAAE,UAAc,CACjC,GAAM,WAAW,CAAE,eAAmB,CACtC,GAAM,WAAW,CAAE,YAAgB,CACnC,GAAM,WAAW,CAAE,eAAmB,CAEtC,oBAEA,GAAM,WAAW,CAAE,kBAAsB,CACzC,GAAM,WAAW,CAAE,iBAAqB,CACxC,GAAM,WAAW,CAAE,oBAAwB,CAE3C,SAEA,GAAM,WAAW,CAAE,kBAAsB,CACzC,GAAM,WAAW,CAAE,eAAmB,CACtC,GAAM,WAAW,CAAE,cAAkB,CAErC,GAAM,WAAW,CAAE,eAAmB,CACtC,GAAM,WAAW,CAAE,aAAiB,CACpC,GAAM,WAAW,CAAE,gBAAoB,CAExC,IAEA,CAAC,IAAI,CAAC,MAEP,eAAgB,CAEf,wBACA,yBAEA,GAAM,WAAW,CAAE,mBAAuB,CAC1C,GAAM,WAAW,CAAE,iBAAqB,CACxC,GAAM,WAAW,CAAE,sBAA0B,CAC7C,GAAM,WAAW,CAAE,oBAAwB,CAC3C,GAAM,WAAW,CAAE,iBAAqB,CACxC,GAAM,WAAW,CAAE,uBAA2B,CAC9C,GAAM,WAAW,CAAE,yBAA6B,CAEhD,gBAEC,2CAEA,GAAM,WAAW,CAAE,YAAgB,CACnC,GAAM,WAAW,CAAE,kBAAsB,CACzC,GAAM,WAAW,CAAE,oBAAwB,CAC3C,GAAM,WAAW,CAAE,iBAAqB,CACxC,GAAM,WAAW,CAAE,cAAkB,CACrC,GAAM,WAAW,CAAE,eAAmB,CACtC,GAAM,WAAW,CAAE,kBAAsB,CAEzC,GAAM,WAAW,CAAE,wBAA4B,CAE/C,GAAM,WAAW,CAAE,YAAgB,CAEpC,IAEA,CAAC,IAAI,CAAC,KAER,EAEA,QAAW,CAEV,SAAU,GAAM,aAAa,CAAC,KAAK,CAAE,CAEpC,GAAM,WAAW,CAAE,MAAU,CAC7B,GAAM,WAAW,CAAE,GAAO,CAC1B,GAAM,WAAW,CAAE,MAAU,CAC7B,GAAM,WAAW,CAAE,SAAa,CAEhC,CACC,QAAa,CAAE,KAAM,IAAK,MAAO,IAAI,GAAM,KAAK,CAAE,SAAW,EAC7D,SAAa,CAAE,KAAM,IAAK,MAAO,IAAI,GAAM,KAAK,CAAE,EAAW,EAC7D,QAAa,CAAE,KAAM,KAAM,MAAO,IAAI,GAAM,OAAO,CAAE,EAAG,EAAG,EAAI,CAChE,EAEA,EAED,aAAc,CAEb,kBAEA,4BAEA,sBAEC,2BAED,SAEA,GAAM,WAAW,CAAE,eAAmB,CACtC,GAAM,WAAW,CAAE,oBAAwB,CAC3C,GAAM,WAAW,CAAE,kBAAsB,CACzC,GAAM,WAAW,CAAE,0BAA8B,CACjD,GAAM,WAAW,CAAE,iBAAqB,CACxC,GAAM,WAAW,CAAE,uBAA2B,CAC9C,GAAM,WAAW,CAAE,oBAAwB,CAC3C,GAAM,WAAW,CAAE,qBAAyB,CAE5C,gBAEC,GAAM,WAAW,CAAE,UAAc,CACjC,GAAM,WAAW,CAAE,eAAmB,CACtC,GAAM,WAAW,CAAE,YAAgB,CAEnC,GAAM,WAAW,CAAE,kBAAsB,CACzC,GAAM,WAAW,CAAE,eAAmB,CACtC,GAAM,WAAW,CAAE,iBAAqB,CACxC,GAAM,WAAW,CAAE,oBAAwB,CAE3C,GAAM,WAAW,CAAE,kBAAsB,CACzC,GAAM,WAAW,CAAE,eAAmB,CACtC,GAAM,WAAW,CAAE,cAAkB,CAErC,GAAM,WAAW,CAAE,eAAmB,CACtC,GAAM,WAAW,CAAE,aAAiB,CACpC,GAAM,WAAW,CAAE,qBAAyB,CAC5C,GAAM,WAAW,CAAE,gBAAoB,CAExC,IAEA,CAAC,IAAI,CAAC,MAEP,eAAgB,CAEf,yBAEA,4BAEA,sBAEC,2BAED,SAEA,GAAM,WAAW,CAAE,mBAAuB,CAC1C,GAAM,WAAW,CAAE,iBAAqB,CACxC,GAAM,WAAW,CAAE,sBAA0B,CAC7C,GAAM,WAAW,CAAE,oBAAwB,CAC3C,GAAM,WAAW,CAAE,iBAAqB,CACxC,GAAM,WAAW,CAAE,uBAA2B,CAC9C,GAAM,WAAW,CAAE,yBAA6B,CAEhD,gBAEC,gDAEA,GAAM,WAAW,CAAE,YAAgB,CACnC,GAAM,WAAW,CAAE,kBAAsB,CACzC,GAAM,WAAW,CAAE,oBAAwB,CAE3C,sBAKC,wBACC,mCACD,OACC,kCAEF,QAEC,mCAED,SAEA,GAAM,WAAW,CAAE,iBAAqB,CACxC,GAAM,WAAW,CAAE,cAAkB,CACrC,GAAM,WAAW,CAAE,eAAmB,CACtC,GAAM,WAAW,CAAE,kBAAsB,CAEzC,GAAM,WAAW,CAAE,wBAA4B,CAE/C,GAAM,WAAW,CAAE,YAAgB,CAEpC,IAEA,CAAC,IAAI,CAAC,KAER,EAEA,MAAS,CAER,SAAU,GAAM,aAAa,CAAC,KAAK,CAAE,CAEpC,GAAM,WAAW,CAAE,MAAU,CAC7B,GAAM,WAAW,CAAE,IAAQ,CAC3B,GAAM,WAAW,CAAE,SAAa,CAChC,GAAM,WAAW,CAAE,GAAO,CAC1B,GAAM,WAAW,CAAE,MAAU,CAC7B,GAAM,WAAW,CAAE,SAAa,CAEhC,CACC,QAAa,CAAE,KAAM,IAAK,MAAO,IAAI,GAAM,KAAK,CAAE,SAAW,EAC7D,SAAa,CAAE,KAAM,IAAK,MAAO,IAAI,GAAM,KAAK,CAAE,EAAW,EAC7D,SAAa,CAAE,KAAM,IAAK,MAAO,IAAI,GAAM,KAAK,CAAE,QAAW,EAC7D,UAAa,CAAE,KAAM,IAAK,MAAO,EAAG,EACpC,QAAa,CAAE,KAAM,KAAM,MAAO,IAAI,GAAM,OAAO,CAAE,EAAG,EAAG,EAAI,CAChE,EAEA,EAED,aAAc,CAEb,gBAEA,8BACA,wBAEA,GAAM,WAAW,CAAE,eAAmB,CACtC,GAAM,WAAW,CAAE,oBAAwB,CAC3C,GAAM,WAAW,CAAE,kBAAsB,CACzC,GAAM,WAAW,CAAE,wBAA4B,CAC/C,GAAM,WAAW,CAAE,iBAAqB,CACxC,GAAM,WAAW,CAAE,uBAA2B,CAC9C,GAAM,WAAW,CAAE,oBAAwB,CAC3C,GAAM,WAAW,CAAE,qBAAyB,CAE5C,gBAEC,GAAM,WAAW,CAAE,UAAc,CACjC,GAAM,WAAW,CAAE,eAAmB,CACtC,GAAM,WAAW,CAAE,YAAgB,CAEnC,GAAM,WAAW,CAAE,kBAAsB,CACzC,GAAM,WAAW,CAAE,eAAmB,CACtC,GAAM,WAAW,CAAE,iBAAqB,CACxC,GAAM,WAAW,CAAE,oBAAwB,CAE3C,4CAEA,GAAM,WAAW,CAAE,kBAAsB,CACzC,GAAM,WAAW,CAAE,eAAmB,CACtC,GAAM,WAAW,CAAE,cAAkB,CAErC,mCAEA,GAAM,WAAW,CAAE,eAAmB,CACtC,GAAM,WAAW,CAAE,aAAiB,CACpC,GAAM,WAAW,CAAE,mBAAuB,CAC1C,GAAM,WAAW,CAAE,gBAAoB,CAExC,IAEA,CAAC,IAAI,CAAC,MAEP,eAAgB,CAEf,wBACA,yBAEA,wBACA,yBACA,yBACA,2BAEA,GAAM,WAAW,CAAE,mBAAuB,CAC1C,GAAM,WAAW,CAAE,iBAAqB,CACxC,GAAM,WAAW,CAAE,sBAA0B,CAC7C,GAAM,WAAW,CAAE,oBAAwB,CAC3C,GAAM,WAAW,CAAE,iBAAqB,CACxC,GAAM,WAAW,CAAE,0BAA8B,CACjD,GAAM,WAAW,CAAE,uBAA2B,CAC9C,GAAM,WAAW,CAAE,qBAAyB,CAC5C,GAAM,WAAW,CAAE,uBAA2B,CAC9C,GAAM,WAAW,CAAE,yBAA6B,CAEhD,gBAEC,gDAEA,GAAM,WAAW,CAAE,YAAgB,CACnC,GAAM,WAAW,CAAE,kBAAsB,CACzC,GAAM,WAAW,CAAE,oBAAwB,CAE3C,GAAM,WAAW,CAAE,qBAAyB,CAE5C,GAAM,WAAW,CAAE,iBAAqB,CACxC,GAAM,WAAW,CAAE,cAAkB,CACrC,GAAM,WAAW,CAAE,eAAmB,CACtC,GAAM,WAAW,CAAE,kBAAsB,CAEzC,GAAM,WAAW,CAAE,wBAA4B,CAE/C,GAAM,WAAW,CAAE,YAAgB,CAEpC,IAEA,CAAC,IAAI,CAAC,KAER,EAEA,eAAkB,CAEjB,SAAW,GAAM,aAAa,CAAC,KAAK,CAAE,CAErC,GAAM,WAAW,CAAE,QAAY,CAC/B,GAAM,WAAW,CAAE,SAAa,CAEhC,EAED,aAAc,CAEb,sBACA,uBAEA,GAAM,WAAW,CAAE,iBAAqB,CACxC,GAAM,WAAW,CAAE,qBAAyB,CAE5C,gBAEC,GAAM,WAAW,CAAE,YAAgB,CAEnC,6DAEA,6BACC,8DACD,QACC,uBACD,SAEA,+CAEA,GAAM,WAAW,CAAE,eAAmB,CACtC,GAAM,WAAW,CAAE,gBAAoB,CAExC,IAEA,CAAC,IAAI,CAAC,MAEP,eAAgB,CAEf,wBACA,yBAEA,GAAM,WAAW,CAAE,mBAAuB,CAC1C,GAAM,WAAW,CAAE,0BAA8B,CACjD,GAAM,WAAW,CAAE,iBAAqB,CACxC,GAAM,WAAW,CAAE,uBAA2B,CAE9C,gBAEC,2CAEA,GAAM,WAAW,CAAE,qBAAyB,CAC5C,GAAM,WAAW,CAAE,kBAAsB,CACzC,GAAM,WAAW,CAAE,cAAkB,CACrC,GAAM,WAAW,CAAE,kBAAsB,CACzC,GAAM,WAAW,CAAE,YAAgB,CAEpC,IAEA,CAAC,IAAI,CAAC,KAER,EAEA,OAAU,CAET,SAAU,GAAM,aAAa,CAAC,KAAK,CAAE,CAEpC,GAAM,WAAW,CAAE,MAAU,CAC7B,GAAM,WAAW,CAAE,GAAO,CAE1B,CACC,MAAa,CAAE,KAAM,IAAK,MAAO,CAAE,EACnC,SAAa,CAAE,KAAM,IAAK,MAAO,CAAE,EACnC,UAAa,CAAE,KAAM,IAAK,MAAO,CAAE,CACpC,EAEA,EAED,aAAc,CAEb,uBACA,gCAEA,+BAEA,GAAM,WAAW,CAAE,iBAAqB,CAExC,gBAEC,GAAM,WAAW,CAAE,YAAgB,CAEnC,wCAEA,6DACA,+CAED,IAEA,CAAC,IAAI,CAAC,MAEP,eAAgB,CAEf,wBACA,yBAEA,0BACA,2BAEA,+BAEA,GAAM,WAAW,CAAE,mBAAuB,CAC1C,GAAM,WAAW,CAAE,iBAAqB,CAExC,gBAEC,sDAEC,WAED,IAEA,2CAEA,GAAM,WAAW,CAAE,cAAkB,CACrC,GAAM,WAAW,CAAE,YAAgB,CAEpC,IAEA,CAAC,IAAI,CAAC,KAER,EAEA,MAAS,CAER,SAAU,CAET,MAAS,CAAE,KAAM,IAAK,MAAO,CAAI,EACjC,KAAS,CAAE,KAAM,IAAK,MAAO,GAAO,EACpC,QAAY,CAAE,KAAM,IAAK,MAAO,CAAI,CAErC,EAEA,aAAc,8FAUd,eAAgB,4OAgBjB,EAEA,OAAU,CAET,SAAU,CAET,QAAY,CAAE,KAAM,IAAK,MAAO,CAAI,CAErC,EAEA,aAAc,mMAed,eAAgB,oIAajB,EASA,UAAc,CAEb,SAAU,GAAM,aAAa,CAAC,KAAK,CAAE,CAEpC,GAAM,WAAW,CAAE,GAAO,CAC1B,GAAM,WAAW,CAAE,MAAU,CAC7B,GAAM,WAAW,CAAE,SAAa,CAEhC,CAEA,SAAgB,CAAE,KAAM,IAAK,MAAO,CAAE,EACtC,cAAoB,CAAE,KAAM,IAAK,MAAO,CAAE,EAC1C,eAAoB,CAAE,KAAM,IAAK,MAAO,CAAE,EAC1C,iBAAoB,CAAE,KAAM,IAAK,MAAO,CAAE,EAC1C,mBAAsB,CAAE,KAAM,IAAK,MAAO,CAAE,EAE5C,cAAiB,CAAE,KAAM,IAAK,MAAO,IAAK,EAC1C,SAAgB,CAAE,KAAM,IAAK,MAAO,IAAK,EACzC,MAAc,CAAE,KAAM,IAAK,MAAO,IAAK,EACvC,QAAe,CAAE,KAAM,IAAK,MAAO,IAAK,EACxC,UAAiB,CAAE,KAAM,IAAK,MAAO,IAAK,EAC1C,IAAY,CAAE,KAAM,IAAK,MAAO,IAAK,EAErC,aAAgB,CAAE,KAAM,KAAM,MAAO,IAAI,GAAM,OAAO,CAAE,EAAG,EAAI,EAE/D,kBAAqB,CAAE,KAAM,IAAK,MAAO,CAAI,EAC7C,mBAAsB,CAAE,KAAM,IAAK,MAAO,CAAI,EAE9C,cAAiB,CAAE,KAAM,IAAK,MAAO,IAAI,GAAM,KAAK,CAAE,SAAW,EACjE,eAAkB,CAAE,KAAM,IAAK,MAAO,IAAI,GAAM,KAAK,CAAE,QAAW,EAClE,cAAiB,CAAE,KAAM,IAAK,MAAO,IAAI,GAAM,KAAK,CAAE,SAAW,EACjE,WAAc,CAAE,KAAM,IAAK,MAAO,EAAG,EACrC,SAAY,CAAE,KAAM,IAAK,MAAO,CAAE,EAElC,WAAc,CAAE,KAAM,IAAK,MAAO,CAAE,EACpC,iBAAoB,CAAE,KAAM,IAAK,MAAO,GAAK,EAC7C,cAAiB,CAAE,KAAM,IAAK,MAAO,EAAI,EAEzC,QAAY,CAAE,KAAM,KAAM,MAAO,IAAI,GAAM,OAAO,CAAE,EAAG,EAAI,EAC3D,QAAY,CAAE,KAAM,KAAM,MAAO,IAAI,GAAM,OAAO,CAAE,EAAG,EAAI,EAE3D,QAAa,CAAE,KAAM,KAAM,MAAO,IAAI,GAAM,OAAO,CAAE,EAAG,EAAG,EAAI,CAE/D,EAEA,EAED,eAAgB,CAEf,8BACA,8BACA,+BACA,4BACA,0BAEA,8BACA,+BACA,yBACA,iCAEA,8BACA,6BACA,+BACA,yBAEA,6BAEA,6BAEA,2BACA,kCACA,+BAEA,yBACA,0BACA,wBACA,oBAEA,kCAEA,yBAEC,wDACA,4DAED,SAEA,0BAEC,2DACA,8DACA,4DAED,SAEA,2BAEC,oDACA,uDACA,wDAED,SAEA,0BAEC,kDACA,qDACA,sDACA,sDACA,sDACA,sDAED,SAEA,qBAEC,wBAED,SAEA,+BACA,8BAEA,GAAM,WAAW,CAAE,uBAA2B,CAC9C,GAAM,WAAW,CAAE,iBAAqB,CAExC,gBAEC,gDAEA,kCAEA,8DACA,gCACA,sCAEA,wBAEC,qBAEC,gDACA,oCAEA,4CAED,QAEC,4DAED,SAED,IAEA,mBAEC,qBAEC,wCACA,8BAEA,qDAED,QAEC,mEAED,SAED,IAEA,uBACC,iDAED,0FACA,sCAEA,oBAEC,8BAED,SAEA,0CACA,kDAIA,2BAEC,mCACA,oCAEA,kDAEC,sEACA,wDAEA,6BACA,uCACC,yFAED,0CAIA,qBAEC,yEACA,qFAEA,6GAED,QAEC,qEAED,SAEA,6FAIA,kEACA,yEACA,iGAEA,kCAIC,+DAEA,wHACA,sIAED,QAEC,qHAED,SAED,IAED,SAIA,0BAEC,kCACA,mCAEA,iDAEC,qEACA,uDAEA,4BACA,sCACC,sFAED,wCAEA,2GAEA,+CAEC,sEAIA,qBAEC,uEACA,mFAEA,0GAED,QAEC,mEAED,SAEA,sGAIA,gEACA,uEACA,+FAEA,kCAIC,+DAEA,sHACA,8IAED,QAEC,6HAED,SAED,IAED,IAED,SAIA,yBAEC,iCACA,kCAEA,8CAEC,8EACA,gDAIA,qBAEC,8EACA,0FAEA,wHAED,QAEC,iEAED,SAEA,+EAIA,8DACA,qEACA,6FAEA,kCAIC,+DAEA,oHACA,sHAED,QAEC,qGAED,SAED,IAED,SAIA,0BAEC,mCACA,mCAEA,gDAEC,6EACA,8CAIA,6CACA,oDAEA,4GAEA,4CAKA,gEACA,6EACA,qGAIA,iCAEA,yEACA,mFACA,2GAEA,kCAEC,yDAIA,+DAEA,yHACA,qIACA,iMAED,QAEC,yHAED,SAED,IAED,SAIA,mCACA,oCAEA,yBAEC,8BACA,gCAED,SAEA,0BAEC,+BACA,iCAED,SAEA,2BAEC,gCACA,kCAED,SAEA,0BAEC,+BACA,iCAED,SAEA,eAEC,8GAED,QAEC,8GAED,SAEA,4BAEC,iBACA,sEAEA,sBAEC,kEAED,WAEC,gDAED,IAEA,2EAEA,qBAEC,kCAED,SAEA,4FAED,IAEA,GAAM,WAAW,CAAE,kBAAsB,CACzC,GAAM,WAAW,CAAE,wBAA4B,CAC/C,GAAM,WAAW,CAAE,YAAgB,CAEpC,IAEA,CAAC,IAAI,CAAC,MAEP,aAAc,CAEb,0BAEA,wBACA,wBAEA,mCAEA,yBAEC,mCACA,oCACA,mCAED,SAEA,yBACA,0BACA,wBACA,oBAEA,+BACA,8BAEA,GAAM,WAAW,CAAE,oBAAwB,CAC3C,GAAM,WAAW,CAAE,qBAAyB,CAE5C,gBAEC,GAAM,WAAW,CAAE,eAAmB,CACtC,GAAM,WAAW,CAAE,iBAAqB,CAIxC,sBAEC,2DAEA,+DACA,6DAED,QAEC,gDACA,sDAED,SAEA,mEAEA,gCAIA,0BAEA,yBAEC,8BAEC,gDACA,4DACA,2DAED,WAEC,sBAEC,2CAEA,wDACA,sDAEA,oCAED,QAEC,gCAED,SAED,IAED,QAEC,sBAEC,2CAEA,wDACA,sDAEA,oCAED,QAEC,gCAED,SAED,SAIA,sEACA,qEAEA,+CAIA,sCACA,mCAIA,uBAEC,4CAEC,yDAED,IAED,SAED,IAEA,CAAC,IAAI,CAAC,KAER,EAMA,KAAQ,CAEP,SAAU,CAAE,MAAS,CAAE,KAAM,IAAK,MAAO,IAAK,EAC3C,MAAS,CAAE,KAAM,IAAK,MAAO,EAAG,CAAE,EAErC,aAAc,4NAed,eAAgB,6LAejB,EAUA,UAAa,CAEZ,SAAU,CAAC,EAEX,aAAc,CAEb,GAAM,WAAW,CAAE,uBAA2B,CAC9C,GAAM,WAAW,CAAE,oBAAwB,CAE3C,gBAEC,GAAM,WAAW,CAAE,eAAmB,CACtC,GAAM,WAAW,CAAE,kBAAsB,CACzC,GAAM,WAAW,CAAE,eAAmB,CACtC,GAAM,WAAW,CAAE,cAAkB,CAEtC,IAEA,CAAC,IAAI,CAAC,MAEP,eAAgB,kWAyBjB,CAED,EAQA,GAAM,aAAa,CAAG,SAAW,CAAU,EAE1C,QAAQ,GAAG,CAAE,sBAAuB,GAAM,QAAQ,EAIlD,IAqKI,EAEA,EACA,EACA,EACA,EA1KA,EAAU,AAAsB,KAAA,IAAtB,AAFd,CAAA,EAAa,GAAc,CAAC,CAAA,EAEH,MAAM,CAAiB,EAAW,MAAM,CAAG,SAAS,aAAa,CAAE,UAE5F,EAAa,AAAyB,KAAA,IAAzB,EAAW,SAAS,CAAiB,EAAW,SAAS,CAAG,QAEzE,EAAS,AAAqB,KAAA,IAArB,EAAW,KAAK,EAAiB,EAAW,KAAK,CAC1D,EAAsB,AAAkC,KAAA,IAAlC,EAAW,kBAAkB,EAAiB,EAAW,kBAAkB,CACjG,EAAa,AAAyB,KAAA,IAAzB,EAAW,SAAS,EAAiB,EAAW,SAAS,CACtE,EAAW,AAAuB,KAAA,IAAvB,EAAW,OAAO,EAAiB,EAAW,OAAO,CAChE,EAAyB,AAAqC,KAAA,IAArC,EAAW,qBAAqB,EAAiB,EAAW,qBAAqB,CAE1G,MAAwD,GAAM,KAAK,CAArD,AAA0B,KAAA,IAA1B,EAAW,UAAU,CAAkC,EAAW,UAAU,CAAsB,GAChH,EAAc,AAA0B,KAAA,IAA1B,EAAW,UAAU,CAAiB,EAAW,UAAU,CAAG,CAI5E,CAAA,IAAI,CAAC,UAAU,CAAG,EAClB,IAAI,CAAC,OAAO,CAAG,KACf,IAAI,CAAC,gBAAgB,CAAG,AAAgC,KAAA,IAAhC,EAAW,gBAAgB,CAC9C,EAAW,gBAAgB,CAC3B,AAA4B,KAAA,IAA5B,OAAO,gBAAgB,CACtB,OAAO,gBAAgB,CACvB,EAIN,IAAI,CAAC,SAAS,CAAG,CAAA,EACjB,IAAI,CAAC,cAAc,CAAG,CAAA,EACtB,IAAI,CAAC,cAAc,CAAG,CAAA,EACtB,IAAI,CAAC,gBAAgB,CAAG,CAAA,EAIxB,IAAI,CAAC,WAAW,CAAG,CAAA,EAEnB,IAAI,CAAC,iBAAiB,CAAG,CAAA,EACzB,IAAI,CAAC,eAAe,CAAG,CAAA,EAIvB,IAAI,CAAC,UAAU,CAAG,CAAA,EAClB,IAAI,CAAC,WAAW,CAAG,CAAA,EACnB,IAAI,CAAC,sBAAsB,CAAG,CAAA,EAI9B,IAAI,CAAC,gBAAgB,CAAG,CAAA,EACxB,IAAI,CAAC,mBAAmB,CAAG,CAAA,EAC3B,IAAI,CAAC,aAAa,CAAG,GAAM,YAAY,CACvC,IAAI,CAAC,iBAAiB,CAAG,GAAM,aAAa,CAC5C,IAAI,CAAC,cAAc,CAAG,CAAA,EACtB,IAAI,CAAC,gBAAgB,CAAG,CAAA,EAIxB,IAAI,CAAC,eAAe,CAAG,EACvB,IAAI,CAAC,eAAe,CAAG,EAIvB,IAAI,CAAC,iBAAiB,CAAG,CAAA,EAIzB,IAAI,CAAC,gBAAgB,CAAG,EAAE,CAC1B,IAAI,CAAC,iBAAiB,CAAG,EAAE,CAI3B,IAAI,CAAC,IAAI,CAAG,CAEX,OAAQ,CAEP,SAAU,EACV,WAAY,EACZ,SAAU,CAEX,EAEA,OAAQ,CAEP,MAAO,EACP,SAAU,EACV,MAAO,EACP,OAAQ,CAET,CAED,EAIA,IAAI,EAAQ,IAAI,CAEhB,EAAY,EAAE,CACd,EAAoB,EAIpB,EAAkB,KAClB,EAAsB,KACtB,EAAqB,GACrB,EAA4B,KAC5B,EAAiB,KACjB,EAAwB,EAExB,EAAoB,EAIpB,EAAkB,GAClB,EAAgB,GAEhB,EAAe,GAEf,EAAoB,GACpB,EAAe,GACf,EAAe,GAEf,EAAgB,GAChB,EAAiB,GAEjB,EAAoB,KACpB,EAA0B,KAC1B,EAAyB,KAEzB,EAAgB,KAEhB,EAAa,EACb,EAAa,EACb,EAAiB,EACjB,EAAkB,EAClB,EAAgB,EAChB,EAAiB,EAEjB,EAAqB,CAAC,EAItB,EAAW,IAAI,GAAM,OAAO,CAI5B,EAAoB,IAAI,GAAM,OAAO,CACrC,EAAsB,IAAI,GAAM,OAAO,CAEvC,EAAW,IAAI,GAAM,OAAO,CAI5B,EAAa,IAAI,GAAM,OAAO,CAE9B,EAAoB,CAAA,EAEpB,EAAU,CAET,QAAS,CAAE,EAAG,EAAG,EAAG,CACpB,YAAa,CAAE,OAAQ,EAAG,OAAQ,EAAR,CAAqB,UAAW,EAAX,AAAuB,EACtE,MAAO,CAAE,OAAQ,EAAG,OAAQ,EAAR,CAAqB,UAAW,EAAX,CAAwB,UAAW,EAAX,AAAuB,EACxF,KAAM,CAAE,OAAQ,EAAG,OAAQ,EAAR,CAAqB,UAAW,EAAX,CAAwB,UAAW,EAAX,CAAwB,WAAY,EAAZ,CAAyB,UAAW,EAAX,CAAwB,UAAW,EAAX,AAAuB,EAChK,KAAM,CAAE,OAAQ,EAAG,UAAW,EAAX,CAAwB,aAAc,EAAd,CAA2B,UAAW,EAAX,AAAuB,CAE9F,EAWA,AAwkOA,CAAA,WAEC,GAAI,CAEH,GAAK,CAAI,CAAA,EAAM,EAAQ,UAAU,CAAE,qBAAsB,CAAE,MAAO,EAAQ,mBAAoB,EAAqB,UAAW,EAAY,QAAS,EAAU,sBAAuB,CAAuB,EAAA,EAE1M,KAAM,+BAIR,CAAE,MAAQ,EAAQ,CAEjB,QAAQ,KAAK,CAAE,EAEhB,CAEA,EAA2B,EAAI,YAAY,CAAE,qBAC7C,EAAkC,EAAI,YAAY,CAAE,4BAEpD,EAAuC,EAAI,YAAY,CAAE,mCAC7C,EAAI,YAAY,CAAE,uCAClB,EAAI,YAAY,CAAE,yCAG9B,EAAoC,EAAI,YAAY,CAAE,kCAC7C,EAAI,YAAY,CAAE,sCAClB,EAAI,YAAY,CAAE,wCAEpB,GAEN,QAAQ,GAAG,CAAE,sDAIP,GAEN,QAAQ,GAAG,CAAE,4DAIP,GAEN,QAAQ,GAAG,CAAE,qEAIP,GAEN,QAAQ,GAAG,CAAE,gEAIwB,KAAA,IAAjC,EAAI,wBAAwB,EAEhC,CAAA,EAAI,wBAAwB,CAAG,WAE9B,MAAO,CACN,SAAc,EACd,SAAc,EACd,UAAc,CACf,CAED,CAAA,CAGF,CAAA,IAIC,EAAI,UAAU,CAAE,EAAG,EAAG,EAAG,GACzB,EAAI,UAAU,CAAE,GAChB,EAAI,YAAY,CAAE,GAElB,EAAI,MAAM,CAAE,EAAI,UAAU,EAC1B,EAAI,SAAS,CAAE,EAAI,MAAM,EAEzB,EAAI,SAAS,CAAE,EAAI,GAAG,EACtB,EAAI,QAAQ,CAAE,EAAI,IAAI,EACtB,EAAI,MAAM,CAAE,EAAI,SAAS,EAEzB,EAAI,MAAM,CAAE,EAAI,KAAK,EACrB,EAAI,aAAa,CAAE,EAAI,QAAQ,EAC/B,EAAI,SAAS,CAAE,EAAI,SAAS,CAAE,EAAI,mBAAmB,EAErD,EAAI,UAAU,CAAE,EAAY,CAAC,CAAE,EAAY,CAAC,CAAE,EAAY,CAAC,CAAE,GAxpO9D,IAAI,CAAC,OAAO,CAAG,EAIf,IAAI,EAAe,EAAI,YAAY,CAAE,EAAI,uBAAuB,EAC5D,EAAqB,EAAI,YAAY,CAAE,EAAI,8BAA8B,EACvD,EAAI,YAAY,CAAE,EAAI,gBAAgB,EAC5D,IAAI,EAAkB,EAAI,YAAY,CAAE,EAAI,yBAAyB,EAEjE,GAAiB,EAAuC,EAAI,YAAY,CAAE,EAAqC,8BAA8B,EAAK,EAElJ,GAA4B,EAAqB,EACjD,GAAwB,IAA2B,CAEvB,CAAA,GAAoC,EAAI,YAAY,CAAE,EAAI,0BAA0B,EAIpH,IAAI,GAAmC,EAAI,wBAAwB,CAAE,EAAI,aAAa,CAAE,EAAI,UAAU,EAClG,GAAqC,EAAI,wBAAwB,CAAE,EAAI,aAAa,CAAE,EAAI,YAAY,EACpE,EAAI,wBAAwB,CAAE,EAAI,aAAa,CAAE,EAAI,SAAS,EAEpG,IAAI,GAAqC,EAAI,wBAAwB,CAAE,EAAI,eAAe,CAAE,EAAI,UAAU,EACtG,GAAuC,EAAI,wBAAwB,CAAE,EAAI,eAAe,CAAE,EAAI,YAAY,EACtE,EAAI,wBAAwB,CAAE,EAAI,eAAe,CAAE,EAAI,SAAS,EAEnE,EAAI,wBAAwB,CAAE,EAAI,aAAa,CAAE,EAAI,QAAQ,EAC3D,EAAI,wBAAwB,CAAE,EAAI,aAAa,CAAE,EAAI,UAAU,EAClE,EAAI,wBAAwB,CAAE,EAAI,aAAa,CAAE,EAAI,OAAO,EAEzD,EAAI,wBAAwB,CAAE,EAAI,eAAe,CAAE,EAAI,QAAQ,EAC7D,EAAI,wBAAwB,CAAE,EAAI,eAAe,CAAE,EAAI,UAAU,EACpE,EAAI,wBAAwB,CAAE,EAAI,eAAe,CAAE,EAAI,OAAO,EAIpG,IAAI,GAAiB,GAAiC,SAAS,CAAG,GAAK,GAAmC,SAAS,CAAG,EAClH,GAAmB,GAAmC,SAAS,CAAG,GAAK,GAAqC,SAAS,CAAG,CAExG,CAAA,UAAf,GAA4B,KAE3B,IAEJ,EAAa,UACb,QAAQ,IAAI,CAAE,uDAId,EAAa,OACb,QAAQ,IAAI,CAAE,gEAMI,YAAf,GAA8B,KAElC,EAAa,OACb,QAAQ,IAAI,CAAE,qDAMf,IAAI,CAAC,UAAU,CAAG,WAEjB,OAAO,CAER,EAEA,IAAI,CAAC,sBAAsB,CAAG,WAE7B,OAAO,EAER,EAEA,IAAI,CAAC,qBAAqB,CAAG,WAE5B,OAAO,CAER,EAEA,IAAI,CAAC,2BAA2B,CAAG,WAElC,OAAO,CAER,EAEA,IAAI,CAAC,6BAA6B,CAAG,WAEpC,OAAO,CAER,EAEA,IAAI,CAAC,gBAAgB,CAAI,WAExB,OAAO,EAER,EAEA,IAAI,CAAC,YAAY,CAAG,WAEnB,OAAO,CAER,EAEA,IAAI,CAAC,OAAO,CAAG,SAAW,CAAK,CAAE,CAAM,EAEtC,EAAQ,KAAK,CAAG,EAAQ,IAAI,CAAC,gBAAgB,CAC7C,EAAQ,MAAM,CAAG,EAAS,IAAI,CAAC,gBAAgB,CAE/C,EAAQ,KAAK,CAAC,KAAK,CAAG,EAAQ,KAC9B,EAAQ,KAAK,CAAC,MAAM,CAAG,EAAS,KAEhC,IAAI,CAAC,WAAW,CAAE,EAAG,EAAG,EAAQ,KAAK,CAAE,EAAQ,MAAM,CAEtD,EAEA,IAAI,CAAC,WAAW,CAAG,SAAW,CAAC,CAAE,CAAC,CAAE,CAAK,CAAE,CAAM,EAEhD,EAAa,AAAM,KAAA,IAAN,EAAkB,EAAI,EACnC,EAAa,AAAM,KAAA,IAAN,EAAkB,EAAI,EAEnC,EAAiB,AAAU,KAAA,IAAV,EAAsB,EAAQ,EAAQ,KAAK,CAC5D,EAAkB,AAAW,KAAA,IAAX,EAAuB,EAAS,EAAQ,MAAM,CAEhE,EAAI,QAAQ,CAAE,EAAY,EAAY,EAAgB,EAEvD,EAEA,IAAI,CAAC,UAAU,CAAG,SAAW,CAAC,CAAE,CAAC,CAAE,CAAK,CAAE,CAAM,EAE/C,EAAI,OAAO,CAAE,EAAG,EAAG,EAAO,EAE3B,EAEA,IAAI,CAAC,iBAAiB,CAAG,SAAW,CAAM,EAEzC,EAAS,EAAI,MAAM,CAAE,EAAI,YAAY,EAAK,EAAI,OAAO,CAAE,EAAI,YAAY,CAExE,EAIA,IAAI,CAAC,gBAAgB,CAAG,SAAW,CAAG,CAAE,CAAK,EAE5C,EAAY,MAAM,CAAE,GACpB,EAAc,EAEd,EAAI,UAAU,CAAE,EAAY,CAAC,CAAE,EAAY,CAAC,CAAE,EAAY,CAAC,CAAE,EAE9D,EAEA,IAAI,CAAC,aAAa,CAAG,SAAW,CAAK,CAAE,CAAK,EAE3C,EAAY,IAAI,CAAE,GAClB,EAAc,EAEd,EAAI,UAAU,CAAE,EAAY,CAAC,CAAE,EAAY,CAAC,CAAE,EAAY,CAAC,CAAE,EAE9D,EAEA,IAAI,CAAC,aAAa,CAAG,WAEpB,OAAO,CAER,EAEA,IAAI,CAAC,aAAa,CAAG,WAEpB,OAAO,CAER,EAEA,IAAI,CAAC,KAAK,CAAG,SAAW,CAAK,CAAE,CAAK,CAAE,CAAO,EAE5C,IAAI,EAAO,EAEN,CAAA,AAAU,KAAA,IAAV,GAAuB,CAAA,GAAQ,CAAA,GAAQ,EAAI,gBAAgB,AAAhB,EAC3C,CAAA,AAAU,KAAA,IAAV,GAAuB,CAAA,GAAQ,CAAA,GAAQ,EAAI,gBAAgB,AAAhB,EAC3C,CAAA,AAAY,KAAA,IAAZ,GAAyB,CAAA,GAAU,CAAA,GAAQ,EAAI,kBAAkB,AAAlB,EAEpD,EAAI,KAAK,CAAE,EAEZ,EAEA,IAAI,CAAC,WAAW,CAAG,SAAW,CAAY,CAAE,CAAK,CAAE,CAAK,CAAE,CAAO,EAEhE,IAAI,CAAC,eAAe,CAAE,GACtB,IAAI,CAAC,KAAK,CAAE,EAAO,EAAO,EAE3B,EAIA,IAAI,CAAC,aAAa,CAAG,SAAW,CAAM,EAErC,EAAO,IAAI,CAAE,IAAI,EACjB,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAE,EAE9B,EAEA,IAAI,CAAC,YAAY,CAAG,SAAW,CAAM,EAEpC,EAAO,IAAI,CAAE,IAAI,EACjB,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAE,EAE7B,EAIA,IAAI,CAAC,eAAe,CAAG,SAAW,CAAK,CAAE,CAAM,EAE9C,EAAkB,KAClB,EAAe,GACf,EAAgB,GAChB,EAAiB,GACjB,EAA4B,GAC5B,EAAqB,GACrB,EAAoB,CAAA,EACpB,EAAkB,GAClB,EAAgB,GAEhB,IAAI,CAAC,eAAe,CAAC,MAAM,CAAE,EAAO,EAErC,EAkFA,IAAI,GAAoB,SAAW,CAAK,EAEvC,IAAI,EAAW,EAAM,MAAM,CAE3B,EAAS,mBAAmB,CAAE,UAAW,IAEzC,GAAoB,GAEpB,EAAM,IAAI,CAAC,MAAM,CAAC,UAAU,EAE7B,EAEI,GAAmB,SAAW,CAAK,EAEtC,IAAI,EAAU,EAAM,MAAM,CAE1B,EAAQ,mBAAmB,CAAE,UAAW,IAExC,GAAmB,GAEnB,EAAM,IAAI,CAAC,MAAM,CAAC,QAAQ,EAG3B,EAEI,GAAwB,SAAW,CAAK,EAE3C,IAAI,EAAe,EAAM,MAAM,CAE/B,EAAa,mBAAmB,CAAE,UAAW,IAE7C,GAAwB,GAExB,EAAM,IAAI,CAAC,MAAM,CAAC,QAAQ,EAE3B,EAEI,GAAoB,SAAW,CAAK,EAEvC,IAAI,EAAW,EAAM,MAAM,CAE3B,EAAS,mBAAmB,CAAE,UAAW,IAEzC,GAAoB,EAErB,EAII,GAAqB,SAAW,CAAQ,EAqB3C,GAnBA,EAAS,WAAW,CAAG,KAAA,EAEe,KAAA,IAAjC,EAAS,mBAAmB,EAAiB,EAAI,YAAY,CAAE,EAAS,mBAAmB,EAC1D,KAAA,IAAjC,EAAS,mBAAmB,EAAiB,EAAI,YAAY,CAAE,EAAS,mBAAmB,EACzD,KAAA,IAAlC,EAAS,oBAAoB,EAAiB,EAAI,YAAY,CAAE,EAAS,oBAAoB,EAC7D,KAAA,IAAhC,EAAS,kBAAkB,EAAiB,EAAI,YAAY,CAAE,EAAS,kBAAkB,EAC5D,KAAA,IAA7B,EAAS,eAAe,EAAiB,EAAI,YAAY,CAAE,EAAS,eAAe,EACrD,KAAA,IAA9B,EAAS,gBAAgB,EAAiB,EAAI,YAAY,CAAE,EAAS,gBAAgB,EAE/C,KAAA,IAAtC,EAAS,wBAAwB,EAAiB,EAAI,YAAY,CAAE,EAAS,wBAAwB,EAC/D,KAAA,IAAtC,EAAS,wBAAwB,EAAiB,EAAI,YAAY,CAAE,EAAS,wBAAwB,EAEtE,KAAA,IAA/B,EAAS,iBAAiB,EAAiB,EAAI,YAAY,CAAE,EAAS,iBAAiB,EACxD,KAAA,IAA/B,EAAS,iBAAiB,EAAiB,EAAI,YAAY,CAAE,EAAS,iBAAiB,EAEhD,KAAA,IAAvC,EAAS,yBAAyB,EAAiB,EAAI,YAAY,CAAE,EAAS,yBAAyB,EAIvG,AAA4B,KAAA,IAA5B,EAAS,cAAc,CAE3B,IAAM,IAAI,KAAK,EAAS,cAAc,CAAG,CAExC,IAAI,EAAgB,EAAS,cAAc,CAAE,EAAG,CAEhD,GAAK,AAAkC,KAAA,IAAlC,EAAc,eAAe,CAEjC,IAAM,IAAI,EAAI,EAAG,EAAK,EAAc,eAAe,CAAE,EAAI,EAAI,IAE5D,EAAI,YAAY,CAAE,EAAc,0BAA0B,CAAE,EAAG,EAMjE,GAAK,AAAkC,KAAA,IAAlC,EAAc,eAAe,CAEjC,IAAM,IAAI,EAAI,EAAG,EAAK,EAAc,eAAe,CAAE,EAAI,EAAI,IAE5D,EAAI,YAAY,CAAE,EAAc,0BAA0B,CAAE,EAAG,EAMjE,GAA+B,EAEhC,CAID,GAA+B,EAEhC,EAEI,GAAoB,SAAW,CAAO,EAEzC,GAAK,EAAQ,KAAK,EAAI,EAAQ,KAAK,CAAC,kBAAkB,CAIrD,EAAI,aAAa,CAAE,EAAQ,KAAK,CAAC,kBAAkB,MAE7C,CAIN,GAAK,CAAE,EAAQ,WAAW,CAAG,MAE7B,CAAA,EAAQ,WAAW,CAAG,CAAA,EACtB,EAAI,aAAa,CAAE,EAAQ,cAAc,CAE1C,CAED,EAEI,GAAyB,SAAW,CAAY,EAEnD,GAAK,AAAC,GAAkB,EAAa,cAAc,EAInD,GAFA,EAAI,aAAa,CAAE,EAAa,cAAc,EAEzC,aAAwB,GAAM,qBAAqB,CAEvD,IAAM,IAAI,EAAI,EAAG,EAAI,EAAG,IAEvB,EAAI,iBAAiB,CAAE,EAAa,kBAAkB,CAAE,EAAG,EAC3D,EAAI,kBAAkB,CAAE,EAAa,mBAAmB,CAAE,EAAG,OAM9D,EAAI,iBAAiB,CAAE,EAAa,kBAAkB,EACtD,EAAI,kBAAkB,CAAE,EAAa,mBAAmB,EAI1D,EAEI,GAAqB,SAAW,CAAQ,EAE3C,IAUI,EAAG,EAAI,EAVP,EAAU,EAAS,OAAO,CAE9B,GAAK,AAAY,KAAA,IAAZ,GAEL,EAAS,OAAO,CAAG,KAAA,EAOnB,IAAI,EAAgB,CAAA,EAEpB,IAAM,EAAI,EAAG,EAAK,EAAU,MAAM,CAAE,EAAI,EAAI,IAI3C,GAAK,AAFL,CAAA,EAAc,CAAS,CAAE,EAAG,AAAH,EAER,OAAO,GAAK,EAAU,CAEtC,EAAY,SAAS,GAEU,IAA1B,EAAY,SAAS,EAEzB,CAAA,EAAgB,CAAA,CAFjB,EAMA,KAED,CAID,GAAK,AAAkB,CAAA,IAAlB,EAAyB,CAI7B,IAAI,EAAc,EAAE,CAEpB,IAAM,EAAI,EAAG,EAAK,EAAU,MAAM,CAAE,EAAI,EAAI,IAItC,AAFL,CAAA,EAAc,CAAS,CAAE,EAAG,AAAH,EAER,OAAO,GAAK,GAE5B,EAAY,IAAI,CAAE,GAMpB,EAAY,EAEZ,EAAI,aAAa,CAAE,GAEnB,EAAM,IAAI,CAAC,MAAM,CAAC,QAAQ,EAE3B,EAED,EAoFA,SAAS,GAA+B,CAAQ,EAE/C,GAAK,EAAS,2BAA2B,CAExC,IAAM,IAAI,KAAM,EAAS,2BAA2B,CAEnD,EAAI,YAAY,CAAE,EAAS,2BAA2B,CAAE,EAAI,CAAC,MAAM,CAMtE,CAIA,SAAS,GAAuB,CAAQ,CAAE,CAAM,EAE/C,IAAI,EAAY,EAAS,QAAQ,CAAC,MAAM,CAEpC,EAAW,EAAO,QAAQ,CAE9B,GAAK,EAAS,UAAU,CAQvB,IAAM,IAAI,KANoC,KAAA,IAAzC,EAAS,2BAA2B,EAExC,CAAA,EAAS,2BAA2B,CAAG,EAAE,AAAF,EAIzB,EAAS,UAAU,CAAG,CAEpC,IAAI,EAAY,EAAS,UAAU,CAAE,EAAG,CAExC,GAAK,CAAC,EAAU,kBAAkB,EAAI,EAAU,mBAAmB,CAAG,CAErE,EAAU,kBAAkB,CAAG,CAAA,EAE/B,IAAI,EAAO,CAEN,AAAmB,CAAA,OAAnB,EAAU,IAAI,CAAY,EAAO,EAC5B,AAAmB,OAAnB,EAAU,IAAI,CAAY,EAAO,EACjC,AAAmB,OAAnB,EAAU,IAAI,CAAY,EAAO,EACd,MAAnB,EAAU,IAAI,EAAY,CAAA,EAAO,CAAA,EAE3C,EAAU,IAAI,CAAG,EAEjB,EAAU,KAAK,CAAG,IAAI,aAAc,EAAY,GAEhD,EAAU,MAAM,CAAG,EAAI,YAAY,GACnC,EAAU,MAAM,CAAC,kBAAkB,CAAG,EAEtC,EAAU,WAAW,CAAG,CAAA,CAEzB,CAEA,EAAS,2BAA2B,CAAC,IAAI,CAAE,EAE5C,CAIF,CA6CA,SAAS,GAAkB,CAAa,CAAE,CAAM,EAE/C,IA8DI,EAAG,EA9DH,EAAW,EAAO,QAAQ,CAC7B,EAAS,EAAc,MAAM,CAC7B,EAAS,EAAc,MAAM,CAE7B,EAAY,AAAgB,EAAhB,EAAO,MAAM,CAAO,AAAgB,EAAhB,EAAO,MAAM,CAC7C,EAAY,AAAgB,EAAhB,EAAO,MAAM,CAAO,AAAgB,EAAhB,EAAO,MAAM,CAC7C,EAAY,AAAgB,EAAhB,EAAO,MAAM,CAAO,AAAgB,EAAhB,EAAO,MAAM,CAE7C,EAAW,GAAmB,EAAQ,GAEtC,EAAS,GAAmB,GAC5B,EAAa,GAAuB,GACpC,EAAkB,GAA4B,GAoD/C,GAhDA,EAAc,aAAa,CAAG,IAAI,aAAc,AAAY,EAAZ,GAE3C,GAEJ,CAAA,EAAc,aAAa,CAAG,IAAI,aAAc,AAAY,EAAZ,EAFjD,EAMK,EAAS,WAAW,EAExB,CAAA,EAAc,cAAc,CAAG,IAAI,aAAc,AAAY,EAAZ,EAFlD,EAMK,GAEJ,CAAA,EAAc,YAAY,CAAG,IAAI,aAAc,AAAY,EAAZ,EAFhD,EAMK,IAEC,CAAA,EAAS,OAAO,CAAC,MAAM,CAAG,GAAK,EAAS,aAAa,CAAC,MAAM,CAAG,CAAA,GAEnE,CAAA,EAAc,SAAS,CAAG,IAAI,aAAc,AAAY,EAAZ,EAF7C,EAMK,CAAA,EAAS,OAAO,CAAC,MAAM,CAAG,GAAK,EAAS,aAAa,CAAC,MAAM,CAAG,CAAA,GAEnE,CAAA,EAAc,UAAU,CAAG,IAAI,aAAc,AAAY,EAAZ,EAF9C,GAQI,EAAO,QAAQ,CAAC,WAAW,CAAC,MAAM,EAAI,EAAO,QAAQ,CAAC,WAAW,CAAC,MAAM,GAE5E,EAAc,gBAAgB,CAAG,IAAI,aAAc,AAAY,EAAZ,GACnD,EAAc,iBAAiB,CAAG,IAAI,aAAc,AAAY,EAAZ,IAIrD,EAAc,WAAW,CAAG,IAAI,YAAa,AAAQ,EAAR,GAC7C,EAAc,WAAW,CAAG,IAAI,YAAa,AAAS,EAAT,GAIxC,EAAc,eAAe,CAIjC,IAAM,EAAI,EAFV,EAAc,oBAAoB,CAAG,EAAE,CAE1B,EAAK,EAAc,eAAe,CAAE,EAAI,EAAI,IAExD,EAAc,oBAAoB,CAAC,IAAI,CAAE,IAAI,aAAc,AAAY,EAAZ,IAM7D,GAAK,EAAc,eAAe,CAIjC,IAAM,EAAI,EAFV,EAAc,oBAAoB,CAAG,EAAE,CAE1B,EAAK,EAAc,eAAe,CAAE,EAAI,EAAI,IAExD,EAAc,oBAAoB,CAAC,IAAI,CAAE,IAAI,aAAc,AAAY,EAAZ,IAY7D,GANA,EAAc,gBAAgB,CAAG,AAAQ,EAAR,EACjC,EAAc,gBAAgB,CAAG,AAAS,EAAT,EAK5B,EAAS,UAAU,CAQvB,IAAM,IAAI,KANyC,KAAA,IAA9C,EAAc,2BAA2B,EAE7C,CAAA,EAAc,2BAA2B,CAAG,EAAE,AAAF,EAI9B,EAAS,UAAU,CAAG,CAKpC,IAAI,EAAoB,EAAS,UAAU,CAAE,EAAG,CAE5C,EAAY,CAAC,EAEjB,IAAM,IAAI,KAAY,EAErB,CAAS,CAAE,EAAU,CAAG,CAAiB,CAAE,EAAU,CAItD,GAAK,CAAC,EAAU,kBAAkB,EAAI,EAAU,mBAAmB,CAAG,CAErE,EAAU,kBAAkB,CAAG,CAAA,EAE/B,IAAI,EAAO,CAEP,AAAmB,CAAA,OAAnB,EAAU,IAAI,CAAY,EAAO,EAC5B,AAAmB,OAAnB,EAAU,IAAI,CAAY,EAAO,EACjC,AAAmB,OAAnB,EAAU,IAAI,CAAY,EAAO,EACd,MAAnB,EAAU,IAAI,EAAY,CAAA,EAAO,CAAA,EAE1C,EAAU,IAAI,CAAG,EAEjB,EAAU,KAAK,CAAG,IAAI,aAAc,EAAY,GAEhD,EAAU,MAAM,CAAG,EAAI,YAAY,GACnC,EAAU,MAAM,CAAC,kBAAkB,CAAG,EAEtC,EAAkB,WAAW,CAAG,CAAA,EAChC,EAAU,UAAU,CAAG,CAExB,CAEA,EAAc,2BAA2B,CAAC,IAAI,CAAE,EAEjD,CAID,EAAc,eAAe,CAAG,CAAA,CAEjC,CAEA,SAAS,GAAmB,CAAM,CAAE,CAAa,EAEhD,OAAO,EAAO,QAAQ,YAAY,GAAM,gBAAgB,CACrD,EAAO,QAAQ,CAAC,SAAS,CAAE,EAAc,aAAa,CAAE,CACxD,EAAO,QAAQ,AAEnB,CAQA,SAAS,GAAwB,CAAQ,QAIxC,AAAO,CAAA,CAAA,CAAA,aAAoB,GAAM,iBAAiB,AAAjB,IAAqB,CAAC,EAAS,MAAM,AAAN,IAAY,CAAA,aAAoB,GAAM,iBAAiB,AAAjB,GAMtG,CAAA,AAdO,AAc0B,GAdd,AAAqB,KAAA,IAArB,AAcc,EAdL,OAAO,EAAkB,AAcpB,EAd6B,OAAO,GAAK,GAAM,aAAa,CAgBrF,GAAM,aAAa,CAInB,GAAM,WAAW,CAI1B,CAEA,SAAS,GAA6B,CAAQ,QAE7C,EAAK,EAAS,YAAY,EAElB,EAAS,YAAY,AAM9B,CAEA,SAAS,GAAoB,CAAQ,QAI/B,EAAA,EAAS,GAAG,IAAI,EAAS,QAAQ,IAAI,EAAS,OAAO,IAAI,EAAS,SAAS,IAAI,EAAS,WAAW,EAAI,aAAoB,GAAM,cAAc,AAQrJ,CAIA,SAAS,GAAmB,CAAQ,EAEnC,IAAI,EAAG,EAAW,EAElB,IAAM,KAAK,EAAS,UAAU,CAI5B,EAFI,AAAM,UAAN,EAEG,EAAI,oBAAoB,CAIxB,EAAI,YAAY,CAMxB,AAFA,CAAA,EAAY,EAAS,UAAU,CAAE,EAAG,AAAH,EAEvB,MAAM,CAAG,EAAI,YAAY,GAEnC,EAAI,UAAU,CAAE,EAAM,EAAU,MAAM,EACtC,EAAI,UAAU,CAAE,EAAM,EAAU,KAAK,CAAE,EAAI,WAAW,CAIxD,CAgjEA,SAAS,GAAmB,CAAQ,CAAE,CAAI,CAAE,CAAO,EAElD,IAAI,EAAa,EAAS,UAAU,CAEhC,EAAQ,EAAY,KAAS,CAC7B,EAAW,EAAY,QAAY,CACnC,EAAS,EAAY,MAAU,CAC/B,EAAK,EAAY,EAAM,CACvB,EAAQ,EAAY,KAAS,CAC7B,EAAU,EAAY,OAAW,CA4CrC,GA1CK,EAAS,kBAAkB,EAAI,AAAU,KAAA,IAAV,IAEnC,EAAI,UAAU,CAAE,EAAI,oBAAoB,CAAE,EAAM,MAAM,EACtD,EAAI,UAAU,CAAE,EAAI,oBAAoB,CAAE,EAAM,KAAK,CAAE,IAInD,EAAS,kBAAkB,EAAI,AAAa,KAAA,IAAb,IAEnC,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAS,MAAM,EACjD,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAS,KAAK,CAAE,IAI9C,EAAS,iBAAiB,EAAI,AAAW,KAAA,IAAX,IAElC,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAO,MAAM,EAC/C,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAO,KAAK,CAAE,IAI5C,EAAS,aAAa,EAAI,AAAO,KAAA,IAAP,IAE9B,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAG,MAAM,EAC3C,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAG,KAAK,CAAE,IAIxC,EAAS,gBAAgB,EAAI,AAAU,KAAA,IAAV,IAEjC,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAM,MAAM,EAC9C,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAM,KAAK,CAAE,IAI3C,EAAS,kBAAkB,EAAI,AAAY,KAAA,IAAZ,IAEnC,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAQ,MAAM,EAChD,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAQ,KAAK,CAAE,IAI7C,EAEJ,IAAM,IAAI,KAAK,EAAS,UAAU,CAEjC,OAAO,EAAS,UAAU,CAAE,EAAG,CAAC,KAAK,AAMxC,CAulBA,SAAS,GAAiB,CAAS,EAE3B,CAAkB,CAAE,EAAW,GAErC,EAAI,uBAAuB,CAAE,GAC7B,CAAkB,CAAE,EAAW,CAAG,CAAA,EAIpC,CAEA,SAAS,KAER,IAAM,IAAI,KAAa,EAEjB,CAAkB,CAAE,EAAW,GAEnC,EAAI,wBAAwB,CAAE,GAC9B,CAAkB,CAAE,EAAW,CAAG,CAAA,EAMrC,CAqJA,SAAS,GAAoB,CAAC,CAAE,CAAC,SAEhC,AAAK,EAAE,CAAC,GAAK,EAAE,CAAC,CAER,EAAE,CAAC,CAAG,EAAE,CAAC,CAIT,EAAE,EAAE,CAAG,EAAE,EAAE,AAIpB,CAEA,SAAS,GAAgB,CAAC,CAAE,CAAC,EAE5B,OAAO,CAAC,CAAE,EAAG,CAAG,CAAC,CAAE,EAAG,AAEvB,CA0LA,SAAS,GAAe,CAAO,CAAE,CAAK,CAAE,CAAM,EAE7C,GAAO,EAAQ,MAAM,CAErB,IAAM,IAAI,EAAI,EAAG,EAAK,EAAQ,MAAM,CAAE,EAAI,EAAI,IAI7C,EAAkB,KAClB,EAAiB,KAEjB,EAAe,GACf,EAAgB,GAChB,EAAiB,GACjB,EAAkB,GAClB,EAAgB,GAChB,EAA4B,GAC5B,EAAqB,GAErB,EAAoB,CAAA,EAEpB,CAAO,CAAE,EAAG,CAAC,MAAM,CAAE,EAAO,EAAQ,EAAe,GAInD,EAAkB,KAClB,EAAiB,KAEjB,EAAe,GACf,EAAgB,GAChB,EAAiB,GACjB,EAAkB,GAClB,EAAgB,GAChB,EAA4B,GAC5B,EAAqB,GAErB,EAAoB,CAAA,CAItB,CAEA,SAAS,GAAgB,CAAU,CAAE,CAAO,CAAE,CAAY,CAAE,CAAM,CAAE,CAAM,CAAE,CAAG,CAAE,CAAW,CAAE,CAAgB,EAE7G,IAAI,EAAa,EAAQ,EAAQ,EAAU,EAAO,EAAK,EAElD,GAEJ,EAAQ,EAAW,MAAM,CAAG,EAC5B,EAAM,GACN,EAAQ,KAIR,EAAQ,EACR,EAAM,EAAW,MAAM,CACvB,EAAQ,GAGT,IAAM,IAAI,EAAI,EAAO,IAAM,EAAK,GAAK,EAIpC,GAAK,AAFL,CAAA,EAAc,CAAU,CAAE,EAAG,AAAH,EAET,MAAM,CAAG,CAKzB,GAHA,EAAS,EAAY,MAAM,CAC3B,EAAS,EAAY,MAAM,CAEtB,EAEJ,EAAW,MAEL,CAIN,GAAK,CAFL,CAAA,EAAW,CAAW,CAAE,EAAc,AAAd,EAEN,SAEb,GAAc,EAAM,WAAW,CAAE,EAAS,QAAQ,CAAE,EAAS,aAAa,CAAE,EAAS,QAAQ,CAAE,EAAS,QAAQ,EAErH,EAAM,YAAY,CAAE,EAAS,SAAS,EACtC,EAAM,aAAa,CAAE,EAAS,UAAU,EACxC,GAAkB,EAAS,aAAa,CAAE,EAAS,mBAAmB,CAAE,EAAS,kBAAkB,CAEpG,CAEA,EAAM,gBAAgB,CAAE,GAEnB,aAAkB,GAAM,cAAc,CAE1C,EAAM,kBAAkB,CAAE,EAAQ,EAAQ,EAAK,EAAU,EAAQ,GAIjE,EAAM,YAAY,CAAE,EAAQ,EAAQ,EAAK,EAAU,EAAQ,EAI7D,CAIF,CAEA,SAAS,GAAyB,CAAU,CAAE,CAAY,CAAE,CAAM,CAAE,CAAM,CAAE,CAAG,CAAE,CAAW,CAAE,CAAgB,EAI7G,IAAM,IAFF,EAAa,EAAQ,EAEf,EAAI,EAAG,EAAK,EAAW,MAAM,CAAE,EAAI,EAAI,IAKhD,GAAK,AAFL,CAAA,EAAS,AADT,CAAA,EAAc,CAAU,CAAE,EAAG,AAAH,EACL,MAAM,AAAN,EAET,OAAO,CAAG,CAErB,GAAK,EAEJ,EAAW,MAEL,CAIN,GAAK,CAFL,CAAA,EAAW,CAAW,CAAE,EAAc,AAAd,EAEN,SAEb,GAAc,EAAM,WAAW,CAAE,EAAS,QAAQ,CAAE,EAAS,aAAa,CAAE,EAAS,QAAQ,CAAE,EAAS,QAAQ,EAErH,EAAM,YAAY,CAAE,EAAS,SAAS,EACtC,EAAM,aAAa,CAAE,EAAS,UAAU,EACxC,GAAkB,EAAS,aAAa,CAAE,EAAS,mBAAmB,CAAE,EAAS,kBAAkB,CAEpG,CAEA,EAAM,qBAAqB,CAAE,EAAQ,EAAQ,EAAK,EAAU,EAE7D,CAIF,CA4XA,SAAS,GAAY,CAAO,CAAE,CAAM,CAAE,CAAM,EAE3C,EAAQ,IAAI,CACX,CACC,OAAQ,EACR,OAAQ,EACR,OAAQ,KACR,YAAa,IACd,EAGF,CA2KA,SAAS,GAA2B,CAAQ,EAE3C,IAAM,IAAI,KAAK,EAAS,UAAU,CAEjC,GAAK,EAAS,UAAU,CAAE,EAAG,CAAC,WAAW,CAAG,MAAO,CAAA,EAIpD,MAAO,CAAA,CAER,CAEA,SAAS,GAAwB,CAAQ,EAExC,IAAM,IAAI,KAAK,EAAS,UAAU,CAEjC,EAAS,UAAU,CAAE,EAAG,CAAC,WAAW,CAAG,CAAA,CAIzC,CA+BA,SAAS,GAAkB,CAAO,CAAE,CAAM,EAEzC,IAAM,IAAI,EAAI,EAAQ,MAAM,CAAG,EAAG,GAAK,EAAG,IAEpC,CAAO,CAAE,EAAG,CAAC,MAAM,GAAK,GAE5B,EAAQ,MAAM,CAAE,EAAG,EAMtB,CAEA,SAAS,GAAwB,CAAO,CAAE,CAAM,EAE/C,IAAM,IAAI,EAAI,EAAQ,MAAM,CAAG,EAAG,GAAK,EAAG,IAEpC,CAAO,CAAE,EAAG,GAAK,GAErB,EAAQ,MAAM,CAAE,EAAG,EAMtB,CAyKA,SAAS,GAAY,CAAM,CAAE,CAAM,CAAE,CAAG,CAAE,CAAQ,CAAE,CAAM,EAEzD,EAAoB,EAEf,EAAS,WAAW,GAEnB,EAAS,OAAO,EAAG,GAAoB,GAE5C,EAAM,YAAY,CAAE,EAAU,EAAQ,EAAK,GAC3C,EAAS,WAAW,CAAG,CAAA,GAInB,EAAS,YAAY,EAEpB,CAAE,EAAO,4BAA4B,EAEzC,CAAA,EAAO,4BAA4B,CAAG,IAAI,aAAc,EAAM,eAAe,CAAA,EAM/E,IAAI,EAAkB,CAAA,EAElB,EAAU,EAAS,OAAO,CAC7B,EAAa,EAAQ,QAAQ,CAC7B,EAAa,EAAS,QAAQ,CA8B/B,GA5BK,IAAY,IAEhB,EAAI,UAAU,CAAE,GAChB,EAAkB,EAElB,EAAkB,CAAA,GAId,EAAS,EAAE,GAAK,IAEpB,EAAqB,EAAS,EAAE,CAChC,EAAkB,CAAA,GAId,CAAA,GAAmB,IAAW,CAAA,IAElC,EAAI,gBAAgB,CAAE,EAAW,gBAAgB,CAAE,CAAA,EAAO,EAAO,gBAAgB,CAAC,QAAQ,EAErF,IAAW,GAAiB,CAAA,EAAiB,CAAlD,GAQI,EAAS,QAAQ,EAErB,GAAK,IAAyB,EAAO,gBAAgB,CAEpD,CAAA,GAAK,AAA2B,OAA3B,EAAW,WAAW,CAAY,CAEtC,IAAI,EAAc,KAElB,EAAI,SAAS,CAAE,EAAW,WAAW,CAAE,GACvC,EAAM,UAAU,CAAE,EAAO,WAAW,CAAE,EAEvC,CAAA,MAIuC,OAAlC,EAAW,kBAAkB,EAEjC,EAAI,gBAAgB,CAAE,EAAW,kBAAkB,CAAE,CAAA,EAAO,EAAO,YAAY,EA6HlF,OArHK,IAIC,GAAO,EAAS,GAAG,GA0OzB,AAxOsB,EAwOb,QAAQ,CAAC,KAAK,CAAG,AAxOQ,EAwOJ,KAAK,CAE9B,AA1O6B,aA0Od,GAAM,GAAG,EAE5B,AA5OqB,EA4OZ,OAAO,CAAC,KAAK,CAAG,AA5OQ,EA4OJ,IAAI,CACjC,AA7OqB,EA6OZ,MAAM,CAAC,KAAK,CAAG,AA7OS,EA6OL,GAAG,EA7OE,aA+OP,GAAM,OAAO,EAEvC,CAAA,AAjPqB,EAiPZ,UAAU,CAAC,KAAK,CAAG,AAjPK,EAiPD,OAAO,AAAP,GA7O3B,CAAA,aAAoB,GAAM,iBAAiB,EAC9C,aAAoB,GAAM,mBAAmB,EAC7C,EAAS,MAAM,AAAN,IAEL,IAEJ,AAmlBJ,SAAuB,CAAO,CAAE,CAAM,EAErC,IAAI,EAAG,EAAI,EAEX,EAAO,EAAU,EACjB,EAAY,EAEZ,EAJA,EAAI,EAAG,EAAI,EAAG,EAAI,EAQlB,EAAY,AAFF,EAEU,WAAW,CAAC,MAAM,CACtC,EAAe,AAHL,EAGa,WAAW,CAAC,SAAS,CAE5C,EAAc,AALJ,EAKY,KAAK,CAAC,MAAM,CAClC,EAAiB,AANP,EAMe,KAAK,CAAC,SAAS,CACxC,EAAiB,AAPP,EAOe,KAAK,CAAC,SAAS,CAExC,EAAa,AATH,EASW,IAAI,CAAC,MAAM,CAChC,EAAgB,AAVN,EAUc,IAAI,CAAC,SAAS,CACtC,EAAgB,AAXN,EAWc,IAAI,CAAC,SAAS,CACtC,EAAiB,AAZP,EAYe,IAAI,CAAC,UAAU,CACxC,EAAgB,AAbN,EAac,IAAI,CAAC,SAAS,CACtC,EAAgB,AAdN,EAcc,IAAI,CAAC,SAAS,CAEtC,EAAgB,AAhBN,EAgBc,IAAI,CAAC,SAAS,CACtC,EAAmB,AAjBT,EAiBiB,IAAI,CAAC,YAAY,CAC5C,EAAgB,AAlBN,EAkBc,IAAI,CAAC,SAAS,CAEtC,EAAY,EACZ,EAAc,EACd,EAAa,EACb,EAAa,EAEb,EAAW,EACX,EAAa,EACb,EAAY,EACZ,EAAY,EAEZ,EAAY,EACZ,EAAc,EACd,EAAa,EACb,EAAa,EAEb,IAAM,EAAI,EAAG,EAAK,EAAO,MAAM,CAAE,EAAI,EAAI,IAIxC,IAAK,AAFL,CAAA,EAAQ,CAAM,CAAE,EAAG,AAAH,EAEL,UAAU,EAMrB,GAJA,EAAQ,EAAM,KAAK,CACnB,EAAY,EAAM,SAAS,CAC3B,EAAW,EAAM,QAAQ,CAEpB,aAAiB,GAAM,YAAY,CAAG,CAE1C,GAAK,CAAE,EAAM,OAAO,CAAG,QAElB,CAAA,EAAM,UAAU,EAEpB,GAAK,EAAM,CAAC,CAAG,EAAM,CAAC,CACtB,GAAK,EAAM,CAAC,CAAG,EAAM,CAAC,CACtB,GAAK,EAAM,CAAC,CAAG,EAAM,CAAC,GAItB,GAAK,EAAM,CAAC,CACZ,GAAK,EAAM,CAAC,CACZ,GAAK,EAAM,CAAC,CAId,MAAO,GAAK,aAAiB,GAAM,gBAAgB,CAAG,CAIrD,GAFA,GAAY,EAEP,CAAE,EAAM,OAAO,GAEpB,EAAW,qBAAqB,CAAE,EAAM,WAAW,EACnD,EAAS,qBAAqB,CAAE,EAAM,MAAM,CAAC,WAAW,EACxD,EAAW,GAAG,CAAE,GAChB,EAAW,SAAS,GAKf,AAAiB,IAAjB,EAAW,CAAC,EAAU,AAAiB,IAAjB,EAAW,CAAC,EAAU,AAAiB,IAAjB,EAAW,CAAC,EAVtC,QAcvB,CAAA,CAAY,CAFZ,EAAY,AAAY,EAAZ,EAEa,CAAO,EAAW,CAAC,CAC5C,CAAY,CAAE,EAAY,EAAG,CAAG,EAAW,CAAC,CAC5C,CAAY,CAAE,EAAY,EAAG,CAAG,EAAW,CAAC,CAEvC,EAAM,UAAU,CAEpB,GAAe,EAAW,EAAW,EAAO,EAAY,GAIxD,GAAgB,EAAW,EAAW,EAAO,GAI9C,GAAa,CAEd,MAAO,GAAK,aAAiB,GAAM,UAAU,CAAG,CAI/C,GAFA,GAAc,EAET,CAAE,EAAM,OAAO,CAAG,SAEvB,EAAc,AAAc,EAAd,EAET,EAAM,UAAU,CAEpB,GAAe,EAAa,EAAa,EAAO,EAAY,GAI5D,GAAgB,EAAa,EAAa,EAAO,GAIlD,EAAS,qBAAqB,CAAE,EAAM,WAAW,EAEjD,CAAc,CAAE,EAAa,CAAO,EAAS,CAAC,CAC9C,CAAc,CAAE,EAAc,EAAG,CAAG,EAAS,CAAC,CAC9C,CAAc,CAAE,EAAc,EAAG,CAAG,EAAS,CAAC,CAE9C,CAAc,CAAE,EAAa,CAAG,EAEhC,GAAe,CAEhB,MAAO,GAAK,aAAiB,GAAM,SAAS,CAAG,CAI9C,GAFA,GAAa,EAER,CAAE,EAAM,OAAO,CAAG,SAEvB,EAAa,AAAa,EAAb,EAER,EAAM,UAAU,CAEpB,GAAe,EAAY,EAAY,EAAO,EAAY,GAI1D,GAAgB,EAAY,EAAY,EAAO,GAIhD,EAAS,qBAAqB,CAAE,EAAM,WAAW,EAEjD,CAAa,CAAE,EAAY,CAAO,EAAS,CAAC,CAC5C,CAAa,CAAE,EAAa,EAAG,CAAG,EAAS,CAAC,CAC5C,CAAa,CAAE,EAAa,EAAG,CAAG,EAAS,CAAC,CAE5C,CAAa,CAAE,EAAY,CAAG,EAE9B,EAAW,IAAI,CAAE,GACjB,EAAS,qBAAqB,CAAE,EAAM,MAAM,CAAC,WAAW,EACxD,EAAW,GAAG,CAAE,GAChB,EAAW,SAAS,GAEpB,CAAc,CAAE,EAAY,CAAO,EAAW,CAAC,CAC/C,CAAc,CAAE,EAAa,EAAG,CAAG,EAAW,CAAC,CAC/C,CAAc,CAAE,EAAa,EAAG,CAAG,EAAW,CAAC,CAE/C,CAAa,CAAE,EAAY,CAAG,KAAK,GAAG,CAAE,EAAM,KAAK,EACnD,CAAa,CAAE,EAAY,CAAG,EAAM,QAAQ,CAE5C,GAAc,CAEf,MAAO,GAAK,aAAiB,GAAM,eAAe,CAAG,CAIpD,GAFA,GAAa,EAER,CAAE,EAAM,OAAO,GAEpB,EAAW,qBAAqB,CAAE,EAAM,WAAW,EACnD,EAAW,SAAS,GAKf,AAAiB,IAAjB,EAAW,CAAC,EAAU,AAAiB,IAAjB,EAAW,CAAC,EAAU,AAAiB,IAAjB,EAAW,CAAC,EARtC,QAYvB,CAAA,CAAa,CAFb,EAAa,AAAa,EAAb,EAEc,CAAO,EAAW,CAAC,CAC9C,CAAa,CAAE,EAAa,EAAG,CAAG,EAAW,CAAC,CAC9C,CAAa,CAAE,EAAa,EAAG,CAAG,EAAW,CAAC,CAE9C,EAAW,EAAM,KAAK,CACtB,EAAc,EAAM,WAAW,CAE1B,EAAM,UAAU,EAIpB,GAAe,EAAe,EAAY,EAF1C,EAAc,EAAY,GAG1B,GAAe,EAAkB,EAAY,EAAa,KAI1D,GAAgB,EAAe,EAAY,EAAU,GACrD,GAAgB,EAAkB,EAAY,EAAa,IAI5D,GAAc,CAEf,EAOD,IAAM,EAAI,AAAY,EAAZ,EAAe,EAAK,KAAK,GAAG,CAAE,EAAU,MAAM,CAAE,AAAW,EAAX,GAAgB,EAAI,EAAI,IAAO,CAAS,CAAE,EAAG,CAAG,EAC1G,IAAM,EAAI,AAAc,EAAd,EAAiB,EAAK,KAAK,GAAG,CAAE,EAAY,MAAM,CAAE,AAAa,EAAb,GAAkB,EAAI,EAAI,IAAO,CAAW,CAAE,EAAG,CAAG,EAClH,IAAM,EAAI,AAAa,EAAb,EAAgB,EAAK,KAAK,GAAG,CAAE,EAAW,MAAM,CAAE,AAAY,EAAZ,GAAiB,EAAI,EAAI,IAAO,CAAU,CAAE,EAAG,CAAG,EAC9G,IAAM,EAAI,AAAa,EAAb,EAAgB,EAAK,KAAK,GAAG,CAAE,EAAc,MAAM,CAAE,AAAY,EAAZ,GAAiB,EAAI,EAAI,IAAO,CAAa,CAAE,EAAG,CAAG,EACpH,IAAM,EAAI,AAAa,EAAb,EAAgB,EAAK,KAAK,GAAG,CAAE,EAAiB,MAAM,CAAE,AAAY,EAAZ,GAAiB,EAAI,EAAI,IAAO,CAAgB,CAAE,EAAG,CAAG,CAE1H,CAzNU,EAyNF,WAAW,CAAC,MAAM,CAAG,EAC7B,AA1NU,EA0NF,KAAK,CAAC,MAAM,CAAG,EACvB,AA3NU,EA2NF,IAAI,CAAC,MAAM,CAAG,EACtB,AA5NU,EA4NF,IAAI,CAAC,MAAM,CAAG,EAEtB,AA9NU,EA8NF,OAAO,CAAE,EAAG,CAAG,EACvB,AA/NU,EA+NF,OAAO,CAAE,EAAG,CAAG,EACvB,AAhOU,EAgOF,OAAO,CAAE,EAAG,CAAG,CAExB,EA9zBiB,EAAS,GACtB,EAAoB,CAAA,GA8RvB,AA1RyB,EA0RhB,iBAAiB,CAAC,KAAK,CAAG,AA1RE,EA0RK,OAAO,CAEjD,AA5RyB,EA4RhB,qBAAqB,CAAC,KAAK,CAAG,AA5RF,EA4RS,WAAW,CAAC,MAAM,CAChE,AA7RyB,EA6RhB,yBAAyB,CAAC,KAAK,CAAG,AA7RN,EA6Ra,WAAW,CAAC,SAAS,CAEvE,AA/RyB,EA+RhB,eAAe,CAAC,KAAK,CAAG,AA/RI,EA+RG,KAAK,CAAC,MAAM,CACpD,AAhSyB,EAgShB,kBAAkB,CAAC,KAAK,CAAG,AAhSC,EAgSM,KAAK,CAAC,SAAS,CAC1D,AAjSyB,EAiShB,kBAAkB,CAAC,KAAK,CAAG,AAjSC,EAiSM,KAAK,CAAC,SAAS,CAE1D,AAnSyB,EAmShB,cAAc,CAAC,KAAK,CAAG,AAnSK,EAmSE,IAAI,CAAC,MAAM,CAClD,AApSyB,EAoShB,iBAAiB,CAAC,KAAK,CAAG,AApSE,EAoSK,IAAI,CAAC,SAAS,CACxD,AArSyB,EAqShB,iBAAiB,CAAC,KAAK,CAAG,AArSE,EAqSK,IAAI,CAAC,SAAS,CACxD,AAtSyB,EAsShB,kBAAkB,CAAC,KAAK,CAAG,AAtSC,EAsSM,IAAI,CAAC,UAAU,CAC1D,AAvSyB,EAuShB,iBAAiB,CAAC,KAAK,CAAG,AAvSE,EAuSK,IAAI,CAAC,SAAS,CACxD,AAxSyB,EAwShB,iBAAiB,CAAC,KAAK,CAAG,AAxSE,EAwSK,IAAI,CAAC,SAAS,CAExD,AA1SyB,EA0ShB,uBAAuB,CAAC,KAAK,CAAG,AA1SJ,EA0SW,IAAI,CAAC,SAAS,CAC9D,AA3SyB,EA2ShB,0BAA0B,CAAC,KAAK,CAAG,AA3SP,EA2Sc,IAAI,CAAC,YAAY,CACpE,AA5SyB,EA4ShB,wBAAwB,CAAC,KAAK,CAAG,AA5SL,EA4SY,IAAI,CAAC,SAAS,EAxSzD,CAAA,aAAoB,GAAM,iBAAiB,EAC9C,aAAoB,GAAM,mBAAmB,EAC7C,aAAoB,GAAM,iBAAiB,AAAjB,GAE3B,AA8FH,SAAiC,CAAQ,CAAE,CAAQ,EA0DlD,GAxDA,EAAS,OAAO,CAAC,KAAK,CAAG,EAAS,OAAO,CAEpC,EAAM,UAAU,CAEpB,EAAS,OAAO,CAAC,KAAK,CAAC,iBAAiB,CAAE,EAAS,KAAK,EAIxD,EAAS,OAAO,CAAC,KAAK,CAAG,EAAS,KAAK,CAIxC,EAAS,GAAG,CAAC,KAAK,CAAG,EAAS,GAAG,CACjC,EAAS,QAAQ,CAAC,KAAK,CAAG,EAAS,QAAQ,CAC3C,EAAS,WAAW,CAAC,KAAK,CAAG,EAAS,WAAW,CAE5C,EAAS,OAAO,GAEpB,EAAS,OAAO,CAAC,KAAK,CAAG,EAAS,OAAO,CACzC,EAAS,SAAS,CAAC,KAAK,CAAG,EAAS,SAAS,EAIzC,EAAS,SAAS,GAEtB,EAAS,SAAS,CAAC,KAAK,CAAG,EAAS,SAAS,CAC7C,EAAS,WAAW,CAAC,KAAK,CAAC,IAAI,CAAE,EAAS,WAAW,GAYjD,EAAS,GAAG,CAEhB,EAAa,EAAS,GAAG,CAEd,EAAS,WAAW,CAE/B,EAAa,EAAS,WAAW,CAEtB,EAAS,SAAS,CAE7B,EAAa,EAAS,SAAS,CAEpB,EAAS,OAAO,EAE3B,CAAA,EAAa,EAAS,OAAO,AAAP,EAIlB,AAAe,KAAA,IAAf,EAA2B,CAE/B,IAtBG,EAsBC,EAAS,EAAW,MAAM,CAC1B,EAAS,EAAW,MAAM,CAE9B,EAAS,YAAY,CAAC,KAAK,CAAC,GAAG,CAAE,EAAO,CAAC,CAAE,EAAO,CAAC,CAAE,EAAO,CAAC,CAAE,EAAO,CAAC,CAExE,CAEA,EAAS,MAAM,CAAC,KAAK,CAAG,EAAS,MAAM,CACvC,EAAS,UAAU,CAAC,KAAK,CAAG,EAAW,MAAM,YAAY,GAAM,qBAAqB,CAAK,EAAI,GAExF,EAAM,UAAU,CAGpB,EAAS,YAAY,CAAC,KAAK,CAAG,EAAS,YAAY,CAQpD,EAAS,eAAe,CAAC,KAAK,CAAG,EAAS,eAAe,CACzD,EAAS,OAAO,CAAC,KAAK,CAAG,EAAS,OAAO,CACzC,EAAS,UAAU,CAAC,KAAK,CAAG,EAAS,MAAM,EAAI,EAAS,MAAM,CAAC,OAAO,YAAY,GAAM,qBAAqB,AAE9G,EAnL0B,EAAY,GAM/B,aAAoB,GAAM,iBAAiB,CAE/C,GAAqB,EAAY,GAEtB,aAAoB,GAAM,kBAAkB,EAEvD,GAAqB,EAAY,GAkLnC,AAjLuB,EAiLd,QAAQ,CAAC,KAAK,CAAG,AAjLS,EAiLA,QAAQ,CAC3C,AAlLuB,EAkLd,SAAS,CAAC,KAAK,CAAG,AAlLQ,EAkLC,QAAQ,CAAG,AAlLZ,EAkLqB,OAAO,CAC/D,AAnLuB,EAmLd,KAAK,CAAC,KAAK,CAAG,AAnLY,EAmLH,KAAK,EAjLxB,aAAoB,GAAM,qBAAqB,EAuL5D,AArL2B,EAqLlB,OAAO,CAAC,KAAK,CAAG,AArLc,EAqLL,KAAK,CACvC,AAtL2B,EAsLlB,OAAO,CAAC,KAAK,CAAG,AAtLc,EAsLL,OAAO,CACzC,AAvL2B,EAuLlB,IAAI,CAAC,KAAK,CAAG,AAvLiB,EAuLR,IAAI,CACnC,AAxL2B,EAwLlB,KAAK,CAAC,KAAK,CAAG,EAAQ,MAAM,CAAG,EAExC,AA1L2B,EA0LlB,GAAG,CAAC,KAAK,CAAG,AA1LkB,EA0LT,GAAG,EAxLpB,aAAoB,GAAM,iBAAiB,EA+MxD,AA7MwB,EA6Mf,SAAS,CAAC,KAAK,CAAG,AA7MS,EA6MA,SAAS,CAExC,EAAM,UAAU,EAEpB,AAjNuB,EAiNd,OAAO,CAAC,KAAK,CAAC,iBAAiB,CAAE,AAjNP,EAiNgB,OAAO,EAC1D,AAlNuB,EAkNd,QAAQ,CAAC,KAAK,CAAC,iBAAiB,CAAE,AAlNR,EAkNiB,QAAQ,EAC5D,AAnNuB,EAmNd,QAAQ,CAAC,KAAK,CAAC,iBAAiB,CAAE,AAnNR,EAmNiB,QAAQ,IAI5D,AAvNuB,EAuNd,OAAO,CAAC,KAAK,CAAG,AAvNU,EAuND,OAAO,CACzC,AAxNuB,EAwNd,QAAQ,CAAC,KAAK,CAAG,AAxNS,EAwNA,QAAQ,CAC3C,AAzNuB,EAyNd,QAAQ,CAAC,KAAK,CAAG,AAzNS,EAyNA,QAAQ,EAIvC,AA7N+B,EA6NtB,UAAU,EAEvB,AA/NuB,EA+Nd,OAAO,CAAC,KAAK,CAAC,IAAI,CAAE,AA/NM,EA+NG,OAAO,GA7NjC,aAAoB,GAAM,mBAAmB,EAqOrD,EAAM,UAAU,EAEpB,AArOyB,EAqOhB,OAAO,CAAC,KAAK,CAAC,iBAAiB,CAAE,AArOL,EAqOc,OAAO,EAC1D,AAtOyB,EAsOhB,QAAQ,CAAC,KAAK,CAAC,iBAAiB,CAAE,AAtON,EAsOe,QAAQ,IAI5D,AA1OyB,EA0OhB,OAAO,CAAC,KAAK,CAAG,AA1OY,EA0OH,OAAO,CACzC,AA3OyB,EA2OhB,QAAQ,CAAC,KAAK,CAAG,AA3OW,EA2OF,QAAQ,EAIvC,AA/OiC,EA+OxB,UAAU,EAEvB,AAjPyB,EAiPhB,OAAO,CAAC,KAAK,CAAC,IAAI,CAAE,AAjPQ,EAiPC,OAAO,GA/OjC,aAAoB,GAAM,iBAAiB,EAEtD,EAAW,KAAK,CAAC,KAAK,CAAG,EAAO,IAAI,CACpC,EAAW,IAAI,CAAC,KAAK,CAAG,EAAO,GAAG,CAClC,EAAW,OAAO,CAAC,KAAK,CAAG,EAAS,OAAO,EAEhC,aAAoB,GAAM,kBAAkB,EAEvD,CAAA,EAAW,OAAO,CAAC,KAAK,CAAG,EAAS,OAAO,AAAP,EAIhC,EAAO,aAAa,EAAI,CAAE,EAAS,WAAW,EAElD,AA+PH,SAAiC,CAAQ,CAAE,CAAM,EAEhD,GAAK,EAAS,YAAY,CAIzB,IAAM,IAFF,EAAI,EAEE,EAAI,EAAG,EAAK,EAAO,MAAM,CAAE,EAAI,EAAI,IAAO,CAEnD,IAAI,EAAQ,CAAM,CAAE,EAAG,AAEhB,CAAA,EAAM,UAAU,EAElB,CAAA,aAAiB,GAAM,SAAS,EAAM,aAAiB,GAAM,gBAAgB,EAAI,CAAE,EAAM,aAAa,AAAb,IAE7F,EAAS,SAAS,CAAC,KAAK,CAAE,EAAG,CAAG,EAAM,SAAS,CAC/C,EAAS,aAAa,CAAC,KAAK,CAAE,EAAG,CAAG,EAAM,aAAa,CAEvD,EAAS,YAAY,CAAC,KAAK,CAAE,EAAG,CAAG,EAAM,YAAY,CAErD,EAAS,cAAc,CAAC,KAAK,CAAE,EAAG,CAAG,EAAM,cAAc,CACzD,EAAS,UAAU,CAAC,KAAK,CAAE,EAAG,CAAG,EAAM,UAAU,CAEjD,IAIF,CAIF,EA7R0B,EAAY,GAMpC,AAuTF,SAA+B,CAAO,CAAE,CAAQ,MAE3C,EAAS,EAAO,EAAM,EAAU,EAAS,EAAa,EAAG,EAAI,EAAG,EAAI,EA80CxC,EAAS,EA50CzC,IAAM,EAAI,EAAG,EAAK,EAAS,MAAM,CAAE,EAAI,EAAI,IAG1C,GADA,EAAW,EAAQ,QAAQ,CAAE,CAAQ,CAAE,EAAG,CAAE,EAAG,CAAE,EAQjD,GAHA,EAAO,AAFP,CAAA,EAAU,CAAQ,CAAE,EAAG,CAAE,EAAG,AAAH,EAEV,IAAI,CACnB,EAAQ,EAAQ,KAAK,CAEhB,AAAS,MAAT,EAEJ,EAAI,SAAS,CAAE,EAAU,QAEnB,GAAK,AAAS,MAAT,EAEX,EAAI,SAAS,CAAE,EAAU,QAEnB,GAAK,AAAS,OAAT,EAEX,EAAI,SAAS,CAAE,EAAU,EAAM,CAAC,CAAE,EAAM,CAAC,OAEnC,GAAK,AAAS,OAAT,EAEX,EAAI,SAAS,CAAE,EAAU,EAAM,CAAC,CAAE,EAAM,CAAC,CAAE,EAAM,CAAC,OAE5C,GAAK,AAAS,OAAT,EAEX,EAAI,SAAS,CAAE,EAAU,EAAM,CAAC,CAAE,EAAM,CAAC,CAAE,EAAM,CAAC,CAAE,EAAM,CAAC,OAErD,GAAK,AAAS,MAAT,EAEX,EAAI,SAAS,CAAE,EAAU,EAAM,CAAC,CAAE,EAAM,CAAC,CAAE,EAAM,CAAC,OAE5C,GAAK,AAAS,QAAT,EAEX,EAAI,UAAU,CAAE,EAAU,QAEpB,GAAK,AAAS,OAAT,EAEX,EAAI,UAAU,CAAE,EAAU,QAEpB,GAAK,AAAS,QAAT,EAEX,EAAI,UAAU,CAAE,EAAU,QAEpB,GAAK,AAAS,OAAT,EAEX,EAAI,UAAU,CAAE,EAAU,QAEpB,GAAK,AAAS,QAAT,EAAiB,CAQ5B,IAAM,AANkB,KAAA,IAAnB,EAAQ,MAAM,EAElB,CAAA,EAAQ,MAAM,CAAG,IAAI,aAAc,EAAI,EAAM,MAAM,CAAA,EAI9C,EAAI,EAAG,EAAK,EAAM,MAAM,CAAE,EAAI,EAAI,IAEvC,EAAS,AAAI,EAAJ,EAET,EAAQ,MAAM,CAAE,EAAQ,CAAK,CAAK,CAAE,EAAG,CAAC,CAAC,CACzC,EAAQ,MAAM,CAAE,EAAS,EAAG,CAAG,CAAK,CAAE,EAAG,CAAC,CAAC,CAI5C,EAAI,UAAU,CAAE,EAAU,EAAQ,MAAM,CAEzC,MAAO,GAAK,AAAS,QAAT,EAAiB,CAQ5B,IAAM,AANkB,KAAA,IAAnB,EAAQ,MAAM,EAElB,CAAA,EAAQ,MAAM,CAAG,IAAI,aAAc,EAAI,EAAM,MAAM,CAAA,EAI9C,EAAI,EAAG,EAAK,EAAM,MAAM,CAAE,EAAI,EAAI,IAEvC,EAAS,AAAI,EAAJ,EAET,EAAQ,MAAM,CAAE,EAAQ,CAAK,CAAK,CAAE,EAAG,CAAC,CAAC,CACzC,EAAQ,MAAM,CAAE,EAAS,EAAG,CAAG,CAAK,CAAE,EAAG,CAAC,CAAC,CAC3C,EAAQ,MAAM,CAAE,EAAS,EAAG,CAAG,CAAK,CAAE,EAAG,CAAC,CAAC,CAI5C,EAAI,UAAU,CAAE,EAAU,EAAQ,MAAM,CAEzC,MAAO,GAAK,AAAS,QAAT,EAAiB,CAQ5B,IAAM,AANkB,KAAA,IAAnB,EAAQ,MAAM,EAElB,CAAA,EAAQ,MAAM,CAAG,IAAI,aAAc,EAAI,EAAM,MAAM,CAAA,EAI9C,EAAI,EAAG,EAAK,EAAM,MAAM,CAAE,EAAI,EAAI,IAEvC,EAAS,AAAI,EAAJ,EAET,EAAQ,MAAM,CAAE,EAAQ,CAAK,CAAK,CAAE,EAAG,CAAC,CAAC,CACzC,EAAQ,MAAM,CAAE,EAAS,EAAG,CAAG,CAAK,CAAE,EAAG,CAAC,CAAC,CAC3C,EAAQ,MAAM,CAAE,EAAS,EAAG,CAAG,CAAK,CAAE,EAAG,CAAC,CAAC,CAC3C,EAAQ,MAAM,CAAE,EAAS,EAAG,CAAG,CAAK,CAAE,EAAG,CAAC,CAAC,CAI5C,EAAI,UAAU,CAAE,EAAU,EAAQ,MAAM,CAEzC,MAAO,GAAK,AAAS,OAAT,EAEa,KAAA,IAAnB,EAAQ,MAAM,EAElB,CAAA,EAAQ,MAAM,CAAG,IAAI,aAAc,GAFpC,EAMA,EAAM,cAAc,CAAE,EAAQ,MAAM,EACpC,EAAI,gBAAgB,CAAE,EAAU,CAAA,EAAO,EAAQ,MAAM,OAE/C,GAAK,AAAS,QAAT,EAAiB,CAQ5B,IAAM,AANkB,KAAA,IAAnB,EAAQ,MAAM,EAElB,CAAA,EAAQ,MAAM,CAAG,IAAI,aAAc,GAAK,EAAM,MAAM,CAAA,EAI/C,EAAI,EAAG,EAAK,EAAM,MAAM,CAAE,EAAI,EAAI,IAEvC,CAAK,CAAE,EAAG,CAAC,oBAAoB,CAAE,EAAQ,MAAM,CAAE,AAAI,GAAJ,GAIlD,EAAI,gBAAgB,CAAE,EAAU,CAAA,EAAO,EAAQ,MAAM,CAEtD,MAAO,GAAK,AAAS,MAAT,EAAe,CAO1B,GALA,EAAU,EACV,EAAc,KAEd,EAAI,SAAS,CAAE,EAAU,GAEpB,CAAC,EAAU,QAEX,CAAA,EAAQ,KAAK,YAAY,OAAS,AAAyB,IAAzB,EAAQ,KAAK,CAAC,MAAM,CAE1D,AAkmCJ,SAA0B,CAAO,CAAE,CAAI,EAEtC,GAAK,AAAyB,IAAzB,EAAQ,KAAK,CAAC,MAAM,EAExB,GAAK,EAAQ,WAAW,CAAG,CAErB,CAAE,EAAQ,KAAK,CAAC,kBAAkB,GAEtC,EAAQ,KAAK,CAAC,kBAAkB,CAAG,EAAI,aAAa,GAEpD,EAAM,IAAI,CAAC,MAAM,CAAC,QAAQ,IAI3B,EAAI,aAAa,CAAE,EAAI,QAAQ,CAAG,GAClC,EAAI,WAAW,CAAE,EAAI,gBAAgB,CAAE,EAAQ,KAAK,CAAC,kBAAkB,EAEvE,EAAI,WAAW,CAAE,EAAI,mBAAmB,CAAE,EAAQ,KAAK,EAMvD,IAAM,IAJF,EAAe,aAAmB,GAAM,iBAAiB,CAEzD,EAAY,EAAE,CAER,EAAI,EAAG,EAAI,EAAG,IAElB,EAAM,iBAAiB,EAAI,CAAE,EAEjC,CAAS,CAAE,EAAG,CAAG,AArDtB,SAA0B,CAAK,CAAE,CAAO,EAEvC,GAAK,EAAM,KAAK,EAAI,GAAW,EAAM,MAAM,EAAI,EAE9C,OAAO,EAOR,IAAI,EAAe,KAAK,GAAG,CAAE,EAAM,KAAK,CAAE,EAAM,MAAM,EAClD,EAAW,KAAK,KAAK,CAAE,EAAM,KAAK,CAAG,EAAU,GAC/C,EAAY,KAAK,KAAK,CAAE,EAAM,MAAM,CAAG,EAAU,GAEjD,EAAS,SAAS,aAAa,CAAE,UAOrC,OANA,EAAO,KAAK,CAAG,EACf,EAAO,MAAM,CAAG,EAGhB,AADU,EAAO,UAAU,CAAE,MACzB,SAAS,CAAE,EAAO,EAAG,EAAG,EAAM,KAAK,CAAE,EAAM,MAAM,CAAE,EAAG,EAAG,EAAU,GAEhE,CAER,EA6BsC,EAAQ,KAAK,CAAE,EAAG,CAAE,GAIrD,CAAS,CAAE,EAAG,CAAG,EAAQ,KAAK,CAAE,EAAG,CAZrC,IAkBI,EAAQ,CAAS,CAAE,EAAG,CAC1B,EAAoB,GAAc,EAAM,KAAK,GAAM,GAAc,EAAM,MAAM,EAC7E,EAAW,GAAgB,EAAQ,MAAM,EACzC,EAAS,GAAgB,EAAQ,IAAI,EAErC,GAAsB,EAAI,gBAAgB,CAAE,EAAS,GAErD,IAAM,IAAI,EAAI,EAAG,EAAI,EAAG,IAEvB,GAAK,EAIJ,IAAK,IAFD,EAAQ,EAAU,CAAS,CAAE,EAAG,CAAC,OAAO,CAEnC,EAAI,EAAG,EAAK,EAAQ,MAAM,CAAE,EAAI,EAAI,IAE5C,EAAS,CAAO,CAAE,EAAG,CACrB,EAAI,oBAAoB,CAAE,EAAI,2BAA2B,CAAG,EAAG,EAAG,EAAU,EAAO,KAAK,CAAE,EAAO,MAAM,CAAE,EAAG,EAAO,IAAI,OAMxH,EAAI,UAAU,CAAE,EAAI,2BAA2B,CAAG,EAAG,EAAG,EAAU,EAAU,EAAQ,CAAS,CAAE,EAAG,CAM/F,CAAA,EAAQ,eAAe,EAAI,GAE/B,EAAI,cAAc,CAAE,EAAI,gBAAgB,EAIzC,EAAQ,WAAW,CAAG,CAAA,EAEjB,EAAQ,QAAQ,EAAG,EAAQ,QAAQ,EAEzC,MAEC,EAAI,aAAa,CAAE,EAAI,QAAQ,CAAG,GAClC,EAAI,WAAW,CAAE,EAAI,gBAAgB,CAAE,EAAQ,KAAK,CAAC,kBAAkB,EAM1E,EAtrCoB,EAAS,GAEd,aAAmB,GAAM,qBAAqB,EAsrC5B,EAprCN,EAorCe,EAprCN,EAsrCnC,EAAI,aAAa,CAAE,EAAI,QAAQ,CAAG,GAClC,EAAI,WAAW,CAAE,EAAI,gBAAgB,CAAE,EAAQ,cAAc,GAnrC1D,EAAM,UAAU,CAAE,EAAS,EAI7B,MAAO,GAAK,AAAS,OAAT,EAAgB,CAQ3B,IAAK,AANmB,KAAA,IAAnB,EAAQ,MAAM,EAElB,CAAA,EAAQ,MAAM,CAAG,EAAE,AAAF,EAIb,EAAI,EAAG,EAAK,EAAQ,KAAK,CAAC,MAAM,CAAE,EAAI,EAAI,IAE9C,EAAQ,MAAM,CAAE,EAAG,CAAG,KAMvB,IAAK,AAFL,EAAI,UAAU,CAAE,EAAU,EAAQ,MAAM,EAEnC,EAAI,EAAG,EAAK,EAAQ,KAAK,CAAC,MAAM,CAAE,EAAI,EAAI,IAE9C,EAAU,EAAQ,KAAK,CAAE,EAAG,CAC5B,EAAc,EAAQ,MAAM,CAAE,EAAG,CAE3B,GAEN,EAAM,UAAU,CAAE,EAAS,EAI7B,EAIF,EA1fuB,EAAS,EAAS,YAAY,EAK9C,CAAA,aAAoB,GAAM,cAAc,EAC3C,aAAoB,GAAM,iBAAiB,EAC3C,EAAS,MAAM,AAAN,GAEL,AAA8B,OAA9B,EAAW,cAAc,GAE7B,EAAS,qBAAqB,CAAE,EAAO,WAAW,EAClD,EAAI,SAAS,CAAE,EAAW,cAAc,CAAE,EAAS,CAAC,CAAE,EAAS,CAAC,CAAE,EAAS,CAAC,GAMzE,CAAA,aAAoB,GAAM,iBAAiB,EAC9C,aAAoB,GAAM,mBAAmB,EAC7C,aAAoB,GAAM,cAAc,EACxC,EAAS,QAAQ,AAAR,GAEL,AAA0B,OAA1B,EAAW,UAAU,EAEzB,EAAI,gBAAgB,CAAE,EAAW,UAAU,CAAE,CAAA,EAAO,EAAO,kBAAkB,CAAC,QAAQ,GAoQzF,EAAI,gBAAgB,CAAE,AA5PA,EA4PS,eAAe,CAAE,CAAA,EAAO,AA5PrB,EA4P4B,gBAAgB,CAAC,QAAQ,EAElF,AA9PiB,EA8PR,YAAY,EAEzB,EAAI,gBAAgB,CAAE,AAhQD,EAgQU,YAAY,CAAE,CAAA,EAAO,AAhQnB,EAgQ0B,aAAa,CAAC,QAAQ,EA9PlD,OAA3B,EAAW,WAAW,EAE1B,EAAI,gBAAgB,CAAE,EAAW,WAAW,CAAE,CAAA,EAAO,EAAO,WAAW,CAAC,QAAQ,EAI1E,CAER,CA2FA,SAAS,GAAsB,CAAQ,CAAE,CAAQ,EAEhD,EAAS,OAAO,CAAC,KAAK,CAAG,EAAS,KAAK,CACvC,EAAS,OAAO,CAAC,KAAK,CAAG,EAAS,OAAO,AAE1C,CA4JA,SAAS,KAER,IAAI,EAAc,EAUlB,OARK,GAAe,GAEnB,QAAQ,IAAI,CAAE,gCAAkC,EAAc,+CAAiD,GAIhH,GAAqB,EAEd,CAER,CAuMA,SAAS,GAAgB,CAAM,CAAE,CAAM,EAEtC,EAAO,gBAAgB,CAAC,gBAAgB,CAAE,EAAO,kBAAkB,CAAE,EAAO,WAAW,EAEvF,EAAO,aAAa,CAAC,UAAU,CAAE,EAAO,gBAAgB,EACxD,EAAO,aAAa,CAAC,SAAS,EAE/B,CAIA,SAAS,GAAe,CAAK,CAAE,CAAM,CAAE,CAAK,CAAE,CAAW,EAExD,CAAK,CAAE,EAAQ,CAAO,EAAM,CAAC,CAAG,EAAM,CAAC,CAAG,EAC1C,CAAK,CAAE,EAAS,EAAG,CAAG,EAAM,CAAC,CAAG,EAAM,CAAC,CAAG,EAC1C,CAAK,CAAE,EAAS,EAAG,CAAG,EAAM,CAAC,CAAG,EAAM,CAAC,CAAG,CAE3C,CAEA,SAAS,GAAgB,CAAK,CAAE,CAAM,CAAE,CAAK,CAAE,CAAS,EAEvD,CAAK,CAAE,EAAQ,CAAO,EAAM,CAAC,CAAG,EAChC,CAAK,CAAE,EAAS,EAAG,CAAG,EAAM,CAAC,CAAG,EAChC,CAAK,CAAE,EAAS,EAAG,CAAG,EAAM,CAAC,CAAG,CAEjC,CA6VA,SAAS,GAAe,CAAK,EAEvB,IAAU,IAEd,EAAI,SAAS,CAAE,GAEf,EAAgB,EAIlB,CAEA,SAAS,GAAmB,CAAa,CAAE,CAAM,CAAE,CAAK,EAElD,IAAsB,IAErB,EAEJ,EAAI,MAAM,CAAE,EAAI,mBAAmB,EAInC,EAAI,OAAO,CAAE,EAAI,mBAAmB,EAIrC,EAAoB,GAIhB,GAAmB,CAAA,IAA4B,GAAU,IAA2B,CAAA,IAExF,EAAI,aAAa,CAAE,EAAQ,GAE3B,EAA0B,EAC1B,EAAyB,EAI3B,CA4cA,SAAS,GAAY,CAAI,CAAE,CAAM,EAEhC,IAAI,QAeJ,CAbK,AAAS,aAAT,EAEJ,EAAS,EAAI,YAAY,CAAE,EAAI,eAAe,EAE1B,WAAT,GAEX,CAAA,EAAS,EAAI,YAAY,CAAE,EAAI,aAAa,CAAA,EAI7C,EAAI,YAAY,CAAE,EAAQ,GAC1B,EAAI,aAAa,CAAE,GAEb,EAAI,kBAAkB,CAAE,EAAQ,EAAI,cAAc,GAQjD,GANN,QAAQ,KAAK,CAAE,EAAI,gBAAgB,CAAE,IACrC,QAAQ,KAAK,CAAE,AArCjB,SAA0B,CAAM,EAI/B,IAAM,IAFF,EAAS,EAAO,KAAK,CAAE,MAEjB,EAAI,EAAG,EAAK,EAAO,MAAM,CAAE,EAAI,EAAI,IAK5C,CAAM,CAAE,EAAG,CAAK,EAAI,EAAM,KAAO,CAAM,CAAE,EAAG,CAI7C,OAAO,EAAO,IAAI,CAAE,KAErB,EAsBiC,IACxB,KAMT,CAKA,SAAS,GAAe,CAAK,EAE5B,MAAS,AAAA,CAAA,EAAU,EAAQ,CAAA,GAAU,CAEtC,CAEA,SAAS,GAAuB,CAAW,CAAE,CAAO,CAAE,CAAiB,EAEjE,GAEJ,EAAI,aAAa,CAAE,EAAa,EAAI,cAAc,CAAE,GAAgB,EAAQ,KAAK,GACjF,EAAI,aAAa,CAAE,EAAa,EAAI,cAAc,CAAE,GAAgB,EAAQ,KAAK,GAEjF,EAAI,aAAa,CAAE,EAAa,EAAI,kBAAkB,CAAE,GAAgB,EAAQ,SAAS,GACzF,EAAI,aAAa,CAAE,EAAa,EAAI,kBAAkB,CAAE,GAAgB,EAAQ,SAAS,KAIzF,EAAI,aAAa,CAAE,EAAa,EAAI,cAAc,CAAE,EAAI,aAAa,EACrE,EAAI,aAAa,CAAE,EAAa,EAAI,cAAc,CAAE,EAAI,aAAa,EAErE,EAAI,aAAa,CAAE,EAAa,EAAI,kBAAkB,CAAE,GAAgB,EAAQ,SAAS,GACzF,EAAI,aAAa,CAAE,EAAa,EAAI,kBAAkB,CAAE,GAAgB,EAAQ,SAAS,IAIrF,GAAwC,EAAQ,IAAI,GAAK,GAAM,SAAS,EAEvE,CAAA,EAAQ,UAAU,CAAG,GAAK,EAAQ,eAAe,AAAf,IAEtC,EAAI,aAAa,CAAE,EAAa,EAAqC,0BAA0B,CAAE,KAAK,GAAG,CAAE,EAAQ,UAAU,CAAE,KAC/H,EAAQ,eAAe,CAAG,EAAQ,UAAU,CAM/C,CAsOA,SAAS,GAAmB,CAAW,CAAE,CAAY,CAAE,CAAa,EAEnE,EAAI,eAAe,CAAE,EAAI,WAAW,CAAE,GACtC,EAAI,oBAAoB,CAAE,EAAI,WAAW,CAAE,EAAI,iBAAiB,CAAE,EAAe,EAAa,cAAc,CAAE,EAE/G,CAEA,SAAS,GAAoB,CAAY,CAAE,CAAY,EAEtD,EAAI,gBAAgB,CAAE,EAAI,YAAY,CAAE,GAEnC,EAAa,WAAW,EAAI,CAAE,EAAa,aAAa,EAE5D,EAAI,mBAAmB,CAAE,EAAI,YAAY,CAAE,EAAI,iBAAiB,CAAE,EAAa,KAAK,CAAE,EAAa,MAAM,EACzG,EAAI,uBAAuB,CAAE,EAAI,WAAW,CAAE,EAAI,gBAAgB,CAAE,EAAI,YAAY,CAAE,IAQ3E,EAAa,WAAW,EAAI,EAAa,aAAa,EAEjE,EAAI,mBAAmB,CAAE,EAAI,YAAY,CAAE,EAAI,aAAa,CAAE,EAAa,KAAK,CAAE,EAAa,MAAM,EACrG,EAAI,uBAAuB,CAAE,EAAI,WAAW,CAAE,EAAI,wBAAwB,CAAE,EAAI,YAAY,CAAE,IAI9F,EAAI,mBAAmB,CAAE,EAAI,YAAY,CAAE,EAAI,KAAK,CAAE,EAAa,KAAK,CAAE,EAAa,MAAM,CAI/F,CA2KA,SAAS,GAAiB,CAAC,SAE1B,AAAK,IAAM,GAAM,aAAa,EAAI,IAAM,GAAM,0BAA0B,EAAI,IAAM,GAAM,yBAAyB,CAEzG,EAAI,OAAO,CAIZ,EAAI,MAAM,AAElB,CAIA,SAAS,GAAiB,CAAC,EAE1B,GAAK,IAAM,GAAM,cAAc,CAAG,OAAO,EAAI,MAAM,CACnD,GAAK,IAAM,GAAM,mBAAmB,CAAG,OAAO,EAAI,aAAa,CAC/D,GAAK,IAAM,GAAM,sBAAsB,CAAG,OAAO,EAAI,eAAe,CAEpE,GAAK,IAAM,GAAM,aAAa,CAAG,OAAO,EAAI,OAAO,CACnD,GAAK,IAAM,GAAM,0BAA0B,CAAG,OAAO,EAAI,sBAAsB,CAC/E,GAAK,IAAM,GAAM,yBAAyB,CAAG,OAAO,EAAI,qBAAqB,CAE7E,GAAK,IAAM,GAAM,YAAY,CAAG,OAAO,EAAI,MAAM,CACjD,GAAK,IAAM,GAAM,yBAAyB,CAAG,OAAO,EAAI,qBAAqB,CAC7E,GAAK,IAAM,GAAM,wBAAwB,CAAG,OAAO,EAAI,oBAAoB,CAE3E,GAAK,IAAM,GAAM,gBAAgB,CAAG,OAAO,EAAI,aAAa,CAC5D,GAAK,IAAM,GAAM,qBAAqB,CAAG,OAAO,EAAI,sBAAsB,CAC1E,GAAK,IAAM,GAAM,qBAAqB,CAAG,OAAO,EAAI,sBAAsB,CAC1E,GAAK,IAAM,GAAM,oBAAoB,CAAG,OAAO,EAAI,oBAAoB,CAEvE,GAAK,IAAM,GAAM,QAAQ,CAAG,OAAO,EAAI,IAAI,CAC3C,GAAK,IAAM,GAAM,SAAS,CAAG,OAAO,EAAI,KAAK,CAC7C,GAAK,IAAM,GAAM,iBAAiB,CAAG,OAAO,EAAI,cAAc,CAC9D,GAAK,IAAM,GAAM,OAAO,CAAG,OAAO,EAAI,GAAG,CACzC,GAAK,IAAM,GAAM,eAAe,CAAG,OAAO,EAAI,YAAY,CAC1D,GAAK,IAAM,GAAM,SAAS,CAAG,OAAO,EAAI,KAAK,CAE7C,GAAK,IAAM,GAAM,WAAW,CAAG,OAAO,EAAI,KAAK,CAC/C,GAAK,IAAM,GAAM,SAAS,CAAG,OAAO,EAAI,GAAG,CAC3C,GAAK,IAAM,GAAM,UAAU,CAAG,OAAO,EAAI,IAAI,CAC7C,GAAK,IAAM,GAAM,eAAe,CAAG,OAAO,EAAI,SAAS,CACvD,GAAK,IAAM,GAAM,oBAAoB,CAAG,OAAO,EAAI,eAAe,CAElE,GAAK,IAAM,GAAM,WAAW,CAAG,OAAO,EAAI,QAAQ,CAClD,GAAK,IAAM,GAAM,gBAAgB,CAAG,OAAO,EAAI,aAAa,CAC5D,GAAK,IAAM,GAAM,uBAAuB,CAAG,OAAO,EAAI,qBAAqB,CAE3E,GAAK,IAAM,GAAM,UAAU,CAAG,OAAO,EAAI,IAAI,CAC7C,GAAK,IAAM,GAAM,SAAS,CAAG,OAAO,EAAI,GAAG,CAC3C,GAAK,IAAM,GAAM,cAAc,CAAG,OAAO,EAAI,SAAS,CACtD,GAAK,IAAM,GAAM,sBAAsB,CAAG,OAAO,EAAI,mBAAmB,CACxE,GAAK,IAAM,GAAM,cAAc,CAAG,OAAO,EAAI,SAAS,CACtD,GAAK,IAAM,GAAM,sBAAsB,CAAG,OAAO,EAAI,mBAAmB,CACxE,GAAK,IAAM,GAAM,cAAc,CAAG,OAAO,EAAI,SAAS,CACtD,GAAK,IAAM,GAAM,sBAAsB,CAAG,OAAO,EAAI,mBAAmB,CAExE,GAAK,IAAM,GAAM,cAAc,CAAG,OAAO,EAAI,SAAS,CACtD,GAAK,IAAM,GAAM,sBAAsB,CAAG,OAAO,EAAI,mBAAmB,CACxE,GAAK,IAAM,GAAM,sBAAsB,CAAG,OAAO,EAAI,kBAAkB,CAEvE,GAAK,AAAsC,KAAA,IAAtC,EAAkD,CAEtD,GAAK,IAAM,GAAM,oBAAoB,CAAG,OAAO,EAAkC,4BAA4B,CAC7G,GAAK,IAAM,GAAM,qBAAqB,CAAG,OAAO,EAAkC,6BAA6B,CAC/G,GAAK,IAAM,GAAM,qBAAqB,CAAG,OAAO,EAAkC,6BAA6B,CAC/G,GAAK,IAAM,GAAM,qBAAqB,CAAG,OAAO,EAAkC,6BAA6B,AAEhH,CAEA,OAAO,CAER,CAn8HA,IAAI,CAAC,qBAAqB,CAAG,SAAW,CAAM,CAAE,CAAO,CAAE,CAAQ,EAgBhE,GAdK,EAAO,YAAY,EAAI,CAAE,EAAO,mBAAmB,EAAG,CAAA,EAAO,mBAAmB,CAAG,EAAI,YAAY,EAAxG,EACK,EAAO,UAAU,EAAI,CAAE,EAAO,mBAAmB,EAAG,CAAA,EAAO,mBAAmB,CAAG,EAAI,YAAY,EAAtG,EACK,EAAO,MAAM,EAAI,CAAE,EAAO,eAAe,EAAG,CAAA,EAAO,eAAe,CAAG,EAAI,YAAY,EAA1F,EACK,EAAO,SAAS,EAAI,CAAE,EAAO,kBAAkB,EAAG,CAAA,EAAO,kBAAkB,CAAG,EAAI,YAAY,EAAnG,EAEK,EAAO,YAAY,GAEvB,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAO,mBAAmB,EAC5D,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAO,aAAa,CAAE,EAAI,YAAY,EACxE,EAAI,uBAAuB,CAAE,EAAQ,UAAU,CAAC,QAAQ,EACxD,EAAI,mBAAmB,CAAE,EAAQ,UAAU,CAAC,QAAQ,CAAE,EAAG,EAAI,KAAK,CAAE,CAAA,EAAO,EAAG,IAI1E,EAAO,UAAU,CAAG,CAIxB,GAFA,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAO,mBAAmB,EAEvD,EAAS,OAAO,GAAK,GAAM,WAAW,CAAG,CAE7C,IAAI,EAAI,EAAI,EACX,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EACxC,EACA,EAAG,EAAK,AAAe,EAAf,EAAO,KAAK,CAErB,IAAK,EAAI,EAAG,EAAI,EAAI,GAAK,EAIxB,EAAO,AAFP,CAAA,EAAc,EAAO,WAAW,AAAX,CAEH,CAAE,EAAG,CACvB,EAAO,CAAW,CAAE,EAAI,EAAG,CAC3B,EAAO,CAAW,CAAE,EAAI,EAAG,CAE3B,EAAO,CAAW,CAAE,EAAI,EAAG,CAC3B,EAAO,CAAW,CAAE,EAAI,EAAG,CAC3B,EAAO,CAAW,CAAE,EAAI,EAAG,CAE3B,EAAO,CAAW,CAAE,EAAI,EAAG,CAC3B,EAAO,CAAW,CAAE,EAAI,EAAG,CAC3B,EAAO,CAAW,CAAE,EAAI,EAAG,CAE3B,EAAO,AAAA,CAAA,EAAM,EAAM,CAAA,EAAQ,EAC3B,EAAO,AAAA,CAAA,EAAM,EAAM,CAAA,EAAQ,EAC3B,EAAO,AAAA,CAAA,EAAM,EAAM,CAAA,EAAQ,EAE3B,CAAW,CAAE,EAAG,CAAK,EACrB,CAAW,CAAE,EAAI,EAAG,CAAG,EACvB,CAAW,CAAE,EAAI,EAAG,CAAG,EAEvB,CAAW,CAAE,EAAI,EAAG,CAAG,EACvB,CAAW,CAAE,EAAI,EAAG,CAAG,EACvB,CAAW,CAAE,EAAI,EAAG,CAAG,EAEvB,CAAW,CAAE,EAAI,EAAG,CAAG,EACvB,CAAW,CAAE,EAAI,EAAG,CAAG,EACvB,CAAW,CAAE,EAAI,EAAG,CAAG,CAIzB,CAEA,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAO,WAAW,CAAE,EAAI,YAAY,EACtE,EAAI,uBAAuB,CAAE,EAAQ,UAAU,CAAC,MAAM,EACtD,EAAI,mBAAmB,CAAE,EAAQ,UAAU,CAAC,MAAM,CAAE,EAAG,EAAI,KAAK,CAAE,CAAA,EAAO,EAAG,EAE7E,CAEK,EAAO,MAAM,EAAI,EAAS,GAAG,GAEjC,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAO,eAAe,EACxD,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAO,OAAO,CAAE,EAAI,YAAY,EAClE,EAAI,uBAAuB,CAAE,EAAQ,UAAU,CAAC,EAAE,EAClD,EAAI,mBAAmB,CAAE,EAAQ,UAAU,CAAC,EAAE,CAAE,EAAG,EAAI,KAAK,CAAE,CAAA,EAAO,EAAG,IAIpE,EAAO,SAAS,EAAI,EAAS,YAAY,GAAK,GAAM,QAAQ,GAEhE,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAO,kBAAkB,EAC3D,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAO,UAAU,CAAE,EAAI,YAAY,EACrE,EAAI,uBAAuB,CAAE,EAAQ,UAAU,CAAC,KAAK,EACrD,EAAI,mBAAmB,CAAE,EAAQ,UAAU,CAAC,KAAK,CAAE,EAAG,EAAI,KAAK,CAAE,CAAA,EAAO,EAAG,IAI5E,EAAI,UAAU,CAAE,EAAI,SAAS,CAAE,EAAG,EAAO,KAAK,EAE9C,EAAO,KAAK,CAAG,CAEhB,EAEA,IAAI,CAAC,kBAAkB,CAAG,SAAW,CAAM,CAAE,CAAM,CAAE,CAAG,CAAE,CAAQ,CAAE,CAAQ,CAAE,CAAM,EAEnF,GAAK,AAAqB,CAAA,IAArB,EAAS,OAAO,EAMrB,EAAa,AAFb,CAAA,EAAU,GAAY,EAAQ,EAAQ,EAAK,EAAU,EAArD,EAEqB,UAAU,CAE/B,IANI,EAAS,EAMT,EAAgB,CAAA,EACnB,EAAe,EAAS,SAAS,CAAG,EAAI,EACxC,EAAe,AAAgB,SAAhB,EAAW,EAAE,CAAkB,AAAa,EAAb,EAAQ,EAAE,CAAS,EAiBlE,GAfK,IAAiB,IAErB,EAA4B,EAC5B,EAAgB,CAAA,GAIZ,GAEJ,KAMI,aAAkB,GAAM,IAAI,CAAG,CAEnC,IAAI,EAAQ,EAAS,UAAU,CAAE,KAAS,CAI1C,GAAK,EAAQ,CAEZ,IAAI,EAAU,EAAS,OAAO,AAMzB,CAAA,EAAQ,MAAM,CAAG,GAAI,CAAA,EAAgB,CAAA,CAA1C,EAEA,IAAM,IAAI,EAAI,EAAG,EAAK,EAAQ,MAAM,CAAE,EAAI,EAAI,IAAO,CAEpD,IAAI,EAAa,CAAO,CAAE,EAAG,CAAC,KAAK,CAEnC,GAAK,EAAgB,CAIpB,IAAI,EAAW,EAAS,UAAU,CAAE,QAAY,CAC5C,EAAe,EAAS,QAAQ,CAEpC,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAS,MAAM,EACjD,GAAiB,EAAW,QAAQ,EACpC,EAAI,mBAAmB,CAAE,EAAW,QAAQ,CAAE,EAAc,EAAI,KAAK,CAAE,CAAA,EAAO,EAAG,EAAa,EAAe,GAI7G,IAAI,EAAS,EAAS,UAAU,CAAE,MAAU,CAE5C,GAAK,EAAW,MAAM,EAAI,GAAK,EAAS,CAEvC,IAAI,EAAa,EAAO,QAAQ,CAEhC,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAO,MAAM,EAC/C,GAAiB,EAAW,MAAM,EAClC,EAAI,mBAAmB,CAAE,EAAW,MAAM,CAAE,EAAY,EAAI,KAAK,CAAE,CAAA,EAAO,EAAG,EAAa,EAAa,EAExG,CAIA,IAAI,EAAK,EAAS,UAAU,CAAE,EAAM,CAEpC,GAAK,EAAW,EAAE,EAAI,GAAK,EAAK,CAE/B,IAAI,EAAS,EAAG,QAAQ,CAExB,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAG,MAAM,EAC3C,GAAiB,EAAW,EAAE,EAC9B,EAAI,mBAAmB,CAAE,EAAW,EAAE,CAAE,EAAQ,EAAI,KAAK,CAAE,CAAA,EAAO,EAAG,EAAa,EAAS,EAE5F,CAIA,IAAI,EAAQ,EAAS,UAAU,CAAE,KAAS,CAE1C,GAAK,EAAW,KAAK,EAAI,GAAK,EAAQ,CAErC,IAAI,EAAY,EAAM,QAAQ,CAE9B,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAM,MAAM,EAC9C,GAAiB,EAAW,KAAK,EACjC,EAAI,mBAAmB,CAAE,EAAW,KAAK,CAAE,EAAW,EAAI,KAAK,CAAE,CAAA,EAAO,EAAG,EAAa,EAAY,EAErG,CAIA,IAAI,EAAU,EAAS,UAAU,CAAE,OAAW,CAE9C,GAAK,EAAW,OAAO,EAAI,GAAK,EAAU,CAEzC,IAAI,EAAc,EAAQ,QAAQ,CAElC,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAQ,MAAM,EAChD,GAAiB,EAAW,OAAO,EACnC,EAAI,mBAAmB,CAAE,EAAW,OAAO,CAAE,EAAa,EAAI,KAAK,CAAE,CAAA,EAAO,EAAG,EAAa,EAAc,EAE3G,CAIA,EAAI,UAAU,CAAE,EAAI,oBAAoB,CAAE,EAAM,MAAM,CAEvD,CAIA,EAAI,YAAY,CAAE,EAAI,SAAS,CAAE,CAAO,CAAE,EAAG,CAAC,KAAK,CAAE,EAAI,cAAc,CAAE,AAAqB,EAArB,CAAO,CAAE,EAAG,CAAC,KAAK,EAE3F,EAAM,IAAI,CAAC,MAAM,CAAC,KAAK,GACvB,EAAM,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAI,CAAO,CAAE,EAAG,CAAC,KAAK,CAChD,EAAM,IAAI,CAAC,MAAM,CAAC,KAAK,EAAI,CAAO,CAAE,EAAG,CAAC,KAAK,CAAG,CAEjD,CAID,KAAO,CAEN,GAAK,EAAgB,CAIpB,IAAI,EAAW,EAAS,UAAU,CAAE,QAAY,CAC5C,EAAe,EAAS,QAAQ,CAEpC,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAS,MAAM,EACjD,GAAiB,EAAW,QAAQ,EACpC,EAAI,mBAAmB,CAAE,EAAW,QAAQ,CAAE,EAAc,EAAI,KAAK,CAAE,CAAA,EAAO,EAAG,GAIjF,IAAI,EAAS,EAAS,UAAU,CAAE,MAAU,CAE5C,GAAK,EAAW,MAAM,EAAI,GAAK,EAAS,CAEvC,IAAI,EAAa,EAAO,QAAQ,CAEhC,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAO,MAAM,EAC/C,GAAiB,EAAW,MAAM,EAClC,EAAI,mBAAmB,CAAE,EAAW,MAAM,CAAE,EAAY,EAAI,KAAK,CAAE,CAAA,EAAO,EAAG,EAE9E,CAIA,IAAI,EAAK,EAAS,UAAU,CAAE,EAAM,CAEpC,GAAK,EAAW,EAAE,EAAI,GAAK,EAAK,CAE/B,IAAI,EAAS,EAAG,QAAQ,CAExB,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAG,MAAM,EAC3C,GAAiB,EAAW,EAAE,EAC9B,EAAI,mBAAmB,CAAE,EAAW,EAAE,CAAE,EAAQ,EAAI,KAAK,CAAE,CAAA,EAAO,EAAG,EAEtE,CAIA,IAAI,EAAQ,EAAS,UAAU,CAAE,KAAS,CAE1C,GAAK,EAAW,KAAK,EAAI,GAAK,EAAQ,CAErC,IAAI,EAAY,EAAM,QAAQ,CAE9B,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAM,MAAM,EAC9C,GAAiB,EAAW,KAAK,EACjC,EAAI,mBAAmB,CAAE,EAAW,KAAK,CAAE,EAAW,EAAI,KAAK,CAAE,CAAA,EAAO,EAAG,EAE5E,CAIA,IAAI,EAAU,EAAS,UAAU,CAAE,OAAW,CAE9C,GAAK,EAAW,OAAO,EAAI,GAAK,EAAU,CAEzC,IAAI,EAAc,EAAQ,QAAQ,CAElC,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAQ,MAAM,EAChD,GAAiB,EAAW,OAAO,EACnC,EAAI,mBAAmB,CAAE,EAAW,OAAO,CAAE,EAAa,EAAI,KAAK,CAAE,CAAA,EAAO,EAAG,EAEhF,CAED,CAIA,EAAI,UAAU,CAAE,EAAI,SAAS,CAAE,EAAG,EAAS,QAAQ,CAAG,GAEtD,EAAM,IAAI,CAAC,MAAM,CAAC,KAAK,GACvB,EAAM,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAI,EAAS,QAAQ,CAAG,EAClD,EAAM,IAAI,CAAC,MAAM,CAAC,KAAK,EAAI,EAAS,QAAQ,CAAG,EAAI,CAEpD,CAID,MAAO,GAAK,aAAkB,GAAM,cAAc,CAEjD,CAAA,GAAK,EAAgB,CAIpB,IAAI,EAAW,EAAS,UAAU,CAAE,QAAY,CAC5C,EAAe,EAAS,QAAQ,CAEpC,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAS,MAAM,EACjD,GAAiB,EAAW,QAAQ,EACpC,EAAI,mBAAmB,CAAE,EAAW,QAAQ,CAAE,EAAc,EAAI,KAAK,CAAE,CAAA,EAAO,EAAG,GAIjF,IAAI,EAAQ,EAAS,UAAU,CAAE,KAAS,CAE1C,GAAK,EAAW,KAAK,EAAI,GAAK,EAAQ,CAErC,IAAI,EAAY,EAAM,QAAQ,CAE9B,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAM,MAAM,EAC9C,GAAiB,EAAW,KAAK,EACjC,EAAI,mBAAmB,CAAE,EAAW,KAAK,CAAE,EAAW,EAAI,KAAK,CAAE,CAAA,EAAO,EAAG,EAE5E,CAIA,EAAI,UAAU,CAAE,EAAI,MAAM,CAAE,EAAG,EAAS,QAAQ,CAAG,GAEnD,EAAM,IAAI,CAAC,MAAM,CAAC,KAAK,GACvB,EAAM,IAAI,CAAC,MAAM,CAAC,MAAM,EAAI,EAAS,QAAQ,CAAG,CAEjD,CAAA,MAEM,GAAK,aAAkB,GAAM,IAAI,EAElC,EAAgB,CAIpB,IAAI,EAAW,EAAS,UAAU,CAAE,QAAY,CAC5C,EAAe,EAAS,QAAQ,CAEpC,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAS,MAAM,EACjD,GAAiB,EAAW,QAAQ,EACpC,EAAI,mBAAmB,CAAE,EAAW,QAAQ,CAAE,EAAc,EAAI,KAAK,CAAE,CAAA,EAAO,EAAG,GAIjF,IAAI,EAAQ,EAAS,UAAU,CAAE,KAAS,CAE1C,GAAK,EAAW,KAAK,EAAI,GAAK,EAAQ,CAErC,IAAI,EAAY,EAAM,QAAQ,CAE9B,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAM,MAAM,EAC9C,GAAiB,EAAW,KAAK,EACjC,EAAI,mBAAmB,CAAE,EAAW,KAAK,CAAE,EAAW,EAAI,KAAK,CAAE,CAAA,EAAO,EAAG,EAE5E,CAIA,GAAc,EAAS,SAAS,EAEhC,EAAI,UAAU,CAAE,EAAI,UAAU,CAAE,EAAG,EAAS,QAAQ,CAAG,GAEvD,EAAM,IAAI,CAAC,MAAM,CAAC,KAAK,GACvB,EAAM,IAAI,CAAC,MAAM,CAAC,MAAM,EAAI,EAAS,QAAQ,AAE9C,EAIF,EAEA,IAAI,CAAC,YAAY,CAAG,SAAW,CAAM,CAAE,CAAM,CAAE,CAAG,CAAE,CAAQ,CAAE,CAAa,CAAE,CAAM,EAElF,GAAK,AAAqB,CAAA,IAArB,EAAS,OAAO,EAMrB,EAAa,AAFb,CAAA,EAAU,GAAY,EAAQ,EAAQ,EAAK,EAAU,EAArD,EAEqB,UAAU,CAE/B,IANI,EAAS,EAAuB,EAAe,EAAW,EAAG,EAM7D,EAAgB,CAAA,EACnB,EAAe,EAAS,SAAS,CAAG,EAAI,EACxC,EAAoB,AAAqB,SAArB,EAAgB,EAAE,CAAkB,AAAa,EAAb,EAAQ,EAAE,CAAS,EAsC5E,GApCK,IAAsB,IAE1B,EAA4B,EAC5B,EAAgB,CAAA,GAIZ,GAEJ,KAMI,CAAC,EAAS,YAAY,EAAI,EAAW,QAAQ,EAAI,EAEhD,IAEJ,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAc,mBAAmB,EACnE,GAAiB,EAAW,QAAQ,EACpC,EAAI,mBAAmB,CAAE,EAAW,QAAQ,CAAE,EAAG,EAAI,KAAK,CAAE,CAAA,EAAO,EAAG,IAMlE,EAAO,eAAe,EAE1B,AA8LH,SAA6B,CAAQ,CAAE,CAAa,CAAE,CAAM,EAI3D,IAAI,EAAa,EAAS,OAAO,CAAC,UAAU,CAgB5C,GAdK,AAA2B,KAA3B,EAAO,eAAe,EAAW,EAAW,QAAQ,EAAI,GAE5D,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAc,0BAA0B,CAAE,EAAO,eAAe,CAAE,EACpG,GAAiB,EAAW,QAAQ,EACpC,EAAI,mBAAmB,CAAE,EAAW,QAAQ,CAAE,EAAG,EAAI,KAAK,CAAE,CAAA,EAAO,EAAG,IAE3D,EAAW,QAAQ,EAAI,IAElC,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAc,mBAAmB,EACnE,GAAiB,EAAW,QAAQ,EACpC,EAAI,mBAAmB,CAAE,EAAW,QAAQ,CAAE,EAAG,EAAI,KAAK,CAAE,CAAA,EAAO,EAAG,IAIlE,EAAO,sBAAsB,CAAC,MAAM,CAQxC,IAJA,IAAI,EAAI,EACJ,EAAQ,EAAO,sBAAsB,CACrC,EAAa,EAAO,qBAAqB,CAErC,EAAI,EAAS,wBAAwB,EAAI,EAAI,EAAM,MAAM,EAE3D,CAAU,CAAE,cAAgB,EAAG,EAAI,IAEvC,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAc,0BAA0B,CAAE,CAAK,CAAE,EAAG,CAAE,EACxF,GAAiB,CAAU,CAAE,cAAgB,EAAG,EAChD,EAAI,mBAAmB,CAAE,CAAU,CAAE,cAAgB,EAAG,CAAE,EAAG,EAAI,KAAK,CAAE,CAAA,EAAO,EAAG,IAI9E,CAAU,CAAE,cAAgB,EAAG,EAAI,GAAK,EAAS,YAAY,GAEjE,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAc,0BAA0B,CAAE,CAAK,CAAE,EAAG,CAAE,EACxF,GAAiB,CAAU,CAAE,cAAgB,EAAG,EAChD,EAAI,mBAAmB,CAAE,CAAU,CAAE,cAAgB,EAAG,CAAE,EAAG,EAAI,KAAK,CAAE,CAAA,EAAO,EAAG,IAInF,EAAO,4BAA4B,CAAE,EAAG,CAAG,CAAU,CAAE,CAAK,CAAE,EAAG,CAAE,CAEnE,QAGK,CAIN,IAAI,EAEA,EAFW,EAAyB,EAAE,CACtC,EAAa,EAAO,qBAAqB,CACtC,EAAK,EAAW,MAAM,CAE7B,IAAM,EAAI,EAAG,EAAI,EAAI,IAEpB,CAAA,EAAY,CAAU,CAAE,EAAG,AAAH,EAEP,GAEhB,EAAuB,IAAI,CAAE,CAAE,EAAW,EAAG,CAM1C,CAAA,EAAuB,MAAM,CAAG,EAAS,wBAAwB,EAErE,EAAuB,IAAI,CAAE,IAC7B,EAAuB,MAAM,CAAG,EAAS,wBAAwB,EAEtD,EAAuB,MAAM,CAAG,EAAS,wBAAwB,CAE5E,EAAuB,IAAI,CAAE,IAEgB,IAAlC,EAAuB,MAAM,EAExC,EAAuB,IAAI,CAAE,CAAE,EAAG,EAAG,EAMtC,IAFA,IAAI,EAAgB,EAAI,EAEhB,EAAI,EAAS,wBAAwB,EAEvC,CAAsB,CAAE,EAAG,EAE/B,EAAiB,CAAsB,CAAE,EAAG,CAAE,EAAG,CAE5C,CAAU,CAAE,cAAgB,EAAG,EAAI,IAEvC,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAc,0BAA0B,CAAE,EAAgB,EAC5F,GAAiB,CAAU,CAAE,cAAgB,EAAG,EAChD,EAAI,mBAAmB,CAAE,CAAU,CAAE,cAAgB,EAAG,CAAE,EAAG,EAAI,KAAK,CAAE,CAAA,EAAO,EAAG,IAI9E,CAAU,CAAE,cAAgB,EAAG,EAAI,GAAK,EAAS,YAAY,GAEjE,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAc,0BAA0B,CAAE,EAAgB,EAC5F,GAAiB,CAAU,CAAE,cAAgB,EAAG,EAChD,EAAI,mBAAmB,CAAE,CAAU,CAAE,cAAgB,EAAG,CAAE,EAAG,EAAI,KAAK,CAAE,CAAA,EAAO,EAAG,IAKnF,EAAO,4BAA4B,CAAE,EAAG,CAAG,CAAU,CAAE,EAAgB,EAcvE,EAAO,4BAA4B,CAAE,EAAG,CAAG,EAI5C,GAIF,CAIyD,OAApD,EAAS,OAAO,CAAC,QAAQ,CAAC,qBAAqB,EAEnD,EAAI,UAAU,CAAE,EAAS,OAAO,CAAC,QAAQ,CAAC,qBAAqB,CAAE,EAAO,4BAA4B,CAItG,EA7UsB,EAAU,EAAe,GAOzC,EAAgB,CAMpB,GAAK,EAAc,2BAA2B,CAE7C,IAAM,EAAI,EAAG,EAAK,EAAc,2BAA2B,CAAC,MAAM,CAAE,EAAI,EAAI,IAItE,CAAU,CAAE,AAFjB,CAAA,EAAY,EAAc,2BAA2B,CAAE,EAAG,AAAH,EAE5B,MAAM,CAAC,kBAAkB,CAAE,EAAI,IAEzD,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAU,MAAM,EAClD,GAAiB,CAAU,CAAE,EAAU,MAAM,CAAC,kBAAkB,CAAE,EAClE,EAAI,mBAAmB,CAAE,CAAU,CAAE,EAAU,MAAM,CAAC,kBAAkB,CAAE,CAAE,EAAU,IAAI,CAAE,EAAI,KAAK,CAAE,CAAA,EAAO,EAAG,GAW/G,CAAA,EAAW,KAAK,EAAI,IAExB,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAc,kBAAkB,EAClE,GAAiB,EAAW,KAAK,EACjC,EAAI,mBAAmB,CAAE,EAAW,KAAK,CAAE,EAAG,EAAI,KAAK,CAAE,CAAA,EAAO,EAAG,IAM/D,EAAW,MAAM,EAAI,IAEzB,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAc,mBAAmB,EACnE,GAAiB,EAAW,MAAM,EAClC,EAAI,mBAAmB,CAAE,EAAW,MAAM,CAAE,EAAG,EAAI,KAAK,CAAE,CAAA,EAAO,EAAG,IAMhE,EAAW,OAAO,EAAI,IAE1B,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAc,oBAAoB,EACpE,GAAiB,EAAW,OAAO,EACnC,EAAI,mBAAmB,CAAE,EAAW,OAAO,CAAE,EAAG,EAAI,KAAK,CAAE,CAAA,EAAO,EAAG,IAMjE,EAAW,EAAE,EAAI,IAErB,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAc,eAAe,EAC/D,GAAiB,EAAW,EAAE,EAC9B,EAAI,mBAAmB,CAAE,EAAW,EAAE,CAAE,EAAG,EAAI,KAAK,CAAE,CAAA,EAAO,EAAG,IAI5D,EAAW,GAAG,EAAI,IAEtB,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAc,gBAAgB,EAChE,GAAiB,EAAW,GAAG,EAC/B,EAAI,mBAAmB,CAAE,EAAW,GAAG,CAAE,EAAG,EAAI,KAAK,CAAE,CAAA,EAAO,EAAG,IAI7D,EAAS,QAAQ,EACpB,EAAW,SAAS,EAAI,GAAK,EAAW,UAAU,EAAI,IAEvD,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAc,wBAAwB,EACxE,GAAiB,EAAW,SAAS,EACrC,EAAI,mBAAmB,CAAE,EAAW,SAAS,CAAE,EAAG,EAAI,KAAK,CAAE,CAAA,EAAO,EAAG,GAEvE,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAc,wBAAwB,EACxE,GAAiB,EAAW,UAAU,EACtC,EAAI,mBAAmB,CAAE,EAAW,UAAU,CAAE,EAAG,EAAI,KAAK,CAAE,CAAA,EAAO,EAAG,IAMpE,EAAW,YAAY,EAAI,IAE/B,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAc,yBAAyB,EACzE,GAAiB,EAAW,YAAY,EACxC,EAAI,mBAAmB,CAAE,EAAW,YAAY,CAAE,EAAG,EAAI,KAAK,CAAE,CAAA,EAAO,EAAG,GAI5E,CAIK,aAAkB,GAAM,IAAI,EAI3B,EAAS,SAAS,EAEtB,GAAc,EAAS,kBAAkB,EAEpC,GAAgB,EAAI,UAAU,CAAE,EAAI,oBAAoB,CAAE,EAAc,iBAAiB,EAC9F,EAAI,YAAY,CAAE,EAAI,KAAK,CAAE,EAAc,gBAAgB,CAAE,EAAI,cAAc,CAAE,KAM5E,GAAgB,EAAI,UAAU,CAAE,EAAI,oBAAoB,CAAE,EAAc,iBAAiB,EAC9F,EAAI,YAAY,CAAE,EAAI,SAAS,CAAE,EAAc,gBAAgB,CAAE,EAAI,cAAc,CAAE,IAItF,EAAM,IAAI,CAAC,MAAM,CAAC,KAAK,GACvB,EAAM,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAI,EAAc,gBAAgB,CAC5D,EAAM,IAAI,CAAC,MAAM,CAAC,KAAK,EAAI,EAAc,gBAAgB,CAAG,GAIjD,aAAkB,GAAM,IAAI,EAEvC,EAAa,EAAS,IAAI,GAAK,GAAM,SAAS,CAAK,EAAI,UAAU,CAAG,EAAI,KAAK,CAE7E,GAAc,EAAS,SAAS,EAEhC,EAAI,UAAU,CAAE,EAAY,EAAG,EAAc,gBAAgB,EAE7D,EAAM,IAAI,CAAC,MAAM,CAAC,KAAK,IAIZ,aAAkB,GAAM,cAAc,EAEjD,EAAI,UAAU,CAAE,EAAI,MAAM,CAAE,EAAG,EAAc,oBAAoB,EAEjE,EAAM,IAAI,CAAC,MAAM,CAAC,KAAK,GACvB,EAAM,IAAI,CAAC,MAAM,CAAC,MAAM,EAAI,EAAc,oBAAoB,EAInD,aAAkB,GAAM,MAAM,GAEzC,EAAI,UAAU,CAAE,EAAI,cAAc,CAAE,EAAG,EAAc,kBAAkB,EAEvE,EAAM,IAAI,CAAC,MAAM,CAAC,KAAK,IAIzB,EAsMA,IAAI,CAAC,MAAM,CAAG,SAAW,CAAK,CAAE,CAAM,CAAE,CAAY,CAAE,CAAU,EAE/D,GAAK,aAAkB,GAAM,MAAM,EAAK,CAAA,EAAQ,CAE/C,QAAQ,KAAK,CAAE,0EACf,MAED,CAEA,IAAI,EAAG,EAEP,EAAa,EACb,EAEA,EAAS,EAAM,QAAQ,CACvB,EAAM,EAAM,GAAG,CA+Cf,IAAM,AA3CN,EAAqB,GACrB,EAAoB,CAAA,EAIf,IAAI,CAAC,eAAe,EAAG,EAAM,iBAAiB,GAI5B,KAAA,IAAlB,EAAO,MAAM,EAAiB,EAAO,iBAAiB,GAE3D,EAAO,kBAAkB,CAAC,UAAU,CAAE,EAAO,WAAW,EAExD,EAAkB,gBAAgB,CAAE,EAAO,gBAAgB,CAAE,EAAO,kBAAkB,EACtF,EAAS,aAAa,CAAE,GAInB,IAAI,CAAC,iBAAiB,EAAG,IAAI,CAAC,gBAAgB,CAAE,GAIrD,GAAe,IAAI,CAAC,gBAAgB,CAAE,EAAO,GAI7C,EAAM,IAAI,CAAC,MAAM,CAAC,KAAK,CAAG,EAC1B,EAAM,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAG,EAC7B,EAAM,IAAI,CAAC,MAAM,CAAC,KAAK,CAAG,EAC1B,EAAM,IAAI,CAAC,MAAM,CAAC,MAAM,CAAG,EAE3B,IAAI,CAAC,eAAe,CAAE,GAEjB,CAAA,IAAI,CAAC,SAAS,EAAI,CAAA,GAEtB,IAAI,CAAC,KAAK,CAAE,IAAI,CAAC,cAAc,CAAE,IAAI,CAAC,cAAc,CAAE,IAAI,CAAC,gBAAgB,EAQtE,EAAI,EAAG,EAAK,AAFlB,CAAA,EAAa,EAAM,cAAc,AAAd,EAEU,MAAM,CAAE,EAAI,EAAI,IAG5C,EAAS,AADT,CAAA,EAAc,CAAU,CAAE,EAAG,AAAH,EACL,MAAM,CAE3B,EAAY,MAAM,CAAG,CAAA,EAEhB,EAAO,OAAO,EAEb,CAAA,CAAI,CAAA,aAAkB,GAAM,IAAI,EAAI,aAAkB,GAAM,cAAc,AAAd,GAAoB,CAAI,EAAO,aAAa,EAAM,EAAS,gBAAgB,CAAE,EAAA,IAE7I,GAAe,EAAQ,GAEvB,AA8RJ,SAAgC,CAAQ,EAEvC,IAEC,EAAU,EAAe,EAFtB,EAAS,EAAS,MAAM,CAC3B,EAAS,EAAS,MAAM,AAKpB,CAFL,CAAA,EAAe,EAAO,QAAQ,AAAR,YAEO,GAAM,gBAAgB,EAElD,EAAgB,EAAO,aAAa,CAI/B,AAFL,CAAA,EAAW,EAAa,SAAS,CAAE,EAAe,AAAf,EAErB,WAAW,EAExB,EAAS,WAAW,CAAG,EACvB,EAAS,MAAM,CAAG,OAIlB,EAAS,MAAM,CAAG,EAClB,EAAS,WAAW,CAAG,OAMxB,CAAA,EAAW,CAAX,IAIM,EAAS,WAAW,EAExB,EAAS,WAAW,CAAG,EACvB,EAAS,MAAM,CAAG,OAIlB,EAAS,MAAM,CAAG,EAClB,EAAS,WAAW,CAAG,MAQ3B,EA9U0B,GAEtB,EAAY,MAAM,CAAG,CAAA,EAEK,CAAA,IAArB,IAAI,CAAC,WAAW,GAEf,AAAuB,OAAvB,EAAO,WAAW,CAEtB,EAAY,CAAC,CAAG,EAAO,WAAW,EAIlC,EAAS,qBAAqB,CAAE,EAAO,WAAW,EAClD,EAAS,eAAe,CAAE,GAE1B,EAAY,CAAC,CAAG,EAAS,CAAC,EAI3B,EAAY,EAAE,CAAG,EAAO,EAAE,GAoB9B,IAAM,AAVD,IAAI,CAAC,WAAW,EAEpB,EAAW,IAAI,CAAE,IAQZ,EAAI,EAAG,EAAK,AAFlB,CAAA,EAAa,EAAM,uBAAuB,AAAvB,EAEU,MAAM,CAAE,EAAI,EAAI,IAKvC,AAFL,CAAA,EAAS,AADT,CAAA,EAAc,CAAU,CAAE,EAAG,AAAH,EACL,MAAM,AAAN,EAET,OAAO,GAElB,GAAe,EAAQ,GAEvB,AA2NH,SAAyC,CAAQ,EAEhD,IACC,EAAW,AADC,EAAS,MAAM,CACT,QAAQ,AAEtB,CAAA,EAAS,WAAW,EAExB,EAAS,WAAW,CAAG,EACvB,EAAS,MAAM,CAAG,OAIlB,EAAS,MAAM,CAAG,EAClB,EAAS,WAAW,CAAG,KAIzB,EA5OkC,IAMjC,GAAK,EAAM,gBAAgB,CAAG,CAE7B,IAAI,EAAW,EAAM,gBAAgB,CAErC,IAAI,CAAC,WAAW,CAAE,EAAS,QAAQ,CAAE,EAAS,aAAa,CAAE,EAAS,QAAQ,CAAE,EAAS,QAAQ,EACjG,IAAI,CAAC,YAAY,CAAE,EAAS,SAAS,EACrC,IAAI,CAAC,aAAa,CAAE,EAAS,UAAU,EACvC,GAAkB,EAAS,aAAa,CAAE,EAAS,mBAAmB,CAAE,EAAS,kBAAkB,EAEnG,GAAe,EAAM,cAAc,CAAE,CAAA,EAAO,GAAI,EAAQ,EAAQ,EAAK,CAAA,EAAM,GAC3E,GAAwB,EAAM,uBAAuB,CAAE,GAAI,EAAQ,EAAQ,EAAK,CAAA,EAAO,EAExF,KAAO,CAEN,IAAI,EAAW,KAIf,IAAI,CAAC,WAAW,CAAE,GAAM,UAAU,EAElC,GAAe,EAAM,cAAc,CAAE,CAAA,EAAM,SAAU,EAAQ,EAAQ,EAAK,CAAA,EAAO,GACjF,GAAwB,EAAM,uBAAuB,CAAE,SAAU,EAAQ,EAAQ,EAAK,CAAA,EAAO,GAI7F,GAAe,EAAM,cAAc,CAAE,CAAA,EAAO,cAAe,EAAQ,EAAQ,EAAK,CAAA,EAAM,GACtF,GAAwB,EAAM,uBAAuB,CAAE,cAAe,EAAQ,EAAQ,EAAK,CAAA,EAAM,EAElG,CAIA,GAAe,IAAI,CAAC,iBAAiB,CAAE,EAAO,GAKzC,GAAgB,EAAa,eAAe,EAAI,EAAa,SAAS,GAAK,GAAM,aAAa,EAAI,EAAa,SAAS,GAAK,GAAM,YAAY,GA06F/I,AAx6FsB,aAw6FE,GAAM,qBAAqB,EAEvD,EAAI,WAAW,CAAE,EAAI,gBAAgB,CAAE,AA16Fb,EA06F0B,cAAc,EAClE,EAAI,cAAc,CAAE,EAAI,gBAAgB,EACxC,EAAI,WAAW,CAAE,EAAI,gBAAgB,CAAE,QAIvC,EAAI,WAAW,CAAE,EAAI,UAAU,CAAE,AAh7FP,EAg7FoB,cAAc,EAC5D,EAAI,cAAc,CAAE,EAAI,UAAU,EAClC,EAAI,WAAW,CAAE,EAAI,UAAU,CAAE,QA56FlC,IAAI,CAAC,YAAY,CAAE,CAAA,GACnB,IAAI,CAAC,aAAa,CAAE,CAAA,EAIrB,EA+IA,IAAI,CAAC,qBAAqB,CAAG,SAAW,CAAM,CAAE,CAAM,CAAE,CAAG,CAAE,CAAQ,CAAE,CAAM,EAE5E,IAAI,EAAU,GAAY,EAAQ,EAAQ,EAAK,EAAU,GAEzD,EAA4B,GAE5B,EAAM,gBAAgB,CAAE,GAEnB,EAAO,uBAAuB,CAElC,EAAO,uBAAuB,CAAE,EAAS,EAAK,GAI9C,EAAO,MAAM,CAAE,SAAU,CAAM,EAAK,EAAM,qBAAqB,CAAE,EAAQ,EAAS,EAAY,EAIhG,EAmJA,IAAI,CAAC,gBAAgB,CAAG,SAAW,CAAK,EAWvC,IATM,EAAM,cAAc,GAEzB,EAAM,cAAc,CAAG,EAAE,CACzB,EAAM,uBAAuB,CAAG,EAAE,CAClC,EAAM,cAAc,CAAG,EAAE,CACzB,EAAM,aAAa,CAAG,EAAE,EAIjB,EAAM,cAAc,CAAC,MAAM,EAElC,AAwBF,CAAA,SAAqB,CAAM,CAAE,CAAK,MAE7B,EAAG,EAAU,EAAU,EArlIG,EA8bF,EAExB,EA1cwB,EA0bF,EAEtB,EArc4B,EAobF,EAE1B,EAorHJ,GAAK,CAAE,EAAO,WAAW,EAcxB,GAZA,EAAO,WAAW,CAAG,CAAA,EAErB,EAAO,gBAAgB,CAAG,IAAI,GAAM,OAAO,CAC3C,EAAO,aAAa,CAAG,IAAI,GAAM,OAAO,CAEf,KAAA,IAApB,EAAO,QAAQ,EAAkB,AAAgC,KAAA,IAAhC,EAAO,QAAQ,CAAC,WAAW,GAEhE,EAAO,QAAQ,CAAC,WAAW,CAAG,CAAA,EAC9B,EAAO,QAAQ,CAAC,gBAAgB,CAAE,UAAW,KAIzC,aAAkB,GAAM,IAAI,EAKhC,GAHA,EAAW,EAAO,QAAQ,CAC1B,EAAW,EAAO,QAAQ,CAErB,aAAoB,GAAM,QAAQ,CAUtC,IAAM,KAR2B,KAAA,IAA5B,EAAS,cAAc,EAE3B,AA1IL,SAA+B,CAAQ,CAAE,CAAQ,EAEhD,IAAI,EAAG,EAAI,EAAM,EAAe,EAC/B,EAAW,EAAW,CAAC,EAEpB,EAAkB,EAAS,YAAY,CAAC,MAAM,CAC9C,EAAkB,EAAS,YAAY,CAAC,MAAM,CAE9C,EAAmB,aAAoB,GAAM,gBAAgB,CAIjE,IAAM,EAAI,EAFV,EAAS,cAAc,CAAG,CAAC,EAEd,EAAK,EAAS,KAAK,CAAC,MAAM,CAAE,EAAI,EAAI,IAEhD,EAAO,EAAS,KAAK,CAAE,EAAG,CAGS,KAAA,IAA9B,CAAQ,CAFb,EAAgB,EAAmB,EAAK,aAAa,CAAG,EAE1B,EAE7B,CAAA,CAAQ,CAAE,EAAe,CAAG,CAAE,KAAQ,EAAe,QAAW,CAAE,CAAA,EAInE,EAAY,CAAQ,CAAE,EAAe,CAAC,IAAI,CAAG,IAAM,CAAQ,CAAE,EAAe,CAAC,OAAO,CAEtC,KAAA,IAAzC,EAAS,cAAc,CAAE,EAAW,EAExC,CAAA,EAAS,cAAc,CAAE,EAAW,CAAG,CAAE,OAAU,EAAE,CAAE,OAAU,EAAE,CAAE,cAAiB,EAAe,SAAY,EAAG,gBAAmB,EAAiB,gBAAmB,CAAgB,CAAA,EAI5L,EAAW,aAAgB,GAAM,KAAK,CAAG,EAAI,EAExC,EAAS,cAAc,CAAE,EAAW,CAAC,QAAQ,CAAG,EAAW,QAE/D,CAAQ,CAAE,EAAe,CAAC,OAAO,EAAI,EACrC,EAAY,CAAQ,CAAE,EAAe,CAAC,IAAI,CAAG,IAAM,CAAQ,CAAE,EAAe,CAAC,OAAO,CAEtC,KAAA,IAAzC,EAAS,cAAc,CAAE,EAAW,EAExC,CAAA,EAAS,cAAc,CAAE,EAAW,CAAG,CAAE,OAAU,EAAE,CAAE,OAAU,EAAE,CAAE,cAAiB,EAAe,SAAY,EAAG,gBAAmB,EAAiB,gBAAmB,CAAgB,CAAA,GAMxL,aAAgB,GAAM,KAAK,CAE/B,EAAS,cAAc,CAAE,EAAW,CAAC,MAAM,CAAC,IAAI,CAAE,GAIlD,EAAS,cAAc,CAAE,EAAW,CAAC,MAAM,CAAC,IAAI,CAAE,GAInD,EAAS,cAAc,CAAE,EAAW,CAAC,QAAQ,EAAI,EAMlD,IAAM,IAAI,KAFV,EAAS,kBAAkB,CAAG,EAAE,CAEjB,EAAS,cAAc,CAErC,EAAS,cAAc,CAAE,EAAG,CAAC,EAAE,CAAG,IAElC,EAAS,kBAAkB,CAAC,IAAI,CAAE,EAAS,cAAc,CAAE,EAAG,CAIhE,EAoE0B,EAAU,GAMrB,EAAS,cAAc,CAM1B,AAJP,CAAA,EAAgB,EAAS,cAAc,CAAE,EAAG,AAAH,EAIpB,mBAAmB,GAEvC,AAlnIN,SAA6B,CAAa,MAerC,EAAG,EAEP,GAfA,EAAc,mBAAmB,CAAG,EAAI,YAAY,GACpD,EAAc,mBAAmB,CAAG,EAAI,YAAY,GACpD,EAAc,oBAAoB,CAAG,EAAI,YAAY,GACrD,EAAc,kBAAkB,CAAG,EAAI,YAAY,GACnD,EAAc,eAAe,CAAG,EAAI,YAAY,GAChD,EAAc,gBAAgB,CAAG,EAAI,YAAY,GAEjD,EAAc,wBAAwB,CAAG,EAAI,YAAY,GACzD,EAAc,wBAAwB,CAAG,EAAI,YAAY,GAEzD,EAAc,iBAAiB,CAAG,EAAI,YAAY,GAClD,EAAc,iBAAiB,CAAG,EAAI,YAAY,GAI7C,EAAc,eAAe,CAIjC,IAAM,EAAI,EAFV,EAAc,0BAA0B,CAAG,EAAE,CAEhC,EAAK,EAAc,eAAe,CAAE,EAAI,EAAI,IAExD,EAAc,0BAA0B,CAAC,IAAI,CAAE,EAAI,YAAY,IAMjE,GAAK,EAAc,eAAe,CAIjC,IAAM,EAAI,EAFV,EAAc,0BAA0B,CAAG,EAAE,CAEhC,EAAK,EAAc,eAAe,CAAE,EAAI,EAAI,IAExD,EAAc,0BAA0B,CAAC,IAAI,CAAE,EAAI,YAAY,GAMjE,CAAA,EAAM,IAAI,CAAC,MAAM,CAAC,UAAU,EAE7B,EAukIyB,GACnB,GAAiB,EAAe,GAEhC,EAAS,kBAAkB,CAAG,CAAA,EAC9B,EAAS,sBAAsB,CAAG,CAAA,EAClC,EAAS,kBAAkB,CAAG,CAAA,EAC9B,EAAS,aAAa,CAAG,CAAA,EACzB,EAAS,iBAAiB,CAAG,CAAA,EAC7B,EAAS,kBAAkB,CAAG,CAAA,EAC9B,EAAS,gBAAgB,CAAG,CAAA,QAMnB,aAAoB,GAAM,cAAc,EAEnD,GAAmB,QAIT,aAAkB,GAAM,MAAM,CAIlC,AAFP,CAAA,EAAW,EAAO,QAAQ,AAAR,EAEF,mBAAmB,GAnpIrC,CAF8B,EAupIN,GArpIf,mBAAmB,CAAG,EAAI,YAAY,GAC/C,EAAS,kBAAkB,CAAG,EAAI,YAAY,GAC9C,EAAS,mBAAmB,CAAG,EAAI,YAAY,GAE/C,EAAM,IAAI,CAAC,MAAM,CAAC,UAAU,GA0bxB,EAAY,CAFY,EA0tHN,GAxtHG,QAAQ,CAAC,MAAM,CAExC,EAAS,aAAa,CAAG,IAAI,aAAc,AAAY,EAAZ,GAC3C,EAAS,YAAY,CAAG,IAAI,aAAc,AAAY,EAAZ,GAC1C,EAAS,aAAa,CAAG,IAAI,aAAc,AAAY,EAAZ,GAE3C,EAAS,kBAAkB,CAAG,EAE9B,GAAuB,EAgtHS,GAE7B,EAAS,kBAAkB,CAAG,CAAA,EAC9B,EAAS,gBAAgB,CAAG,CAAA,EAC5B,EAAS,iBAAiB,CAAG,CAAA,GAInB,aAAkB,GAAM,IAAI,CAIlC,CAAE,AAFP,CAAA,EAAW,EAAO,QAAQ,AAAR,EAEF,mBAAmB,GAE7B,aAAoB,GAAM,QAAQ,EA9qI1C,CAF4B,EAkrIC,GAhrIpB,mBAAmB,CAAG,EAAI,YAAY,GAC/C,EAAS,kBAAkB,CAAG,EAAI,YAAY,GAC9C,EAAS,yBAAyB,CAAG,EAAI,YAAY,GAErD,EAAM,IAAI,CAAC,MAAM,CAAC,UAAU,GAsbxB,EAAY,CAFU,EAyvHC,GAvvHF,QAAQ,CAAC,MAAM,CAExC,EAAS,aAAa,CAAG,IAAI,aAAc,AAAY,EAAZ,GAC3C,EAAS,YAAY,CAAG,IAAI,aAAc,AAAY,EAAZ,GAC1C,EAAS,mBAAmB,CAAG,IAAI,aAAc,AAAY,EAAZ,GAEjD,EAAS,gBAAgB,CAAG,EAE5B,GAAuB,EA+uHc,GAE3B,EAAS,kBAAkB,CAAG,CAAA,EAC9B,EAAS,gBAAgB,CAAG,CAAA,EAC5B,EAAS,uBAAuB,CAAG,CAAA,GAEzB,aAAoB,GAAM,cAAc,EAExD,GAAmB,IAMV,aAAkB,GAAM,cAAc,EAI5C,CAAE,AAFP,CAAA,EAAW,EAAO,QAAQ,AAAR,EAEF,mBAAmB,GAE7B,aAAoB,GAAM,QAAQ,EA9sI1C,CAFgC,EAktIL,GAhtIlB,mBAAmB,CAAG,EAAI,YAAY,GAC/C,EAAS,kBAAkB,CAAG,EAAI,YAAY,GAE9C,EAAM,IAAI,CAAC,MAAM,CAAC,UAAU,GAibxB,EAAY,CAFc,EA+xHL,GA7xHA,QAAQ,CAAC,MAAM,CAExC,EAAS,aAAa,CAAG,IAAI,aAAc,AAAY,EAAZ,GAC3C,EAAS,YAAY,CAAG,IAAI,aAAc,AAAY,EAAZ,GAE1C,EAAS,WAAW,CAAG,EAAE,CAEzB,EAAS,oBAAoB,CAAG,EAEhC,GAAuB,EAoxHY,GAE/B,EAAS,kBAAkB,CAAG,CAAA,EAC9B,EAAS,gBAAgB,CAAG,CAAA,GAEjB,aAAoB,GAAM,cAAc,EAEnD,GAAmB,IAWvB,GAAK,CAAE,EAAO,aAAa,CAAG,CAE7B,GAAK,aAAkB,GAAM,IAAI,EAIhC,GAAK,AAFL,CAAA,EAAW,EAAO,QAAQ,AAAR,YAEO,GAAM,cAAc,CAE5C,GAAW,EAAM,cAAc,CAAE,EAAU,QAErC,GAAK,aAAoB,GAAM,QAAQ,CAE7C,IAAM,KAAK,EAAS,cAAc,CAEjC,EAAgB,EAAS,cAAc,CAAE,EAAG,CAE5C,GAAW,EAAM,cAAc,CAAE,EAAe,QAMvC,aAAkB,GAAM,MAAM,EACvC,aAAkB,GAAM,IAAI,EAC5B,aAAkB,GAAM,cAAc,EAExC,EAAW,EAAO,QAAQ,CAC1B,GAAW,EAAM,cAAc,CAAE,EAAU,IAEhC,aAAkB,GAAM,qBAAqB,EAAI,EAAO,uBAAuB,CAE1F,AA+BH,SAA8B,CAAO,CAAE,CAAM,EAE5C,EAAQ,IAAI,CACX,CACC,OAAQ,EACR,OAAQ,KACR,YAAa,IACd,EAGF,EAzCuB,EAAM,uBAAuB,CAAE,GAExC,aAAkB,GAAM,MAAM,CAEzC,EAAM,cAAc,CAAC,IAAI,CAAE,GAEhB,aAAkB,GAAM,SAAS,EAE5C,EAAM,aAAa,CAAC,IAAI,CAAE,EAI3B,CAAA,EAAO,aAAa,CAAG,CAAA,CAExB,CAED,CAAA,EAtMa,EAAM,cAAc,CAAE,EAAG,CAAE,GACtC,EAAM,cAAc,CAAC,MAAM,CAAE,EAAG,GAIjC,KAAQ,EAAM,gBAAgB,CAAC,MAAM,OAiZd,CAElB,EAFkB,EA/YR,EAAM,gBAAgB,CAAE,EAAG,YAiZnB,GAAM,IAAI,EAC/B,aAAkB,GAAM,cAAc,EACtC,aAAkB,GAAM,MAAM,EAC9B,aAAkB,GAAM,IAAI,CAE7B,GAAiB,AAtZ0B,EAsZpB,cAAc,CAAE,GAE5B,aAAkB,GAAM,MAAM,CAEzC,GAAuB,AA1ZoB,EA0Zd,cAAc,CAAE,GAElC,aAAkB,GAAM,SAAS,CAE5C,GAAuB,AA9ZoB,EA8Zd,aAAa,CAAE,GAEjC,CAAA,aAAkB,GAAM,qBAAqB,EAAI,EAAO,uBAAuB,AAAvB,GAEnE,GAAiB,AAla0B,EAkapB,uBAAuB,CAAE,GAIjD,EAAO,aAAa,CAAG,CAAA,EAratB,EAAM,gBAAgB,CAAC,MAAM,CAAE,EAAG,GAMnC,IAAM,IAAI,EAAI,EAAG,EAAK,EAAM,cAAc,CAAC,MAAM,CAAE,EAAI,EAAI,IAE1D,AAmNF,CAAA,SAAwB,CAAM,EAE7B,IACC,EAAe,EAAuB,EADnC,EAAW,EAAO,QAAQ,CAG9B,GAAK,aAAkB,GAAM,IAAI,EAEhC,GAAK,aAAoB,GAAM,cAAc,CAEvC,CAAA,EAAS,kBAAkB,EAAI,EAAS,kBAAkB,EAC7D,EAAS,aAAa,EAAI,EAAS,iBAAiB,EACpD,EAAS,gBAAgB,EAAI,EAAS,kBAAkB,AAAlB,GAEvC,GAAkB,EAAU,EAAI,YAAY,CAAE,CAAC,EAAS,OAAO,EAIhE,EAAS,kBAAkB,CAAG,CAAA,EAC9B,EAAS,kBAAkB,CAAG,CAAA,EAC9B,EAAS,aAAa,CAAG,CAAA,EACzB,EAAS,iBAAiB,CAAG,CAAA,EAC7B,EAAS,gBAAgB,CAAG,CAAA,EAC5B,EAAS,kBAAkB,CAAG,CAAA,MAExB,CAIN,IAAK,IAAI,EAAI,EAAG,EAAK,EAAS,kBAAkB,CAAC,MAAM,CAAE,EAAI,EAAI,IAIhE,EAAW,GAAmB,EAF9B,EAAgB,EAAS,kBAAkB,CAAE,EAAG,EAI3C,EAAS,iBAAiB,EAE9B,GAAiB,EAAe,GAIjC,EAAwB,EAAS,UAAU,EAAI,GAA0B,GAEpE,CAAA,EAAS,kBAAkB,EAAI,EAAS,sBAAsB,EAAI,EAAS,kBAAkB,EAChG,EAAS,aAAa,EAAI,EAAS,iBAAiB,EACpD,EAAS,gBAAgB,EAAI,EAAS,kBAAkB,EAAI,CAAA,GAE7D,AA7+FL,SAAyB,CAAa,CAAE,CAAM,CAAE,CAAI,CAAE,CAAO,CAAE,CAAQ,EAEtE,GAAO,EAAc,eAAe,EAMpC,IA0/BO,EAp/BH,EAAG,EAAQ,EACf,EAAe,EACf,EAAc,EACd,EACA,EAAI,EAAK,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,EACrD,EAAI,EAAI,EAAI,EACZ,EAAK,EAAK,EAAK,EACf,EAAK,EAAK,EAAK,EAGR,EAAG,EACV,EAAI,EAAK,EACT,EAAI,EAAK,EACT,EAAK,EAAK,EAkBV,EAgBA,EArDI,GAAa,GAAuB,GACxC,GAAkB,GAA4B,GAC9C,GAAS,GAAmB,GAE5B,GAAuB,KAAe,GAAM,aAAa,CAkBzD,GAAc,EAEd,GAAS,EACT,GAAY,EACZ,GAAa,EACb,GAAc,EACd,GAAgB,EAChB,GAAiB,EACjB,GAAc,EACd,GAAe,EACf,GAAc,EACd,GAAqB,EACrB,GAAgB,EAKhB,GAAc,EAAc,aAAa,CACzC,GAAU,EAAc,SAAS,CACjC,GAAW,EAAc,UAAU,CACnC,GAAc,EAAc,aAAa,CACzC,GAAe,EAAc,cAAc,CAC3C,GAAa,EAAc,YAAY,CAEvC,GAAiB,EAAc,gBAAgB,CAC/C,GAAkB,EAAc,iBAAiB,CAEjD,GAAqB,EAAc,oBAAoB,CACvD,GAAqB,EAAc,oBAAoB,CAEvD,GAAmB,EAAc,2BAA2B,CAG5D,GAAY,EAAc,WAAW,CACrC,GAAY,EAAc,WAAW,CAErC,GAAW,EAAO,QAAQ,CAE1B,GAAgB,GAAS,kBAAkB,CAC3C,GAAgB,GAAS,kBAAkB,CAC3C,GAAW,GAAS,aAAa,CACjC,GAAe,GAAS,iBAAiB,CACzC,GAAgB,GAAS,kBAAkB,CAC3C,GAAc,GAAS,gBAAgB,CACvC,GAAoB,GAAS,sBAAsB,CAEnD,GAAW,GAAS,QAAQ,CAC5B,GAAe,EAAc,MAAM,CACnC,GAAe,EAAc,MAAM,CACnC,GAAY,GAAS,KAAK,CAE1B,GAAW,GAAS,aAAa,CAAE,EAAG,CACtC,GAAW,GAAS,aAAa,CAAE,EAAG,CAItC,IAFa,GAAS,MAAM,CAEV,GAAS,WAAW,EACtC,GAAkB,GAAS,WAAW,CAEtC,GAAe,GAAS,YAAY,CACpC,GAAe,GAAS,YAAY,CAEpC,GAAK,GAAgB,CAEpB,IAAM,EAAI,EAAG,EAAK,GAAa,MAAM,CAAE,EAAI,EAAI,IAI9C,EAAK,EAAQ,CAAE,AAFf,CAAA,EAAO,EAAS,CAAE,EAAY,CAAE,EAAG,CAAE,AAAF,EAEf,CAAC,CAAE,CACvB,EAAK,EAAQ,CAAE,EAAK,CAAC,CAAE,CACvB,EAAK,EAAQ,CAAE,EAAK,CAAC,CAAE,CAEvB,EAAW,CAAE,GAAQ,CAAO,EAAG,CAAC,CAChC,EAAW,CAAE,GAAS,EAAG,CAAG,EAAG,CAAC,CAChC,EAAW,CAAE,GAAS,EAAG,CAAG,EAAG,CAAC,CAEhC,EAAW,CAAE,GAAS,EAAG,CAAG,EAAG,CAAC,CAChC,EAAW,CAAE,GAAS,EAAG,CAAG,EAAG,CAAC,CAChC,EAAW,CAAE,GAAS,EAAG,CAAG,EAAG,CAAC,CAEhC,EAAW,CAAE,GAAS,EAAG,CAAG,EAAG,CAAC,CAChC,EAAW,CAAE,GAAS,EAAG,CAAG,EAAG,CAAC,CAChC,EAAW,CAAE,GAAS,EAAG,CAAG,EAAG,CAAC,CAEhC,IAAU,EAIX,IAAM,EAAI,EAAG,EAAK,GAAa,MAAM,CAAE,EAAI,EAAI,IAI9C,EAAK,EAAQ,CAAE,AAFf,CAAA,EAAO,EAAS,CAAE,EAAY,CAAE,EAAG,CAAE,AAAF,EAEf,CAAC,CAAE,CACvB,EAAK,EAAQ,CAAE,EAAK,CAAC,CAAE,CACvB,EAAK,EAAQ,CAAE,EAAK,CAAC,CAAE,CACvB,EAAK,EAAQ,CAAE,EAAK,CAAC,CAAE,CAEvB,EAAW,CAAE,GAAQ,CAAO,EAAG,CAAC,CAChC,EAAW,CAAE,GAAS,EAAG,CAAG,EAAG,CAAC,CAChC,EAAW,CAAE,GAAS,EAAG,CAAG,EAAG,CAAC,CAEhC,EAAW,CAAE,GAAS,EAAG,CAAG,EAAG,CAAC,CAChC,EAAW,CAAE,GAAS,EAAG,CAAG,EAAG,CAAC,CAChC,EAAW,CAAE,GAAS,EAAG,CAAG,EAAG,CAAC,CAEhC,EAAW,CAAE,GAAS,EAAG,CAAG,EAAG,CAAC,CAChC,EAAW,CAAE,GAAS,EAAG,CAAG,EAAG,CAAC,CAChC,EAAW,CAAE,GAAS,EAAG,CAAG,EAAG,CAAC,CAEhC,EAAW,CAAE,GAAS,EAAG,CAAI,EAAG,CAAC,CACjC,EAAW,CAAE,GAAS,GAAI,CAAG,EAAG,CAAC,CACjC,EAAW,CAAE,GAAS,GAAI,CAAG,EAAG,CAAC,CAEjC,IAAU,GAIX,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAc,mBAAmB,EACnE,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,GAAa,EAEhD,CAEA,GAAK,GAEJ,IAAM,EAAK,EAAG,EAAM,GAAa,MAAM,CAAE,EAAK,EAAK,IAAQ,CAI1D,IAAM,EAAI,EAFV,GAAqB,EAER,EAAK,GAAa,MAAM,CAAE,EAAI,EAAI,IAG9C,EAAO,EAAS,CADhB,EAAM,EAAY,CAAE,EAAG,CACA,CAIvB,EAAK,EAAY,CAAE,EAAI,CAAC,QAAQ,CAAE,EAAK,CAAC,CAAE,CAC1C,EAAK,EAAY,CAAE,EAAI,CAAC,QAAQ,CAAE,EAAK,CAAC,CAAE,CAC1C,EAAK,EAAY,CAAE,EAAI,CAAC,QAAQ,CAAE,EAAK,CAAC,CAAE,CAI1C,AAFA,CAAA,EAAM,EAAkB,CAAE,EAAI,AAAJ,CAEvB,CAAE,GAAoB,CAAM,EAAG,CAAC,CACnC,CAAG,CAAE,GAAqB,EAAG,CAAG,EAAG,CAAC,CACpC,CAAG,CAAE,GAAqB,EAAG,CAAG,EAAG,CAAC,CAEpC,CAAG,CAAE,GAAqB,EAAG,CAAG,EAAG,CAAC,CACpC,CAAG,CAAE,GAAqB,EAAG,CAAG,EAAG,CAAC,CACpC,CAAG,CAAE,GAAqB,EAAG,CAAG,EAAG,CAAC,CAEpC,CAAG,CAAE,GAAqB,EAAG,CAAG,EAAG,CAAC,CACpC,CAAG,CAAE,GAAqB,EAAG,CAAG,EAAG,CAAC,CACpC,CAAG,CAAE,GAAqB,EAAG,CAAG,EAAG,CAAC,CAI/B,EAAS,YAAY,GAEpB,IAIJ,EAAK,AAFL,CAAA,EAAoB,EAAY,CAAE,EAAI,CAAC,aAAa,CAAE,EAAK,AAAL,EAE/B,CAAC,CACxB,EAAK,EAAkB,CAAC,CACxB,EAAK,EAAkB,CAAC,GAKxB,EADA,EAAK,EAAY,CAAE,EAAI,CAAC,WAAW,CAAE,EAAK,CAE1C,EAAK,GAMN,AAFA,CAAA,EAAM,EAAkB,CAAE,EAAI,AAAJ,CAEvB,CAAE,GAAoB,CAAM,EAAG,CAAC,CACnC,CAAG,CAAE,GAAqB,EAAG,CAAG,EAAG,CAAC,CACpC,CAAG,CAAE,GAAqB,EAAG,CAAG,EAAG,CAAC,CAEpC,CAAG,CAAE,GAAqB,EAAG,CAAG,EAAG,CAAC,CACpC,CAAG,CAAE,GAAqB,EAAG,CAAG,EAAG,CAAC,CACpC,CAAG,CAAE,GAAqB,EAAG,CAAG,EAAG,CAAC,CAEpC,CAAG,CAAE,GAAqB,EAAG,CAAG,EAAG,CAAC,CACpC,CAAG,CAAE,GAAqB,EAAG,CAAG,EAAG,CAAC,CACpC,CAAG,CAAE,GAAqB,EAAG,CAAG,EAAG,CAAC,EAMrC,IAAsB,EAIvB,IAAM,EAAI,EAAG,EAAK,GAAa,MAAM,CAAE,EAAI,EAAI,IAG9C,EAAO,EAAS,CADhB,EAAM,EAAY,CAAE,EAAG,CACA,CAIvB,EAAK,EAAY,CAAE,EAAI,CAAC,QAAQ,CAAE,EAAK,CAAC,CAAE,CAC1C,EAAK,EAAY,CAAE,EAAI,CAAC,QAAQ,CAAE,EAAK,CAAC,CAAE,CAC1C,EAAK,EAAY,CAAE,EAAI,CAAC,QAAQ,CAAE,EAAK,CAAC,CAAE,CAC1C,EAAK,EAAY,CAAE,EAAI,CAAC,QAAQ,CAAE,EAAK,CAAC,CAAE,CAI1C,AAFA,CAAA,EAAM,EAAkB,CAAE,EAAI,AAAJ,CAEvB,CAAE,GAAoB,CAAM,EAAG,CAAC,CACnC,CAAG,CAAE,GAAqB,EAAG,CAAG,EAAG,CAAC,CACpC,CAAG,CAAE,GAAqB,EAAG,CAAG,EAAG,CAAC,CAEpC,CAAG,CAAE,GAAqB,EAAG,CAAG,EAAG,CAAC,CACpC,CAAG,CAAE,GAAqB,EAAG,CAAG,EAAG,CAAC,CACpC,CAAG,CAAE,GAAqB,EAAG,CAAG,EAAG,CAAC,CAEpC,CAAG,CAAE,GAAqB,EAAG,CAAG,EAAG,CAAC,CACpC,CAAG,CAAE,GAAqB,EAAG,CAAG,EAAG,CAAC,CACpC,CAAG,CAAE,GAAqB,EAAG,CAAG,EAAG,CAAC,CAEpC,CAAG,CAAE,GAAqB,EAAG,CAAI,EAAG,CAAC,CACrC,CAAG,CAAE,GAAqB,GAAI,CAAG,EAAG,CAAC,CACrC,CAAG,CAAE,GAAqB,GAAI,CAAG,EAAG,CAAC,CAIhC,EAAS,YAAY,GAEpB,IAIJ,EAAK,AAFL,CAAA,EAAoB,EAAY,CAAE,EAAI,CAAC,aAAa,CAAE,EAAK,AAAL,EAE/B,CAAC,CACxB,EAAK,EAAkB,CAAC,CACxB,EAAK,EAAkB,CAAC,CACxB,EAAK,EAAkB,CAAC,GAKxB,EADA,EAAK,EAAY,CAAE,EAAI,CAAC,WAAW,CAAE,EAAK,CAE1C,EAAK,EACL,EAAK,GAMN,AAFA,CAAA,EAAM,EAAkB,CAAE,EAAI,AAAJ,CAEvB,CAAE,GAAoB,CAAM,EAAG,CAAC,CACnC,CAAG,CAAE,GAAqB,EAAG,CAAG,EAAG,CAAC,CACpC,CAAG,CAAE,GAAqB,EAAG,CAAG,EAAG,CAAC,CAEpC,CAAG,CAAE,GAAqB,EAAG,CAAG,EAAG,CAAC,CACpC,CAAG,CAAE,GAAqB,EAAG,CAAG,EAAG,CAAC,CACpC,CAAG,CAAE,GAAqB,EAAG,CAAG,EAAG,CAAC,CAEpC,CAAG,CAAE,GAAqB,EAAG,CAAG,EAAG,CAAC,CACpC,CAAG,CAAE,GAAqB,EAAG,CAAG,EAAG,CAAC,CACpC,CAAG,CAAE,GAAqB,EAAG,CAAG,EAAG,CAAC,CAEpC,CAAG,CAAE,GAAqB,EAAG,CAAI,EAAG,CAAC,CACrC,CAAG,CAAE,GAAqB,GAAI,CAAG,EAAG,CAAC,CACrC,CAAG,CAAE,GAAqB,GAAI,CAAG,EAAG,CAAC,EAMtC,IAAsB,GAIvB,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAc,0BAA0B,CAAE,EAAI,EAChF,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAkB,CAAE,EAAI,CAAE,GAEvD,EAAS,YAAY,GAEzB,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAc,0BAA0B,CAAE,EAAI,EAChF,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAkB,CAAE,EAAI,CAAE,GAI9D,CAID,GAAK,GAAgB,MAAM,CAAG,CAE7B,IAAM,EAAI,EAAG,EAAK,GAAa,MAAM,CAAE,EAAI,EAAI,IAM9C,EAAM,EAAe,CAAE,AAJvB,CAAA,EAAO,EAAS,CAAE,EAAY,CAAE,EAAG,CAAE,AAAF,EAIP,CAAC,CAAE,CAC/B,EAAM,EAAe,CAAE,EAAK,CAAC,CAAE,CAC/B,EAAM,EAAe,CAAE,EAAK,CAAC,CAAE,CAE/B,EAAe,CAAE,GAAa,CAAO,EAAI,CAAC,CAC1C,EAAe,CAAE,GAAc,EAAG,CAAG,EAAI,CAAC,CAC1C,EAAe,CAAE,GAAc,EAAG,CAAG,EAAI,CAAC,CAC1C,EAAe,CAAE,GAAc,EAAG,CAAG,EAAI,CAAC,CAE1C,EAAe,CAAE,GAAc,EAAG,CAAG,EAAI,CAAC,CAC1C,EAAe,CAAE,GAAc,EAAG,CAAG,EAAI,CAAC,CAC1C,EAAe,CAAE,GAAc,EAAG,CAAG,EAAI,CAAC,CAC1C,EAAe,CAAE,GAAc,EAAG,CAAG,EAAI,CAAC,CAE1C,EAAe,CAAE,GAAc,EAAG,CAAI,EAAI,CAAC,CAC3C,EAAe,CAAE,GAAc,EAAG,CAAI,EAAI,CAAC,CAC3C,EAAe,CAAE,GAAc,GAAI,CAAG,EAAI,CAAC,CAC3C,EAAe,CAAE,GAAc,GAAI,CAAG,EAAI,CAAC,CAI3C,EAAM,EAAe,CAAE,EAAK,CAAC,CAAE,CAC/B,EAAM,EAAe,CAAE,EAAK,CAAC,CAAE,CAC/B,EAAM,EAAe,CAAE,EAAK,CAAC,CAAE,CAE/B,EAAc,CAAE,GAAa,CAAO,EAAI,CAAC,CACzC,EAAc,CAAE,GAAc,EAAG,CAAG,EAAI,CAAC,CACzC,EAAc,CAAE,GAAc,EAAG,CAAG,EAAI,CAAC,CACzC,EAAc,CAAE,GAAc,EAAG,CAAG,EAAI,CAAC,CAEzC,EAAc,CAAE,GAAc,EAAG,CAAG,EAAI,CAAC,CACzC,EAAc,CAAE,GAAc,EAAG,CAAG,EAAI,CAAC,CACzC,EAAc,CAAE,GAAc,EAAG,CAAG,EAAI,CAAC,CACzC,EAAc,CAAE,GAAc,EAAG,CAAG,EAAI,CAAC,CAEzC,EAAc,CAAE,GAAc,EAAG,CAAI,EAAI,CAAC,CAC1C,EAAc,CAAE,GAAc,EAAG,CAAI,EAAI,CAAC,CAC1C,EAAc,CAAE,GAAc,GAAI,CAAG,EAAI,CAAC,CAC1C,EAAc,CAAE,GAAc,GAAI,CAAG,EAAI,CAAC,CAE1C,IAAe,GAIhB,IAAM,EAAI,EAAG,EAAK,GAAa,MAAM,CAAE,EAAI,EAAI,IAM9C,EAAM,EAAe,CAAE,AAJvB,CAAA,EAAO,EAAS,CAAE,EAAY,CAAE,EAAG,CAAE,AAAF,EAIP,CAAC,CAAE,CAC/B,EAAM,EAAe,CAAE,EAAK,CAAC,CAAE,CAC/B,EAAM,EAAe,CAAE,EAAK,CAAC,CAAE,CAC/B,EAAM,EAAe,CAAE,EAAK,CAAC,CAAE,CAE/B,EAAe,CAAE,GAAa,CAAO,EAAI,CAAC,CAC1C,EAAe,CAAE,GAAc,EAAG,CAAG,EAAI,CAAC,CAC1C,EAAe,CAAE,GAAc,EAAG,CAAG,EAAI,CAAC,CAC1C,EAAe,CAAE,GAAc,EAAG,CAAG,EAAI,CAAC,CAE1C,EAAe,CAAE,GAAc,EAAG,CAAG,EAAI,CAAC,CAC1C,EAAe,CAAE,GAAc,EAAG,CAAG,EAAI,CAAC,CAC1C,EAAe,CAAE,GAAc,EAAG,CAAG,EAAI,CAAC,CAC1C,EAAe,CAAE,GAAc,EAAG,CAAG,EAAI,CAAC,CAE1C,EAAe,CAAE,GAAc,EAAG,CAAI,EAAI,CAAC,CAC3C,EAAe,CAAE,GAAc,EAAG,CAAI,EAAI,CAAC,CAC3C,EAAe,CAAE,GAAc,GAAI,CAAG,EAAI,CAAC,CAC3C,EAAe,CAAE,GAAc,GAAI,CAAG,EAAI,CAAC,CAE3C,EAAe,CAAE,GAAc,GAAI,CAAG,EAAI,CAAC,CAC3C,EAAe,CAAE,GAAc,GAAI,CAAG,EAAI,CAAC,CAC3C,EAAe,CAAE,GAAc,GAAI,CAAG,EAAI,CAAC,CAC3C,EAAe,CAAE,GAAc,GAAI,CAAG,EAAI,CAAC,CAI3C,EAAM,EAAe,CAAE,EAAK,CAAC,CAAE,CAC/B,EAAM,EAAe,CAAE,EAAK,CAAC,CAAE,CAC/B,EAAM,EAAe,CAAE,EAAK,CAAC,CAAE,CAC/B,EAAM,EAAe,CAAE,EAAK,CAAC,CAAE,CAE/B,EAAc,CAAE,GAAa,CAAO,EAAI,CAAC,CACzC,EAAc,CAAE,GAAc,EAAG,CAAG,EAAI,CAAC,CACzC,EAAc,CAAE,GAAc,EAAG,CAAG,EAAI,CAAC,CACzC,EAAc,CAAE,GAAc,EAAG,CAAG,EAAI,CAAC,CAEzC,EAAc,CAAE,GAAc,EAAG,CAAG,EAAI,CAAC,CACzC,EAAc,CAAE,GAAc,EAAG,CAAG,EAAI,CAAC,CACzC,EAAc,CAAE,GAAc,EAAG,CAAG,EAAI,CAAC,CACzC,EAAc,CAAE,GAAc,EAAG,CAAG,EAAI,CAAC,CAEzC,EAAc,CAAE,GAAc,EAAG,CAAI,EAAI,CAAC,CAC1C,EAAc,CAAE,GAAc,EAAG,CAAI,EAAI,CAAC,CAC1C,EAAc,CAAE,GAAc,GAAI,CAAG,EAAI,CAAC,CAC1C,EAAc,CAAE,GAAc,GAAI,CAAG,EAAI,CAAC,CAE1C,EAAc,CAAE,GAAc,GAAI,CAAG,EAAI,CAAC,CAC1C,EAAc,CAAE,GAAc,GAAI,CAAG,EAAI,CAAC,CAC1C,EAAc,CAAE,GAAc,GAAI,CAAG,EAAI,CAAC,CAC1C,EAAc,CAAE,GAAc,GAAI,CAAG,EAAI,CAAC,CAE1C,IAAe,GAIX,GAAc,IAElB,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAc,wBAAwB,EACxE,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,GAAgB,GAElD,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAc,wBAAwB,EACxE,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,GAAiB,GAIrD,CAEA,GAAK,IAAe,GAAkB,CAErC,IAAM,EAAI,EAAG,EAAK,GAAa,MAAM,CAAE,EAAI,EAAI,IAI9C,EAAe,AAFf,CAAA,EAAO,EAAS,CAAE,EAAY,CAAE,EAAG,CAAE,AAAF,EAEf,YAAY,CAChC,EAAY,EAAK,KAAK,CAEjB,AAAwB,IAAxB,EAAa,MAAM,EAAU,KAAoB,GAAM,YAAY,EAEvE,EAAK,CAAY,CAAE,EAAG,CACtB,EAAK,CAAY,CAAE,EAAG,CACtB,EAAK,CAAY,CAAE,EAAG,GAItB,EAAK,EACL,EAAK,EACL,EAAK,GAIN,EAAU,CAAE,GAAc,CAAO,EAAG,CAAC,CACrC,EAAU,CAAE,GAAe,EAAG,CAAG,EAAG,CAAC,CACrC,EAAU,CAAE,GAAe,EAAG,CAAG,EAAG,CAAC,CAErC,EAAU,CAAE,GAAe,EAAG,CAAG,EAAG,CAAC,CACrC,EAAU,CAAE,GAAe,EAAG,CAAG,EAAG,CAAC,CACrC,EAAU,CAAE,GAAe,EAAG,CAAG,EAAG,CAAC,CAErC,EAAU,CAAE,GAAe,EAAG,CAAG,EAAG,CAAC,CACrC,EAAU,CAAE,GAAe,EAAG,CAAG,EAAG,CAAC,CACrC,EAAU,CAAE,GAAe,EAAG,CAAG,EAAG,CAAC,CAErC,IAAgB,EAIjB,IAAM,EAAI,EAAG,EAAK,GAAa,MAAM,CAAE,EAAI,EAAI,IAI9C,EAAe,AAFf,CAAA,EAAO,EAAS,CAAE,EAAY,CAAE,EAAG,CAAE,AAAF,EAEf,YAAY,CAChC,EAAY,EAAK,KAAK,CAEjB,AAAwB,IAAxB,EAAa,MAAM,EAAU,KAAoB,GAAM,YAAY,EAEvE,EAAK,CAAY,CAAE,EAAG,CACtB,EAAK,CAAY,CAAE,EAAG,CACtB,EAAK,CAAY,CAAE,EAAG,CACtB,EAAK,CAAY,CAAE,EAAG,GAItB,EAAK,EACL,EAAK,EACL,EAAK,EACL,EAAK,GAIN,EAAU,CAAE,GAAc,CAAO,EAAG,CAAC,CACrC,EAAU,CAAE,GAAe,EAAG,CAAG,EAAG,CAAC,CACrC,EAAU,CAAE,GAAe,EAAG,CAAG,EAAG,CAAC,CAErC,EAAU,CAAE,GAAe,EAAG,CAAG,EAAG,CAAC,CACrC,EAAU,CAAE,GAAe,EAAG,CAAG,EAAG,CAAC,CACrC,EAAU,CAAE,GAAe,EAAG,CAAG,EAAG,CAAC,CAErC,EAAU,CAAE,GAAe,EAAG,CAAG,EAAG,CAAC,CACrC,EAAU,CAAE,GAAe,EAAG,CAAG,EAAG,CAAC,CACrC,EAAU,CAAE,GAAe,EAAG,CAAG,EAAG,CAAC,CAErC,EAAU,CAAE,GAAe,EAAG,CAAI,EAAG,CAAC,CACtC,EAAU,CAAE,GAAe,GAAI,CAAG,EAAG,CAAC,CACtC,EAAU,CAAE,GAAe,GAAI,CAAG,EAAG,CAAC,CAEtC,IAAgB,GAIZ,GAAe,IAEnB,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAc,kBAAkB,EAClE,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,GAAY,GAIhD,CAEA,GAAK,IAAiB,GAAS,WAAW,CAAG,CAE5C,IAAM,EAAI,EAAG,EAAK,GAAa,MAAM,CAAE,EAAI,EAAI,IAM9C,EAAK,AAFL,CAAA,EAAiB,AAFjB,CAAA,EAAO,EAAS,CAAE,EAAY,CAAE,EAAG,CAAE,AAAF,EAEb,cAAc,AAAd,CAEH,CAAE,EAAG,CACxB,EAAK,CAAc,CAAE,EAAG,CACxB,EAAK,CAAc,CAAE,EAAG,CAExB,EAAY,CAAE,GAAgB,CAAO,EAAG,CAAC,CACzC,EAAY,CAAE,GAAiB,EAAG,CAAG,EAAG,CAAC,CACzC,EAAY,CAAE,GAAiB,EAAG,CAAG,EAAG,CAAC,CACzC,EAAY,CAAE,GAAiB,EAAG,CAAG,EAAG,CAAC,CAEzC,EAAY,CAAE,GAAiB,EAAG,CAAG,EAAG,CAAC,CACzC,EAAY,CAAE,GAAiB,EAAG,CAAG,EAAG,CAAC,CACzC,EAAY,CAAE,GAAiB,EAAG,CAAG,EAAG,CAAC,CACzC,EAAY,CAAE,GAAiB,EAAG,CAAG,EAAG,CAAC,CAEzC,EAAY,CAAE,GAAiB,EAAG,CAAI,EAAG,CAAC,CAC1C,EAAY,CAAE,GAAiB,EAAG,CAAI,EAAG,CAAC,CAC1C,EAAY,CAAE,GAAiB,GAAI,CAAG,EAAG,CAAC,CAC1C,EAAY,CAAE,GAAiB,GAAI,CAAG,EAAG,CAAC,CAE1C,IAAkB,GAInB,IAAM,EAAI,EAAG,EAAK,GAAa,MAAM,CAAE,EAAI,EAAI,IAM9C,EAAK,AAFL,CAAA,EAAiB,AAFjB,CAAA,EAAO,EAAS,CAAE,EAAY,CAAE,EAAG,CAAE,AAAF,EAEb,cAAc,AAAd,CAEH,CAAE,EAAG,CACxB,EAAK,CAAc,CAAE,EAAG,CACxB,EAAK,CAAc,CAAE,EAAG,CACxB,EAAK,CAAc,CAAE,EAAG,CAExB,EAAY,CAAE,GAAgB,CAAO,EAAG,CAAC,CACzC,EAAY,CAAE,GAAiB,EAAG,CAAG,EAAG,CAAC,CACzC,EAAY,CAAE,GAAiB,EAAG,CAAG,EAAG,CAAC,CACzC,EAAY,CAAE,GAAiB,EAAG,CAAG,EAAG,CAAC,CAEzC,EAAY,CAAE,GAAiB,EAAG,CAAG,EAAG,CAAC,CACzC,EAAY,CAAE,GAAiB,EAAG,CAAG,EAAG,CAAC,CACzC,EAAY,CAAE,GAAiB,EAAG,CAAG,EAAG,CAAC,CACzC,EAAY,CAAE,GAAiB,EAAG,CAAG,EAAG,CAAC,CAEzC,EAAY,CAAE,GAAiB,EAAG,CAAI,EAAG,CAAC,CAC1C,EAAY,CAAE,GAAiB,EAAG,CAAI,EAAG,CAAC,CAC1C,EAAY,CAAE,GAAiB,GAAI,CAAG,EAAG,CAAC,CAC1C,EAAY,CAAE,GAAiB,GAAI,CAAG,EAAG,CAAC,CAE1C,EAAY,CAAE,GAAiB,GAAI,CAAG,EAAG,CAAC,CAC1C,EAAY,CAAE,GAAiB,GAAI,CAAG,EAAG,CAAC,CAC1C,EAAY,CAAE,GAAiB,GAAI,CAAG,EAAG,CAAC,CAC1C,EAAY,CAAE,GAAiB,GAAI,CAAG,EAAG,CAAC,CAE1C,IAAkB,GAInB,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAc,oBAAoB,EACpE,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,GAAc,EAEjD,CAEA,GAAK,IAAgB,GAAa,CAEjC,IAAM,EAAI,EAAG,EAAK,GAAa,MAAM,CAAE,EAAI,EAAI,IAO9C,GAHA,EAAgB,AAFhB,CAAA,EAAO,EAAS,CAAE,EAAY,CAAE,EAAG,CAAE,AAAF,EAEd,aAAa,CAClC,EAAa,EAAK,MAAM,CAEnB,AAAyB,IAAzB,EAAc,MAAM,EAAU,GAElC,IAAM,EAAI,EAAG,EAAI,EAAG,IAEnB,EAAK,CAAa,CAAE,EAAG,CAEvB,EAAW,CAAE,GAAe,CAAO,EAAG,CAAC,CACvC,EAAW,CAAE,GAAgB,EAAG,CAAG,EAAG,CAAC,CACvC,EAAW,CAAE,GAAgB,EAAG,CAAG,EAAG,CAAC,CAEvC,IAAiB,OAMlB,IAAM,EAAI,EAAG,EAAI,EAAG,IAEnB,EAAW,CAAE,GAAe,CAAO,EAAW,CAAC,CAC/C,EAAW,CAAE,GAAgB,EAAG,CAAG,EAAW,CAAC,CAC/C,EAAW,CAAE,GAAgB,EAAG,CAAG,EAAW,CAAC,CAE/C,IAAiB,EAQpB,IAAM,EAAI,EAAG,EAAK,GAAa,MAAM,CAAE,EAAI,EAAI,IAO9C,GAHA,EAAgB,AAFhB,CAAA,EAAO,EAAS,CAAE,EAAY,CAAE,EAAG,CAAE,AAAF,EAEd,aAAa,CAClC,EAAa,EAAK,MAAM,CAEnB,AAAyB,IAAzB,EAAc,MAAM,EAAU,GAElC,IAAM,EAAI,EAAG,EAAI,EAAG,IAEnB,EAAK,CAAa,CAAE,EAAG,CAEvB,EAAW,CAAE,GAAe,CAAO,EAAG,CAAC,CACvC,EAAW,CAAE,GAAgB,EAAG,CAAG,EAAG,CAAC,CACvC,EAAW,CAAE,GAAgB,EAAG,CAAG,EAAG,CAAC,CAEvC,IAAiB,OAMlB,IAAM,EAAI,EAAG,EAAI,EAAG,IAEnB,EAAW,CAAE,GAAe,CAAO,EAAW,CAAC,CAC/C,EAAW,CAAE,GAAgB,EAAG,CAAG,EAAW,CAAC,CAC/C,EAAW,CAAE,GAAgB,EAAG,CAAG,EAAW,CAAC,CAE/C,IAAiB,EAQpB,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAc,mBAAmB,EACnE,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,GAAa,EAEhD,CAEA,GAAK,IAAY,IAAW,GAAS,CAEpC,IAAM,EAAI,EAAG,EAAK,GAAa,MAAM,CAAE,EAAI,EAAI,IAM9C,GAAK,AAAO,KAAA,IAFZ,CAAA,EAAK,EAAO,CAFP,EAAY,CAAE,EAAG,CAEJ,AAAJ,EAId,IAAM,EAAI,EAAG,EAAI,EAAG,IAEnB,EAAM,CAAE,CAAE,EAAG,CAEb,EAAO,CAAE,GAAW,CAAO,EAAI,CAAC,CAChC,EAAO,CAAE,GAAY,EAAG,CAAG,EAAI,CAAC,CAEhC,IAAa,EAMf,IAAM,EAAI,EAAG,EAAK,GAAa,MAAM,CAAE,EAAI,EAAI,IAM9C,GAAK,AAAO,KAAA,IAFZ,CAAA,EAAK,EAAO,CAFP,EAAY,CAAE,EAAG,CAEJ,AAAJ,EAId,IAAM,EAAI,EAAG,EAAI,EAAG,IAEnB,EAAM,CAAE,CAAE,EAAG,CAEb,EAAO,CAAE,GAAW,CAAO,EAAI,CAAC,CAChC,EAAO,CAAE,GAAY,EAAG,CAAG,EAAI,CAAC,CAEhC,IAAa,EAMV,GAAY,IAEhB,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAc,eAAe,EAC/D,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,GAAS,GAI7C,CAEA,GAAK,IAAY,IAAY,GAAS,CAErC,IAAM,EAAI,EAAG,EAAK,GAAa,MAAM,CAAE,EAAI,EAAI,IAM9C,GAAK,AAAQ,KAAA,IAFb,CAAA,EAAM,EAAQ,CAFT,EAAY,CAAE,EAAG,CAEF,AAAJ,EAIhB,IAAM,EAAI,EAAG,EAAI,EAAG,IAEnB,EAAO,CAAG,CAAE,EAAG,CAEf,EAAQ,CAAE,GAAY,CAAO,EAAK,CAAC,CACnC,EAAQ,CAAE,GAAa,EAAG,CAAG,EAAK,CAAC,CAEnC,IAAc,EAMhB,IAAM,EAAI,EAAG,EAAK,GAAa,MAAM,CAAE,EAAI,EAAI,IAM9C,GAAK,AAAQ,KAAA,IAFb,CAAA,EAAM,EAAQ,CAFT,EAAY,CAAE,EAAG,CAEF,AAAJ,EAIhB,IAAM,EAAI,EAAG,EAAI,EAAG,IAEnB,EAAO,CAAG,CAAE,EAAG,CAEf,EAAQ,CAAE,GAAY,CAAO,EAAK,CAAC,CACnC,EAAQ,CAAE,GAAa,EAAG,CAAG,EAAK,CAAC,CAEnC,IAAc,EAMX,GAAa,IAEjB,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAc,gBAAgB,EAChE,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,GAAU,GAI9C,CAEA,GAAK,GAAgB,CAEpB,IAAM,EAAI,EAAG,EAAK,GAAa,MAAM,CAAE,EAAI,EAAI,IAE9C,EAAS,CAAE,GAAa,CAAK,GAC7B,EAAS,CAAE,GAAc,EAAG,CAAG,GAAc,EAC7C,EAAS,CAAE,GAAc,EAAG,CAAG,GAAc,EAE7C,IAAe,EAEf,EAAS,CAAE,GAAa,CAAO,GAC/B,EAAS,CAAE,GAAc,EAAG,CAAG,GAAc,EAE7C,EAAS,CAAE,GAAc,EAAG,CAAG,GAC/B,EAAS,CAAE,GAAc,EAAG,CAAG,GAAc,EAE7C,EAAS,CAAE,GAAc,EAAG,CAAG,GAAc,EAC7C,EAAS,CAAE,GAAc,EAAG,CAAG,GAAc,EAE7C,IAAe,EAEf,IAAe,EAIhB,IAAM,EAAI,EAAG,EAAK,GAAa,MAAM,CAAE,EAAI,EAAI,IAE9C,EAAS,CAAE,GAAa,CAAO,GAC/B,EAAS,CAAE,GAAc,EAAG,CAAG,GAAc,EAC7C,EAAS,CAAE,GAAc,EAAG,CAAG,GAAc,EAE7C,EAAS,CAAE,GAAc,EAAG,CAAG,GAAc,EAC7C,EAAS,CAAE,GAAc,EAAG,CAAG,GAAc,EAC7C,EAAS,CAAE,GAAc,EAAG,CAAG,GAAc,EAE7C,IAAe,EAEf,EAAS,CAAE,GAAa,CAAO,GAC/B,EAAS,CAAE,GAAc,EAAG,CAAG,GAAc,EAE7C,EAAS,CAAE,GAAc,EAAG,CAAG,GAC/B,EAAS,CAAE,GAAc,EAAG,CAAG,GAAc,EAE7C,EAAS,CAAE,GAAc,EAAG,CAAG,GAAc,EAC7C,EAAS,CAAE,GAAc,EAAG,CAAG,GAAc,EAE7C,EAAS,CAAE,GAAc,EAAG,CAAG,GAAc,EAC7C,EAAS,CAAE,GAAc,EAAG,CAAG,GAAc,EAE7C,IAAe,EAEf,IAAe,EAIhB,EAAI,UAAU,CAAE,EAAI,oBAAoB,CAAE,EAAc,iBAAiB,EACzE,EAAI,UAAU,CAAE,EAAI,oBAAoB,CAAE,GAAW,GAErD,EAAI,UAAU,CAAE,EAAI,oBAAoB,CAAE,EAAc,iBAAiB,EACzE,EAAI,UAAU,CAAE,EAAI,oBAAoB,CAAE,GAAW,EAEtD,CAEA,GAAK,GAEJ,CAAA,IAAM,EAAI,EAAG,EAAK,GAAiB,MAAM,CAAE,EAAI,EAAI,IAIlD,GAAO,AAFP,CAAA,EAAkB,EAAgB,CAAE,EAAG,AAAH,EAEb,UAAU,CAAC,WAAW,EAK7C,GAHA,GAAgB,EAGX,AAAyB,IAAzB,EAAgB,IAAI,EAExB,GAAK,AAA4B,KAAA,IAA5B,EAAgB,OAAO,EAAkB,AAA4B,aAA5B,EAAgB,OAAO,CAAkB,CAEtF,IAAM,EAAI,EAAG,EAAK,GAAa,MAAM,CAAE,EAAI,EAAI,IAE9C,EAAO,EAAS,CAAE,EAAY,CAAE,EAAG,CAAE,CAErC,EAAgB,KAAK,CAAE,GAAe,CAAO,EAAgB,KAAK,CAAE,EAAK,CAAC,CAAE,CAC5E,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,EAAgB,KAAK,CAAE,EAAK,CAAC,CAAE,CAC5E,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,EAAgB,KAAK,CAAE,EAAK,CAAC,CAAE,CAE5E,IAAiB,EAIlB,IAAM,EAAI,EAAG,EAAK,GAAa,MAAM,CAAE,EAAI,EAAI,IAE9C,EAAO,EAAS,CAAE,EAAY,CAAE,EAAG,CAAE,CAErC,EAAgB,KAAK,CAAE,GAAe,CAAO,EAAgB,KAAK,CAAE,EAAK,CAAC,CAAE,CAC5E,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,EAAgB,KAAK,CAAE,EAAK,CAAC,CAAE,CAC5E,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,EAAgB,KAAK,CAAE,EAAK,CAAC,CAAE,CAC5E,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,EAAgB,KAAK,CAAE,EAAK,CAAC,CAAE,CAE5E,IAAiB,CAInB,MAAO,GAAK,AAA4B,UAA5B,EAAgB,OAAO,CAAe,CAEjD,IAAM,EAAI,EAAG,EAAK,GAAa,MAAM,CAAE,EAAI,EAAI,IAE9C,EAAQ,EAAgB,KAAK,CAAE,EAAY,CAAE,EAAG,CAAE,CAElD,EAAgB,KAAK,CAAE,GAAe,CAAO,EAC7C,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,EAC7C,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,EAE7C,IAAiB,EAIlB,IAAM,EAAI,EAAG,EAAK,GAAa,MAAM,CAAE,EAAI,EAAI,IAE9C,EAAQ,EAAgB,KAAK,CAAE,EAAY,CAAE,EAAG,CAAE,CAElD,EAAgB,KAAK,CAAE,GAAe,CAAO,EAC7C,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,EAC7C,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,EAC7C,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,EAE7C,IAAiB,CAInB,OAEM,GAAK,AAAyB,IAAzB,EAAgB,IAAI,EAE/B,GAAK,AAA4B,KAAA,IAA5B,EAAgB,OAAO,EAAkB,AAA4B,aAA5B,EAAgB,OAAO,CAAkB,CAEtF,IAAM,EAAI,EAAG,EAAK,GAAa,MAAM,CAAE,EAAI,EAAI,IAE9C,EAAO,EAAS,CAAE,EAAY,CAAE,EAAG,CAAE,CAErC,EAAK,EAAgB,KAAK,CAAE,EAAK,CAAC,CAAE,CACpC,EAAK,EAAgB,KAAK,CAAE,EAAK,CAAC,CAAE,CACpC,EAAK,EAAgB,KAAK,CAAE,EAAK,CAAC,CAAE,CAEpC,EAAgB,KAAK,CAAE,GAAe,CAAO,EAAG,CAAC,CACjD,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,EAAG,CAAC,CAEjD,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,EAAG,CAAC,CACjD,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,EAAG,CAAC,CAEjD,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,EAAG,CAAC,CACjD,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,EAAG,CAAC,CAEjD,IAAiB,EAIlB,IAAM,EAAI,EAAG,EAAK,GAAa,MAAM,CAAE,EAAI,EAAI,IAE9C,EAAO,EAAS,CAAE,EAAY,CAAE,EAAG,CAAE,CAErC,EAAK,EAAgB,KAAK,CAAE,EAAK,CAAC,CAAE,CACpC,EAAK,EAAgB,KAAK,CAAE,EAAK,CAAC,CAAE,CACpC,EAAK,EAAgB,KAAK,CAAE,EAAK,CAAC,CAAE,CACpC,EAAK,EAAgB,KAAK,CAAE,EAAK,CAAC,CAAE,CAEpC,EAAgB,KAAK,CAAE,GAAe,CAAO,EAAG,CAAC,CACjD,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,EAAG,CAAC,CAEjD,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,EAAG,CAAC,CACjD,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,EAAG,CAAC,CAEjD,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,EAAG,CAAC,CACjD,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,EAAG,CAAC,CAEjD,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,EAAG,CAAC,CACjD,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,EAAG,CAAC,CAEjD,IAAiB,CAInB,MAAO,GAAK,AAA4B,UAA5B,EAAgB,OAAO,CAAe,CAEjD,IAAM,EAAI,EAAG,EAAK,GAAa,MAAM,CAAE,EAAI,EAAI,IAI9C,EAFA,EAAQ,EAAgB,KAAK,CAAE,EAAY,CAAE,EAAG,CAAE,CAGlD,EAAK,EACL,EAAK,EAEL,EAAgB,KAAK,CAAE,GAAe,CAAO,EAAG,CAAC,CACjD,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,EAAG,CAAC,CAEjD,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,EAAG,CAAC,CACjD,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,EAAG,CAAC,CAEjD,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,EAAG,CAAC,CACjD,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,EAAG,CAAC,CAEjD,IAAiB,EAIlB,IAAM,EAAI,EAAG,EAAK,GAAa,MAAM,CAAE,EAAI,EAAI,IAI9C,EAFA,EAAQ,EAAgB,KAAK,CAAE,EAAY,CAAE,EAAG,CAAE,CAGlD,EAAK,EACL,EAAK,EACL,EAAK,EAEL,EAAgB,KAAK,CAAE,GAAe,CAAO,EAAG,CAAC,CACjD,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,EAAG,CAAC,CAEjD,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,EAAG,CAAC,CACjD,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,EAAG,CAAC,CAEjD,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,EAAG,CAAC,CACjD,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,EAAG,CAAC,CAEjD,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,EAAG,CAAC,CACjD,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,EAAG,CAAC,CAEjD,IAAiB,CAInB,OAEM,GAAK,AAAyB,IAAzB,EAAgB,IAAI,EAc/B,GARC,EAFI,AAAyB,MAAzB,EAAgB,IAAI,CAEnB,CAAE,IAAK,IAAK,IAAK,CAIjB,CAAE,IAAK,IAAK,IAAK,CAIlB,AAA4B,KAAA,IAA5B,EAAgB,OAAO,EAAkB,AAA4B,aAA5B,EAAgB,OAAO,CAAkB,CAEtF,IAAM,EAAI,EAAG,EAAK,GAAa,MAAM,CAAE,EAAI,EAAI,IAE9C,EAAO,EAAS,CAAE,EAAY,CAAE,EAAG,CAAE,CAErC,EAAK,EAAgB,KAAK,CAAE,EAAK,CAAC,CAAE,CACpC,EAAK,EAAgB,KAAK,CAAE,EAAK,CAAC,CAAE,CACpC,EAAK,EAAgB,KAAK,CAAE,EAAK,CAAC,CAAE,CAEpC,EAAgB,KAAK,CAAE,GAAe,CAAO,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAC1D,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAC1D,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAE1D,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAC1D,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAC1D,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAE1D,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAC1D,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAC1D,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAE1D,IAAiB,EAIlB,IAAM,EAAI,EAAG,EAAK,GAAa,MAAM,CAAE,EAAI,EAAI,IAE9C,EAAO,EAAS,CAAE,EAAY,CAAE,EAAG,CAAE,CAErC,EAAK,EAAgB,KAAK,CAAE,EAAK,CAAC,CAAE,CACpC,EAAK,EAAgB,KAAK,CAAE,EAAK,CAAC,CAAE,CACpC,EAAK,EAAgB,KAAK,CAAE,EAAK,CAAC,CAAE,CACpC,EAAK,EAAgB,KAAK,CAAE,EAAK,CAAC,CAAE,CAEpC,EAAgB,KAAK,CAAE,GAAgB,CAAI,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CACxD,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAC3D,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAE3D,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAC3D,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAC3D,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAE3D,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAC3D,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAC3D,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAE3D,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAC3D,EAAgB,KAAK,CAAE,GAAgB,GAAI,CAAG,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAC3D,EAAgB,KAAK,CAAE,GAAgB,GAAI,CAAG,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAE3D,IAAiB,EAInB,MAAO,GAAK,AAA4B,UAA5B,EAAgB,OAAO,CAAe,CAEjD,IAAM,EAAI,EAAG,EAAK,GAAa,MAAM,CAAE,EAAI,EAAI,IAI9C,EAFA,EAAQ,EAAgB,KAAK,CAAE,EAAY,CAAE,EAAG,CAAE,CAGlD,EAAK,EACL,EAAK,EAEL,EAAgB,KAAK,CAAE,GAAe,CAAO,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAC1D,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAC1D,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAE1D,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAC1D,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAC1D,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAE1D,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAC1D,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAC1D,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAE1D,IAAiB,EAIlB,IAAM,EAAI,EAAG,EAAK,GAAa,MAAM,CAAE,EAAI,EAAI,IAI9C,EAFA,EAAQ,EAAgB,KAAK,CAAE,EAAY,CAAE,EAAG,CAAE,CAGlD,EAAK,EACL,EAAK,EACL,EAAK,EAEL,EAAgB,KAAK,CAAE,GAAgB,CAAI,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CACxD,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAC3D,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAE3D,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAC3D,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAC3D,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAE3D,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAC3D,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAC3D,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAE3D,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAC3D,EAAgB,KAAK,CAAE,GAAgB,GAAI,CAAG,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAC3D,EAAgB,KAAK,CAAE,GAAgB,GAAI,CAAG,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAE3D,IAAiB,EAInB,MAAO,GAAK,AAA4B,iBAA5B,EAAgB,OAAO,CAAsB,CAExD,IAAM,EAAI,EAAG,EAAK,GAAa,MAAM,CAAE,EAAI,EAAI,IAI9C,EAAK,AAFL,CAAA,EAAQ,EAAgB,KAAK,CAAE,EAAY,CAAE,EAAG,CAAE,AAAF,CAEtC,CAAE,EAAG,CACf,EAAK,CAAK,CAAE,EAAG,CACf,EAAK,CAAK,CAAE,EAAG,CAEf,EAAgB,KAAK,CAAE,GAAe,CAAO,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAC1D,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAC1D,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAE1D,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAC1D,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAC1D,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAE1D,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAC1D,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAC1D,EAAgB,KAAK,CAAE,GAAgB,EAAG,CAAG,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAE1D,IAAiB,EAIlB,IAAM,EAAI,EAAG,EAAK,GAAa,MAAM,CAAE,EAAI,EAAI,IAI9C,EAAK,AAFL,CAAA,EAAQ,EAAgB,KAAK,CAAE,EAAY,CAAE,EAAG,CAAE,AAAF,CAEtC,CAAE,EAAG,CACf,EAAK,CAAK,CAAE,EAAG,CACf,EAAK,CAAK,CAAE,EAAG,CACf,EAAK,CAAK,CAAE,EAAG,CAEf,EAAgB,KAAK,CAAE,GAAgB,CAAI,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CACxD,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAC3D,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAE3D,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAC3D,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAC3D,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAE3D,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAC3D,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAC3D,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAE3D,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAC3D,EAAgB,KAAK,CAAE,GAAgB,GAAI,CAAG,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAC3D,EAAgB,KAAK,CAAE,GAAgB,GAAI,CAAG,CAAE,CAAE,CAAE,CAAE,EAAG,CAAE,CAE3D,IAAiB,EAInB,OAEM,GAAK,AAAyB,IAAzB,EAAgB,IAAI,EAE/B,GAAK,AAA4B,KAAA,IAA5B,EAAgB,OAAO,EAAkB,AAA4B,aAA5B,EAAgB,OAAO,CAAkB,CAEtF,IAAM,EAAI,EAAG,EAAK,GAAa,MAAM,CAAE,EAAI,EAAI,IAE9C,EAAO,EAAS,CAAE,EAAY,CAAE,EAAG,CAAE,CAErC,EAAK,EAAgB,KAAK,CAAE,EAAK,CAAC,CAAE,CACpC,EAAK,EAAgB,KAAK,CAAE,EAAK,CAAC,CAAE,CACpC,EAAK,EAAgB,KAAK,CAAE,EAAK,CAAC,CAAE,CAEpC,EAAgB,KAAK,CAAE,GAAgB,CAAI,EAAG,CAAC,CAC/C,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,EAAG,CAAC,CAClD,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,EAAG,CAAC,CAClD,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,EAAG,CAAC,CAElD,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,EAAG,CAAC,CAClD,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,EAAG,CAAC,CAClD,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,EAAG,CAAC,CAClD,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,EAAG,CAAC,CAElD,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,EAAG,CAAC,CAClD,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,EAAG,CAAC,CAClD,EAAgB,KAAK,CAAE,GAAgB,GAAI,CAAG,EAAG,CAAC,CAClD,EAAgB,KAAK,CAAE,GAAgB,GAAI,CAAG,EAAG,CAAC,CAElD,IAAiB,GAIlB,IAAM,EAAI,EAAG,EAAK,GAAa,MAAM,CAAE,EAAI,EAAI,IAE9C,EAAO,EAAS,CAAE,EAAY,CAAE,EAAG,CAAE,CAErC,EAAK,EAAgB,KAAK,CAAE,EAAK,CAAC,CAAE,CACpC,EAAK,EAAgB,KAAK,CAAE,EAAK,CAAC,CAAE,CACpC,EAAK,EAAgB,KAAK,CAAE,EAAK,CAAC,CAAE,CACpC,EAAK,EAAgB,KAAK,CAAE,EAAK,CAAC,CAAE,CAEpC,EAAgB,KAAK,CAAE,GAAgB,CAAI,EAAG,CAAC,CAC/C,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,EAAG,CAAC,CAClD,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,EAAG,CAAC,CAClD,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,EAAG,CAAC,CAElD,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,EAAG,CAAC,CAClD,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,EAAG,CAAC,CAClD,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,EAAG,CAAC,CAClD,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,EAAG,CAAC,CAElD,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,EAAG,CAAC,CAClD,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,EAAG,CAAC,CAClD,EAAgB,KAAK,CAAE,GAAgB,GAAI,CAAG,EAAG,CAAC,CAClD,EAAgB,KAAK,CAAE,GAAgB,GAAI,CAAG,EAAG,CAAC,CAElD,EAAgB,KAAK,CAAE,GAAgB,GAAI,CAAG,EAAG,CAAC,CAClD,EAAgB,KAAK,CAAE,GAAgB,GAAI,CAAG,EAAG,CAAC,CAClD,EAAgB,KAAK,CAAE,GAAgB,GAAI,CAAG,EAAG,CAAC,CAClD,EAAgB,KAAK,CAAE,GAAgB,GAAI,CAAG,EAAG,CAAC,CAElD,IAAiB,EAInB,MAAO,GAAK,AAA4B,UAA5B,EAAgB,OAAO,CAAe,CAEjD,IAAM,EAAI,EAAG,EAAK,GAAa,MAAM,CAAE,EAAI,EAAI,IAI9C,EAFA,EAAQ,EAAgB,KAAK,CAAE,EAAY,CAAE,EAAG,CAAE,CAGlD,EAAK,EACL,EAAK,EAEL,EAAgB,KAAK,CAAE,GAAgB,CAAI,EAAG,CAAC,CAC/C,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,EAAG,CAAC,CAClD,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,EAAG,CAAC,CAClD,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,EAAG,CAAC,CAElD,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,EAAG,CAAC,CAClD,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,EAAG,CAAC,CAClD,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,EAAG,CAAC,CAClD,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,EAAG,CAAC,CAElD,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,EAAG,CAAC,CAClD,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,EAAG,CAAC,CAClD,EAAgB,KAAK,CAAE,GAAgB,GAAI,CAAG,EAAG,CAAC,CAClD,EAAgB,KAAK,CAAE,GAAgB,GAAI,CAAG,EAAG,CAAC,CAElD,IAAiB,GAIlB,IAAM,EAAI,EAAG,EAAK,GAAa,MAAM,CAAE,EAAI,EAAI,IAI9C,EAFA,EAAQ,EAAgB,KAAK,CAAE,EAAY,CAAE,EAAG,CAAE,CAGlD,EAAK,EACL,EAAK,EACL,EAAK,EAEL,EAAgB,KAAK,CAAE,GAAgB,CAAI,EAAG,CAAC,CAC/C,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,EAAG,CAAC,CAClD,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,EAAG,CAAC,CAClD,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,EAAG,CAAC,CAElD,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,EAAG,CAAC,CAClD,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,EAAG,CAAC,CAClD,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,EAAG,CAAC,CAClD,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,EAAG,CAAC,CAElD,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,EAAG,CAAC,CAClD,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,EAAG,CAAC,CAClD,EAAgB,KAAK,CAAE,GAAgB,GAAI,CAAG,EAAG,CAAC,CAClD,EAAgB,KAAK,CAAE,GAAgB,GAAI,CAAG,EAAG,CAAC,CAElD,EAAgB,KAAK,CAAE,GAAgB,GAAI,CAAG,EAAG,CAAC,CAClD,EAAgB,KAAK,CAAE,GAAgB,GAAI,CAAG,EAAG,CAAC,CAClD,EAAgB,KAAK,CAAE,GAAgB,GAAI,CAAG,EAAG,CAAC,CAClD,EAAgB,KAAK,CAAE,GAAgB,GAAI,CAAG,EAAG,CAAC,CAElD,IAAiB,EAInB,MAAO,GAAK,AAA4B,iBAA5B,EAAgB,OAAO,CAAsB,CAExD,IAAM,EAAI,EAAG,EAAK,GAAa,MAAM,CAAE,EAAI,EAAI,IAI9C,EAAK,AAFL,CAAA,EAAQ,EAAgB,KAAK,CAAE,EAAY,CAAE,EAAG,CAAE,AAAF,CAEtC,CAAE,EAAG,CACf,EAAK,CAAK,CAAE,EAAG,CACf,EAAK,CAAK,CAAE,EAAG,CAEf,EAAgB,KAAK,CAAE,GAAgB,CAAI,EAAG,CAAC,CAC/C,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,EAAG,CAAC,CAClD,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,EAAG,CAAC,CAClD,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,EAAG,CAAC,CAElD,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,EAAG,CAAC,CAClD,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,EAAG,CAAC,CAClD,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,EAAG,CAAC,CAClD,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,EAAG,CAAC,CAElD,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,EAAG,CAAC,CAClD,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,EAAG,CAAC,CAClD,EAAgB,KAAK,CAAE,GAAgB,GAAI,CAAG,EAAG,CAAC,CAClD,EAAgB,KAAK,CAAE,GAAgB,GAAI,CAAG,EAAG,CAAC,CAElD,IAAiB,GAIlB,IAAM,EAAI,EAAG,EAAK,GAAa,MAAM,CAAE,EAAI,EAAI,IAI9C,EAAK,AAFL,CAAA,EAAQ,EAAgB,KAAK,CAAE,EAAY,CAAE,EAAG,CAAE,AAAF,CAEtC,CAAE,EAAG,CACf,EAAK,CAAK,CAAE,EAAG,CACf,EAAK,CAAK,CAAE,EAAG,CACf,EAAK,CAAK,CAAE,EAAG,CAEf,EAAgB,KAAK,CAAE,GAAgB,CAAI,EAAG,CAAC,CAC/C,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,EAAG,CAAC,CAClD,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,EAAG,CAAC,CAClD,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,EAAG,CAAC,CAElD,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,EAAG,CAAC,CAClD,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,EAAG,CAAC,CAClD,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,EAAG,CAAC,CAClD,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,EAAG,CAAC,CAElD,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,EAAG,CAAC,CAClD,EAAgB,KAAK,CAAE,GAAgB,EAAI,CAAG,EAAG,CAAC,CAClD,EAAgB,KAAK,CAAE,GAAgB,GAAI,CAAG,EAAG,CAAC,CAClD,EAAgB,KAAK,CAAE,GAAgB,GAAI,CAAG,EAAG,CAAC,CAElD,EAAgB,KAAK,CAAE,GAAgB,GAAI,CAAG,EAAG,CAAC,CAClD,EAAgB,KAAK,CAAE,GAAgB,GAAI,CAAG,EAAG,CAAC,CAClD,EAAgB,KAAK,CAAE,GAAgB,GAAI,CAAG,EAAG,CAAC,CAClD,EAAgB,KAAK,CAAE,GAAgB,GAAI,CAAG,EAAG,CAAC,CAElD,IAAiB,EAInB,EAID,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAgB,MAAM,EACxD,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAgB,KAAK,CAAE,GAE1D,CAII,IAEJ,OAAO,EAAc,eAAe,CACpC,OAAO,EAAc,YAAY,CACjC,OAAO,EAAc,aAAa,CAClC,OAAO,EAAc,cAAc,CACnC,OAAO,EAAc,SAAS,CAC9B,OAAO,EAAc,UAAU,CAC/B,OAAO,EAAc,WAAW,CAChC,OAAO,EAAc,aAAa,CAClC,OAAO,EAAc,WAAW,CAChC,OAAO,EAAc,gBAAgB,CACrC,OAAO,EAAc,iBAAiB,EAIxC,EAimDqB,EAAe,EAAQ,EAAI,YAAY,CAAE,CAAC,EAAS,OAAO,CAAE,EAM9E,CAAA,EAAS,kBAAkB,CAAG,CAAA,EAC9B,EAAS,sBAAsB,CAAG,CAAA,EAClC,EAAS,kBAAkB,CAAG,CAAA,EAC9B,EAAS,aAAa,CAAG,CAAA,EACzB,EAAS,iBAAiB,CAAG,CAAA,EAC7B,EAAS,gBAAgB,CAAG,CAAA,EAC5B,EAAS,kBAAkB,CAAG,CAAA,EAE9B,EAAS,iBAAiB,CAAG,CAAA,EAE7B,EAAS,UAAU,EAAI,GAAuB,EAE/C,OAEW,aAAkB,GAAM,MAAM,EAIzC,EAAwB,AAFxB,CAAA,EAAW,GAAmB,EAAQ,EAAtC,EAEiC,UAAU,EAAI,GAA0B,GAEpE,CAAA,EAAS,kBAAkB,EAAI,EAAS,gBAAgB,EAAI,EAAS,iBAAiB,EAAI,CAAA,GAE9F,AAzrGH,SAA4B,CAAQ,CAAE,CAAI,EAEzC,IAAI,EAAG,EAAG,EAAG,EAAQ,EAAQ,EAAO,EAEpC,EAAG,EAAI,EAAI,EAAK,EAAiB,EAEjC,EAAW,EAAS,QAAQ,CAC5B,EAAS,EAAS,MAAM,CACxB,EAAU,EAAS,OAAO,CAE1B,EAAK,EAAS,MAAM,CACpB,EAAK,EAAO,MAAM,CAClB,EAAK,EAAQ,MAAM,CAEnB,EAAc,EAAS,aAAa,CACpC,EAAa,EAAS,YAAY,CAClC,EAAc,EAAS,aAAa,CAEpC,EAAgB,EAAS,kBAAkB,CAC3C,EAAc,EAAS,gBAAgB,CACvC,EAAe,EAAS,iBAAiB,CAEzC,EAAmB,EAAS,2BAA2B,CAEvD,GAAK,EAAgB,CAEpB,IAAM,EAAI,EAAG,EAAI,EAAI,IAEpB,EAAS,CAAQ,CAAE,EAAG,CAItB,CAAW,CAFX,EAAS,AAAI,EAAJ,EAEY,CAAO,EAAO,CAAC,CACpC,CAAW,CAAE,EAAS,EAAG,CAAG,EAAO,CAAC,CACpC,CAAW,CAAE,EAAS,EAAG,CAAG,EAAO,CAAC,CAIrC,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAS,mBAAmB,EAC9D,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAa,EAEhD,CAEA,GAAK,EAAc,CAElB,IAAM,EAAI,EAAG,EAAI,EAAI,IAEpB,EAAQ,CAAM,CAAE,EAAG,CAInB,CAAU,CAFV,EAAS,AAAI,EAAJ,EAEW,CAAO,EAAM,CAAC,CAClC,CAAU,CAAE,EAAS,EAAG,CAAG,EAAM,CAAC,CAClC,CAAU,CAAE,EAAS,EAAG,CAAG,EAAM,CAAC,CAInC,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAS,kBAAkB,EAC7D,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAY,EAE/C,CAEA,GAAK,EAAe,CAEnB,IAAM,EAAI,EAAG,EAAI,EAAI,IAEpB,EAAS,CAAO,CAAE,EAAG,CAIrB,CAAW,CAFX,EAAS,AAAI,EAAJ,EAEY,CAAO,EAAO,CAAC,CACpC,CAAW,CAAE,EAAS,EAAG,CAAG,EAAO,CAAC,CACpC,CAAW,CAAE,EAAS,EAAG,CAAG,EAAO,CAAC,CAIrC,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAS,mBAAmB,EAC9D,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAa,EAEhD,CAEA,GAAK,EAEJ,CAAA,IAAM,EAAI,EAAG,EAAK,EAAiB,MAAM,CAAE,EAAI,EAAI,IAIlD,GAAK,AAFL,CAAA,EAAkB,CAAgB,CAAE,EAAG,AAAH,EAEf,WAAW,EAC5B,CAAA,AAA4B,KAAA,IAA5B,EAAgB,OAAO,EACvB,AAA4B,aAA5B,EAAgB,OAAO,AAAK,EAAe,CAM9C,GAJA,EAAS,EAET,EAAM,EAAgB,KAAK,CAAC,MAAM,CAE7B,AAAyB,IAAzB,EAAgB,IAAI,CAExB,IAAM,EAAK,EAAG,EAAK,EAAK,IAEvB,EAAgB,KAAK,CAAE,EAAI,CAAG,EAAgB,KAAK,CAAE,EAAI,MAIpD,GAAK,AAAyB,IAAzB,EAAgB,IAAI,CAE/B,IAAM,EAAK,EAAG,EAAK,EAAK,IAEvB,EAAQ,EAAgB,KAAK,CAAE,EAAI,CAEnC,EAAgB,KAAK,CAAE,EAAQ,CAAI,EAAM,CAAC,CAC1C,EAAgB,KAAK,CAAE,EAAS,EAAG,CAAG,EAAM,CAAC,CAE7C,GAAU,OAIL,GAAK,AAAyB,IAAzB,EAAgB,IAAI,EAE/B,GAAK,AAAyB,MAAzB,EAAgB,IAAI,CAExB,IAAM,EAAK,EAAG,EAAK,EAAK,IAEvB,EAAQ,EAAgB,KAAK,CAAE,EAAI,CAEnC,EAAgB,KAAK,CAAE,EAAQ,CAAI,EAAM,CAAC,CAC1C,EAAgB,KAAK,CAAE,EAAS,EAAG,CAAG,EAAM,CAAC,CAC7C,EAAgB,KAAK,CAAE,EAAS,EAAG,CAAG,EAAM,CAAC,CAE7C,GAAU,OAMX,IAAM,EAAK,EAAG,EAAK,EAAK,IAEvB,EAAQ,EAAgB,KAAK,CAAE,EAAI,CAEnC,EAAgB,KAAK,CAAE,EAAQ,CAAI,EAAM,CAAC,CAC1C,EAAgB,KAAK,CAAE,EAAS,EAAG,CAAG,EAAM,CAAC,CAC7C,EAAgB,KAAK,CAAE,EAAS,EAAG,CAAG,EAAM,CAAC,CAE7C,GAAU,OAMN,GAAK,AAAyB,IAAzB,EAAgB,IAAI,CAE/B,IAAM,EAAK,EAAG,EAAK,EAAK,IAEvB,EAAQ,EAAgB,KAAK,CAAE,EAAI,CAEnC,EAAgB,KAAK,CAAE,EAAQ,CAAK,EAAM,CAAC,CAC3C,EAAgB,KAAK,CAAE,EAAS,EAAI,CAAG,EAAM,CAAC,CAC9C,EAAgB,KAAK,CAAE,EAAS,EAAI,CAAG,EAAM,CAAC,CAC9C,EAAgB,KAAK,CAAE,EAAS,EAAI,CAAG,EAAM,CAAC,CAE9C,GAAU,EAMZ,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAgB,MAAM,EACxD,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAgB,KAAK,CAAE,EAE1D,CAED,CAIF,EA2gGqB,EAAU,EAAI,YAAY,EAI7C,EAAS,kBAAkB,CAAG,CAAA,EAC9B,EAAS,gBAAgB,CAAG,CAAA,EAC5B,EAAS,iBAAiB,CAAG,CAAA,EAE7B,EAAS,UAAU,EAAI,GAAuB,IAEnC,aAAkB,GAAM,IAAI,CAE/B,aAAoB,GAAM,cAAc,EAE1C,CAAA,EAAS,kBAAkB,EAAI,EAAS,gBAAgB,AAAhB,GAE5C,GAAkB,EAAU,EAAI,YAAY,CAAE,CAAC,EAAS,OAAO,EAIhE,EAAS,kBAAkB,CAAG,CAAA,EAC9B,EAAS,gBAAgB,CAAG,CAAA,IAMxB,EAAwB,AAFxB,CAAA,EAAW,GAAmB,EAAQ,EAAtC,EAEiC,UAAU,EAAI,GAA0B,GAEpE,CAAA,EAAS,kBAAkB,EAAI,EAAS,gBAAgB,EAAI,EAAS,uBAAuB,EAAI,CAAA,GAEnG,AAp4GT,SAA0B,CAAQ,CAAE,CAAI,EAEvC,IAAI,EAAG,EAAG,EAAG,EAAQ,EAAQ,EAoB7B,EAAG,EACA,EAAI,EAAK,EACZ,EApBA,EAAW,EAAS,QAAQ,CAC5B,EAAS,EAAS,MAAM,CACxB,EAAgB,EAAS,aAAa,CAEtC,EAAK,EAAS,MAAM,CACpB,EAAK,EAAO,MAAM,CAClB,EAAK,EAAc,MAAM,CAEzB,EAAc,EAAS,aAAa,CACpC,EAAa,EAAS,YAAY,CAClC,EAAoB,EAAS,mBAAmB,CAEhD,EAAgB,EAAS,kBAAkB,CAC3C,EAAc,EAAS,gBAAgB,CACvC,EAAqB,EAAS,uBAAuB,CAErD,EAAmB,EAAS,2BAA2B,CAMvD,GAAK,EAAgB,CAEpB,IAAM,EAAI,EAAG,EAAI,EAAI,IAEpB,EAAS,CAAQ,CAAE,EAAG,CAItB,CAAW,CAFX,EAAS,AAAI,EAAJ,EAEY,CAAO,EAAO,CAAC,CACpC,CAAW,CAAE,EAAS,EAAG,CAAG,EAAO,CAAC,CACpC,CAAW,CAAE,EAAS,EAAG,CAAG,EAAO,CAAC,CAIrC,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAS,mBAAmB,EAC9D,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAa,EAEhD,CAEA,GAAK,EAAc,CAElB,IAAM,EAAI,EAAG,EAAI,EAAI,IAEpB,EAAQ,CAAM,CAAE,EAAG,CAInB,CAAU,CAFV,EAAS,AAAI,EAAJ,EAEW,CAAO,EAAM,CAAC,CAClC,CAAU,CAAE,EAAS,EAAG,CAAG,EAAM,CAAC,CAClC,CAAU,CAAE,EAAS,EAAG,CAAG,EAAM,CAAC,CAInC,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAS,kBAAkB,EAC7D,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAY,EAE/C,CAEA,GAAK,EAAqB,CAEzB,IAAM,EAAI,EAAG,EAAI,EAAI,IAEpB,CAAiB,CAAE,EAAG,CAAG,CAAa,CAAE,EAAG,CAI5C,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAS,yBAAyB,EACpE,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAmB,EAEtD,CAEA,GAAK,EAEJ,CAAA,IAAM,EAAI,EAAG,EAAK,EAAiB,MAAM,CAAE,EAAI,EAAI,IAIlD,GAAK,AAFL,CAAA,EAAkB,CAAgB,CAAE,EAAG,AAAH,EAEf,WAAW,EAC5B,CAAA,AAA4B,KAAA,IAA5B,EAAgB,OAAO,EACvB,AAA4B,aAA5B,EAAgB,OAAO,AAAK,EAAe,CAM9C,GAJA,EAAS,EAET,EAAM,EAAgB,KAAK,CAAC,MAAM,CAE7B,AAAyB,IAAzB,EAAgB,IAAI,CAExB,IAAM,EAAK,EAAG,EAAK,EAAK,IAEvB,EAAgB,KAAK,CAAE,EAAI,CAAG,EAAgB,KAAK,CAAE,EAAI,MAIpD,GAAK,AAAyB,IAAzB,EAAgB,IAAI,CAE/B,IAAM,EAAK,EAAG,EAAK,EAAK,IAEvB,EAAQ,EAAgB,KAAK,CAAE,EAAI,CAEnC,EAAgB,KAAK,CAAE,EAAQ,CAAI,EAAM,CAAC,CAC1C,EAAgB,KAAK,CAAE,EAAS,EAAG,CAAG,EAAM,CAAC,CAE7C,GAAU,OAIL,GAAK,AAAyB,IAAzB,EAAgB,IAAI,EAE/B,GAAK,AAAyB,MAAzB,EAAgB,IAAI,CAExB,IAAM,EAAK,EAAG,EAAK,EAAK,IAEvB,EAAQ,EAAgB,KAAK,CAAE,EAAI,CAEnC,EAAgB,KAAK,CAAE,EAAQ,CAAI,EAAM,CAAC,CAC1C,EAAgB,KAAK,CAAE,EAAS,EAAG,CAAG,EAAM,CAAC,CAC7C,EAAgB,KAAK,CAAE,EAAS,EAAG,CAAG,EAAM,CAAC,CAE7C,GAAU,OAMX,IAAM,EAAK,EAAG,EAAK,EAAK,IAEvB,EAAQ,EAAgB,KAAK,CAAE,EAAI,CAEnC,EAAgB,KAAK,CAAE,EAAQ,CAAI,EAAM,CAAC,CAC1C,EAAgB,KAAK,CAAE,EAAS,EAAG,CAAG,EAAM,CAAC,CAC7C,EAAgB,KAAK,CAAE,EAAS,EAAG,CAAG,EAAM,CAAC,CAE7C,GAAU,OAMN,GAAK,AAAyB,IAAzB,EAAgB,IAAI,CAE/B,IAAM,EAAK,EAAG,EAAK,EAAK,IAEvB,EAAQ,EAAgB,KAAK,CAAE,EAAI,CAEnC,EAAgB,KAAK,CAAE,EAAQ,CAAK,EAAM,CAAC,CAC3C,EAAgB,KAAK,CAAE,EAAS,EAAI,CAAG,EAAM,CAAC,CAC9C,EAAgB,KAAK,CAAE,EAAS,EAAI,CAAG,EAAM,CAAC,CAC9C,EAAgB,KAAK,CAAE,EAAS,EAAI,CAAG,EAAM,CAAC,CAE9C,GAAU,EAMZ,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAgB,MAAM,EACxD,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAgB,KAAK,CAAE,EAE1D,CAED,CAIF,EA0tGyB,EAAU,EAAI,YAAY,EAI5C,EAAS,kBAAkB,CAAG,CAAA,EAC9B,EAAS,gBAAgB,CAAG,CAAA,EAC5B,EAAS,uBAAuB,CAAG,CAAA,EAEnC,EAAS,UAAU,EAAI,GAAuB,IAIxC,aAAkB,GAAM,cAAc,GAE5C,aAAoB,GAAM,cAAc,EAEvC,CAAA,EAAS,kBAAkB,EAAI,EAAS,gBAAgB,AAAhB,GAE5C,GAAkB,EAAU,EAAI,YAAY,CAAE,CAAC,EAAS,OAAO,EAIhE,EAAS,kBAAkB,CAAG,CAAA,EAC9B,EAAS,gBAAgB,CAAG,CAAA,IAM5B,EAAwB,AAFxB,CAAA,EAAW,GAAmB,EAAQ,EAAtC,EAEiC,UAAU,EAAI,GAA0B,GAEpE,CAAA,EAAS,kBAAkB,EAAI,EAAS,gBAAgB,EAAI,EAAO,aAAa,EAAI,CAAA,GAExF,AAvuHJ,SAA8B,CAAQ,CAAE,CAAI,CAAE,CAAM,EAEnD,IAAI,EAAG,EAAG,EAAQ,EAAQ,EAAO,EAkBjC,EAAG,EACA,EAAI,EAAK,EACZ,EAlBA,EAAW,EAAS,QAAQ,CAC5B,EAAK,EAAS,MAAM,CAEpB,EAAS,EAAS,MAAM,CACxB,EAAK,EAAO,MAAM,CAElB,EAAc,EAAS,aAAa,CACpC,EAAa,EAAS,YAAY,CAElC,EAAY,EAAS,WAAW,CAEhC,EAAgB,EAAS,kBAAkB,CAE3C,GADgB,EAAS,kBAAkB,CAC7B,EAAS,gBAAgB,EAEvC,EAAmB,EAAS,2BAA2B,CAKvD,GAAK,EAAO,aAAa,CAAG,CAK3B,IAHA,EAAoB,IAAI,CAAE,GAC1B,EAAoB,QAAQ,CAAE,EAAO,WAAW,EAE1C,EAAI,EAAG,EAAI,EAAI,IAEpB,EAAS,CAAQ,CAAE,EAAG,CAEtB,EAAS,IAAI,CAAE,GACf,EAAS,eAAe,CAAE,GAE1B,CAAS,CAAE,EAAG,CAAG,CAAE,EAAS,CAAC,CAAE,EAAG,CAMnC,IAFA,EAAU,IAAI,CAAE,IAEV,EAAI,EAAG,EAAI,EAAI,IAEpB,EAAS,CAAQ,CAAE,CAAS,CAAC,EAAE,CAAC,EAAE,CAAE,CAIpC,CAAW,CAFX,EAAS,AAAI,EAAJ,EAEY,CAAO,EAAO,CAAC,CACpC,CAAW,CAAE,EAAS,EAAG,CAAG,EAAO,CAAC,CACpC,CAAW,CAAE,EAAS,EAAG,CAAG,EAAO,CAAC,CAIrC,IAAM,EAAI,EAAG,EAAI,EAAI,IAEpB,EAAS,AAAI,EAAJ,EAET,EAAQ,CAAM,CAAE,CAAS,CAAC,EAAE,CAAC,EAAE,CAAE,CAEjC,CAAU,CAAE,EAAQ,CAAO,EAAM,CAAC,CAClC,CAAU,CAAE,EAAS,EAAG,CAAG,EAAM,CAAC,CAClC,CAAU,CAAE,EAAS,EAAG,CAAG,EAAM,CAAC,CAInC,GAAK,EAEJ,CAAA,IAAM,EAAI,EAAG,EAAK,EAAiB,MAAM,CAAE,EAAI,EAAI,IAIlD,GAAK,CAAI,CAAA,AAA4B,KAAA,IAA5B,AAFT,CAAA,EAAkB,CAAgB,CAAE,EAAG,AAAH,EAEX,OAAO,EAAkB,AAA4B,aAA5B,EAAgB,OAAO,AAAK,GAM9E,GAJA,EAAS,EAET,EAAM,EAAgB,KAAK,CAAC,MAAM,CAE7B,AAAyB,IAAzB,EAAgB,IAAI,CAExB,IAAM,EAAK,EAAG,EAAK,EAAK,IAEvB,EAAQ,CAAS,CAAE,EAAI,CAAE,EAAG,CAE5B,EAAgB,KAAK,CAAE,EAAI,CAAG,EAAgB,KAAK,CAAE,EAAO,MAIvD,GAAK,AAAyB,IAAzB,EAAgB,IAAI,CAE/B,IAAM,EAAK,EAAG,EAAK,EAAK,IAEvB,EAAQ,CAAS,CAAE,EAAI,CAAE,EAAG,CAE5B,EAAQ,EAAgB,KAAK,CAAE,EAAO,CAEtC,EAAgB,KAAK,CAAE,EAAQ,CAAI,EAAM,CAAC,CAC1C,EAAgB,KAAK,CAAE,EAAS,EAAG,CAAG,EAAM,CAAC,CAE7C,GAAU,OAIL,GAAK,AAAyB,IAAzB,EAAgB,IAAI,EAE/B,GAAK,AAAyB,MAAzB,EAAgB,IAAI,CAExB,IAAM,EAAK,EAAG,EAAK,EAAK,IAEvB,EAAQ,CAAS,CAAE,EAAI,CAAE,EAAG,CAE5B,EAAQ,EAAgB,KAAK,CAAE,EAAO,CAEtC,EAAgB,KAAK,CAAE,EAAQ,CAAO,EAAM,CAAC,CAC7C,EAAgB,KAAK,CAAE,EAAS,EAAG,CAAG,EAAM,CAAC,CAC7C,EAAgB,KAAK,CAAE,EAAS,EAAG,CAAG,EAAM,CAAC,CAE7C,GAAU,OAMX,IAAM,EAAK,EAAG,EAAK,EAAK,IAEvB,EAAQ,CAAS,CAAE,EAAI,CAAE,EAAG,CAE5B,EAAQ,EAAgB,KAAK,CAAE,EAAO,CAEtC,EAAgB,KAAK,CAAE,EAAQ,CAAI,EAAM,CAAC,CAC1C,EAAgB,KAAK,CAAE,EAAS,EAAG,CAAG,EAAM,CAAC,CAC7C,EAAgB,KAAK,CAAE,EAAS,EAAG,CAAG,EAAM,CAAC,CAE7C,GAAU,OAMN,GAAK,AAAyB,IAAzB,EAAgB,IAAI,CAE/B,IAAM,EAAK,EAAG,EAAK,EAAK,IAEvB,EAAQ,CAAS,CAAE,EAAI,CAAE,EAAG,CAE5B,EAAQ,EAAgB,KAAK,CAAE,EAAO,CAEtC,EAAgB,KAAK,CAAE,EAAQ,CAAQ,EAAM,CAAC,CAC9C,EAAgB,KAAK,CAAE,EAAS,EAAI,CAAG,EAAM,CAAC,CAC9C,EAAgB,KAAK,CAAE,EAAS,EAAI,CAAG,EAAM,CAAC,CAC9C,EAAgB,KAAK,CAAE,EAAS,EAAI,CAAG,EAAM,CAAC,CAE9C,GAAU,EAMb,CAIF,KAAO,CAEN,GAAK,EAEJ,IAAM,EAAI,EAAG,EAAI,EAAI,IAEpB,EAAS,CAAQ,CAAE,EAAG,CAItB,CAAW,CAFX,EAAS,AAAI,EAAJ,EAEY,CAAO,EAAO,CAAC,CACpC,CAAW,CAAE,EAAS,EAAG,CAAG,EAAO,CAAC,CACpC,CAAW,CAAE,EAAS,EAAG,CAAG,EAAO,CAAC,CAMtC,GAAK,EAEJ,IAAM,EAAI,EAAG,EAAI,EAAI,IAEpB,EAAQ,CAAM,CAAE,EAAG,CAInB,CAAU,CAFV,EAAS,AAAI,EAAJ,EAEW,CAAO,EAAM,CAAC,CAClC,CAAU,CAAE,EAAS,EAAG,CAAG,EAAM,CAAC,CAClC,CAAU,CAAE,EAAS,EAAG,CAAG,EAAM,CAAC,CAMpC,GAAK,EAEJ,CAAA,IAAM,EAAI,EAAG,EAAK,EAAiB,MAAM,CAAE,EAAI,EAAI,IAIlD,GAAK,AAFL,CAAA,EAAkB,CAAgB,CAAE,EAAG,AAAH,EAEf,WAAW,EAC5B,CAAA,AAA4B,KAAA,IAA5B,EAAgB,OAAO,EACvB,AAA4B,aAA5B,EAAgB,OAAO,AAAK,GAM/B,GAJA,EAAM,EAAgB,KAAK,CAAC,MAAM,CAElC,EAAS,EAEJ,AAAyB,IAAzB,EAAgB,IAAI,CAExB,IAAM,EAAK,EAAG,EAAK,EAAK,IAEvB,EAAgB,KAAK,CAAE,EAAI,CAAG,EAAgB,KAAK,CAAE,EAAI,MAIpD,GAAK,AAAyB,IAAzB,EAAgB,IAAI,CAE/B,IAAM,EAAK,EAAG,EAAK,EAAK,IAEvB,EAAQ,EAAgB,KAAK,CAAE,EAAI,CAEnC,EAAgB,KAAK,CAAE,EAAQ,CAAI,EAAM,CAAC,CAC1C,EAAgB,KAAK,CAAE,EAAS,EAAG,CAAG,EAAM,CAAC,CAE7C,GAAU,OAIL,GAAK,AAAyB,IAAzB,EAAgB,IAAI,EAE/B,GAAK,AAAyB,MAAzB,EAAgB,IAAI,CAExB,IAAM,EAAK,EAAG,EAAK,EAAK,IAEvB,EAAQ,EAAgB,KAAK,CAAE,EAAI,CAEnC,EAAgB,KAAK,CAAE,EAAQ,CAAI,EAAM,CAAC,CAC1C,EAAgB,KAAK,CAAE,EAAS,EAAG,CAAG,EAAM,CAAC,CAC7C,EAAgB,KAAK,CAAE,EAAS,EAAG,CAAG,EAAM,CAAC,CAE7C,GAAU,OAMX,IAAM,EAAK,EAAG,EAAK,EAAK,IAEvB,EAAQ,EAAgB,KAAK,CAAE,EAAI,CAEnC,EAAgB,KAAK,CAAE,EAAQ,CAAI,EAAM,CAAC,CAC1C,EAAgB,KAAK,CAAE,EAAS,EAAG,CAAG,EAAM,CAAC,CAC7C,EAAgB,KAAK,CAAE,EAAS,EAAG,CAAG,EAAM,CAAC,CAE7C,GAAU,OAMN,GAAK,AAAyB,IAAzB,EAAgB,IAAI,CAE/B,IAAM,EAAK,EAAG,EAAK,EAAK,IAEvB,EAAQ,EAAgB,KAAK,CAAE,EAAI,CAEnC,EAAgB,KAAK,CAAE,EAAQ,CAAQ,EAAM,CAAC,CAC9C,EAAgB,KAAK,CAAE,EAAS,EAAI,CAAG,EAAM,CAAC,CAC9C,EAAgB,KAAK,CAAE,EAAS,EAAI,CAAG,EAAM,CAAC,CAC9C,EAAgB,KAAK,CAAE,EAAS,EAAI,CAAG,EAAM,CAAC,CAE9C,GAAU,EAQd,CAIF,CAgBA,GAdK,CAAA,GAAiB,EAAO,aAAa,AAAb,IAE5B,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAS,mBAAmB,EAC9D,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAa,IAI3C,CAAA,GAAe,EAAO,aAAa,AAAb,IAE1B,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAS,kBAAkB,EAC7D,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAY,IAI1C,EAEJ,IAAM,EAAI,EAAG,EAAK,EAAiB,MAAM,CAAE,EAAI,EAAI,IAI7C,CAAA,AAFL,CAAA,EAAkB,CAAgB,CAAE,EAAG,AAAH,EAEf,WAAW,EAAI,EAAO,aAAa,AAAb,IAE1C,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAgB,MAAM,EACxD,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAgB,KAAK,CAAE,GAS7D,EAu6GwB,EAAU,EAAI,YAAY,CAAE,GAIjD,EAAS,kBAAkB,CAAG,CAAA,EAC9B,EAAS,gBAAgB,CAAG,CAAA,EAE5B,EAAS,UAAU,EAAI,GAAuB,IAMjD,CAAA,EA1WgB,EAAM,cAAc,CAAE,EAAG,CAAC,MAAM,CAIhD,EA2bA,IAAI,CAAC,YAAY,CAAG,SAAW,CAAQ,CAAE,CAAM,CAAE,CAAG,CAAE,CAAM,EAE3D,EAAS,gBAAgB,CAAE,UAAW,IAIjC,aAAoB,GAAM,iBAAiB,CAE/C,EAAW,QAEA,aAAoB,GAAM,kBAAkB,CAEvD,EAAW,SAEA,aAAoB,GAAM,iBAAiB,CAEtD,EAAW,QAEA,aAAoB,GAAM,mBAAmB,CAExD,EAAW,UAEA,aAAoB,GAAM,iBAAiB,CAEtD,EAAW,QAEA,aAAoB,GAAM,iBAAiB,CAEtD,EAAW,QAEA,aAAoB,GAAM,kBAAkB,CAEvD,EAAW,SAEA,aAAoB,GAAM,qBAAqB,EAE1D,CAAA,EAAW,gBAFL,EAMF,IAqHiC,EAnHP,GAAM,SAAS,CAAE,EAAU,CAqH1D,AArHqB,EAqHZ,QAAQ,CAAG,GAAM,aAAa,CAAC,KAAK,CAAE,EAAQ,QAAQ,EAC/D,AAtHqB,EAsHZ,YAAY,CAAG,EAAQ,YAAY,CAC5C,AAvHqB,EAuHZ,cAAc,CAAG,EAAQ,cAAc,EAhHhD,EAAgB,AAmuEjB,SAA0B,CAAM,EAE/B,IAAI,EAAG,EAAI,EAAO,EAAW,EAAa,EAAY,EAItD,IAAM,EAAI,EAFV,EAAY,EAAc,EAAa,EAAa,EAEvC,EAAK,EAAO,MAAM,CAAE,EAAI,EAAI,KAInC,AAFL,CAAA,EAAQ,CAAM,CAAE,EAAG,AAAH,EAEL,UAAU,GAEhB,aAAiB,GAAM,gBAAgB,EAAG,IAC1C,aAAiB,GAAM,UAAU,EAAG,IACpC,aAAiB,GAAM,SAAS,EAAG,IACnC,aAAiB,GAAM,eAAe,EAAG,KAI/C,MAAO,CAAE,YAAgB,EAAW,MAAU,EAAa,KAAQ,EAAY,KAAQ,CAAW,CAEnG,EAxvEiC,GAEhC,EAAa,AAwvEd,SAA2B,CAAM,EAEhC,IAAI,EAAG,EAAI,EAAO,EAAa,EAE/B,IAAM,EAAI,EAAG,EAAK,EAAO,MAAM,CAAE,EAAI,EAAI,IAIjC,AAFP,CAAA,EAAQ,CAAM,CAAE,EAAG,AAAH,EAEH,UAAU,GAElB,aAAiB,GAAM,SAAS,EAAG,IACnC,aAAiB,GAAM,gBAAgB,EAAI,CAAE,EAAM,aAAa,EAAG,KAIzE,OAAO,CAER,EAzwE+B,GAE9B,EAAW,AAwrEZ,SAAyB,CAAM,EAE9B,GAAK,IAAyB,GAAU,EAAO,gBAAgB,CAE9D,OAAO,KAYP,IAGI,EAFkB,KAAK,KAAK,CAAE,AAAE,CAAA,AADd,EAAI,YAAY,CAAE,EAAI,0BAA0B,EAChB,EAAA,EAAO,GAgB7D,OAZgB,KAAA,IAAX,GAAwB,aAAkB,GAAM,WAAW,EAI1D,AAFL,CAAA,EAAW,KAAK,GAAG,CAAE,EAAO,KAAK,CAAC,MAAM,CAAE,EAA1C,EAEgB,EAAO,KAAK,CAAC,MAAM,EAElC,QAAQ,IAAI,CAAE,mCAAqC,EAAO,KAAK,CAAC,MAAM,CAAG,4BAA8B,EAAW,kCAM7G,CAIT,EA7tE2B,GAE1B,EAAa,CAEZ,IAAK,CAAC,CAAC,EAAS,GAAG,CACnB,OAAQ,CAAC,CAAC,EAAS,MAAM,CACzB,SAAU,CAAC,CAAC,EAAS,QAAQ,CAC7B,QAAS,CAAC,CAAC,EAAS,OAAO,CAC3B,UAAW,CAAC,CAAC,EAAS,SAAS,CAC/B,YAAa,CAAC,CAAC,EAAS,WAAW,CAEnC,aAAc,EAAS,YAAY,CAEnC,IAAK,EACL,OAAQ,EAAS,GAAG,CACpB,OAAQ,aAAe,GAAM,OAAO,CAEpC,gBAAiB,EAAS,eAAe,CAEzC,SAAU,EAAS,QAAQ,CAC3B,SAAU,EACV,iBAAkB,IAAyB,GAAU,EAAO,gBAAgB,CAC5E,iBAAkB,GAAU,EAAO,gBAAgB,CACnD,kBAAmB,GAAU,EAAO,iBAAiB,CAErD,aAAc,EAAS,YAAY,CACnC,aAAc,EAAS,YAAY,CACnC,gBAAiB,IAAI,CAAC,eAAe,CACrC,gBAAiB,IAAI,CAAC,eAAe,CAErC,aAAc,EAAc,WAAW,CACvC,eAAgB,EAAc,KAAK,CACnC,cAAe,EAAc,IAAI,CACjC,cAAe,EAAc,IAAI,CAEjC,WAAY,EACZ,iBAAkB,IAAI,CAAC,gBAAgB,EAAI,EAAO,aAAa,CAC/D,cAAe,IAAI,CAAC,aAAa,CACjC,eAAgB,IAAI,CAAC,cAAc,CACnC,iBAAkB,IAAI,CAAC,gBAAgB,CAEvC,UAAW,EAAS,SAAS,CAC7B,MAAO,EAAS,KAAK,CACrB,SAAU,EAAS,QAAQ,CAC3B,WAAY,EAAS,UAAU,CAC/B,YAAa,EAAS,IAAI,GAAK,GAAM,UAAU,CAC/C,UAAW,EAAS,IAAI,GAAK,GAAM,QAAQ,AAE5C,EAEA,EAAS,OAAO,CAAG,AAstCpB,SAAwB,CAAQ,CAAE,CAAc,CAAE,CAAY,CAAE,CAAQ,CAAE,CAAU,CAAE,CAAO,CAAE,CAAU,EAGxG,IADI,EAAG,EAAI,EAAG,EAAS,EAwPnB,EAAa,EAAG,EAAG,EAvPnB,EAAS,EAAE,CAef,IAAM,KAXD,EAEJ,EAAO,IAAI,CAAE,IAIb,EAAO,IAAI,CAAE,GACb,EAAO,IAAI,CAAE,IAIH,EAEV,EAAO,IAAI,CAAE,GACb,EAAO,IAAI,CAAE,CAAO,CAAE,EAAG,EAI1B,IAAM,KAAK,EAEV,EAAO,IAAI,CAAE,GACb,EAAO,IAAI,CAAE,CAAU,CAAE,EAAG,EAQ7B,IAAM,EAAI,EAJV,EAAO,EAAO,IAAI,GAIL,EAAK,EAAU,MAAM,CAAE,EAAI,EAAI,IAAO,CAElD,IAAI,EAAc,CAAS,CAAE,EAAG,CAEhC,GAAK,EAAY,IAAI,GAAK,EAMzB,OAFA,EAAY,SAAS,GAEd,EAAY,OAAO,AAI5B,CAEA,IAAI,EAAsB,sBAErB,CAAA,EAAW,aAAa,GAAK,GAAM,YAAY,CAEnD,EAAsB,qBAEX,EAAW,aAAa,GAAK,GAAM,gBAAgB,EAE9D,CAAA,EAAsB,yBAFhB,EAUP,IAAI,EAAgB,AAxFrB,SAA2B,CAAO,EAEjC,IAAI,EAAO,EAAO,EAAS,EAAE,CAE7B,IAAM,IAAI,KAAK,EAGC,CAAA,IADf,CAAA,EAAQ,CAAO,CAAE,EAAG,AAAH,IAGjB,EAAQ,WAAa,EAAI,IAAM,EAC/B,EAAO,IAAI,CAAE,IAId,OAAO,EAAO,IAAI,CAAE,KAErB,EAwEsC,GAIrC,EAAU,EAAI,aAAa,GAE3B,IAAI,EAAgB,CAEnB,aAAe,EAAa,UAE5B,EAEA,GAA0B,0BAA4B,GAEtD,EAAM,UAAU,CAAG,sBAAwB,GAC3C,EAAM,WAAW,CAAG,uBAAyB,GAC7C,EAAM,sBAAsB,CAAG,mCAAqC,GAEpE,0BAA4B,EAAW,YAAY,CACnD,4BAA8B,EAAW,cAAc,CACvD,2BAA6B,EAAW,aAAa,CACrD,2BAA6B,EAAW,aAAa,CAErD,uBAAyB,EAAW,UAAU,CAE9C,qBAAuB,EAAW,QAAQ,CAE1C,EAAW,GAAG,CAAG,kBAAoB,GACrC,EAAW,MAAM,CAAG,qBAAuB,GAC3C,EAAW,QAAQ,CAAG,uBAAyB,GAC/C,EAAW,OAAO,CAAG,sBAAwB,GAC7C,EAAW,SAAS,CAAG,wBAA0B,GACjD,EAAW,WAAW,CAAG,0BAA4B,GACrD,EAAW,YAAY,CAAG,oBAAsB,GAEhD,EAAW,QAAQ,CAAG,uBAAyB,GAC/C,EAAW,gBAAgB,CAAG,uBAAyB,GACvD,EAAW,gBAAgB,CAAG,0BAA4B,EAAW,gBAAgB,CAAC,OAAO,CAAE,GAAM,GACrG,EAAW,iBAAiB,CAAG,0BAA4B,EAAW,iBAAiB,CAAC,OAAO,CAAE,GAAM,GAEvG,EAAW,YAAY,CAAG,2BAA6B,GACvD,EAAW,YAAY,CAAG,2BAA6B,GACvD,EAAW,QAAQ,CAAG,0BAA4B,GAClD,EAAW,UAAU,CAAG,sBAAwB,GAChD,EAAW,WAAW,CAAG,uBAAyB,GAClD,EAAW,SAAS,CAAG,qBAAuB,GAE9C,EAAW,gBAAgB,CAAG,wBAA0B,GACxD,EAAW,gBAAgB,CAAG,WAAa,EAAsB,GACjE,EAAW,cAAc,CAAG,0BAA4B,GACxD,EAAW,gBAAgB,CAAG,4BAA8B,GAE5D,EAAW,eAAe,CAAG,8BAAgC,GAE7D,4BACA,gCACA,iCACA,2BACA,6BACA,+BAEA,2BACA,yBACA,qBACA,sBAEA,mBAEC,wBAED,SAEA,0BAEC,+BACA,+BACA,+BACA,+BAEA,0BAEC,+BACA,+BACA,+BACA,+BAED,QAEC,+BACA,+BACA,+BACA,+BAED,SAED,SAEA,sBAEC,4BACA,6BAED,SAEA,GAEA,CAAC,IAAI,CAAC,MAmDH,EAAmB,GAAW,WAAY,AAjDxB,CAErB,aAAe,EAAa,UAE1B,EAAW,OAAO,EAAI,EAAW,SAAS,CAAK,kDAAoD,GAErG,EAEA,0BAA4B,EAAW,YAAY,CACnD,4BAA8B,EAAW,cAAc,CACvD,2BAA6B,EAAW,aAAa,CACrD,2BAA6B,EAAW,aAAa,CAErD,uBAAyB,EAAW,UAAU,CAE9C,EAAW,SAAS,CAAG,qBAAuB,EAAW,SAAS,CAAE,GAEpE,EAAM,UAAU,CAAG,sBAAwB,GAC3C,EAAM,WAAW,CAAG,uBAAyB,GAC7C,EAAM,sBAAsB,CAAG,mCAAqC,GAElE,EAAW,MAAM,EAAI,EAAW,GAAG,CAAK,kBAAoB,GAC5D,EAAW,MAAM,EAAI,EAAW,MAAM,CAAK,mBAAqB,GAElE,EAAW,GAAG,CAAG,kBAAoB,GACrC,EAAW,MAAM,CAAG,qBAAuB,GAC3C,EAAW,QAAQ,CAAG,uBAAyB,GAC/C,EAAW,OAAO,CAAG,sBAAwB,GAC7C,EAAW,SAAS,CAAG,wBAA0B,GACjD,EAAW,WAAW,CAAG,0BAA4B,GACrD,EAAW,YAAY,CAAG,oBAAsB,GAEhD,EAAW,KAAK,CAAG,gBAAkB,GACrC,EAAW,QAAQ,CAAG,0BAA4B,GAClD,EAAW,UAAU,CAAG,sBAAwB,GAChD,EAAW,WAAW,CAAG,uBAAyB,GAClD,EAAW,SAAS,CAAG,qBAAuB,GAE9C,EAAW,gBAAgB,CAAG,wBAA0B,GACxD,EAAW,gBAAgB,CAAG,WAAa,EAAsB,GACjE,EAAW,cAAc,CAAG,0BAA4B,GACxD,EAAW,gBAAgB,CAAG,4BAA8B,GAE5D,2BACA,+BACA,GAEA,CAAC,IAAI,CAAC,MAEyD,GAC5D,EAAiB,GAAW,SAAU,EAAgB,GA6C1D,IAAM,KA3CN,EAAI,YAAY,CAAE,EAAS,GAC3B,EAAI,YAAY,CAAE,EAAS,GAE3B,EAAI,WAAW,CAAE,GAEX,EAAI,mBAAmB,CAAE,EAAS,EAAI,WAAW,GAEtD,QAAQ,KAAK,CAAE,iDAAwD,EAAI,mBAAmB,CAAE,EAAS,EAAI,eAAe,EAAK,eAAiB,EAAI,QAAQ,GAAK,KAMpK,EAAI,YAAY,CAAE,GAClB,EAAI,YAAY,CAAE,GAKlB,EAAQ,QAAQ,CAAG,CAAC,EACpB,EAAQ,UAAU,CAAG,CAAC,EAMtB,EAAc,CAEb,aAAc,kBAAmB,mBAAoB,eAAgB,cAAe,iBACpF,wBAEA,CAEI,EAAW,gBAAgB,CAE/B,EAAY,IAAI,CAAE,eAIlB,EAAY,IAAI,CAAE,sBAIR,EAEV,EAAY,IAAI,CAAE,GAenB,IAXA,AA2CD,SAAiC,CAAO,CAAE,CAAW,EAEpD,IAAI,EAAG,EAAG,EAEV,IAAK,EAAI,EAAG,EAAI,EAAY,MAAM,CAAE,EAAI,EAAG,IAE1C,EAAK,CAAW,CAAE,EAAG,CACrB,EAAQ,QAAQ,CAAE,EAAI,CAAG,EAAI,kBAAkB,CAAE,EAAS,EAI5D,EAtDwB,EAAS,GAIhC,EAAc,CAEb,WAAY,SAAU,KAAM,MAAO,UAAW,QAC9C,YAAa,aAAc,eAE3B,CAEK,EAAI,EAAG,EAAI,EAAW,eAAe,CAAE,IAE5C,EAAY,IAAI,CAAE,cAAgB,GAInC,IAAM,EAAI,EAAG,EAAI,EAAW,eAAe,CAAE,IAE5C,EAAY,IAAI,CAAE,cAAgB,GAInC,IAAM,KAAK,EAEV,EAAY,IAAI,CAAE,GAYnB,OARA,AA2BD,SAAmC,CAAO,CAAE,CAAW,EAEtD,IAAI,EAAG,EAAG,EAEV,IAAK,EAAI,EAAG,EAAI,EAAY,MAAM,CAAE,EAAI,EAAG,IAE1C,EAAK,CAAW,CAAE,EAAG,CACrB,EAAQ,UAAU,CAAE,EAAI,CAAG,EAAI,iBAAiB,CAAE,EAAS,EAI7D,EAtC0B,EAAS,GAElC,EAAQ,EAAE,CAAG,IAEb,EAAU,IAAI,CAAE,CAAE,QAAS,EAAS,KAAM,EAAM,UAAW,CAAE,GAE7D,EAAM,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAG,EAAU,MAAM,CAEtC,CAER,EAlhDkC,EAAU,EAAS,cAAc,CAAE,EAAS,YAAY,CAAE,EAAS,QAAQ,CAAE,EAAS,UAAU,CAAE,EAAS,OAAO,CAAE,GAErJ,IAAI,EAAa,EAAS,OAAO,CAAC,UAAU,CAE5C,GAAK,EAAS,YAAY,CAAG,CAE5B,EAAS,wBAAwB,CAAG,EAEpC,IA8CqC,EAzJlC,EAAmB,EAAG,EAAY,EAAe,EAAU,EAAY,EA2GlE,EAAO,cAEf,IAAM,EAAI,EAAG,EAAI,IAAI,CAAC,eAAe,CAAE,IAIjC,CAAU,CAFV,EAAO,EAES,EAAI,GAExB,EAAS,wBAAwB,EAMpC,CAEA,GAAK,EAAS,YAAY,CAAG,CAE5B,EAAS,wBAAwB,CAAG,EAEpC,IAAQ,EAAO,cAEf,IAAM,EAAI,EAAG,EAAI,IAAI,CAAC,eAAe,CAAE,IAIjC,CAAU,CAFV,EAAO,EAES,EAAI,GAExB,EAAS,wBAAwB,EAMpC,CAIA,IAAM,KAFN,EAAS,YAAY,CAAG,EAAE,CAEf,EAAS,QAAQ,CAE3B,EAAS,YAAY,CAAC,IAAI,CAAE,CAAE,EAAS,QAAQ,CAAE,EAAG,CAAE,EAAG,CAI3D,EA86BA,IAAI,CAAC,cAAc,CAAG,SAAW,CAAQ,CAAE,CAAkB,EAEvD,IAAa,GAAM,YAAY,CAEnC,EAAI,OAAO,CAAE,EAAI,SAAS,GAIrB,IAAuB,GAAM,oBAAoB,CAErD,EAAI,SAAS,CAAE,EAAI,EAAE,EAIrB,EAAI,SAAS,CAAE,EAAI,GAAG,EAIlB,IAAa,GAAM,YAAY,CAEnC,EAAI,QAAQ,CAAE,EAAI,IAAI,EAEX,IAAa,GAAM,aAAa,CAE3C,EAAI,QAAQ,CAAE,EAAI,KAAK,EAIvB,EAAI,QAAQ,CAAE,EAAI,cAAc,EAIjC,EAAI,MAAM,CAAE,EAAI,SAAS,EAI3B,EAEA,IAAI,CAAC,gBAAgB,CAAG,SAAW,CAAQ,EAE1C,IAAI,EAAc,EAAS,IAAI,GAAK,GAAM,UAAU,CAChD,EAAY,EAAS,IAAI,GAAK,GAAM,QAAQ,CAE3C,IAAoB,IAEnB,EAEJ,EAAI,OAAO,CAAE,EAAI,SAAS,EAI1B,EAAI,MAAM,CAAE,EAAI,SAAS,EAI1B,EAAkB,GAId,IAAkB,IAEjB,EAEJ,EAAI,SAAS,CAAE,EAAI,EAAE,EAIrB,EAAI,SAAS,CAAE,EAAI,GAAG,EAIvB,EAAgB,EAIlB,EAEA,IAAI,CAAC,YAAY,CAAG,SAAW,CAAS,EAElC,IAAkB,IAEjB,EAEJ,EAAI,MAAM,CAAE,EAAI,UAAU,EAI1B,EAAI,OAAO,CAAE,EAAI,UAAU,EAI5B,EAAgB,EAIlB,EAEA,IAAI,CAAC,aAAa,CAAG,SAAW,CAAU,EAEpC,IAAmB,IAEvB,EAAI,SAAS,CAAE,GACf,EAAiB,EAInB,EA2CA,IAAI,CAAC,WAAW,CAAG,SAAW,CAAQ,CAAE,CAAa,CAAE,CAAQ,CAAE,CAAQ,EAEnE,IAAa,IAEZ,IAAa,GAAM,UAAU,CAEjC,EAAI,OAAO,CAAE,EAAI,KAAK,EAEX,IAAa,GAAM,gBAAgB,EAE9C,EAAI,MAAM,CAAE,EAAI,KAAK,EACrB,EAAI,aAAa,CAAE,EAAI,QAAQ,EAC/B,EAAI,SAAS,CAAE,EAAI,SAAS,CAAE,EAAI,GAAG,GAE1B,IAAa,GAAM,mBAAmB,EAGjD,EAAI,MAAM,CAAE,EAAI,KAAK,EACrB,EAAI,aAAa,CAAE,EAAI,QAAQ,EAC/B,EAAI,SAAS,CAAE,EAAI,IAAI,CAAE,EAAI,mBAAmB,GAErC,IAAa,GAAM,gBAAgB,EAG9C,EAAI,MAAM,CAAE,EAAI,KAAK,EACrB,EAAI,aAAa,CAAE,EAAI,QAAQ,EAC/B,EAAI,SAAS,CAAE,EAAI,IAAI,CAAE,EAAI,SAAS,GAE3B,IAAa,GAAM,cAAc,CAE5C,EAAI,MAAM,CAAE,EAAI,KAAK,GAIrB,EAAI,MAAM,CAAE,EAAI,KAAK,EACrB,EAAI,qBAAqB,CAAE,EAAI,QAAQ,CAAE,EAAI,QAAQ,EACrD,EAAI,iBAAiB,CAAE,EAAI,SAAS,CAAE,EAAI,mBAAmB,CAAE,EAAI,GAAG,CAAE,EAAI,mBAAmB,GAIhG,EAAe,GAIX,IAAa,GAAM,cAAc,EAEhC,IAAkB,IAEtB,EAAI,aAAa,CAAE,GAAgB,IAEnC,EAAoB,GAIhB,CAAA,IAAa,GAAgB,IAAa,CAAA,IAE9C,EAAI,SAAS,CAAE,GAAgB,GAAY,GAAgB,IAE3D,EAAe,EACf,EAAe,KAMhB,EAAoB,KACpB,EAAe,KACf,EAAe,KAIjB,EA0cA,IAAI,CAAC,UAAU,CAAG,SAAW,CAAO,CAAE,CAAI,EAEzC,GAAK,EAAQ,WAAW,CAAG,CAErB,CAAE,EAAQ,WAAW,GAEzB,EAAQ,WAAW,CAAG,CAAA,EAEtB,EAAQ,gBAAgB,CAAE,UAAW,IAErC,EAAQ,cAAc,CAAG,EAAI,aAAa,GAE1C,EAAM,IAAI,CAAC,MAAM,CAAC,QAAQ,IAI3B,EAAI,aAAa,CAAE,EAAI,QAAQ,CAAG,GAClC,EAAI,WAAW,CAAE,EAAI,UAAU,CAAE,EAAQ,cAAc,EAEvD,EAAI,WAAW,CAAE,EAAI,mBAAmB,CAAE,EAAQ,KAAK,EACvD,EAAI,WAAW,CAAE,EAAI,8BAA8B,CAAE,EAAQ,gBAAgB,EAC7E,EAAI,WAAW,CAAE,EAAI,gBAAgB,CAAE,EAAQ,eAAe,EAE9D,IAAI,EAAQ,EAAQ,KAAK,CACzB,EAAoB,GAAc,EAAM,KAAK,GAAM,GAAc,EAAM,MAAM,EAC7E,EAAW,GAAgB,EAAQ,MAAM,EACzC,EAAS,GAAgB,EAAQ,IAAI,EAErC,GAAsB,EAAI,UAAU,CAAE,EAAS,GAE/C,IAAI,EAAQ,EAAU,EAAQ,OAAO,CAErC,GAAK,aAAmB,GAAM,WAAW,EAMxC,GAAK,EAAQ,MAAM,CAAG,GAAK,EAAoB,CAE9C,IAAM,IAAI,EAAI,EAAG,EAAK,EAAQ,MAAM,CAAE,EAAI,EAAI,IAE7C,EAAS,CAAO,CAAE,EAAG,CACrB,EAAI,UAAU,CAAE,EAAI,UAAU,CAAE,EAAG,EAAU,EAAO,KAAK,CAAE,EAAO,MAAM,CAAE,EAAG,EAAU,EAAQ,EAAO,IAAI,CAI3G,CAAA,EAAQ,eAAe,CAAG,CAAA,CAE3B,MAEC,EAAI,UAAU,CAAE,EAAI,UAAU,CAAE,EAAG,EAAU,EAAM,KAAK,CAAE,EAAM,MAAM,CAAE,EAAG,EAAU,EAAQ,EAAM,IAAI,OAIlG,GAAK,aAAmB,GAAM,iBAAiB,CAKrD,IAAK,IAAI,EAAI,EAAG,EAAK,EAAQ,MAAM,CAAE,EAAI,EAAI,IAE5C,EAAS,CAAO,CAAE,EAAG,CACrB,EAAI,oBAAoB,CAAE,EAAI,UAAU,CAAE,EAAG,EAAU,EAAO,KAAK,CAAE,EAAO,MAAM,CAAE,EAAG,EAAO,IAAI,OAUnG,GAAK,EAAQ,MAAM,CAAG,GAAK,EAAoB,CAE9C,IAAM,IAAI,EAAI,EAAG,EAAK,EAAQ,MAAM,CAAE,EAAI,EAAI,IAE7C,EAAS,CAAO,CAAE,EAAG,CACrB,EAAI,UAAU,CAAE,EAAI,UAAU,CAAE,EAAG,EAAU,EAAU,EAAQ,EAIhE,CAAA,EAAQ,eAAe,CAAG,CAAA,CAE3B,MAEC,EAAI,UAAU,CAAE,EAAI,UAAU,CAAE,EAAG,EAAU,EAAU,EAAQ,EAAQ,KAAK,CAMzE,CAAA,EAAQ,eAAe,EAAI,GAAoB,EAAI,cAAc,CAAE,EAAI,UAAU,EAEtF,EAAQ,WAAW,CAAG,CAAA,EAEjB,EAAQ,QAAQ,EAAG,EAAQ,QAAQ,EAEzC,MAEC,EAAI,aAAa,CAAE,EAAI,QAAQ,CAAG,GAClC,EAAI,WAAW,CAAE,EAAI,UAAU,CAAE,EAAQ,cAAc,CAIzD,EA8JA,IAAI,CAAC,eAAe,CAAG,SAAW,CAAY,EAE7C,IAqGI,EAAa,EAAO,EAAQ,EAAI,EArGhC,EAAW,aAAwB,GAAM,qBAAqB,CAElE,GAAK,GAAgB,CAAE,EAAa,kBAAkB,CAAG,CAEtB,KAAA,IAA7B,EAAa,WAAW,EAAiB,CAAA,EAAa,WAAW,CAAG,CAAA,CAAzE,EACoC,KAAA,IAA/B,EAAa,aAAa,EAAiB,CAAA,EAAa,aAAa,CAAG,CAAA,CAA7E,EAEA,EAAa,gBAAgB,CAAE,UAAW,IAE1C,EAAa,cAAc,CAAG,EAAI,aAAa,GAE/C,EAAM,IAAI,CAAC,MAAM,CAAC,QAAQ,GAI1B,IAAI,EAAqB,GAAc,EAAa,KAAK,GAAM,GAAc,EAAa,MAAM,EAC/F,EAAW,GAAgB,EAAa,MAAM,EAC9C,EAAS,GAAgB,EAAa,IAAI,EAE3C,GAAK,EAAS,CAEb,EAAa,kBAAkB,CAAG,EAAE,CACpC,EAAa,mBAAmB,CAAG,EAAE,CAErC,EAAI,WAAW,CAAE,EAAI,gBAAgB,CAAE,EAAa,cAAc,EAClE,GAAsB,EAAI,gBAAgB,CAAE,EAAc,GAE1D,IAAM,IAAI,EAAI,EAAG,EAAI,EAAG,IAEvB,EAAa,kBAAkB,CAAE,EAAG,CAAG,EAAI,iBAAiB,GAC5D,EAAa,mBAAmB,CAAE,EAAG,CAAG,EAAI,kBAAkB,GAE9D,EAAI,UAAU,CAAE,EAAI,2BAA2B,CAAG,EAAG,EAAG,EAAU,EAAa,KAAK,CAAE,EAAa,MAAM,CAAE,EAAG,EAAU,EAAQ,MAEhI,GAAkB,EAAa,kBAAkB,CAAE,EAAG,CAAE,EAAc,EAAI,2BAA2B,CAAG,GACxG,GAAmB,EAAa,mBAAmB,CAAE,EAAG,CAAE,GAItD,GAAqB,EAAI,cAAc,CAAE,EAAI,gBAAgB,CAEnE,MAEC,EAAa,kBAAkB,CAAG,EAAI,iBAAiB,GAElD,EAAa,cAAc,CAE/B,EAAa,mBAAmB,CAAG,EAAa,cAAc,CAAC,mBAAmB,CAIlF,EAAa,mBAAmB,CAAG,EAAI,kBAAkB,GAI1D,EAAI,WAAW,CAAE,EAAI,UAAU,CAAE,EAAa,cAAc,EAC5D,GAAsB,EAAI,UAAU,CAAE,EAAc,GAEpD,EAAI,UAAU,CAAE,EAAI,UAAU,CAAE,EAAG,EAAU,EAAa,KAAK,CAAE,EAAa,MAAM,CAAE,EAAG,EAAU,EAAQ,MAE3G,GAAkB,EAAa,kBAAkB,CAAE,EAAc,EAAI,UAAU,EAE1E,EAAa,cAAc,CAE1B,EAAa,WAAW,EAAI,CAAE,EAAa,aAAa,CAE5D,EAAI,uBAAuB,CAAE,EAAI,WAAW,CAAE,EAAI,gBAAgB,CAAE,EAAI,YAAY,CAAE,EAAa,mBAAmB,EAE3G,EAAa,WAAW,EAAI,EAAa,aAAa,EAEjE,EAAI,uBAAuB,CAAE,EAAI,WAAW,CAAE,EAAI,wBAAwB,CAAE,EAAI,YAAY,CAAE,EAAa,mBAAmB,EAM/H,GAAmB,EAAa,mBAAmB,CAAE,GAIjD,GAAqB,EAAI,cAAc,CAAE,EAAI,UAAU,EAMxD,EAEJ,EAAI,WAAW,CAAE,EAAI,gBAAgB,CAAE,MAIvC,EAAI,WAAW,CAAE,EAAI,UAAU,CAAE,MAIlC,EAAI,gBAAgB,CAAE,EAAI,YAAY,CAAE,MACxC,EAAI,eAAe,CAAE,EAAI,WAAW,CAAE,KAEvC,CAIK,GAIH,EAFI,EAEU,EAAa,kBAAkB,CAAE,EAAa,cAAc,CAAE,CAI9D,EAAa,kBAAkB,CAI9C,EAAQ,EAAa,KAAK,CAC1B,EAAS,EAAa,MAAM,CAE5B,EAAK,EACL,EAAK,IAIL,EAAc,KAEd,EAAQ,EACR,EAAS,EAET,EAAK,EACL,EAAK,GAID,IAAgB,IAEpB,EAAI,eAAe,CAAE,EAAI,WAAW,CAAE,GACtC,EAAI,QAAQ,CAAE,EAAI,EAAI,EAAO,GAE7B,EAAsB,GAIvB,EAAgB,EAChB,EAAiB,CAElB,EAiRA,IAAI,CAAC,eAAe,CAAG,IAAI,GAAM,eAAe,CAChD,IAAI,CAAC,YAAY,CAAE,IAAI,CAAC,eAAe,EAEvC,IAAI,CAAC,aAAa,CAAE,IAAI,GAAM,YAAY,EAC1C,IAAI,CAAC,aAAa,CAAE,IAAI,GAAM,eAAe,CAE9C,EAMA,GAAM,iBAAiB,CAAG,SAAW,CAAK,CAAE,CAAM,CAAE,CAAO,EAE1D,GAAM,eAAe,CAAC,IAAI,CAAE,IAAI,EAEhC,IAAI,CAAC,KAAK,CAAG,EACb,IAAI,CAAC,MAAM,CAAG,EAEd,EAAU,GAAW,CAAC,EAEtB,IAAI,CAAC,KAAK,CAAG,AAAkB,KAAA,IAAlB,EAAQ,KAAK,CAAiB,EAAQ,KAAK,CAAG,GAAM,mBAAmB,CACpF,IAAI,CAAC,KAAK,CAAG,AAAkB,KAAA,IAAlB,EAAQ,KAAK,CAAiB,EAAQ,KAAK,CAAG,GAAM,mBAAmB,CAEpF,IAAI,CAAC,SAAS,CAAG,AAAsB,KAAA,IAAtB,EAAQ,SAAS,CAAiB,EAAQ,SAAS,CAAG,GAAM,YAAY,CACzF,IAAI,CAAC,SAAS,CAAG,AAAsB,KAAA,IAAtB,EAAQ,SAAS,CAAiB,EAAQ,SAAS,CAAG,GAAM,wBAAwB,CAErG,IAAI,CAAC,UAAU,CAAG,AAAuB,KAAA,IAAvB,EAAQ,UAAU,CAAiB,EAAQ,UAAU,CAAG,EAE1E,IAAI,CAAC,MAAM,CAAG,IAAI,GAAM,OAAO,CAAE,EAAG,GACpC,IAAI,CAAC,MAAM,CAAG,IAAI,GAAM,OAAO,CAAE,EAAG,GAEpC,IAAI,CAAC,MAAM,CAAG,AAAmB,KAAA,IAAnB,EAAQ,MAAM,CAAiB,EAAQ,MAAM,CAAG,GAAM,UAAU,CAC9E,IAAI,CAAC,IAAI,CAAG,AAAiB,KAAA,IAAjB,EAAQ,IAAI,CAAiB,EAAQ,IAAI,CAAG,GAAM,gBAAgB,CAE9E,IAAI,CAAC,WAAW,CAAG,AAAwB,KAAA,IAAxB,EAAQ,WAAW,EAAiB,EAAQ,WAAW,CAC1E,IAAI,CAAC,aAAa,CAAG,AAA0B,KAAA,IAA1B,EAAQ,aAAa,EAAiB,EAAQ,aAAa,CAEhF,IAAI,CAAC,eAAe,CAAG,CAAA,EAEvB,IAAI,CAAC,cAAc,CAAG,IAEvB,EAEA,GAAM,iBAAiB,CAAC,SAAS,CAAC,KAAK,CAAG,WAEzC,IAAI,EAAM,IAAI,GAAM,iBAAiB,CAAE,IAAI,CAAC,KAAK,CAAE,IAAI,CAAC,MAAM,EAuB9D,OArBA,EAAI,KAAK,CAAG,IAAI,CAAC,KAAK,CACtB,EAAI,KAAK,CAAG,IAAI,CAAC,KAAK,CAEtB,EAAI,SAAS,CAAG,IAAI,CAAC,SAAS,CAC9B,EAAI,SAAS,CAAG,IAAI,CAAC,SAAS,CAE9B,EAAI,UAAU,CAAG,IAAI,CAAC,UAAU,CAEhC,EAAI,MAAM,CAAC,IAAI,CAAE,IAAI,CAAC,MAAM,EAC5B,EAAI,MAAM,CAAC,IAAI,CAAE,IAAI,CAAC,MAAM,EAE5B,EAAI,MAAM,CAAG,IAAI,CAAC,MAAM,CACxB,EAAI,IAAI,CAAG,IAAI,CAAC,IAAI,CAEpB,EAAI,WAAW,CAAG,IAAI,CAAC,WAAW,CAClC,EAAI,aAAa,CAAG,IAAI,CAAC,aAAa,CAEtC,EAAI,eAAe,CAAG,IAAI,CAAC,eAAe,CAE1C,EAAI,cAAc,CAAG,IAAI,CAAC,cAAc,CAEjC,CAER,EAEA,GAAM,iBAAiB,CAAC,SAAS,CAAC,OAAO,CAAG,WAE3C,IAAI,CAAC,aAAa,CAAE,CAAE,KAAM,SAAU,EAEvC,EAKA,GAAM,qBAAqB,CAAG,SAAW,CAAK,CAAE,CAAM,CAAE,CAAO,EAE9D,GAAM,iBAAiB,CAAC,IAAI,CAAE,IAAI,CAAE,EAAO,EAAQ,GAEnD,IAAI,CAAC,cAAc,CAAG,CAEvB,EAEA,GAAM,qBAAqB,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,iBAAiB,CAAC,SAAS,EAKxF,GAAM,gBAAgB,CAAG,WAExB,IAAI,CAAC,aAAa,CAAG,IAAI,GAAM,OAAO,CACtC,IAAI,CAAC,cAAc,CAAG,IAAI,GAAM,OAAO,CAEvC,IAAI,CAAC,OAAO,CAAG,CAAA,CAEhB,EAEA,GAAM,gBAAgB,CAAC,SAAS,CAAC,IAAI,CAAG,SAAW,CAAM,EAExD,IAAI,CAAC,aAAa,CAAC,IAAI,CAAE,EAAO,aAAa,EAC7C,IAAI,CAAC,cAAc,CAAC,IAAI,CAAE,EAAO,cAAc,CAEhD,EAKA,GAAM,eAAe,CAAG,WAEvB,IAAI,CAAC,EAAE,CAAG,IAAI,GAAM,gBAAgB,CACpC,IAAI,CAAC,EAAE,CAAG,IAAI,GAAM,gBAAgB,CACpC,IAAI,CAAC,EAAE,CAAG,IAAI,GAAM,gBAAgB,CAEpC,IAAI,CAAC,aAAa,CAAG,IAAI,GAAM,OAAO,CAEtC,IAAI,CAAC,WAAW,CAAG,IAAI,GAAM,OAAO,CACpC,IAAI,CAAC,eAAe,CAAG,IAAI,GAAM,OAAO,CAExC,IAAI,CAAC,mBAAmB,CAAG,EAC3B,IAAI,CAAC,kBAAkB,CAAG,CAAE,IAAI,GAAM,OAAO,CAAI,IAAI,GAAM,OAAO,CAAI,IAAI,GAAM,OAAO,CAAI,CAC3F,IAAI,CAAC,sBAAsB,CAAG,CAAE,IAAI,GAAM,OAAO,CAAI,IAAI,GAAM,OAAO,CAAI,IAAI,GAAM,OAAO,CAAI,CAE/F,IAAI,CAAC,KAAK,CAAG,KACb,IAAI,CAAC,QAAQ,CAAG,KAChB,IAAI,CAAC,GAAG,CAAG,CAAC,EAAE,CAAC,CAEf,IAAI,CAAC,CAAC,CAAG,IAEV,EAKA,GAAM,eAAe,CAAG,WAEvB,IAAI,CAAC,EAAE,CAAG,IAAI,GAAM,gBAAgB,CACpC,IAAI,CAAC,EAAE,CAAG,IAAI,GAAM,gBAAgB,CACpC,IAAI,CAAC,EAAE,CAAG,IAAI,GAAM,gBAAgB,CACpC,IAAI,CAAC,EAAE,CAAG,IAAI,GAAM,gBAAgB,CAEpC,IAAI,CAAC,aAAa,CAAG,IAAI,GAAM,OAAO,CAEtC,IAAI,CAAC,WAAW,CAAG,IAAI,GAAM,OAAO,CACpC,IAAI,CAAC,eAAe,CAAG,IAAI,GAAM,OAAO,CAExC,IAAI,CAAC,mBAAmB,CAAG,EAC3B,IAAI,CAAC,kBAAkB,CAAG,CAAE,IAAI,GAAM,OAAO,CAAI,IAAI,GAAM,OAAO,CAAI,IAAI,GAAM,OAAO,CAAI,IAAI,GAAM,OAAO,CAAI,CAChH,IAAI,CAAC,sBAAsB,CAAG,CAAE,IAAI,GAAM,OAAO,CAAI,IAAI,GAAM,OAAO,CAAI,IAAI,GAAM,OAAO,CAAI,IAAI,GAAM,OAAO,CAAI,CAEpH,IAAI,CAAC,KAAK,CAAG,KACb,IAAI,CAAC,QAAQ,CAAG,KAChB,IAAI,CAAC,GAAG,CAAG,CAAC,EAAE,CAAC,CAEf,IAAI,CAAC,CAAC,CAAG,IAEV,EAKA,GAAM,gBAAgB,CAAG,WAExB,IAAI,CAAC,MAAM,CAAG,KACd,IAAI,CAAC,CAAC,CAAG,IAEV,EAKA,GAAM,kBAAkB,CAAG,WAE1B,IAAI,CAAC,MAAM,CAAG,KAEd,IAAI,CAAC,CAAC,CAAG,KACT,IAAI,CAAC,CAAC,CAAG,KACT,IAAI,CAAC,CAAC,CAAG,KAET,IAAI,CAAC,QAAQ,CAAG,KAChB,IAAI,CAAC,KAAK,CAAG,IAAI,GAAM,OAAO,CAE9B,IAAI,CAAC,QAAQ,CAAG,IAEjB,EAKA,GAAM,cAAc,CAAG,WAEtB,IAAI,CAAC,CAAC,CAAG,KAET,IAAI,CAAC,EAAE,CAAG,IAAI,GAAM,gBAAgB,CACpC,IAAI,CAAC,EAAE,CAAG,IAAI,GAAM,gBAAgB,CAEpC,IAAI,CAAC,QAAQ,CAAG,IAEjB,EAMA,GAAM,aAAa,CAAG,CAIrB,MAAO,SAAW,CAAS,CAAE,CAAA,EAE5B,IAAI,EAAQ,EACZ,EAAe,EAAU,QAAQ,CAAC,MAAM,CAExC,GADa,EAAU,aAAa,CAAE,EAAG,CAAC,MAAM,CACpC,aAAmB,GAAM,IAAI,CAAG,EAAQ,QAAQ,CAAG,GAC/D,EAAY,EAAU,QAAQ,CAC9B,EAAY,EAAU,QAAQ,CAC9B,EAAS,EAAU,KAAK,CACxB,EAAS,EAAU,KAAK,CACxB,EAAO,EAAU,aAAa,CAAE,EAAG,CACnC,EAAO,EAAU,aAAa,CAAE,EAAG,CAE9B,aAAmB,GAAM,IAAI,GAEjC,EAAQ,gBAAgB,EAAI,EAAQ,YAAY,GAEhD,EAAS,EAAQ,MAAM,CAGvB,AADA,CAAA,EAAe,IAAI,GAAM,OAAO,AAAhC,EACa,UAAU,CAAE,GACzB,EAAa,SAAS,IAMvB,IAAM,IAAI,EAAI,EAAG,EAAK,EAAU,MAAM,CAAE,EAAI,EAAI,IAAO,CAItD,IAAI,EAAa,AAFJ,CAAS,CAAE,EAAG,CAEH,KAAK,GAExB,GAAS,EAAW,YAAY,CAAE,GAEvC,EAAU,IAAI,CAAE,EAEjB,CAIA,IAAM,EAAI,EAAG,EAAK,EAAO,MAAM,CAAE,EAAI,EAAI,IAAO,CAE/C,IAAwB,EAAU,EAAQ,EAAtC,EAAO,CAAM,CAAE,EAAG,CACtB,EAAoB,EAAK,aAAa,CACtC,EAAmB,EAAK,YAAY,AAE/B,CAAA,aAAgB,GAAM,KAAK,CAE/B,EAAW,IAAI,GAAM,KAAK,CAAE,EAAK,CAAC,CAAG,EAAc,EAAK,CAAC,CAAG,EAAc,EAAK,CAAC,CAAG,GAExE,aAAgB,GAAM,KAAK,EAEtC,CAAA,EAAW,IAAI,GAAM,KAAK,CAAE,EAAK,CAAC,CAAG,EAAc,EAAK,CAAC,CAAG,EAAc,EAAK,CAAC,CAAG,EAAc,EAAK,CAAC,CAAG,EAFpG,EAMP,EAAS,MAAM,CAAC,IAAI,CAAE,EAAK,MAAM,EAE5B,GAEJ,EAAS,MAAM,CAAC,YAAY,CAAE,GAAe,SAAS,GAIvD,IAAM,IAAI,EAAI,EAAG,EAAK,EAAkB,MAAM,CAAE,EAAI,EAAI,IAEvD,EAAS,CAAiB,CAAE,EAAG,CAAC,KAAK,GAEhC,GAEJ,EAAO,YAAY,CAAE,GAAe,SAAS,GAI9C,EAAS,aAAa,CAAC,IAAI,CAAE,GAI9B,EAAS,KAAK,CAAC,IAAI,CAAE,EAAK,KAAK,EAE/B,IAAM,IAAI,EAAI,EAAG,EAAK,EAAiB,MAAM,CAAE,EAAI,EAAI,IAEtD,EAAQ,CAAgB,CAAE,EAAG,CAC7B,EAAS,YAAY,CAAC,IAAI,CAAE,EAAM,KAAK,GAIxC,CAAA,EAAS,aAAa,CAAG,EAAK,aAAa,CAE3C,EAAS,QAAQ,CAAC,IAAI,CAAE,EAAK,QAAQ,EAEhC,GAEJ,EAAS,QAAQ,CAAC,YAAY,CAAE,GAIjC,EAAO,IAAI,CAAE,EAEd,CAIA,IAAM,EAAI,EAAG,EAAK,EAAK,MAAM,CAAE,EAAI,EAAI,IAAO,CAI7C,IAAM,IAFF,EAAK,CAAI,CAAE,EAAG,CAAE,EAAS,EAAE,CAErB,EAAI,EAAG,EAAK,EAAG,MAAM,CAAE,EAAI,EAAI,IAExC,EAAO,IAAI,CAAE,IAAI,GAAM,OAAO,CAAE,CAAE,CAAE,EAAG,CAAC,CAAC,CAAE,CAAE,CAAE,EAAG,CAAC,CAAC,GAIrD,EAAK,IAAI,CAAE,EAEZ,CAED,EAEA,gBAAiB,SAAW,CAAQ,CAAE,CAAkB,EAIvD,IAAM,IAFF,EAAmB,CAAC,EAEd,EAAI,EAAG,EAAK,EAAmB,MAAM,CAAE,EAAI,EAAI,IAExD,CAAgB,CAAE,CAAkB,CAAC,EAAE,CAAE,CAAG,CAAA,EAM7C,IAAM,IAFF,EAAM,EAAW,EAAE,CAEb,EAAI,EAAG,EAAK,EAAS,KAAK,CAAC,MAAM,CAAE,EAAI,EAAI,IAG3C,AADT,CAAA,EAAO,EAAS,KAAK,CAAE,EAAG,AAAH,EACT,aAAa,IAAI,GAAqB,EAAS,IAAI,CAAE,EAIpE,CAAA,EAAS,KAAK,CAAG,CAElB,EAMA,sBAAuB,SAAW,CAAO,CAAE,CAAO,CAAE,CAAO,EAE1D,IAAI,EAAG,EAAG,EACT,EAAQ,IAAI,GAAM,OAAO,CACzB,EAAM,GAAM,aAAa,CAAC,IAAI,CA2B/B,MAzBA,CAAA,EAAI,GAAM,aAAa,CAAC,MAAM,EAA9B,EACA,CAAA,EAAI,GAAM,aAAa,CAAC,MAAM,EAA9B,EAEiB,IAEhB,EAAI,EAAI,EACR,EAAI,EAAI,GAIT,EAAI,EAAI,EAAI,EAEZ,EAAM,IAAI,CAAE,GACZ,EAAM,cAAc,CAAE,GAEtB,EAAI,IAAI,CAAE,GACV,EAAI,cAAc,CAAE,GAEpB,EAAM,GAAG,CAAE,GAEX,EAAI,IAAI,CAAE,GACV,EAAI,cAAc,CAAE,GAEpB,EAAM,GAAG,CAAE,GAEJ,CAER,EAKA,kBAAmB,SAAW,CAAI,CAAE,CAAQ,CAAE,CAAc,MAEvD,EAAI,EAAI,EAAI,EAiBX,EAAO,SAfZ,AAAK,aAAgB,GAAM,KAAK,EAE/B,EAAK,EAAS,QAAQ,CAAE,EAAK,CAAC,CAAE,CAChC,EAAK,EAAS,QAAQ,CAAE,EAAK,CAAC,CAAE,CAChC,EAAK,EAAS,QAAQ,CAAE,EAAK,CAAC,CAAE,CAEzB,GAAM,aAAa,CAAC,qBAAqB,CAAE,EAAI,EAAI,IAE/C,aAAgB,GAAM,KAAK,CAmCtC,CAjCA,EAAK,EAAS,QAAQ,CAAE,EAAK,CAAC,CAAE,CAChC,EAAK,EAAS,QAAQ,CAAE,EAAK,CAAC,CAAE,CAChC,EAAK,EAAS,QAAQ,CAAE,EAAK,CAAC,CAAE,CAChC,EAAK,EAAS,QAAQ,CAAE,EAAK,CAAC,CAAE,CAI3B,EAEC,EAAK,MAAM,EAAI,EAAK,MAAM,EAE9B,EAAQ,EAAK,MAAM,CACnB,EAAQ,EAAK,MAAM,GAInB,EAAQ,GAAM,aAAa,CAAC,YAAY,CAAE,EAAI,EAAI,GAClD,EAAQ,GAAM,aAAa,CAAC,YAAY,CAAE,EAAI,EAAI,GAElD,EAAK,MAAM,CAAG,EACd,EAAK,MAAM,CAAG,GAMf,CAAA,EAAQ,GAAM,aAAa,CAAC,YAAY,CAAE,EAAI,EAAI,GAClD,EAAQ,GAAM,aAAa,CAAC,YAAY,CAAE,EAAI,EAAI,EADlD,EAOI,AAFG,GAAM,aAAa,CAAC,MAAM,GAAO,CAAA,EAAQ,CAAA,EAExC,GAED,GAAM,aAAa,CAAC,qBAAqB,CAAE,EAAI,EAAI,GAInD,GAAM,aAAa,CAAC,qBAAqB,CAAE,EAAI,EAAI,SAM7D,EAQA,uBAAwB,SAAW,CAAQ,CAAE,CAAC,EAE7C,IAAI,EAAM,EAMT,EAAI,EAAI,EAAI,EALZ,EAAQ,EAAS,KAAK,CACtB,EAAW,EAAS,QAAQ,CAC5B,EAAK,EAAM,MAAM,CACjB,EAAY,EACZ,EAAkB,EAAE,CAKrB,IAAM,EAAI,EAAG,EAAI,EAAI,IAIf,AAFL,CAAA,EAAO,CAAK,CAAE,EAAG,AAAH,YAEO,GAAM,KAAK,EAE/B,EAAK,CAAQ,CAAE,EAAK,CAAC,CAAE,CACvB,EAAK,CAAQ,CAAE,EAAK,CAAC,CAAE,CACvB,EAAK,CAAQ,CAAE,EAAK,CAAC,CAAE,CAEvB,EAAK,KAAK,CAAG,GAAM,aAAa,CAAC,YAAY,CAAE,EAAI,EAAI,IAE5C,aAAgB,GAAM,KAAK,GAEtC,EAAK,CAAQ,CAAE,EAAK,CAAC,CAAE,CACvB,EAAK,CAAQ,CAAE,EAAK,CAAC,CAAE,CACvB,EAAK,CAAQ,CAAE,EAAK,CAAC,CAAE,CACvB,EAAK,CAAQ,CAAE,EAAK,CAAC,CAAE,CAEvB,EAAK,MAAM,CAAG,GAAM,aAAa,CAAC,YAAY,CAAE,EAAI,EAAI,GACxD,EAAK,MAAM,CAAG,GAAM,aAAa,CAAC,YAAY,CAAE,EAAI,EAAI,GAExD,EAAK,KAAK,CAAG,EAAK,MAAM,CAAG,EAAK,MAAM,EAIvC,GAAa,EAAK,KAAK,CAEvB,CAAe,CAAE,EAAG,CAAG,EAyCxB,IAAO,EACN,EAAS,EAAE,CAER,EAAQ,CAAC,EAEb,IAAM,EAAI,EAAG,EAAI,EAAG,IAInB,EAAQ,AA5CT,SAA8B,CAAK,EA6BlC,OADa,AA1Bb,SAAS,EAAc,CAAK,CAAE,CAAG,EAKhC,GAAK,EAAM,EACV,OAAO,EAER,IAAI,EAAM,EAAQ,KAAK,KAAK,CAAE,AAAE,CAAA,EAAM,CAAA,EAAU,UAEhD,AAAK,CAAe,CAAE,EAAK,CAAG,EAEtB,EAAc,EAAO,EAAM,GAEvB,CAAe,CAAE,EAAK,CAAG,EAE7B,EAAc,EAAM,EAAG,GAIvB,CAIT,EAE2B,EAAG,EAAgB,MAAM,CAAG,EAGxD,EAWK,GAAM,aAAa,CAAC,MAAM,GAAK,GAInC,CAAM,CAAE,EAAG,CAAG,GAAM,aAAa,CAAC,iBAAiB,CAAE,CAAK,CAAE,EAAO,CAAE,EAAU,CAAA,GAExE,CAAK,CAAE,EAAO,CAMpB,CAAK,CAAE,EAAO,EAAI,EAJlB,CAAK,CAAE,EAAO,CAAG,EAUnB,OAAO,CAER,EAKA,aAAc,SAAW,CAAO,CAAE,CAAO,CAAE,CAAO,EAEjD,IAAI,EAAO,GAAM,aAAa,CAAC,IAAI,CAClC,EAAO,GAAM,aAAa,CAAC,IAAI,CAMhC,OAJA,EAAK,UAAU,CAAE,EAAS,GAC1B,EAAK,UAAU,CAAE,EAAS,GAC1B,EAAK,KAAK,CAAE,GAEL,GAAM,EAAK,MAAM,EAEzB,EAIA,OAAQ,SAAW,CAAQ,EAE1B,EAAS,kBAAkB,GAE3B,IAAI,EAAK,EAAS,WAAW,CAEzB,EAAS,IAAI,GAAM,OAAO,CAQ9B,OANA,EAAO,UAAU,CAAE,EAAG,GAAG,CAAE,EAAG,GAAG,EACjC,EAAO,cAAc,CAAE,KAEvB,EAAS,WAAW,CAAE,IAAI,GAAM,OAAO,GAAG,eAAe,CAAE,EAAO,CAAC,CAAE,EAAO,CAAC,CAAE,EAAO,CAAC,GACvF,EAAS,kBAAkB,GAEpB,CAER,EAKA,aAAc,SAAW,CAAQ,EAIhC,IAAM,IAFF,EAAQ,EAAS,aAAa,CAAE,EAAG,CAE7B,EAAI,EAAG,EAAK,EAAM,MAAM,CAAE,EAAI,EAAI,IAI3C,IAAM,IAFF,EAAM,CAAK,CAAE,EAAG,CAEV,EAAI,EAAG,EAAK,EAAI,MAAM,CAAE,EAAI,EAAI,IAItB,IAAf,CAAG,CAAE,EAAG,CAAC,CAAC,EAAW,CAAA,CAAG,CAAE,EAAG,CAAC,CAAC,CAAG,CAAG,CAAE,EAAG,CAAC,CAAC,CAAG,KAAK,KAAK,CAAE,CAAG,CAAE,EAAG,CAAC,CAAC,CAAA,EACtD,IAAf,CAAG,CAAE,EAAG,CAAC,CAAC,EAAW,CAAA,CAAG,CAAE,EAAG,CAAC,CAAC,CAAG,CAAG,CAAE,EAAG,CAAC,CAAC,CAAG,KAAK,KAAK,CAAE,CAAG,CAAE,EAAG,CAAC,CAAC,CAAA,CAM5E,EAEA,iBAAkB,SAAW,CAAQ,EAIpC,IAFI,EAAG,EAAI,EAAG,EAEV,EAAQ,EAAE,CACV,EAAU,EAAE,CACZ,EAAgB,EAAE,CAEtB,IAAM,EAAI,EAAG,EAAK,EAAS,OAAO,CAAC,MAAM,CAAE,EAAI,EAAI,IAElD,CAAO,CAAE,EAAG,CAAG,EAAE,CAIlB,IAAM,EAAI,EAAG,EAAK,EAAS,aAAa,CAAC,MAAM,CAAE,EAAI,EAAI,IAExD,CAAa,CAAE,EAAG,CAAG,EAAE,CAIxB,IAAM,EAAI,EAAG,EAAK,EAAS,KAAK,CAAC,MAAM,CAAE,EAAI,EAAI,IAAO,CAEvD,IAAI,EAAO,EAAS,KAAK,CAAE,EAAG,CAE9B,GAAK,aAAgB,GAAM,KAAK,CAAG,CAElC,IAAI,EAAI,EAAK,CAAC,CACV,EAAI,EAAK,CAAC,CACV,EAAI,EAAK,CAAC,CACV,EAAI,EAAK,CAAC,CAEV,EAAO,IAAI,GAAM,KAAK,CACtB,EAAO,IAAI,GAAM,KAAK,CA8B1B,IAAM,AA5BN,EAAK,KAAK,CAAC,IAAI,CAAE,EAAK,KAAK,EAC3B,EAAK,KAAK,CAAC,IAAI,CAAE,EAAK,KAAK,EAE3B,EAAK,aAAa,CAAG,EAAK,aAAa,CACvC,EAAK,aAAa,CAAG,EAAK,aAAa,CAEvC,EAAK,CAAC,CAAG,EACT,EAAK,CAAC,CAAG,EACT,EAAK,CAAC,CAAG,EAET,EAAK,CAAC,CAAG,EACT,EAAK,CAAC,CAAG,EACT,EAAK,CAAC,CAAG,EAEyB,IAA7B,EAAK,YAAY,CAAC,MAAM,GAE5B,EAAK,YAAY,CAAE,EAAG,CAAG,EAAK,YAAY,CAAE,EAAG,CAAC,KAAK,GACrD,EAAK,YAAY,CAAE,EAAG,CAAG,EAAK,YAAY,CAAE,EAAG,CAAC,KAAK,GACrD,EAAK,YAAY,CAAE,EAAG,CAAG,EAAK,YAAY,CAAE,EAAG,CAAC,KAAK,GAErD,EAAK,YAAY,CAAE,EAAG,CAAG,EAAK,YAAY,CAAE,EAAG,CAAC,KAAK,GACrD,EAAK,YAAY,CAAE,EAAG,CAAG,EAAK,YAAY,CAAE,EAAG,CAAC,KAAK,GACrD,EAAK,YAAY,CAAE,EAAG,CAAG,EAAK,YAAY,CAAE,EAAG,CAAC,KAAK,IAItD,EAAM,IAAI,CAAE,EAAM,GAEZ,EAAI,EAAG,EAAK,EAAS,aAAa,CAAC,MAAM,CAAE,EAAI,EAAI,IAExD,GAAK,EAAS,aAAa,CAAE,EAAG,CAAC,MAAM,CAAG,CAEzC,IAAI,EAAM,EAAS,aAAa,CAAE,EAAG,CAAE,EAAG,CAEtC,EAAM,CAAG,CAAE,EAAG,CACd,EAAM,CAAG,CAAE,EAAG,CACd,EAAM,CAAG,CAAE,EAAG,CACd,EAAM,CAAG,CAAE,EAAG,CAEd,EAAU,CAAE,EAAI,KAAK,GAAI,EAAI,KAAK,GAAI,EAAI,KAAK,GAAI,CACnD,EAAU,CAAE,EAAI,KAAK,GAAI,EAAI,KAAK,GAAI,EAAI,KAAK,GAAI,CAEvD,CAAa,CAAE,EAAG,CAAC,IAAI,CAAE,EAAS,EAEnC,CAID,IAAM,EAAI,EAAG,EAAK,EAAS,OAAO,CAAC,MAAM,CAAE,EAAI,EAAI,IAElD,GAAK,EAAS,OAAO,CAAE,EAAG,CAAC,MAAM,CAAG,CAEnC,IAAI,EAAS,EAAS,OAAO,CAAE,EAAG,CAAE,EAAG,CAEvC,CAAO,CAAE,EAAG,CAAC,IAAI,CAAE,EAAQ,EAE5B,CAIF,KAAO,CAIN,IAAM,AAFN,EAAM,IAAI,CAAE,GAEN,EAAI,EAAG,EAAK,EAAS,OAAO,CAAC,MAAM,CAAE,EAAI,EAAI,IAElD,CAAO,CAAE,EAAG,CAAC,IAAI,CAAE,EAAS,OAAO,CAAE,EAAG,CAAE,EAAG,EAI9C,IAAM,EAAI,EAAG,EAAK,EAAS,aAAa,CAAC,MAAM,CAAE,EAAI,EAAI,IAExD,CAAa,CAAE,EAAG,CAAC,IAAI,CAAE,EAAS,aAAa,CAAE,EAAG,CAAE,EAAG,CAI3D,CAED,CAEA,EAAS,KAAK,CAAG,EACjB,EAAS,OAAO,CAAG,EACnB,EAAS,aAAa,CAAG,EAEzB,EAAS,gBAAgB,GACzB,EAAS,kBAAkB,GAC3B,EAAS,oBAAoB,GAExB,EAAS,WAAW,EAAG,EAAS,eAAe,EAErD,EAEA,iBAAkB,SAAW,CAAQ,CAAE,CAAK,CAAE,CAAS,CAAE,CAAO,EAM/D,IAAM,IAJF,EAAQ,EAAS,KAAK,CACtB,EAAQ,GAAa,EACrB,EAAM,GAAW,EAAM,MAAM,CAAG,EAE1B,EAAI,EAAO,GAAK,EAAK,IAE9B,CAAK,CAAC,EAAE,CAAC,aAAa,CAAG,CAIxB,CAEJ,EAEA,GAAM,aAAa,CAAC,MAAM,CAAG,GAAM,IAAI,CAAC,QAAQ,CAEhD,GAAM,aAAa,CAAC,IAAI,CAAG,IAAI,GAAM,OAAO,CAC5C,GAAM,aAAa,CAAC,IAAI,CAAG,IAAI,GAAM,OAAO,CAM5C,GAAM,UAAU,CAAG,CAElB,YAAa,YAEb,YAAa,SAAW,CAAG,CAAE,CAAO,CAAE,CAAM,CAAE,CAAO,EAEpD,IAAI,EAAQ,IAAI,MACZ,EAAU,IAAI,GAAM,OAAO,CAAE,EAAO,GAEpC,EAAS,IAAI,GAAM,WAAW,CAsBlC,OApBA,EAAO,gBAAgB,CAAE,OAAQ,SAAW,CAAK,EAEhD,EAAQ,KAAK,CAAG,EAAM,OAAO,CAC7B,EAAQ,WAAW,CAAG,CAAA,EAEjB,GAAS,EAAQ,EAEvB,GAEA,EAAO,gBAAgB,CAAE,QAAS,SAAW,CAAK,EAE5C,GAAU,EAAS,EAAM,OAAO,CAEtC,GAEA,EAAO,WAAW,CAAG,IAAI,CAAC,WAAW,CACrC,EAAO,IAAI,CAAE,EAAK,GAElB,EAAQ,UAAU,CAAG,EAEd,CAER,EAEA,sBAAuB,SAAW,CAAG,CAAE,CAAO,CAAE,CAAM,CAAE,CAAO,EAE9D,IAAI,EAAU,IAAI,GAAM,iBAAiB,AACzC,CAAA,EAAQ,OAAO,CAAG,EAElB,IAAI,EAAU,IAAI,eA+BlB,OA7BA,EAAQ,MAAM,CAAG,WAEhB,IAAI,EAAS,EAAQ,QAAQ,CACzB,EAAM,GAAM,UAAU,CAAC,QAAQ,CAAE,EAAQ,CAAA,EAE7C,CAAA,EAAQ,MAAM,CAAG,EAAI,MAAM,CAE3B,EAAQ,OAAO,CAAG,EAAI,OAAO,CAC7B,EAAQ,KAAK,CAAC,KAAK,CAAG,EAAI,KAAK,CAC/B,EAAQ,KAAK,CAAC,MAAM,CAAG,EAAI,MAAM,CAMjC,EAAQ,eAAe,CAAG,CAAA,EAE1B,EAAQ,WAAW,CAAG,CAAA,EAEjB,GAAS,EAAQ,EAEvB,EAEA,EAAQ,OAAO,CAAG,EAElB,EAAQ,IAAI,CAAE,MAAO,EAAK,CAAA,GAC1B,EAAQ,YAAY,CAAG,cACvB,EAAQ,IAAI,CAAE,MAEP,CAER,EAEA,gBAAiB,SAAW,CAAK,CAAE,CAAO,CAAE,CAAM,CAAE,CAAO,EAE1D,IAAI,EAAS,EAAE,AACf,CAAA,EAAO,SAAS,CAAG,EAEnB,IAAI,EAAU,IAAI,GAAM,OAAO,AAC/B,CAAA,EAAQ,KAAK,CAAG,EACC,KAAA,IAAZ,GAAwB,CAAA,EAAQ,OAAO,CAAG,CAA/C,EAIA,EAAQ,KAAK,CAAG,CAAA,EAEhB,IAAM,IAAI,EAAI,EAAG,EAAK,EAAM,MAAM,CAAE,EAAI,EAAI,EAAG,EAAI,CAElD,IAAI,EAAY,IAAI,KACpB,CAAA,CAAM,CAAE,EAAG,CAAG,EAEd,EAAU,MAAM,CAAG,WAElB,EAAO,SAAS,EAAI,EAEM,IAArB,EAAO,SAAS,GAEpB,EAAQ,WAAW,CAAG,CAAA,EACjB,GAAS,EAAQ,GAIxB,EAEA,EAAU,OAAO,CAAG,EAEpB,EAAU,WAAW,CAAG,IAAI,CAAC,WAAW,CACxC,EAAU,GAAG,CAAG,CAAK,CAAE,EAAG,AAE3B,CAEA,OAAO,CAER,EAEA,0BAA2B,SAAW,CAAK,CAAE,CAAO,CAAE,CAAM,CAAE,CAAO,EAEpE,IAAI,EAAS,EAAE,AACf,CAAA,EAAO,SAAS,CAAG,EAEnB,IAAI,EAAU,IAAI,GAAM,iBAAiB,AACzC,CAAA,EAAQ,KAAK,CAAG,EACC,KAAA,IAAZ,GAAwB,CAAA,EAAQ,OAAO,CAAG,CAA/C,EAKA,EAAQ,KAAK,CAAG,CAAA,EAKhB,EAAQ,eAAe,CAAG,CAAA,EAE1B,IAAI,EAA2B,SAAW,CAAE,CAAE,CAAG,EAEhD,OAAO,WAEN,IAAI,EAAS,EAAG,QAAQ,CACpB,EAAM,GAAM,UAAU,CAAC,QAAQ,CAAE,EAAQ,CAAA,EAE7C,CAAA,EAAI,MAAM,CAAG,EAAI,MAAM,CAEvB,EAAI,OAAO,CAAG,EAAI,OAAO,CACzB,EAAI,KAAK,CAAG,EAAI,KAAK,CACrB,EAAI,MAAM,CAAG,EAAI,MAAM,CAEvB,EAAO,SAAS,EAAI,EAEM,IAArB,EAAO,SAAS,GAEpB,EAAQ,MAAM,CAAG,EAAI,MAAM,CAC3B,EAAQ,WAAW,CAAG,CAAA,EACjB,GAAS,EAAQ,GAIxB,CAED,EAIA,GAAK,aAAiB,MAErB,IAAM,IAAI,EAAI,EAAG,EAAK,EAAM,MAAM,CAAE,EAAI,EAAI,EAAG,EAAI,CAElD,IAAI,EAAY,CAAC,CACjB,CAAA,CAAM,CAAE,EAAG,CAAG,EAEd,IAAI,EAAU,IAAI,cAElB,CAAA,EAAQ,MAAM,CAAG,EAA0B,EAAS,GACpD,EAAQ,OAAO,CAAG,EAElB,IAAI,EAAM,CAAK,CAAE,EAAG,CAEpB,EAAQ,IAAI,CAAE,MAAO,EAAK,CAAA,GAC1B,EAAQ,YAAY,CAAG,cACvB,EAAQ,IAAI,CAAE,KAEf,KAIM,CAEN,IAAI,EAAM,EACN,EAAU,IAAI,cAElB,CAAA,EAAQ,MAAM,CAAG,WAEhB,IAAI,EAAS,EAAQ,QAAQ,CACzB,EAAM,GAAM,UAAU,CAAC,QAAQ,CAAE,EAAQ,CAAA,GAE7C,GAAK,EAAI,SAAS,CAAG,CAIpB,IAAM,IAFF,EAAQ,EAAI,OAAO,CAAC,MAAM,CAAG,EAAI,WAAW,CAEtC,EAAI,EAAG,EAAI,EAAO,IAAO,CAElC,CAAM,CAAE,EAAG,CAAG,CAAE,QAAU,EAAE,AAAC,EAE7B,IAAM,IAAI,EAAI,EAAG,EAAI,EAAI,WAAW,CAAE,IAErC,CAAM,CAAE,EAAG,CAAC,OAAO,CAAC,IAAI,CAAE,EAAI,OAAO,CAAE,EAAI,EAAI,WAAW,CAAG,EAAG,EAChE,CAAM,CAAE,EAAG,CAAC,MAAM,CAAG,EAAI,MAAM,CAC/B,CAAM,CAAE,EAAG,CAAC,KAAK,CAAG,EAAI,KAAK,CAC7B,CAAM,CAAE,EAAG,CAAC,MAAM,CAAG,EAAI,MAAM,AAIjC,CAEA,EAAQ,MAAM,CAAG,EAAI,MAAM,CAC3B,EAAQ,WAAW,CAAG,CAAA,EACjB,GAAS,EAAQ,EAEvB,CAED,EAEA,EAAQ,OAAO,CAAG,EAElB,EAAQ,IAAI,CAAE,MAAO,EAAK,CAAA,GAC1B,EAAQ,YAAY,CAAG,cACvB,EAAQ,IAAI,CAAE,KAEf,CAEA,OAAO,CAER,EAEA,SAAU,SAAW,CAAM,CAAE,CAAW,EAEvC,IAqGI,EArGA,EAAM,CAAE,QAAS,EAAE,CAAE,MAAO,EAAG,OAAQ,EAAG,OAAQ,KAAM,YAAa,CAAE,EAuC3E,SAAS,EAAe,CAAK,EAE5B,OAAO,EAAM,UAAU,CAAC,GACtB,CAAA,EAAM,UAAU,CAAC,IAAM,CAAA,EACvB,CAAA,EAAM,UAAU,CAAC,IAAM,EAAA,EACvB,CAAA,EAAM,UAAU,CAAC,IAAM,EAAA,CAE1B,CAYA,IAAI,EAAc,EAAc,QAC5B,EAAc,EAAc,QAC5B,EAAc,EAAc,QAyB5B,EAAS,IAAI,WAAY,EAAQ,EAvBf,IAyBtB,GAAK,AA/EW,YA+EX,CAAM,CArBK,EAqBQ,CAGvB,OADA,QAAQ,KAAK,CAAE,6DACR,EAIR,GAAK,AA5DU,EA4DV,CAAE,CAAM,CAnBK,GAmBU,CAG3B,OADA,QAAQ,KAAK,CAAE,yEACR,EAMR,IAAI,EAAS,CAAM,CA3BA,GA2BgB,CAEnC,OAAS,GAER,KAAK,EAEJ,EAAa,EACb,EAAI,MAAM,CAAG,GAAM,oBAAoB,CACvC,KAED,MAAK,EAEJ,EAAa,GACb,EAAI,MAAM,CAAG,GAAM,qBAAqB,CACxC,KAED,MAAK,EAEJ,EAAa,GACb,EAAI,MAAM,CAAG,GAAM,qBAAqB,CACxC,KAED,SAGC,OADA,QAAQ,KAAK,CAAE,mDA7ET,OAAO,YAAY,CACzB,AAAQ,IA4E0E,EA3EjF,AA2EiF,GA3ExE,EAAK,IACd,AA0EiF,GA1ExE,GAAM,IAChB,AAyEkF,GAzExE,GAAM,MA0ET,CAET,CAEA,EAAI,WAAW,CAAG,EArHE,OAuHf,CAAM,CAjEK,EAiEQ,EAAuB,AAAgB,CAAA,IAAhB,GAE9C,CAAA,EAAI,WAAW,CAAG,KAAK,GAAG,CAAE,EAAG,CAAM,CA/DhB,EA+DmC,CAAA,EAMzD,EAAI,SAAS,GAAG,CAAA,AAvHO,IAuHP,CAAM,CA/DN,GA+DmB,AAAG,EAEtC,EAAI,KAAK,CAAG,CAAM,CAzEF,EAyEe,CAC/B,EAAI,MAAM,CAAG,CAAM,CA3EF,EA2EgB,CAWjC,IAAM,IATF,EAAa,CAAM,CA/ER,EA+EoB,CAAG,EAIlC,EAAQ,EAAI,KAAK,CACjB,EAAS,EAAI,MAAM,CAEnB,EAAQ,EAAI,SAAS,CAAG,EAAI,EAEtB,EAAO,EAAG,EAAO,EAAO,IAAU,CAE3C,IAAM,IAAI,EAAI,EAAG,EAAI,EAAI,WAAW,CAAE,IAAO,CAE5C,IAAI,EAAa,KAAK,GAAG,CAAE,EAAG,GAAU,EAAI,KAAK,GAAG,CAAE,EAAG,GAAW,EAAI,EAGpE,EAAS,CAAE,KAFC,IAAI,WAAY,EAAQ,EAAY,GAElB,MAAS,EAAO,OAAU,CAAO,EACnE,EAAI,OAAO,CAAC,IAAI,CAAE,GAElB,GAAc,EAEd,EAAQ,KAAK,GAAG,CAAE,AAAQ,GAAR,EAAa,GAC/B,EAAS,KAAK,GAAG,CAAE,AAAS,GAAT,EAAc,EAElC,CAEA,EAAQ,EAAI,KAAK,CACjB,EAAS,EAAI,MAAM,AAEpB,CAEA,OAAO,CAER,EAEA,aAAc,SAAW,CAAK,CAAE,CAAK,EAUpC,IAAI,EAAW,SAAW,CAAC,CAAE,CAAC,EAE7B,MAAO,CAAE,CAAC,CAAE,EAAG,CAAG,CAAC,CAAE,EAAG,CAAE,CAAC,CAAE,EAAG,CAAG,CAAC,CAAE,EAAG,CAAE,CAAC,CAAE,EAAG,CAAG,CAAC,CAAE,EAAG,CAAE,AAE7D,EASA,GAAgB,EAEhB,IAAI,EAAQ,EAAM,KAAK,CACnB,EAAS,EAAM,MAAM,CAErB,EAAS,SAAS,aAAa,CAAE,SACrC,CAAA,EAAO,KAAK,CAAG,EACf,EAAO,MAAM,CAAG,EAEhB,IAAI,EAAU,EAAO,UAAU,CAAE,MACjC,EAAQ,SAAS,CAAE,EAAO,EAAG,GAM7B,IAAM,IAJF,EAAO,EAAQ,YAAY,CAAE,EAAG,EAAG,EAAO,GAAS,IAAI,CACvD,EAAY,EAAQ,eAAe,CAAE,EAAO,GAC5C,EAAS,EAAU,IAAI,CAEjB,EAAI,EAAG,EAAI,EAAO,IAE3B,IAAM,IAAI,EAAI,EAAG,EAAI,EAAQ,IAAO,CAEnC,IAAI,EAAK,EAAI,EAAI,EAAI,EAAI,EAAI,EACzB,EAAK,EAAI,EAAI,EAAS,EAAI,EAAS,EAAI,EAAI,EAC3C,EAAK,EAAI,EAAI,EAAI,EAAI,EAAI,EACzB,EAAK,EAAI,EAAI,EAAQ,EAAI,EAAQ,EAAI,EAAI,EAEzC,EAAS,EAAE,CACX,EAAS,CAAE,EAAG,EAAG,CAAI,CAAI,AAAA,CAAA,EAAI,EAAQ,CAAA,EAAM,EAAG,CAAG,IAAM,EAAO,CAClE,EAAO,IAAI,CAAE,CAAE,GAAK,EAAG,CAAI,CAAI,AAAA,CAAA,EAAI,EAAQ,CAAA,EAAO,EAAG,CAAG,IAAM,EAAO,EACrE,EAAO,IAAI,CAAE,CAAE,GAAK,GAAK,CAAI,CAAI,AAAA,CAAA,EAAK,EAAQ,CAAA,EAAO,EAAG,CAAG,IAAM,EAAO,EACxE,EAAO,IAAI,CAAE,CAAE,EAAG,GAAK,CAAI,CAAI,AAAA,CAAA,EAAK,EAAQ,CAAA,EAAM,EAAG,CAAG,IAAM,EAAO,EACrE,EAAO,IAAI,CAAE,CAAG,EAAG,GAAK,CAAI,CAAI,AAAA,CAAA,EAAK,EAAQ,CAAA,EAAO,EAAG,CAAG,IAAM,EAAO,EACvE,EAAO,IAAI,CAAE,CAAE,EAAG,EAAG,CAAI,CAAI,AAAA,CAAA,EAAI,EAAQ,CAAA,EAAO,EAAG,CAAG,IAAM,EAAO,EACnE,EAAO,IAAI,CAAE,CAAE,EAAG,EAAG,CAAI,CAAI,AAAA,CAAA,EAAK,EAAQ,CAAA,EAAO,EAAG,CAAG,IAAM,EAAO,EACpE,EAAO,IAAI,CAAE,CAAE,EAAG,EAAG,CAAI,CAAI,AAAA,CAAA,EAAK,EAAQ,CAAA,EAAM,EAAG,CAAG,IAAM,EAAO,EACnE,EAAO,IAAI,CAAE,CAAE,GAAK,EAAG,CAAI,CAAI,AAAA,CAAA,EAAK,EAAQ,CAAA,EAAO,EAAG,CAAG,IAAM,EAAO,EAKtE,IAAM,IAHF,EAAU,EAAE,CACZ,EAAa,EAAO,MAAM,CAEpB,EAAI,EAAG,EAAI,EAAY,IAAO,CAEvC,IA5DoB,EAAG,EA4DnB,EAAK,CAAM,CAAE,EAAG,CAChB,EAAK,CAAM,CAAI,AAAA,CAAA,EAAI,CAAA,EAAM,EAAY,CACzC,EAAK,EAAU,EAAI,GACnB,EAAK,EAAU,EAAI,GACnB,EAAQ,IAAI,CAAE,AApDD,SAAW,CAAC,EAE3B,IAAI,EAAI,KAAK,IAAI,CAAE,CAAC,CAAE,EAAG,CAAG,CAAC,CAAE,EAAG,CAAG,CAAC,CAAE,EAAG,CAAG,CAAC,CAAE,EAAG,CAAG,CAAC,CAAE,EAAG,CAAG,CAAC,CAAE,EAAG,EACtE,MAAO,CAAE,CAAC,CAAE,EAAG,CAAG,EAAG,CAAC,CAAE,EAAG,CAAG,EAAG,CAAC,CAAE,EAAG,CAAG,EAAG,AAE9C,GAjBuB,EAgEY,EAhET,EAgEa,EA9D/B,CAAE,CAAC,CAAE,EAAG,CAAG,CAAC,CAAE,EAAG,CAAG,CAAC,CAAE,EAAG,CAAG,CAAC,CAAE,EAAG,CAAE,CAAC,CAAE,EAAG,CAAG,CAAC,CAAE,EAAG,CAAG,CAAC,CAAE,EAAG,CAAG,CAAC,CAAE,EAAG,CAAE,CAAC,CAAE,EAAG,CAAG,CAAC,CAAE,EAAG,CAAG,CAAC,CAAE,EAAG,CAAG,CAAC,CAAE,EAAG,CAAE,GAgEjH,CAIA,IAAM,IAFF,EAAS,CAAE,EAAG,EAAG,EAAG,CAEd,EAAI,EAAG,EAAI,EAAQ,MAAM,CAAE,IAEpC,CAAM,CAAE,EAAG,EAAI,CAAO,CAAE,EAAG,CAAE,EAAG,CAChC,CAAM,CAAE,EAAG,EAAI,CAAO,CAAE,EAAG,CAAE,EAAG,CAChC,CAAM,CAAE,EAAG,EAAI,CAAO,CAAE,EAAG,CAAE,EAAG,AAIjC,CAAA,CAAM,CAAE,EAAG,EAAI,EAAQ,MAAM,CAC7B,CAAM,CAAE,EAAG,EAAI,EAAQ,MAAM,CAC7B,CAAM,CAAE,EAAG,EAAI,EAAQ,MAAM,CAE7B,IAAI,EAAM,AAAE,CAAA,EAAI,EAAQ,CAAA,EAAM,CAE9B,CAAA,CAAM,CAAE,EAAK,CAAO,AAAA,CAAA,CAAM,CAAE,EAAG,CAAG,CAAA,EAAQ,EAAM,IAAQ,EACxD,CAAM,CAAE,EAAM,EAAG,CAAO,AAAA,CAAA,CAAM,CAAE,EAAG,CAAG,CAAA,EAAQ,EAAM,IAAQ,EAC5D,CAAM,CAAE,EAAM,EAAG,CAAK,AAAc,IAAd,CAAM,CAAE,EAAG,CAAW,EAC5C,CAAM,CAAE,EAAM,EAAG,CAAG,GAErB,CAMD,OAFA,EAAQ,YAAY,CAAE,EAAW,EAAG,GAE7B,CAER,EAEA,oBAAqB,SAAW,CAAK,CAAE,CAAM,CAAE,CAAK,EASnD,IAAM,IAPF,EAAO,EAAQ,EACf,EAAO,IAAI,WAAY,EAAI,GAE3B,EAAI,KAAK,KAAK,CAAE,AAAU,IAAV,EAAM,CAAC,EACvB,EAAI,KAAK,KAAK,CAAE,AAAU,IAAV,EAAM,CAAC,EACvB,EAAI,KAAK,KAAK,CAAE,AAAU,IAAV,EAAM,CAAC,EAEjB,EAAI,EAAG,EAAI,EAAM,IAE1B,CAAI,CAAE,AAAI,EAAJ,EAAO,CAAM,EACnB,CAAI,CAAE,AAAI,EAAJ,EAAQ,EAAG,CAAG,EACpB,CAAI,CAAE,AAAI,EAAJ,EAAQ,EAAG,CAAG,EAXrB,IAeI,EAAU,IAAI,GAAM,WAAW,CAAE,EAAM,EAAO,EAAQ,GAAM,SAAS,EAGzE,OAFA,EAAQ,WAAW,CAAG,CAAA,EAEf,CAER,CAED,EAKA,GAAM,UAAU,CAAG,CAElB,0BAA2B,SAAW,CAAQ,CAAE,CAAS,EAIxD,IAAM,IAFF,EAAQ,IAAI,GAAM,QAAQ,CAEpB,EAAI,EAAG,EAAI,EAAU,MAAM,CAAE,EAAI,EAAG,IAE7C,EAAM,GAAG,CAAE,IAAI,GAAM,IAAI,CAAE,EAAU,CAAS,CAAE,EAAG,GAIpD,OAAO,CAER,EAEA,OAAS,SAAW,CAAK,CAAE,CAAM,CAAE,CAAK,EAEvC,EAAM,WAAW,CAAE,EAAO,WAAW,EACrC,EAAO,MAAM,CAAE,GACf,EAAM,GAAG,CAAE,EAEZ,EAEA,OAAQ,SAAW,CAAK,CAAE,CAAK,CAAE,CAAM,EAEtC,IAAI,EAAqB,IAAI,GAAM,OAAO,CAC1C,EAAmB,UAAU,CAAE,EAAO,WAAW,EACjD,EAAM,WAAW,CAAE,GAEnB,EAAM,MAAM,CAAE,GACd,EAAO,GAAG,CAAE,EAEb,CAED,EAsBA,GAAM,SAAS,CAAG,CAEjB,MAAQ,CAAC,EAIT,KAAO,aACP,OAAQ,SACR,MAAQ,SACR,KAAO,IACP,UAAY,GAEZ,QAAU,WAET,OAAO,IAAI,CAAC,KAAK,CAAE,IAAI,CAAC,IAAI,CAAE,CAAE,IAAI,CAAC,MAAM,CAAE,CAAE,IAAI,CAAC,KAAK,CAAE,AAE5D,EAEA,SAAW,SAAU,CAAI,EAExB,IAAI,EAAS,EAAK,UAAU,CAAC,WAAW,GAWxC,OAPA,AAFgB,IAAI,CAEV,KAAK,CAAE,EAAQ,CAAG,AAFZ,IAAI,CAEkB,KAAK,CAAE,EAAQ,EAAI,CAAC,EAE1D,AAJgB,IAAI,CAIV,KAAK,CAAE,EAAQ,CAAE,EAAK,aAAa,CAAE,CAAG,AAJlC,IAAI,CAIwC,KAAK,CAAE,EAAQ,CAAE,EAAK,aAAa,CAAE,EAAI,CAAC,EACtG,AALgB,IAAI,CAKV,KAAK,CAAE,EAAQ,CAAE,EAAK,aAAa,CAAE,CAAE,EAAK,YAAY,CAAE,CAAG,EAE5D,AAPK,IAAI,CAOC,KAAK,CAAE,EAAQ,CAAE,EAAK,aAAa,CAAE,CAAE,EAAK,YAAY,CAAE,CAAG,EAE3E,CAER,EAEA,SAAW,SAAU,CAAI,EAMxB,IAAI,EACH,EAAO,IAAI,CAAC,OAAO,GACnB,EAAQ,IAAI,CAAC,IAAI,CAAG,EAAK,UAAU,CACnC,EAAS,EACT,EAAQ,OAAQ,GAAO,KAAK,CAAE,IAC9B,EAAS,EAAM,MAAM,CAElB,EAAY,EAAE,CAElB,IAAM,EAAI,EAAG,EAAI,EAAQ,IAAO,CAE/B,IAAI,EAAO,IAAI,GAAM,IAAI,CAErB,EAAM,IAAI,CAAC,kBAAkB,CAAE,CAAK,CAAE,EAAG,CAAE,EAAM,EAAO,EAAQ,GACpE,GAAU,EAAI,MAAM,CAEpB,EAAU,IAAI,CAAE,EAAI,IAAI,CAEzB,CAkBA,MAAO,CAAE,MAAQ,EAAW,OAdhB,EAAS,CAcsB,CAE5C,EAKA,mBAAqB,SAAU,CAAC,CAAE,CAAI,CAAE,CAAK,CAAE,CAAM,CAAE,CAAI,EAE1D,IAEI,EAAG,EAAI,EACV,EAAiB,EAEjB,EAAG,EAAG,EAAK,EAAK,EAAM,EAAM,EAAM,EAAM,EAAM,EAC9C,EANG,EAAM,EAAE,CAOX,EAAQ,EAAK,MAAM,CAAE,EAAG,EAAI,EAAK,MAAM,CAAE,IAAK,CAE/C,GAAM,GAEN,GAAK,EAAM,CAAC,CAQX,IAAM,EAAI,EALV,EAAS,AADT,CAAA,EAAU,EAAM,cAAc,EAAM,CAAA,EAAM,cAAc,CAAG,EAAM,CAAC,CAAC,KAAK,CAAE,IAAA,CAAI,EAC7D,MAAM,CAKV,EAAI,GAMhB,OAJS,CAAO,CAAE,IAAM,EAMxB,IAAK,IAIJ,EAAI,CAAO,CAAE,IAAK,CAfX,EAeuB,EAC9B,EAAI,CAAO,CAAE,IAAK,CAfX,EAiBP,EAAK,MAAM,CAAE,EAAG,GAChB,KAED,KAAK,IAIJ,EAAI,CAAO,CAAE,IAAK,CAzBX,EAyBuB,EAC9B,EAAI,CAAO,CAAE,IAAK,CAzBX,EA0BP,EAAK,MAAM,CAAC,EAAE,GACd,KAED,KAAK,IAaJ,GATA,EAAO,CAAO,CAAE,IAAK,CAlCd,EAkC0B,EACjC,EAAO,CAAO,CAAE,IAAK,CAlCd,EAmCP,EAAO,CAAO,CAAE,IAAK,CApCd,EAoC0B,EACjC,EAAO,CAAO,CAAE,IAAK,CApCd,EAsCP,EAAK,gBAAgB,CAAC,EAAM,EAAM,EAAK,GAEvC,EAAQ,CAAG,CAAE,EAAI,MAAM,CAAG,EAAG,CAO5B,IAAM,EAAK,EAHX,EAAO,EAAM,CAAC,CACd,EAAO,EAAM,CAAC,CAEA,EAAY,IAAI,CAAC,SAAS,CAAE,GAAM,EAAW,IAAQ,CAElE,IAAI,EAAI,EAAK,EACJ,GAAM,KAAK,CAAC,KAAK,CAAC,EAAE,CAAE,EAAG,EAAM,EAAM,GACrC,GAAM,KAAK,CAAC,KAAK,CAAC,EAAE,CAAE,EAAG,EAAM,EAAM,EAC9C,CAID,KAEF,KAAK,IAeJ,GAXA,EAAO,CAAO,CAAE,IAAK,CA/Dd,EA+D2B,EAClC,EAAO,CAAO,CAAE,IAAK,CA/Dd,EAgEP,EAAO,CAAO,CAAE,IAAK,CAjEd,EAiE2B,EAClC,EAAO,CAAA,CAAA,CAAO,CAAE,IAAK,CAjEd,CAiEP,EACA,EAAO,CAAO,CAAE,IAAK,CAnEd,EAmE2B,EAClC,EAAO,CAAA,CAAA,CAAO,CAAE,IAAK,CAnEd,CAmEP,EAEA,EAAK,aAAa,CAAE,EAAK,EAAK,EAAM,EAAM,EAAM,GAEhD,EAAQ,CAAG,CAAE,EAAI,MAAM,CAAG,EAAG,CAO5B,IAAM,EAAK,EAHX,EAAO,EAAM,CAAC,CACd,EAAO,EAAM,CAAC,CAEA,EAAY,IAAI,CAAC,SAAS,CAAE,GAAM,EAAW,IAAQ,CAElE,IAAI,EAAI,EAAK,EACJ,GAAM,KAAK,CAAC,KAAK,CAAC,EAAE,CAAE,EAAG,EAAM,EAAM,EAAM,GAC3C,GAAM,KAAK,CAAC,KAAK,CAAC,EAAE,CAAE,EAAG,EAAM,EAAM,EAAM,EAErD,CAMF,CAOF,MAAO,CAAE,OAAQ,EAAM,EAAE,CAAC,EAAO,KAAK,CAAI,EAC3C,CAED,EAGA,GAAM,SAAS,CAAC,cAAc,CAAG,SAAU,CAAI,CAAE,CAAU,EAM1D,IAAI,EAAO,AAAoB,KAAA,IAApB,AAFX,CAAA,EAAa,GAAc,CAAC,CAAA,EAEN,IAAI,CAAiB,EAAW,IAAI,CAAG,IACzD,EAAgB,AAA6B,KAAA,IAA7B,EAAW,aAAa,CAAiB,EAAW,aAAa,CAAE,EAEnF,EAAO,AAAoB,KAAA,IAApB,EAAW,IAAI,CAAiB,EAAW,IAAI,CAAG,aACzD,EAAS,AAAsB,KAAA,IAAtB,EAAW,MAAM,CAAiB,EAAW,MAAM,CAAG,SAC/D,EAAQ,AAAqB,KAAA,IAArB,EAAW,KAAK,CAAiB,EAAW,KAAK,CAAG,QAEhE,CAAA,GAAM,SAAS,CAAC,IAAI,CAAG,EACvB,GAAM,SAAS,CAAC,SAAS,CAAG,EAE5B,GAAM,SAAS,CAAC,IAAI,CAAG,EACvB,GAAM,SAAS,CAAC,MAAM,CAAG,EACzB,GAAM,SAAS,CAAC,KAAK,CAAG,EASxB,IAAM,IAHF,EAAQ,AAFD,GAAM,SAAS,CAAC,QAAQ,CAAE,GAEpB,KAAK,CAClB,EAAS,EAAE,CAEL,EAAI,EAAG,EAAK,EAAM,MAAM,CAAE,EAAI,EAAI,IAE3C,MAAM,SAAS,CAAC,IAAI,CAAC,KAAK,CAAE,EAAQ,CAAK,CAAE,EAAG,CAAC,QAAQ,IAIxD,OAAO,CAER,EAkBY,EA+KT,GAAM,SAAS,CAvEb,EAAO,SAAW,CAAO,EAK5B,IAAK,IAHD,EAAI,EAAQ,MAAM,CAClB,EAAI,EAEC,EAAI,EAAI,EAAG,EAAI,EAAG,EAAI,EAAG,EAAI,IAErC,GAAK,CAAO,CAAE,EAAG,CAAC,CAAC,CAAG,CAAO,CAAE,EAAG,CAAC,CAAC,CAAG,CAAO,CAAE,EAAG,CAAC,CAAC,CAAG,CAAO,CAAE,EAAG,CAAC,CAAC,CAIvE,OAAO,AAAI,GAAJ,CAER,EAEI,EAAO,SAAW,CAAO,CAAE,CAAC,CAAE,CAAC,CAAE,CAAC,CAAE,CAAC,CAAE,CAAK,MAE3C,EACA,EAAI,EAAI,EAAI,EACZ,EAAI,EAAI,EAAI,EAaZ,EAAI,EAAI,EAAI,EAAI,EAAI,EACpB,EAAK,EAAK,EAAK,EAAK,EAAK,EACzB,EAAU,EAAU,EAJxB,GATA,EAAK,CAAO,CAAE,CAAK,CAAE,EAAG,CAAE,CAAC,CAAC,CAC5B,EAAK,CAAO,CAAE,CAAK,CAAE,EAAG,CAAE,CAAC,CAAC,CAE5B,EAAK,CAAO,CAAE,CAAK,CAAE,EAAG,CAAE,CAAC,CAAC,CAC5B,EAAK,CAAO,CAAE,CAAK,CAAE,EAAG,CAAE,CAAC,CAAC,CAE5B,EAAK,CAAO,CAAE,CAAK,CAAE,EAAG,CAAE,CAAC,CAAC,CAGvB,AApIQ,MAoIG,AAAE,CAAA,EAAG,CAAA,EAAK,CAAA,AAF1B,CAAA,EAAK,CAAO,CAAE,CAAK,CAAE,EAAG,CAAE,CAAC,CAAC,AAAD,EAEE,CAAA,EAAQ,AAAC,CAAA,EAAG,CAAA,EAAK,CAAA,EAAG,CAAA,EAAQ,MAAO,CAAA,EAUhE,IAAM,EAAI,EAJV,EAAK,EAAK,EAAK,EAAK,EAAK,EACzB,EAAK,EAAK,EAAK,EAAK,EAAK,EACzB,EAAK,EAAK,EAAK,EAAK,EAAK,EAEZ,EAAI,EAAG,IAEnB,GAAK,IAAM,GAAO,IAAM,GAAO,IAAM,IAErC,EAAK,CAAO,CAAE,CAAK,CAAE,EAAG,CAAE,CAAC,CAAC,CAC5B,EAAK,CAAO,CAAE,CAAK,CAAE,EAAG,CAAE,CAAC,CAAC,CAE5B,EAAM,EAAK,EAAK,EAAM,EAAK,EAC3B,EAAM,EAAK,EAAK,EAAM,EAAK,EAC3B,EAAM,EAAK,EAAK,EAAM,EAAK,EAI3B,EAAW,EAAG,EAAM,EAAG,EACvB,EAAW,EAAG,EAAM,EAAG,EACvB,EAAW,EAAG,EAAM,EAAG,EAEjB,GAAY,GAAS,GAAY,GAAS,GAAY,GAAO,MAAO,CAAA,EAI3E,MAAO,CAAA,CAER,EAGA,EAAU,WAAW,CApKP,SAAU,CAAO,CAAE,CAAO,EAEvC,IAUI,EAAG,EAAG,EA4CJ,EAAG,EAAG,EAAG,EAAG,EAtDd,EAAI,EAAQ,MAAM,CAEtB,GAAK,EAAI,EAAI,OAAO,KAEpB,IAAI,EAAS,EAAE,CACd,EAAQ,EAAE,CACV,EAAc,EAAE,CAMjB,GAAK,EAAM,GAAY,EAEtB,IAAM,EAAI,EAAG,EAAI,EAAG,IAAM,CAAK,CAAE,EAAG,CAAG,OAIvC,IAAM,EAAI,EAAG,EAAI,EAAG,IAAM,CAAK,CAAE,EAAG,CAAK,EAAI,EAAM,EAIpD,IAAI,EAAK,EAIL,EAAQ,EAAI,EAEhB,IAAK,EAAI,EAAK,EAAG,EAAK,GAAK,CAI1B,GAAK,KAAe,EAAI,CASvB,GAFA,QAAQ,GAAG,CAAE,2CAER,EAAU,OAAO,EACtB,OAAO,CAER,CAQA,GAJe,GAAf,CAAA,EAAI,CAAA,GAAqB,CAAA,EAAI,CAAA,EACZ,GAAjB,CAAA,EAAI,EAAI,CAAA,GAAmB,CAAA,EAAI,CAAA,EACd,GAAjB,CAAA,EAAI,EAAI,CAAA,GAAmB,CAAA,EAAI,CAAA,EAE1B,EAAM,EAAS,EAAG,EAAG,EAAG,EAAI,GAAU,CAqB1C,IAAK,AAfL,EAAI,CAAK,CAAE,EAAG,CACd,EAAI,CAAK,CAAE,EAAG,CACd,EAAI,CAAK,CAAE,EAAG,CAId,EAAO,IAAI,CAAE,CAAE,CAAO,CAAE,EAAG,CAC1B,CAAO,CAAE,EAAG,CACZ,CAAO,CAAE,EAAG,CAAE,EAGf,EAAY,IAAI,CAAE,CAAE,CAAK,CAAE,EAAG,CAAE,CAAK,CAAE,EAAG,CAAE,CAAK,CAAE,EAAG,CAAE,EAInD,EAAI,EAAG,EAAI,EAAI,EAAG,EAAI,EAAI,IAAK,IAEnC,CAAK,CAAE,EAAG,CAAG,CAAK,CAAE,EAAG,CAQxB,EAAQ,IAAI,CAEb,CAED,QAEA,AAAK,EAAiB,EACf,CAER,EAuEA,EAAU,WAAW,CAAC,IAAI,CAAG,EAO9B,KAAK,YAAY,CAAG,CAAE,MAAO,GAAM,SAAS,CAAC,KAAK,CAAE,SAAU,GAAM,SAAS,CAAC,QAAQ,AAAC,EAqCvF,GAAM,KAAK,CAAG,WAEd,EAKA,GAAM,KAAK,CAAC,SAAS,CAAC,QAAQ,CAAG,SAAW,CAAC,EAG5C,OADA,QAAQ,GAAG,CAAE,wCACN,IAER,EAKA,GAAM,KAAK,CAAC,SAAS,CAAC,UAAU,CAAG,SAAW,CAAC,EAE9C,IAAI,EAAI,IAAI,CAAC,cAAc,CAAE,GAC7B,OAAO,IAAI,CAAC,QAAQ,CAAE,EAEvB,EAIA,GAAM,KAAK,CAAC,SAAS,CAAC,SAAS,CAAG,SAAW,CAAS,EAE/C,GAAY,CAAA,EAAY,CAAA,EAE9B,IAAI,EAAG,EAAM,EAAE,CAEf,IAAM,EAAI,EAAG,GAAK,EAAW,IAE5B,EAAI,IAAI,CAAE,IAAI,CAAC,QAAQ,CAAE,EAAI,IAI9B,OAAO,CAER,EAIA,GAAM,KAAK,CAAC,SAAS,CAAC,eAAe,CAAG,SAAW,CAAS,EAErD,GAAY,CAAA,EAAY,CAAA,EAE9B,IAAI,EAAG,EAAM,EAAE,CAEf,IAAM,EAAI,EAAG,GAAK,EAAW,IAE5B,EAAI,IAAI,CAAE,IAAI,CAAC,UAAU,CAAE,EAAI,IAIhC,OAAO,CAER,EAIA,GAAM,KAAK,CAAC,SAAS,CAAC,SAAS,CAAG,WAEjC,IAAI,EAAU,IAAI,CAAC,UAAU,GAC7B,OAAO,CAAO,CAAE,EAAQ,MAAM,CAAG,EAAG,AAErC,EAIA,GAAM,KAAK,CAAC,SAAS,CAAC,UAAU,CAAG,SAAW,CAAS,EAItD,GAFM,GAAY,CAAA,EAAa,IAAI,CAAC,oBAAoB,CAAK,IAAI,CAAC,oBAAoB,CAAG,GAAzF,EAEK,IAAI,CAAC,eAAe,EACnB,IAAI,CAAC,eAAe,CAAC,MAAM,EAAI,EAAY,GAC7C,CAAC,IAAI,CAAC,WAAW,CAGpB,OAAO,IAAI,CAAC,eAAe,AAI5B,CAAA,IAAI,CAAC,WAAW,CAAG,CAAA,EAEnB,IACI,EACA,EAFA,EAAQ,EAAE,CACD,EAAO,IAAI,CAAC,QAAQ,CAAE,GAC5B,EAAM,EAIb,IAFA,EAAM,IAAI,CAAE,GAEN,EAAI,EAAG,GAAK,EAAW,IAI5B,EAAM,IAAI,CADV,GAAO,AADP,CAAA,EAAU,IAAI,CAAC,QAAQ,CAAG,EAAI,EAA9B,EACe,UAAU,CAAE,IAE3B,EAAO,EAMR,OAFA,IAAI,CAAC,eAAe,CAAG,EAEhB,CAER,EAGA,GAAM,KAAK,CAAC,SAAS,CAAC,gBAAgB,CAAG,WACxC,IAAI,CAAC,WAAW,CAAG,CAAA,EACnB,IAAI,CAAC,UAAU,EAChB,EAIA,GAAM,KAAK,CAAC,SAAS,CAAC,cAAc,CAAG,SAAW,CAAC,CAAE,CAAQ,EAE5D,IAAI,EAAa,IAAI,CAAC,UAAU,GAE5B,EAAI,EAAG,EAAK,EAAW,MAAM,CAMhC,EAFI,GAMc,EAAI,CAAU,CAAE,EAAK,EAAG,CAU3C,IAFA,IAhBI,EAgBwB,EAAxB,EAAM,EAAG,EAAO,EAAK,EAEjB,GAAO,GAAO,CAMrB,GAAK,AAFL,CAAA,EAAa,CAAU,CAFvB,EAAI,KAAK,KAAK,CAAE,EAAQ,AAAA,CAAA,EAAO,CAAA,EAAQ,GAEX,CAAG,CAA/B,EAEkB,EAAI,CAErB,EAAM,EAAI,EACV,QAED,CAAO,GAAK,EAAa,EAAI,CAE5B,EAAO,EAAI,EACX,QAED,CAEC,EAAO,EACP,KAMF,CAMA,GAAK,CAAU,CAJf,EAAI,EAIgB,EAAI,EAAkB,CAEzC,IAAI,EAAI,EAAM,CAAA,EAAK,CAAA,EACnB,OAAO,CAER,CAIA,IAAI,EAAe,CAAU,CAAE,EAAG,CAC3B,EAAc,CAAU,CAAE,EAAI,EAAG,CAUjC,EAAI,AAAE,CAAA,EAJY,AAAE,CAAA,EAAkB,CAAA,EAJtB,CAAA,EAAc,CAAlC,CAQc,EAAsB,CAAA,EAAI,CAAA,EAE3C,OAAO,CAER,EAOA,GAAM,KAAK,CAAC,SAAS,CAAC,UAAU,CAAG,SAAU,CAAC,EAG7C,IAAI,EAAK,EADG,KAER,EAAK,EAFG,KAMP,EAAK,GAAI,CAAA,EAAK,CAAA,EACd,EAAK,GAAI,CAAA,EAAK,CAAA,EAEnB,IAAI,EAAM,IAAI,CAAC,QAAQ,CAAE,GAIzB,OAAO,AADG,AAFA,IAAI,CAAC,QAAQ,CAAE,GAEX,KAAK,GAAG,GAAG,CAAC,GACf,SAAS,EAErB,EAGA,GAAM,KAAK,CAAC,SAAS,CAAC,YAAY,CAAG,SAAW,CAAC,EAEhD,IAAI,EAAI,IAAI,CAAC,cAAc,CAAE,GAC7B,OAAO,IAAI,CAAC,UAAU,CAAE,EAEzB,EAMA,GAAM,SAAS,CAAG,SAAW,CAAE,CAAE,CAAE,EAElC,IAAI,CAAC,EAAE,CAAG,EACV,IAAI,CAAC,EAAE,CAAG,CAEX,EAEA,GAAM,SAAS,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,KAAK,CAAC,SAAS,EAEhE,GAAM,SAAS,CAAC,SAAS,CAAC,QAAQ,CAAG,SAAW,CAAC,EAEhD,IAAI,EAAQ,IAAI,CAAC,EAAE,CAAC,KAAK,GAAG,GAAG,CAAC,IAAI,CAAC,EAAE,EAGvC,OAFA,EAAM,cAAc,CAAE,GAAI,GAAG,CAAE,IAAI,CAAC,EAAE,EAE/B,CAER,EAIA,GAAM,SAAS,CAAC,SAAS,CAAC,UAAU,CAAG,SAAW,CAAC,EAElD,OAAO,IAAI,CAAC,QAAQ,CAAE,EAEvB,EAEA,GAAM,SAAS,CAAC,SAAS,CAAC,UAAU,CAAG,SAAU,CAAC,EAIjD,OAAO,AAFO,IAAI,CAAC,EAAE,CAAC,KAAK,GAAG,GAAG,CAAC,IAAI,CAAC,EAAE,EAE1B,SAAS,EAEzB,EAOA,GAAM,oBAAoB,CAAG,SAAW,CAAE,CAAE,CAAE,CAAE,CAAE,EAEjD,IAAI,CAAC,EAAE,CAAG,EACV,IAAI,CAAC,EAAE,CAAG,EACV,IAAI,CAAC,EAAE,CAAG,CAEX,EAEA,GAAM,oBAAoB,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,KAAK,CAAC,SAAS,EAG3E,GAAM,oBAAoB,CAAC,SAAS,CAAC,QAAQ,CAAG,SAAW,CAAC,EAE3D,IAAI,EAAI,EAKR,OAHA,EAAK,GAAM,KAAK,CAAC,KAAK,CAAC,EAAE,CAAE,EAAG,IAAI,CAAC,EAAE,CAAC,CAAC,CAAE,IAAI,CAAC,EAAE,CAAC,CAAC,CAAE,IAAI,CAAC,EAAE,CAAC,CAAC,EAC7D,EAAK,GAAM,KAAK,CAAC,KAAK,CAAC,EAAE,CAAE,EAAG,IAAI,CAAC,EAAE,CAAC,CAAC,CAAE,IAAI,CAAC,EAAE,CAAC,CAAC,CAAE,IAAI,CAAC,EAAE,CAAC,CAAC,EAEtD,IAAI,GAAM,OAAO,CAAE,EAAI,EAE/B,EAGA,GAAM,oBAAoB,CAAC,SAAS,CAAC,UAAU,CAAG,SAAU,CAAC,EAI5D,EAAK,GAAM,KAAK,CAAC,KAAK,CAAC,sBAAsB,CAAE,EAAG,IAAI,CAAC,EAAE,CAAC,CAAC,CAAE,IAAI,CAAC,EAAE,CAAC,CAAC,CAAE,IAAI,CAAC,EAAE,CAAC,CAAC,EACjF,EAAK,GAAM,KAAK,CAAC,KAAK,CAAC,sBAAsB,CAAE,EAAG,IAAI,CAAC,EAAE,CAAC,CAAC,CAAE,IAAI,CAAC,EAAE,CAAC,CAAC,CAAE,IAAI,CAAC,EAAE,CAAC,CAAC,EAIjF,IAPI,EAAI,EAOJ,EAAU,IAAI,GAAM,OAAO,CAAE,EAAI,GAGrC,OAFA,EAAQ,SAAS,GAEV,CAER,EAOA,GAAM,gBAAgB,CAAG,SAAW,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,EAEjD,IAAI,CAAC,EAAE,CAAG,EACV,IAAI,CAAC,EAAE,CAAG,EACV,IAAI,CAAC,EAAE,CAAG,EACV,IAAI,CAAC,EAAE,CAAG,CAEX,EAEA,GAAM,gBAAgB,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,KAAK,CAAC,SAAS,EAEvE,GAAM,gBAAgB,CAAC,SAAS,CAAC,QAAQ,CAAG,SAAW,CAAC,EAEvD,IAAI,EAAI,EAKR,OAHA,EAAK,GAAM,KAAK,CAAC,KAAK,CAAC,EAAE,CAAE,EAAG,IAAI,CAAC,EAAE,CAAC,CAAC,CAAE,IAAI,CAAC,EAAE,CAAC,CAAC,CAAE,IAAI,CAAC,EAAE,CAAC,CAAC,CAAE,IAAI,CAAC,EAAE,CAAC,CAAC,EACxE,EAAK,GAAM,KAAK,CAAC,KAAK,CAAC,EAAE,CAAE,EAAG,IAAI,CAAC,EAAE,CAAC,CAAC,CAAE,IAAI,CAAC,EAAE,CAAC,CAAC,CAAE,IAAI,CAAC,EAAE,CAAC,CAAC,CAAE,IAAI,CAAC,EAAE,CAAC,CAAC,EAEjE,IAAI,GAAM,OAAO,CAAE,EAAI,EAE/B,EAEA,GAAM,gBAAgB,CAAC,SAAS,CAAC,UAAU,CAAG,SAAU,CAAC,EAIxD,EAAK,GAAM,KAAK,CAAC,KAAK,CAAC,kBAAkB,CAAE,EAAG,IAAI,CAAC,EAAE,CAAC,CAAC,CAAE,IAAI,CAAC,EAAE,CAAC,CAAC,CAAE,IAAI,CAAC,EAAE,CAAC,CAAC,CAAE,IAAI,CAAC,EAAE,CAAC,CAAC,EACxF,EAAK,GAAM,KAAK,CAAC,KAAK,CAAC,kBAAkB,CAAE,EAAG,IAAI,CAAC,EAAE,CAAC,CAAC,CAAE,IAAI,CAAC,EAAE,CAAC,CAAC,CAAE,IAAI,CAAC,EAAE,CAAC,CAAC,CAAE,IAAI,CAAC,EAAE,CAAC,CAAC,EAExF,IALI,EAAI,EAKJ,EAAU,IAAI,GAAM,OAAO,CAAE,EAAI,GAGrC,OAFA,EAAQ,SAAS,GAEV,CAER,EAOA,GAAM,WAAW,CAAG,SAAW,CAAA,EAE9B,IAAI,CAAC,MAAM,CAAI,AAAU,KAAA,GAAV,EAAuB,EAAE,CAAG,CAE5C,EAEA,GAAM,WAAW,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,KAAK,CAAC,SAAS,EAElE,GAAM,WAAW,CAAC,SAAS,CAAC,QAAQ,CAAG,SAAW,CAAC,EAElD,IAE0B,EAAO,EAAU,EAFvC,EAAI,IAAI,GAAM,OAAO,CACrB,EAAI,EAAE,CACN,EAAS,IAAI,CAAC,MAAM,CAcxB,OAXA,EAAW,KAAK,KAAK,CAFrB,EAAU,AAAA,CAAA,EAAO,MAAM,CAAG,CAAA,EAAM,GAGhC,EAAS,EAAQ,EAEjB,CAAC,CAAE,EAAG,CAAG,AAAY,GAAZ,EAAgB,EAAW,EAAW,EAC/C,CAAC,CAAE,EAAG,CAAG,EACT,CAAC,CAAE,EAAG,CAAG,EAAY,EAAO,MAAM,CAAG,EAAI,EAAO,MAAM,CAAE,EAAI,EAAW,EACvE,CAAC,CAAE,EAAG,CAAG,EAAY,EAAO,MAAM,CAAG,EAAI,EAAO,MAAM,CAAE,EAAI,EAAW,EAEvE,EAAE,CAAC,CAAG,GAAM,KAAK,CAAC,KAAK,CAAC,WAAW,CAAE,CAAM,CAAE,CAAC,CAAE,EAAG,CAAE,CAAC,CAAC,CAAE,CAAM,CAAE,CAAC,CAAE,EAAG,CAAE,CAAC,CAAC,CAAE,CAAM,CAAE,CAAC,CAAE,EAAG,CAAE,CAAC,CAAC,CAAE,CAAM,CAAE,CAAC,CAAE,EAAG,CAAE,CAAC,CAAC,CAAE,GACrH,EAAE,CAAC,CAAG,GAAM,KAAK,CAAC,KAAK,CAAC,WAAW,CAAE,CAAM,CAAE,CAAC,CAAE,EAAG,CAAE,CAAC,CAAC,CAAE,CAAM,CAAE,CAAC,CAAE,EAAG,CAAE,CAAC,CAAC,CAAE,CAAM,CAAE,CAAC,CAAE,EAAG,CAAE,CAAC,CAAC,CAAE,CAAM,CAAE,CAAC,CAAE,EAAG,CAAE,CAAC,CAAC,CAAE,GAE9G,CAER,EAMA,GAAM,YAAY,CAAG,SAAW,CAAE,CAAE,CAAE,CAAE,CAAO,CAAE,CAAO,CACjD,CAAW,CAAE,CAAS,CACtB,CAAU,EAEhB,IAAI,CAAC,EAAE,CAAG,EACV,IAAI,CAAC,EAAE,CAAG,EAEV,IAAI,CAAC,OAAO,CAAG,EACf,IAAI,CAAC,OAAO,CAAG,EAEf,IAAI,CAAC,WAAW,CAAG,EACnB,IAAI,CAAC,SAAS,CAAG,EAEjB,IAAI,CAAC,UAAU,CAAG,CAEnB,EAEA,GAAM,YAAY,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,KAAK,CAAC,SAAS,EAEnE,GAAM,YAAY,CAAC,SAAS,CAAC,QAAQ,CAAG,SAAW,CAAC,EAEnD,IAAI,EAAa,IAAI,CAAC,SAAS,CAAG,IAAI,CAAC,WAAW,AAE5C,CAAA,IAAI,CAAC,UAAU,EAEpB,CAAA,EAAI,EAAI,CAAA,EAIT,IAAI,EAAQ,IAAI,CAAC,WAAW,CAAG,EAAI,EAE/B,EAAK,IAAI,CAAC,EAAE,CAAG,IAAI,CAAC,OAAO,CAAG,KAAK,GAAG,CAAE,GACxC,EAAK,IAAI,CAAC,EAAE,CAAG,IAAI,CAAC,OAAO,CAAG,KAAK,GAAG,CAAE,GAE5C,OAAO,IAAI,GAAM,OAAO,CAAE,EAAI,EAE/B,EAMA,GAAM,QAAQ,CAAG,SAAW,CAAE,CAAE,CAAE,CAAE,CAAO,CAAE,CAAW,CAAE,CAAS,CAAE,CAAU,EAE9E,GAAM,YAAY,CAAC,IAAI,CAAE,IAAI,CAAE,EAAI,EAAI,EAAS,EAAS,EAAa,EAAW,EAClF,EAEA,GAAM,QAAQ,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,YAAY,CAAC,SAAS,EAOtE,GAAM,KAAK,CAAC,KAAK,CAAG,CAEnB,uBAAwB,SAAW,CAAC,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,EAE/C,OAAO,EAAM,CAAA,EAAI,CAAA,EAAQ,CAAA,EAAK,CAAA,EAAO,EAAI,EAAM,CAAA,EAAK,CAAA,CAErD,EAIA,mBAAoB,SAAU,CAAC,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,EAE9C,OAAO,GAAK,EAAM,CAAA,EAAI,CAAA,EAAM,CAAA,EAAI,CAAA,EAC/B,EAAI,EAAM,CAAA,EAAI,CAAA,EAAM,CAAA,EAAE,CAAA,EAAK,EAAG,EAAG,EAAM,CAAA,EAAE,CAAA,EACzC,EAAI,EAAK,EAAM,CAAA,EAAE,CAAA,EAAK,EAAI,EAAI,EAAI,EAClC,EAAI,EAAI,EAAI,CACd,EAGA,cAAe,SAAW,CAAC,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,EAS1C,OAAO,AALG,EAAI,EAAI,EAAI,EAAI,EAChB,CAAA,EAAI,EAAI,EAAI,EAAI,EAAI,CAAA,EACpB,CAAA,GAAK,EAAI,EAAI,EAAI,CAAA,EACjB,CAAA,EAAI,EAAI,EAAI,EAAI,CAAA,CAI3B,EAIA,YAAa,SAAU,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAC,EAEvC,IAAI,EAAK,AAAE,CAAA,EAAK,CAAA,EAAO,GACnB,EAAK,AAAE,CAAA,EAAK,CAAA,EAAO,GACnB,EAAK,EAAI,EAEb,OAAO,AADE,EAAI,EACJ,CAAA,EAAI,EAAK,EAAI,EAAK,EAAK,CAAA,EAAc,AAAA,CAAA,GAAM,EAAK,EAAI,EAAK,EAAI,EAAK,CAAA,EAAO,EAAK,EAAK,EAAI,CAEjG,CAED,EAWA,GAAM,KAAK,CAAC,MAAM,CAAG,SAAW,CAAW,CAAE,CAAY,EAKxD,OAHA,EAAY,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,KAAK,CAAC,SAAS,EAC5D,EAAY,SAAS,CAAC,QAAQ,CAAG,EAE1B,CAER,EAOA,GAAM,UAAU,CAAG,GAAM,KAAK,CAAC,MAAM,CAEpC,SAAW,CAAE,CAAE,CAAE,EAEhB,IAAI,CAAC,EAAE,CAAG,EACV,IAAI,CAAC,EAAE,CAAG,CAEX,EAEA,SAAW,CAAC,EAEX,IAAI,EAAI,IAAI,GAAM,OAAO,CAOzB,OAJA,EAAE,UAAU,CAAE,IAAI,CAAC,EAAE,CAAE,IAAI,CAAC,EAAE,EAC9B,EAAE,cAAc,CAAE,GAClB,EAAE,GAAG,CAAE,IAAI,CAAC,EAAE,EAEP,CAER,GASD,GAAM,qBAAqB,CAAG,GAAM,KAAK,CAAC,MAAM,CAE/C,SAAW,CAAE,CAAE,CAAE,CAAE,CAAE,EAEpB,IAAI,CAAC,EAAE,CAAG,EACV,IAAI,CAAC,EAAE,CAAG,EACV,IAAI,CAAC,EAAE,CAAG,CAEX,EAEA,SAAW,CAAC,EAEX,IAAI,EAAI,EAAI,EAMZ,OAJA,EAAK,GAAM,KAAK,CAAC,KAAK,CAAC,EAAE,CAAE,EAAG,IAAI,CAAC,EAAE,CAAC,CAAC,CAAE,IAAI,CAAC,EAAE,CAAC,CAAC,CAAE,IAAI,CAAC,EAAE,CAAC,CAAC,EAC7D,EAAK,GAAM,KAAK,CAAC,KAAK,CAAC,EAAE,CAAE,EAAG,IAAI,CAAC,EAAE,CAAC,CAAC,CAAE,IAAI,CAAC,EAAE,CAAC,CAAC,CAAE,IAAI,CAAC,EAAE,CAAC,CAAC,EAC7D,EAAK,GAAM,KAAK,CAAC,KAAK,CAAC,EAAE,CAAE,EAAG,IAAI,CAAC,EAAE,CAAC,CAAC,CAAE,IAAI,CAAC,EAAE,CAAC,CAAC,CAAE,IAAI,CAAC,EAAE,CAAC,CAAC,EAEtD,IAAI,GAAM,OAAO,CAAE,EAAI,EAAI,EAEnC,GAUD,GAAM,iBAAiB,CAAG,GAAM,KAAK,CAAC,MAAM,CAE3C,SAAW,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,EAExB,IAAI,CAAC,EAAE,CAAG,EACV,IAAI,CAAC,EAAE,CAAG,EACV,IAAI,CAAC,EAAE,CAAG,EACV,IAAI,CAAC,EAAE,CAAG,CAEX,EAEA,SAAW,CAAC,EAEX,IAAI,EAAI,EAAI,EAMZ,OAJA,EAAK,GAAM,KAAK,CAAC,KAAK,CAAC,EAAE,CAAE,EAAG,IAAI,CAAC,EAAE,CAAC,CAAC,CAAE,IAAI,CAAC,EAAE,CAAC,CAAC,CAAE,IAAI,CAAC,EAAE,CAAC,CAAC,CAAE,IAAI,CAAC,EAAE,CAAC,CAAC,EACxE,EAAK,GAAM,KAAK,CAAC,KAAK,CAAC,EAAE,CAAE,EAAG,IAAI,CAAC,EAAE,CAAC,CAAC,CAAE,IAAI,CAAC,EAAE,CAAC,CAAC,CAAE,IAAI,CAAC,EAAE,CAAC,CAAC,CAAE,IAAI,CAAC,EAAE,CAAC,CAAC,EACxE,EAAK,GAAM,KAAK,CAAC,KAAK,CAAC,EAAE,CAAE,EAAG,IAAI,CAAC,EAAE,CAAC,CAAC,CAAE,IAAI,CAAC,EAAE,CAAC,CAAC,CAAE,IAAI,CAAC,EAAE,CAAC,CAAC,CAAE,IAAI,CAAC,EAAE,CAAC,CAAC,EAEjE,IAAI,GAAM,OAAO,CAAE,EAAI,EAAI,EAEnC,GAWD,GAAM,YAAY,CAAG,GAAM,KAAK,CAAC,MAAM,CAEtC,SAAW,CAAA,EAEV,IAAI,CAAC,MAAM,CAAI,AAAU,KAAA,GAAV,EAAuB,EAAE,CAAG,CAE5C,EAEA,SAAW,CAAC,EAEX,IAE0B,EAAO,EAAU,EAFvC,EAAI,IAAI,GAAM,OAAO,CACrB,EAAI,EAAE,CACN,EAAS,IAAI,CAAC,MAAM,CAGxB,EAAW,KAAK,KAAK,CAFrB,EAAU,AAAA,CAAA,EAAO,MAAM,CAAG,CAAA,EAAM,GAGhC,EAAS,EAAQ,EAEjB,CAAC,CAAE,EAAG,CAAG,AAAY,GAAZ,EAAgB,EAAW,EAAW,EAC/C,CAAC,CAAE,EAAG,CAAG,EACT,CAAC,CAAE,EAAG,CAAG,EAAY,EAAO,MAAM,CAAG,EAAI,EAAO,MAAM,CAAG,EAAI,EAAW,EACxE,CAAC,CAAE,EAAG,CAAG,EAAY,EAAO,MAAM,CAAG,EAAI,EAAO,MAAM,CAAG,EAAI,EAAW,EAExE,IAAI,EAAM,CAAM,CAAE,CAAC,CAAC,EAAE,CAAE,CACvB,EAAM,CAAM,CAAE,CAAC,CAAC,EAAE,CAAE,CACpB,EAAM,CAAM,CAAE,CAAC,CAAC,EAAE,CAAE,CACpB,EAAM,CAAM,CAAE,CAAC,CAAC,EAAE,CAAE,CAMrB,OAJA,EAAE,CAAC,CAAG,GAAM,KAAK,CAAC,KAAK,CAAC,WAAW,CAAC,EAAI,CAAC,CAAE,EAAI,CAAC,CAAE,EAAI,CAAC,CAAE,EAAI,CAAC,CAAE,GAChE,EAAE,CAAC,CAAG,GAAM,KAAK,CAAC,KAAK,CAAC,WAAW,CAAC,EAAI,CAAC,CAAE,EAAI,CAAC,CAAE,EAAI,CAAC,CAAE,EAAI,CAAC,CAAE,GAChE,EAAE,CAAC,CAAG,GAAM,KAAK,CAAC,KAAK,CAAC,WAAW,CAAC,EAAI,CAAC,CAAE,EAAI,CAAC,CAAE,EAAI,CAAC,CAAE,EAAI,CAAC,CAAE,GAEzD,CAER,GAsCD,GAAM,kBAAkB,CAAG,GAAM,KAAK,CAAC,MAAM,CAE5C,SAAW,CAAA,EAEV,IAAI,CAAC,MAAM,CAAI,AAAU,KAAA,GAAV,EAAuB,EAAE,CAAG,CAE5C,EAEG,SAAW,CAAC,EAER,IAE0B,EAAO,EAAU,EAFvC,EAAI,IAAI,GAAM,OAAO,CACrB,EAAI,EAAE,CACN,EAAS,IAAI,CAAC,MAAM,CAiBxB,OAbA,EAAW,KAAK,KAAK,CAHrB,EAAU,AAAA,CAAA,EAAO,MAAM,CAAG,CAAA,EAAM,GAIhC,EAAS,EAAQ,EAEjB,GAAY,EAAW,EAAI,EAAM,AAAA,CAAA,KAAK,KAAK,CAAE,KAAK,GAAG,CAAE,GAAa,EAAO,MAAM,EAAK,CAAA,EAAM,EAAO,MAAM,CACzG,CAAC,CAAE,EAAG,CAAK,AAAA,CAAA,EAAW,CAAA,EAAM,EAAO,MAAM,CACzC,CAAC,CAAE,EAAG,CAAG,EAAe,EAAO,MAAM,CACrC,CAAC,CAAE,EAAG,CAAK,AAAA,CAAA,EAAW,CAAA,EAAM,EAAO,MAAM,CACzC,CAAC,CAAE,EAAG,CAAK,AAAA,CAAA,EAAW,CAAA,EAAM,EAAO,MAAM,CAEzC,EAAE,CAAC,CAAG,GAAM,KAAK,CAAC,KAAK,CAAC,WAAW,CAAE,CAAM,CAAE,CAAC,CAAE,EAAG,CAAE,CAAC,CAAC,CAAE,CAAM,CAAE,CAAC,CAAE,EAAG,CAAE,CAAC,CAAC,CAAE,CAAM,CAAE,CAAC,CAAE,EAAG,CAAE,CAAC,CAAC,CAAE,CAAM,CAAE,CAAC,CAAE,EAAG,CAAE,CAAC,CAAC,CAAE,GACrH,EAAE,CAAC,CAAG,GAAM,KAAK,CAAC,KAAK,CAAC,WAAW,CAAE,CAAM,CAAE,CAAC,CAAE,EAAG,CAAE,CAAC,CAAC,CAAE,CAAM,CAAE,CAAC,CAAE,EAAG,CAAE,CAAC,CAAC,CAAE,CAAM,CAAE,CAAC,CAAE,EAAG,CAAE,CAAC,CAAC,CAAE,CAAM,CAAE,CAAC,CAAE,EAAG,CAAE,CAAC,CAAC,CAAE,GACrH,EAAE,CAAC,CAAG,GAAM,KAAK,CAAC,KAAK,CAAC,WAAW,CAAE,CAAM,CAAE,CAAC,CAAE,EAAG,CAAE,CAAC,CAAC,CAAE,CAAM,CAAE,CAAC,CAAE,EAAG,CAAE,CAAC,CAAC,CAAE,CAAM,CAAE,CAAC,CAAE,EAAG,CAAE,CAAC,CAAC,CAAE,CAAM,CAAE,CAAC,CAAE,EAAG,CAAE,CAAC,CAAC,CAAE,GAE9G,CAEX,GAaJ,GAAM,SAAS,CAAG,WAEjB,IAAI,CAAC,MAAM,CAAG,EAAE,CAChB,IAAI,CAAC,KAAK,CAAG,EAAE,CAEf,IAAI,CAAC,SAAS,CAAG,CAAA,CAClB,EAEA,GAAM,SAAS,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,KAAK,CAAC,SAAS,EAEhE,GAAM,SAAS,CAAC,SAAS,CAAC,GAAG,CAAG,SAAW,CAAK,EAE/C,IAAI,CAAC,MAAM,CAAC,IAAI,CAAE,EAEnB,EAEA,GAAM,SAAS,CAAC,SAAS,CAAC,eAAe,CAAG,WAI5C,EAEA,GAAM,SAAS,CAAC,SAAS,CAAC,SAAS,CAAG,WAIrC,IAAI,EAAa,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,QAAQ,CAAC,GACrC,EAAW,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,QAAQ,CAAC,GAErD,EAAW,MAAM,CAAC,IACtB,IAAI,CAAC,MAAM,CAAC,IAAI,CAAE,IAAI,GAAM,SAAS,CAAC,EAAU,GAGlD,EAWA,GAAM,SAAS,CAAC,SAAS,CAAC,QAAQ,CAAG,SAAU,CAAC,EAQ/C,IANA,IAEiB,EAFb,EAAI,EAAI,IAAI,CAAC,SAAS,GACtB,EAAe,IAAI,CAAC,eAAe,GACnC,EAAI,EAIA,EAAI,EAAa,MAAM,EAAG,CAEjC,GAAK,CAAY,CAAE,EAAG,EAAI,EAAI,CAK7B,IAAI,EAAI,EAAI,AAHL,CAAA,CAAY,CAAE,EAAG,CAAG,CAAA,EAGR,AAFnB,CAAA,EAAQ,IAAI,CAAC,MAAM,CAAE,EAAG,AAAH,EAEI,SAAS,GAElC,OAAO,EAAM,UAAU,CAAE,EAG1B,CAEA,GAED,CAEA,OAAO,IAIR,EAWA,GAAM,SAAS,CAAC,SAAS,CAAC,SAAS,CAAG,WAErC,IAAI,EAAO,IAAI,CAAC,eAAe,GAC/B,OAAO,CAAI,CAAE,EAAK,MAAM,CAAG,EAAG,AAE/B,EAKA,GAAM,SAAS,CAAC,SAAS,CAAC,eAAe,CAAG,WAI3C,GAAK,IAAI,CAAC,YAAY,EAAI,IAAI,CAAC,YAAY,CAAC,MAAM,EAAI,IAAI,CAAC,MAAM,CAAC,MAAM,CAEvE,OAAO,IAAI,CAAC,YAAY,CAOzB,IACI,EADA,EAAU,EAAE,CAAE,EAAO,EAClB,EAAK,IAAI,CAAC,MAAM,CAAC,MAAM,CAE9B,IAAM,EAAI,EAAG,EAAI,EAAI,IAGpB,EAAQ,IAAI,CADZ,GAAQ,IAAI,CAAC,MAAM,CAAE,EAAG,CAAC,SAAS,IAOnC,OAFA,IAAI,CAAC,YAAY,CAAG,EAEb,CAER,EAMA,GAAM,SAAS,CAAC,SAAS,CAAC,cAAc,CAAG,WAE1C,IAEI,EAAM,EAAM,EACZ,EAAM,EAAM,EAKZ,EAAG,EAAG,EAAI,EARV,EAAS,IAAI,CAAC,SAAS,GAK3B,EAAO,EAAO,OAAO,iBAAiB,CACtC,EAAO,EAAO,OAAO,iBAAiB,CAItC,IAAI,EAAK,CAAM,CAAC,EAAE,WAAY,GAAM,OAAO,CAI3C,IAAM,EAAI,EAFV,EAAM,EAAK,IAAI,GAAM,OAAO,CAAK,IAAI,GAAM,OAAO,CAErC,EAAK,EAAO,MAAM,CAAE,EAAI,EAAI,IAInC,AAFL,CAAA,EAAI,CAAM,CAAE,EAAG,AAAH,EAEL,CAAC,CAAG,EAAO,EAAO,EAAE,CAAC,CAClB,EAAE,CAAC,CAAG,GAAO,CAAA,EAAO,EAAE,CAAC,AAAD,EAE3B,EAAE,CAAC,CAAG,EAAO,EAAO,EAAE,CAAC,CAClB,EAAE,CAAC,CAAG,GAAO,CAAA,EAAO,EAAE,CAAC,AAAD,EAE3B,IAEC,EAAE,CAAC,CAAG,EAAO,EAAO,EAAE,CAAC,CAClB,EAAE,CAAC,CAAG,GAAO,CAAA,EAAO,EAAE,CAAC,AAAD,GAIjC,EAAI,GAAG,CAAE,GAIV,IAAI,EAAM,CAET,KAAM,EACN,KAAM,EACN,KAAM,EACN,KAAM,EACN,SAAU,EAAI,YAAY,CAAE,EAE7B,EASA,OAPK,IAEJ,EAAI,IAAI,CAAG,EACX,EAAI,IAAI,CAAG,GAIL,CAER,EAQA,GAAM,SAAS,CAAC,SAAS,CAAC,oBAAoB,CAAG,SAAU,CAAS,EAEnE,IAAI,EAAM,IAAI,CAAC,SAAS,CAAE,EAAW,CAAA,GACrC,OAAO,IAAI,CAAC,cAAc,CAAE,EAE7B,EAIA,GAAM,SAAS,CAAC,SAAS,CAAC,0BAA0B,CAAG,SAAU,CAAS,EAEzE,IAAI,EAAM,IAAI,CAAC,eAAe,CAAE,EAAW,CAAA,GAC3C,OAAO,IAAI,CAAC,cAAc,CAAE,EAE7B,EAEA,GAAM,SAAS,CAAC,SAAS,CAAC,cAAc,CAAG,SAAU,CAAM,EAI1D,IAAM,IAFF,EAAW,IAAI,GAAM,QAAQ,CAEvB,EAAI,EAAG,EAAI,EAAO,MAAM,CAAE,IAEnC,EAAS,QAAQ,CAAC,IAAI,CAAE,IAAI,GAAM,OAAO,CAAE,CAAM,CAAE,EAAG,CAAC,CAAC,CAAE,CAAM,CAAE,EAAG,CAAC,CAAC,CAAE,CAAM,CAAE,EAAG,CAAC,CAAC,EAAI,IAI3F,OAAO,CAER,EASA,GAAM,SAAS,CAAC,SAAS,CAAC,WAAW,CAAG,SAAW,CAAQ,EAE1D,IAAI,CAAC,KAAK,CAAC,IAAI,CAAE,EAElB,EAEA,GAAM,SAAS,CAAC,SAAS,CAAC,oBAAoB,CAAG,SAAU,CAAQ,CAAE,CAAK,EAEzE,IACI,EAAG,EADH,EAAS,IAAI,CAAC,SAAS,CAAE,GAS7B,IAAM,AANA,GAEL,CAAA,EAAQ,IAAI,CAAC,KAAK,AAAL,EAIR,EAAI,EAAG,EAAK,EAAM,MAAM,CAAE,EAAI,EAAI,IAEvC,EAAS,IAAI,CAAC,aAAa,CAAE,EAAQ,CAAK,CAAE,EAAG,EAIhD,OAAO,CAER,EAEA,GAAM,SAAS,CAAC,SAAS,CAAC,0BAA0B,CAAG,SAAU,CAAQ,CAAE,CAAK,EAE/E,IAEI,EAAG,EAFH,EAAS,IAAI,CAAC,eAAe,CAAE,GAUnC,IAAM,AANA,GAEL,CAAA,EAAQ,IAAI,CAAC,KAAK,AAAL,EAIR,EAAI,EAAG,EAAK,EAAM,MAAM,CAAE,EAAI,EAAI,IAEvC,EAAS,IAAI,CAAC,aAAa,CAAE,EAAQ,CAAK,CAAE,EAAG,EAIhD,OAAO,CAER,EAKA,GAAM,SAAS,CAAC,SAAS,CAAC,aAAa,CAAG,SAAW,CAAM,CAAE,CAAI,EAEhE,IAEI,EAAG,EAAI,EAAG,EAAM,EAAM,EAFtB,EAAS,IAAI,CAAC,cAAc,GAIhC,IAAM,EAAI,EAAG,EAAK,EAAO,MAAM,CAAE,EAAI,EAAI,IAAO,CAI/C,EAAO,AAFP,CAAA,EAAI,CAAM,CAAE,EAAG,AAAH,EAEH,CAAC,CACV,EAAO,EAAE,CAAC,CAEV,EAAQ,EAAO,EAAO,IAAI,CAK1B,EAAQ,EAAK,cAAc,CAAE,EAAO,GAIpC,IAAI,EAAS,EAAK,QAAQ,CAAE,GACxB,EAAS,EAAK,eAAe,CAAE,GAAQ,cAAc,CAAE,EAE3D,CAAA,EAAE,CAAC,CAAG,EAAO,CAAC,CAAG,EAAO,CAAC,CACzB,EAAE,CAAC,CAAG,EAAO,CAAC,CAAG,EAAO,CAAC,AAE1B,CAEA,OAAO,CAER,EAMA,GAAM,SAAS,CAAG,WAEjB,GAAM,QAAQ,CAAC,IAAI,CAAE,IAAI,CAE1B,EAEA,GAAM,SAAS,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,QAAQ,CAAC,SAAS,EAEnE,GAAM,SAAS,CAAC,SAAS,CAAC,iBAAiB,CAAG,SAAW,CAAK,EAE7D,IAAI,CAAC,gBAAgB,EAAI,IAAI,CAAC,YAAY,GAIrC,CAAA,IAAI,CAAC,sBAAsB,EAAI,CAAA,IAE9B,IAAI,CAAC,MAAM,EAEf,IAAI,CAAC,WAAW,CAAC,gBAAgB,CAAE,IAAI,CAAC,MAAM,CAAC,WAAW,CAAE,IAAI,CAAC,MAAM,EAEvE,IAAI,CAAC,WAAW,CAAC,SAAS,CAAE,IAAI,CAAC,gBAAgB,CAAE,IAAI,CAAC,aAAa,CAAE,IAAI,CAAC,UAAU,EACtF,IAAI,CAAC,MAAM,CAAC,SAAS,CAAE,IAAI,CAAC,iBAAiB,CAAE,IAAI,CAAC,cAAc,CAAE,IAAI,CAAC,WAAW,EAEpF,IAAI,CAAC,WAAW,CAAC,OAAO,CAAE,IAAI,CAAC,gBAAgB,CAAE,IAAI,CAAC,cAAc,CAAE,IAAI,CAAC,UAAU,GAKrF,IAAI,CAAC,WAAW,CAAC,IAAI,CAAE,IAAI,CAAC,MAAM,EAKnC,IAAI,CAAC,sBAAsB,CAAG,CAAA,EAE9B,EAAQ,CAAA,GAMT,IAAM,IAAI,EAAI,EAAG,EAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAE,EAAI,EAAG,IAEjD,IAAI,CAAC,QAAQ,CAAE,EAAG,CAAC,iBAAiB,CAAE,EAIxC,EAEA,GAAM,SAAS,CAAC,SAAS,CAAC,gBAAgB,CAAG,IAAI,GAAM,OAAO,CAC9D,GAAM,SAAS,CAAC,SAAS,CAAC,iBAAiB,CAAG,IAAI,GAAM,OAAO,CAC/D,GAAM,SAAS,CAAC,SAAS,CAAC,aAAa,CAAG,IAAI,GAAM,UAAU,CAC9D,GAAM,SAAS,CAAC,SAAS,CAAC,cAAc,CAAG,IAAI,GAAM,UAAU,CAC/D,GAAM,SAAS,CAAC,SAAS,CAAC,UAAU,CAAG,IAAI,GAAM,OAAO,CACxD,GAAM,SAAS,CAAC,SAAS,CAAC,WAAW,CAAG,IAAI,GAAM,OAAO,CAQzD,GAAM,IAAI,CAAG,SAAW,CAAM,EAE7B,GAAM,SAAS,CAAC,IAAI,CAAC,IAAI,EAEzB,IAAI,CAAC,OAAO,CAAG,EAAE,CAEZ,GAEJ,IAAI,CAAC,UAAU,CAAE,EAInB,EAEA,GAAM,IAAI,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,SAAS,CAAC,SAAS,EAE/D,GAAM,WAAW,CAAG,CAEnB,QAAS,SACT,QAAS,SACT,mBAAoB,mBACpB,gBAAiB,gBACjB,aAAc,aACd,IAAK,MACL,QAAS,SACV,EAOA,GAAM,IAAI,CAAC,SAAS,CAAC,UAAU,CAAG,SAAW,CAAO,EAEnD,IAAI,CAAC,MAAM,CAAE,CAAO,CAAE,EAAG,CAAC,CAAC,CAAE,CAAO,CAAE,EAAG,CAAC,CAAC,EAE3C,IAAM,IAAI,EAAI,EAAG,EAAO,EAAQ,MAAM,CAAE,EAAI,EAAM,IAEjD,IAAI,CAAC,MAAM,CAAE,CAAO,CAAE,EAAG,CAAC,CAAC,CAAE,CAAO,CAAE,EAAG,CAAC,CAAC,CAI7C,EAIA,GAAM,IAAI,CAAC,SAAS,CAAC,MAAM,CAAG,SAAW,CAAC,CAAE,CAAC,EAE5C,IAAI,EAAO,MAAM,SAAS,CAAC,KAAK,CAAC,IAAI,CAAE,WACvC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAE,CAAE,OAAQ,GAAM,WAAW,CAAC,OAAO,CAAE,KAAM,CAAK,EAEpE,EAEA,GAAM,IAAI,CAAC,SAAS,CAAC,MAAM,CAAG,SAAW,CAAC,CAAE,CAAC,EAE5C,IAAI,EAAO,MAAM,SAAS,CAAC,KAAK,CAAC,IAAI,CAAE,WAEnC,EAAW,IAAI,CAAC,OAAO,CAAE,IAAI,CAAC,OAAO,CAAC,MAAM,CAAG,EAAG,CAAC,IAAI,CAEvD,EAAK,CAAQ,CAAE,EAAS,MAAM,CAAG,EAAG,CACpC,EAAK,CAAQ,CAAE,EAAS,MAAM,CAAG,EAAG,CAEpC,EAAQ,IAAI,GAAM,SAAS,CAAE,IAAI,GAAM,OAAO,CAAE,EAAI,GAAM,IAAI,GAAM,OAAO,CAAE,EAAG,IACpF,IAAI,CAAC,MAAM,CAAC,IAAI,CAAE,GAElB,IAAI,CAAC,OAAO,CAAC,IAAI,CAAE,CAAE,OAAQ,GAAM,WAAW,CAAC,OAAO,CAAE,KAAM,CAAK,EAEpE,EAEA,GAAM,IAAI,CAAC,SAAS,CAAC,gBAAgB,CAAG,SAAU,CAAI,CAAE,CAAI,CAAE,CAAE,CAAE,CAAE,EAEnE,IAAI,EAAO,MAAM,SAAS,CAAC,KAAK,CAAC,IAAI,CAAE,WAEnC,EAAW,IAAI,CAAC,OAAO,CAAE,IAAI,CAAC,OAAO,CAAC,MAAM,CAAG,EAAG,CAAC,IAAI,CAEvD,EAAK,CAAQ,CAAE,EAAS,MAAM,CAAG,EAAG,CACpC,EAAK,CAAQ,CAAE,EAAS,MAAM,CAAG,EAAG,CAEpC,EAAQ,IAAI,GAAM,oBAAoB,CAAE,IAAI,GAAM,OAAO,CAAE,EAAI,GACxD,IAAI,GAAM,OAAO,CAAE,EAAM,GACzB,IAAI,GAAM,OAAO,CAAE,EAAI,IAClC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAE,GAElB,IAAI,CAAC,OAAO,CAAC,IAAI,CAAE,CAAE,OAAQ,GAAM,WAAW,CAAC,kBAAkB,CAAE,KAAM,CAAK,EAE/E,EAEA,GAAM,IAAI,CAAC,SAAS,CAAC,aAAa,CAAG,SAAU,CAAK,CAAE,CAAK,CACZ,CAAK,CAAE,CAAK,CACZ,CAAE,CAAE,CAAE,EAEpD,IAAI,EAAO,MAAM,SAAS,CAAC,KAAK,CAAC,IAAI,CAAE,WAEnC,EAAW,IAAI,CAAC,OAAO,CAAE,IAAI,CAAC,OAAO,CAAC,MAAM,CAAG,EAAG,CAAC,IAAI,CAEvD,EAAK,CAAQ,CAAE,EAAS,MAAM,CAAG,EAAG,CACpC,EAAK,CAAQ,CAAE,EAAS,MAAM,CAAG,EAAG,CAEpC,EAAQ,IAAI,GAAM,gBAAgB,CAAE,IAAI,GAAM,OAAO,CAAE,EAAI,GACrD,IAAI,GAAM,OAAO,CAAE,EAAO,GAC1B,IAAI,GAAM,OAAO,CAAE,EAAO,GAC1B,IAAI,GAAM,OAAO,CAAE,EAAI,IACjC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAE,GAElB,IAAI,CAAC,OAAO,CAAC,IAAI,CAAE,CAAE,OAAQ,GAAM,WAAW,CAAC,eAAe,CAAE,KAAM,CAAK,EAE5E,EAEA,GAAM,IAAI,CAAC,SAAS,CAAC,UAAU,CAAG,SAAU,CAAA,EAE3C,IAAI,EAAO,MAAM,SAAS,CAAC,KAAK,CAAC,IAAI,CAAE,WACnC,EAAW,IAAI,CAAC,OAAO,CAAE,IAAI,CAAC,OAAO,CAAC,MAAM,CAAG,EAAG,CAAC,IAAI,CAEvD,EAAK,CAAQ,CAAE,EAAS,MAAM,CAAG,EAAG,CACpC,EAAK,CAAQ,CAAE,EAAS,MAAM,CAAG,EAAG,CAEpC,EAAO,CAAE,IAAI,GAAM,OAAO,CAAE,EAAI,GAAM,CAC1C,MAAM,SAAS,CAAC,IAAI,CAAC,KAAK,CAAE,EAAM,GAElC,IAAI,EAAQ,IAAI,GAAM,WAAW,CAAE,GACnC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAE,GAElB,IAAI,CAAC,OAAO,CAAC,IAAI,CAAE,CAAE,OAAQ,GAAM,WAAW,CAAC,YAAY,CAAE,KAAM,CAAK,EAEzE,EAIA,GAAM,IAAI,CAAC,SAAS,CAAC,GAAG,CAAG,SAAW,CAAE,CAAE,CAAE,CAAE,CAAO,CAC1C,CAAW,CAAE,CAAS,CAAE,CAAU,EAE5C,IAAI,EAAW,IAAI,CAAC,OAAO,CAAE,IAAI,CAAC,OAAO,CAAC,MAAM,CAAG,EAAE,CAAC,IAAI,CACtD,EAAK,CAAQ,CAAE,EAAS,MAAM,CAAG,EAAG,CACpC,EAAK,CAAQ,CAAE,EAAS,MAAM,CAAG,EAAG,CAExC,IAAI,CAAC,MAAM,CAAC,EAAK,EAAI,EAAK,EAAI,EAC7B,EAAa,EAAW,EAEzB,EAEA,GAAM,IAAI,CAAC,SAAS,CAAC,MAAM,CAAG,SAAW,CAAE,CAAE,CAAE,CAAE,CAAO,CAC9C,CAAW,CAAE,CAAS,CAAE,CAAU,EAC5C,IAAI,CAAC,UAAU,CAAC,EAAI,EAAI,EAAS,EAAS,EAAa,EAAW,EAClE,EAED,GAAM,IAAI,CAAC,SAAS,CAAC,OAAO,CAAG,SAAW,CAAE,CAAE,CAAE,CAAE,CAAO,CAAE,CAAO,CACvD,CAAW,CAAE,CAAS,CAAE,CAAU,EAE5C,IAAI,EAAW,IAAI,CAAC,OAAO,CAAE,IAAI,CAAC,OAAO,CAAC,MAAM,CAAG,EAAE,CAAC,IAAI,CACtD,EAAK,CAAQ,CAAE,EAAS,MAAM,CAAG,EAAG,CACpC,EAAK,CAAQ,CAAE,EAAS,MAAM,CAAG,EAAG,CAExC,IAAI,CAAC,UAAU,CAAC,EAAK,EAAI,EAAK,EAAI,EAAS,EAC1C,EAAa,EAAW,EAEzB,EAGD,GAAM,IAAI,CAAC,SAAS,CAAC,UAAU,CAAG,SAAW,CAAE,CAAE,CAAE,CAAE,CAAO,CAAE,CAAO,CAC1D,CAAW,CAAE,CAAS,CAAE,CAAU,EAE5C,IAAI,EAAO,MAAM,SAAS,CAAC,KAAK,CAAC,IAAI,CAAE,WACnC,EAAQ,IAAI,GAAM,YAAY,CAAE,EAAI,EAAI,EAAS,EAC7C,EAAa,EAAW,GAChC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAE,GAElB,IAAI,EAAY,EAAM,QAAQ,CAAC,EAAa,EAAI,GAChD,EAAK,IAAI,CAAC,EAAU,CAAC,EACrB,EAAK,IAAI,CAAC,EAAU,CAAC,EAErB,IAAI,CAAC,OAAO,CAAC,IAAI,CAAE,CAAE,OAAQ,GAAM,WAAW,CAAC,OAAO,CAAE,KAAM,CAAK,EAEnE,EAED,GAAM,IAAI,CAAC,SAAS,CAAC,eAAe,CAAG,SAAW,CAAS,CAAE,CAAU,EAE/D,GAAY,CAAA,EAAY,EAA/B,EAIA,IAAM,IAFF,EAAS,EAAE,CAEL,EAAI,EAAG,EAAI,EAAW,IAE/B,EAAO,IAAI,CAAE,IAAI,CAAC,QAAQ,CAAE,EAAI,IAYjC,OAAO,CAER,EAIA,GAAM,IAAI,CAAC,SAAS,CAAC,SAAS,CAAG,SAAU,CAAS,CAAE,CAAU,EAE/D,GAAI,IAAI,CAAC,eAAe,CAEvB,OADA,QAAQ,GAAG,CAAC,QACL,IAAI,CAAC,eAAe,CAAE,EAAW,GAGzC,EAAY,GAAa,GAEzB,IAAI,EAAS,EAAE,CAOf,IAAM,EAAI,EAAG,EAAK,IAAI,CAAC,OAAO,CAAC,MAAM,CAAE,EAAI,EAAI,IAO9C,OAHA,EAAS,AAFT,CAAA,EAAO,IAAI,CAAC,OAAO,CAAE,EAAG,AAAH,EAEP,MAAM,CACpB,EAAO,EAAK,IAAI,CAER,GAER,KAAK,GAAM,WAAW,CAAC,OAAO,CAM9B,KAAK,GAAM,WAAW,CAAC,OAAO,CAJ7B,EAAO,IAAI,CAAE,IAAI,GAAM,OAAO,CAAE,CAAI,CAAE,EAAG,CAAE,CAAI,CAAE,EAAG,GAEpD,KAQD,MAAK,GAAM,WAAW,CAAC,kBAAkB,CAwBxC,IAtBA,EAAO,CAAI,CAAE,EAAG,CAChB,EAAO,CAAI,CAAE,EAAG,CAEhB,EAAO,CAAI,CAAE,EAAG,CAChB,EAAO,CAAI,CAAE,EAAG,CAEX,EAAO,MAAM,CAAG,GAIpB,EAAO,AAFP,CAAA,EAAQ,CAAM,CAAE,EAAO,MAAM,CAAG,EAAG,AAAH,EAEnB,CAAC,CACd,EAAO,EAAM,CAAC,GAMd,EAAO,AAFP,CAAA,EAAQ,IAAI,CAAC,OAAO,CAAE,EAAI,EAAG,CAAC,IAAI,AAAJ,CAElB,CAAE,EAAM,MAAM,CAAG,EAAG,CAChC,EAAO,CAAK,CAAE,EAAM,MAAM,CAAG,EAAG,EAI3B,EAAI,EAAG,GAAK,EAAW,IAE5B,EAAI,EAAI,EAER,EAAK,GAAM,KAAK,CAAC,KAAK,CAAC,EAAE,CAAE,EAAG,EAAM,EAAM,GAC1C,EAAK,GAAM,KAAK,CAAC,KAAK,CAAC,EAAE,CAAE,EAAG,EAAM,EAAM,GAE1C,EAAO,IAAI,CAAE,IAAI,GAAM,OAAO,CAAE,EAAI,IAIrC,KAED,MAAK,GAAM,WAAW,CAAC,eAAe,CA4BrC,IA1BA,EAAO,CAAI,CAAE,EAAG,CAChB,EAAO,CAAI,CAAE,EAAG,CAEhB,EAAO,CAAI,CAAE,EAAG,CAChB,EAAO,CAAI,CAAE,EAAG,CAEhB,EAAO,CAAI,CAAE,EAAG,CAChB,EAAO,CAAI,CAAE,EAAG,CAEX,EAAO,MAAM,CAAG,GAIpB,EAAO,AAFP,CAAA,EAAQ,CAAM,CAAE,EAAO,MAAM,CAAG,EAAG,AAAH,EAEnB,CAAC,CACd,EAAO,EAAM,CAAC,GAMd,EAAO,AAFP,CAAA,EAAQ,IAAI,CAAC,OAAO,CAAE,EAAI,EAAG,CAAC,IAAI,AAAJ,CAElB,CAAE,EAAM,MAAM,CAAG,EAAG,CAChC,EAAO,CAAK,CAAE,EAAM,MAAM,CAAG,EAAG,EAK3B,EAAI,EAAG,GAAK,EAAW,IAE5B,EAAI,EAAI,EAER,EAAK,GAAM,KAAK,CAAC,KAAK,CAAC,EAAE,CAAE,EAAG,EAAM,EAAM,EAAM,GAChD,EAAK,GAAM,KAAK,CAAC,KAAK,CAAC,EAAE,CAAE,EAAG,EAAM,EAAM,EAAM,GAEhD,EAAO,IAAI,CAAE,IAAI,GAAM,OAAO,CAAE,EAAI,IAIrC,KAED,MAAK,GAAM,WAAW,CAAC,YAAY,CAElC,EAAQ,IAAI,CAAC,OAAO,CAAE,EAAI,EAAG,CAAC,IAAI,CAGlC,IAAI,EAAO,CADA,IAAI,GAAM,OAAO,CAAE,CAAK,CAAE,EAAM,MAAM,CAAG,EAAG,CAAE,CAAK,CAAE,EAAM,MAAM,CAAG,EAAG,EAC/D,CAEf,EAAI,EAAY,CAAI,CAAE,EAAG,CAAC,MAAM,CAEpC,EAAO,EAAK,MAAM,CAAE,CAAI,CAAE,EAAG,EAE7B,IAAI,EAAS,IAAI,GAAM,WAAW,CAAE,GAEpC,IAAM,EAAI,EAAG,GAAK,EAAG,IAEpB,EAAO,IAAI,CAAE,EAAO,UAAU,CAAE,EAAI,IAIrC,KAED,MAAK,GAAM,WAAW,CAAC,GAAG,CAEzB,IA/HE,EAAG,EAAI,EAAM,EAAQ,EACrB,EAAK,EAAK,EAAM,EAAM,EAAM,EAAM,EAAM,EAC3C,EAAO,EACP,EAAG,EAAI,EAkIF,EANA,EAAK,CAAI,CAAE,EAAG,CAAE,EAAK,CAAI,CAAE,EAAG,CACjC,EAAU,CAAI,CAAE,EAAG,CACnB,EAAc,CAAI,CAAE,EAAG,CAAE,EAAY,CAAI,CAAE,EAAG,CAC9C,EAAa,CAAC,CAAC,CAAI,CAAE,EAAG,CAErB,EAAa,EAAY,EAEzB,EAAa,AAAY,EAAZ,EAEjB,IAAM,EAAI,EAAG,GAAK,EAAY,IAE7B,EAAI,EAAI,EAED,GAEN,CAAA,EAAI,EAAI,CAAA,EAMT,EAAK,EAAK,EAAU,KAAK,GAAG,CAF5B,EAAQ,EAAc,EAAI,GAG1B,EAAK,EAAK,EAAU,KAAK,GAAG,CAAE,GAI9B,EAAO,IAAI,CAAE,IAAI,GAAM,OAAO,CAAE,EAAI,IAMpC,KAEF,MAAK,GAAM,WAAW,CAAC,OAAO,CAE7B,IAQI,EARA,EAAK,CAAI,CAAE,EAAG,CAAE,EAAK,CAAI,CAAE,EAAG,CACjC,EAAU,CAAI,CAAE,EAAG,CACnB,EAAU,CAAI,CAAE,EAAG,CACnB,EAAc,CAAI,CAAE,EAAG,CAAE,EAAY,CAAI,CAAE,EAAG,CAC9C,EAAa,CAAC,CAAC,CAAI,CAAE,EAAG,CAGrB,EAAa,EAAY,EAEzB,EAAa,AAAY,EAAZ,EAEjB,IAAM,EAAI,EAAG,GAAK,EAAY,IAE7B,EAAI,EAAI,EAED,GAEN,CAAA,EAAI,EAAI,CAAA,EAMT,EAAK,EAAK,EAAU,KAAK,GAAG,CAF5B,EAAQ,EAAc,EAAI,GAG1B,EAAK,EAAK,EAAU,KAAK,GAAG,CAAE,GAI9B,EAAO,IAAI,CAAE,IAAI,GAAM,OAAO,CAAE,EAAI,GAQtC,CAOD,IAAI,EAAY,CAAM,CAAE,EAAO,MAAM,CAAG,EAAE,CAW1C,OAVc,MACT,KAAK,GAAG,CAAC,EAAU,CAAC,CAAG,CAAM,CAAE,EAAG,CAAC,CAAC,GAC7B,AAFE,MAEF,KAAK,GAAG,CAAC,EAAU,CAAC,CAAG,CAAM,CAAE,EAAG,CAAC,CAAC,GAC/C,EAAO,MAAM,CAAE,EAAO,MAAM,CAAG,EAAG,GAC9B,GAEJ,EAAO,IAAI,CAAE,CAAM,CAAE,EAAG,EAIlB,CAER,EAIA,GAAM,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAG,WAI/B,IAAI,EAAW,EAAE,CAAE,EAAW,IAAI,GAAM,IAAI,CAE5C,IAAM,EAAI,EAAG,EAAK,IAAI,CAAC,OAAO,CAAC,MAAM,CAAE,EAAI,EAAI,IAI9C,EAAO,AAFP,CAAA,EAAO,IAAI,CAAC,OAAO,CAAE,EAAG,AAAH,EAET,IAAI,CAChB,CAAA,EAAS,EAAK,MAAM,AAAN,GAEC,GAAM,WAAW,CAAC,OAAO,EAElC,AAA2B,GAA3B,EAAS,OAAO,CAAC,MAAM,GAE3B,EAAS,IAAI,CAAE,GACf,EAAW,IAAI,GAAM,IAAI,EAM3B,CAAQ,CAAE,EAAQ,CAAC,KAAK,CAAE,EAAU,GAYrC,GARgC,GAA3B,EAAS,OAAO,CAAC,MAAM,EAE3B,EAAS,IAAI,CAAE,GAMX,AAAmB,GAAnB,EAAS,MAAM,CAAQ,MAAO,EAAE,CAErC,IApCI,EAAG,EAAI,EAAM,EAAQ,EAoCrB,EAAS,EAAU,EAAS,EAAE,CAE9B,EAAa,CAAC,GAAM,KAAK,CAAC,KAAK,CAAC,WAAW,CAAE,CAAQ,CAAE,EAAG,CAAC,SAAS,IAGxE,GAAK,AAAmB,GAAnB,EAAS,MAAM,CAMnB,OALA,EAAU,CAAQ,CAAC,EAAE,CAErB,AADA,CAAA,EAAW,IAAI,GAAM,KAAK,AAA1B,EACS,OAAO,CAAG,EAAQ,OAAO,CAClC,EAAS,MAAM,CAAG,EAAQ,MAAM,CAChC,EAAO,IAAI,CAAE,GACN,EAGR,GAAK,EAIJ,IAAM,EAAI,EAFV,EAAW,IAAI,GAAM,KAAK,CAEb,EAAK,EAAS,MAAM,CAAE,EAAI,EAAI,IAE1C,EAAU,CAAQ,CAAE,EAAG,CAElB,GAAM,KAAK,CAAC,KAAK,CAAC,WAAW,CAAE,EAAQ,SAAS,KAEpD,EAAS,OAAO,CAAG,EAAQ,OAAO,CAClC,EAAS,MAAM,CAAG,EAAQ,MAAM,CAEhC,EAAO,IAAI,CAAE,GACb,EAAW,IAAI,GAAM,KAAK,EAM1B,EAAS,KAAK,CAAC,IAAI,CAAE,OAQjB,CAIN,IAAM,EAAI,EAAG,EAAK,EAAS,MAAM,CAAE,EAAI,EAAI,IAE1C,EAAU,CAAQ,CAAE,EAAG,CAElB,GAAM,KAAK,CAAC,KAAK,CAAC,WAAW,CAAE,EAAQ,SAAS,KAG/C,GAAW,EAAO,IAAI,CAAE,GAG7B,AADA,CAAA,EAAW,IAAI,GAAM,KAAK,AAA1B,EACS,OAAO,CAAG,EAAQ,OAAO,CAClC,EAAS,MAAM,CAAG,EAAQ,MAAM,EAIhC,EAAS,KAAK,CAAC,IAAI,CAAE,GAMvB,EAAO,IAAI,CAAE,EAEd,CAIA,OAAO,CAER,EAYA,GAAM,KAAK,CAAG,WAEb,GAAM,IAAI,CAAC,KAAK,CAAE,IAAI,CAAE,WACxB,IAAI,CAAC,KAAK,CAAG,EAAE,AAEhB,EAEA,GAAM,KAAK,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,IAAI,CAAC,SAAS,EAI3D,GAAM,KAAK,CAAC,SAAS,CAAC,OAAO,CAAG,SAAW,CAAO,EAGjD,OADe,IAAI,GAAM,eAAe,CAAE,IAAI,CAAE,EAGjD,EAIA,GAAM,KAAK,CAAC,SAAS,CAAC,YAAY,CAAG,SAAW,CAAO,EAGtD,OADe,IAAI,GAAM,aAAa,CAAE,IAAI,CAAE,EAG/C,EAIA,GAAM,KAAK,CAAC,SAAS,CAAC,cAAc,CAAG,SAAW,CAAS,EAE1D,IAAI,EAAG,EAAK,IAAI,CAAC,KAAK,CAAC,MAAM,CAAE,EAAW,EAAE,CAE5C,IAAM,EAAI,EAAG,EAAI,EAAI,IAEpB,CAAQ,CAAE,EAAG,CAAG,IAAI,CAAC,KAAK,CAAE,EAAG,CAAC,oBAAoB,CAAE,EAAW,IAAI,CAAC,KAAK,EAI5E,OAAO,CAER,EAIA,GAAM,KAAK,CAAC,SAAS,CAAC,oBAAoB,CAAG,SAAW,CAAS,EAEhE,IAAI,EAAG,EAAK,IAAI,CAAC,KAAK,CAAC,MAAM,CAAE,EAAW,EAAE,CAE5C,IAAM,EAAI,EAAG,EAAI,EAAI,IAEpB,CAAQ,CAAE,EAAG,CAAG,IAAI,CAAC,KAAK,CAAE,EAAG,CAAC,0BAA0B,CAAE,EAAW,IAAI,CAAC,KAAK,EAIlF,OAAO,CAER,EAKA,GAAM,KAAK,CAAC,SAAS,CAAC,gBAAgB,CAAG,SAAW,CAAS,EAE5D,MAAO,CAEN,MAAO,IAAI,CAAC,oBAAoB,CAAE,GAClC,MAAO,IAAI,CAAC,cAAc,CAAE,EAE7B,CAED,EAEA,GAAM,KAAK,CAAC,SAAS,CAAC,aAAa,CAAG,SAAW,CAAS,SAEzD,AAAI,IAAI,CAAC,eAAe,CAChB,IAAI,CAAC,sBAAsB,CAAC,GAG7B,IAAI,CAAC,gBAAgB,CAAC,EAE9B,EAgBA,GAAM,KAAK,CAAC,SAAS,CAAC,sBAAsB,CAAG,SAAW,CAAS,EAElE,MAAO,CAEN,MAAO,IAAI,CAAC,0BAA0B,CAAE,GACxC,MAAO,IAAI,CAAC,oBAAoB,CAAE,EAEnC,CAED,EAMA,GAAM,KAAK,CAAC,KAAK,CAAG,CAOnB,YAAa,SAAW,CAAO,CAAE,CAAK,EAErC,IAMI,EACH,EACA,EAAW,EAEX,EAAG,EACH,EAAM,EAAU,EAChB,EAAG,EAAM,EACT,EAAW,EACX,EAAU,EAdP,EAAQ,EAAQ,MAAM,GACtB,EAAY,EAAM,MAAM,GAc3B,EAAQ,EAAE,CAEX,IAAM,EAAI,EAAG,EAAI,EAAM,MAAM,CAAE,IAAO,CAoBrC,IAlBA,EAAO,CAAK,CAAE,EAAG,CAOjB,MAAM,SAAS,CAAC,IAAI,CAAC,KAAK,CAAE,EAAW,GAEvC,EAAW,OAAO,iBAAiB,CAS7B,EAAK,EAAG,EAAK,EAAK,MAAM,CAAE,IAAQ,CAEvC,EAAO,CAAI,CAAE,EAAI,CACjB,IAAI,EAAO,EAAE,CAEb,IAAM,EAAI,EAAG,EAAI,EAAM,MAAM,CAAE,IAE9B,EAAO,CAAK,CAAE,EAAG,CAEjB,EAAK,IAAI,CADT,EAAI,EAAK,iBAAiB,CAAE,IAGvB,EAAI,IAER,EAAW,EACX,EAAY,EACZ,EAAa,EAMhB,CAIA,EAAkB,EAAa,GAAO,EAAI,EAAa,EAAI,EAAM,MAAM,CAAG,EAC1E,EAAiB,EAAY,GAAO,EAAI,EAAY,EAAI,EAAK,MAAM,CAAG,EAEtE,IAAI,EAAW,CAEd,CAAI,CAAE,EAAW,CACjB,CAAK,CAAE,EAAY,CACnB,CAAK,CAAE,EAAe,CAEtB,CAEG,EAAQ,GAAM,SAAS,CAAC,WAAW,CAAC,IAAI,CAAE,GAE1C,EAAW,CAEd,CAAI,CAAE,EAAW,CACjB,CAAI,CAAE,EAAc,CACpB,CAAK,CAAE,EAAY,CAEnB,CAEG,EAAQ,GAAM,SAAS,CAAC,WAAW,CAAC,IAAI,CAAE,GAK1C,EAAgB,EAAY,EAAe,EAE/C,GAJiB,GAGjB,CAAA,GAJkB,CAIlB,EAGkB,GAAM,CAAA,GAAc,EAAM,MAAM,AAAN,EAC5C,GAAc,EAAM,MAAM,CAErB,EAAY,GAAM,CAAA,GAAa,EAAK,MAAM,AAAN,EACzC,GAAa,EAAK,MAAM,CAExB,EAAkB,EAAa,GAAO,EAAI,EAAa,EAAI,EAAM,MAAM,CAAG,EAC1E,EAAiB,EAAY,GAAO,EAAI,EAAY,EAAI,EAAK,MAAM,CAAG,EAEtE,EAAW,CAEV,CAAI,CAAE,EAAW,CACjB,CAAK,CAAE,EAAY,CACnB,CAAK,CAAE,EAAe,CAEtB,CAED,IAAI,EAAS,GAAM,SAAS,CAAC,WAAW,CAAC,IAAI,CAAE,GAE/C,EAAW,CAEV,CAAI,CAAE,EAAW,CACjB,CAAI,CAAE,EAAc,CACpB,CAAK,CAAE,EAAY,CAEnB,CAKI,EAAU,EAAY,EAHd,GAAM,SAAS,CAAC,WAAW,CAAC,IAAI,CAAE,KAQ9C,EAAa,EACb,EAAY,EAEP,EAAa,GAAM,CAAA,GAAc,EAAM,MAAM,AAAN,EAC5C,GAAc,EAAM,MAAM,CAErB,EAAY,GAAM,CAAA,GAAa,EAAK,MAAM,AAAN,EACzC,GAAa,EAAK,MAAM,CAExB,EAAkB,EAAa,GAAO,EAAI,EAAa,EAAI,EAAM,MAAM,CAAG,EAC1E,EAAiB,EAAY,GAAO,EAAI,EAAY,EAAI,EAAK,MAAM,CAAG,GAQvE,EAAY,EAAM,KAAK,CAAE,EAAG,GAC5B,EAAY,EAAM,KAAK,CAAE,GACzB,EAAW,EAAK,KAAK,CAAE,GACvB,EAAW,EAAK,KAAK,CAAE,EAAG,GAI1B,IAAI,EAAY,CAEf,CAAI,CAAE,EAAW,CACjB,CAAK,CAAE,EAAY,CACnB,CAAK,CAAE,EAAe,CAEtB,CAEG,EAAY,CAEf,CAAI,CAAE,EAAW,CACjB,CAAI,CAAE,EAAc,CACpB,CAAK,CAAE,EAAY,CAEnB,CAED,EAAM,IAAI,CAAE,GACZ,EAAM,IAAI,CAAE,GAEZ,EAAQ,EAAU,MAAM,CAAE,GAAW,MAAM,CAAE,GAAW,MAAM,CAAE,EAEjE,CAEA,MAAO,CAEN,MAAM,EACN,YAAa,EACb,UAAW,CAEZ,CAGD,EAEA,iBAAkB,SAAW,CAAO,CAAE,CAAK,EAE1C,IAaI,EAAG,EAAI,EAAG,EACb,EAAK,EAdF,EAAoB,GAAM,KAAK,CAAC,KAAK,CAAC,WAAW,CAAE,EAAS,GAE5D,EAAQ,EAAkB,KAAK,CAClC,EAAY,EAAkB,SAAS,CACvC,EAAc,EAAkB,WAAW,CAExC,EAAY,GAAM,SAAS,CAAC,WAAW,CAAE,EAAO,CAAA,GASnD,EAAe,CAAC,EAKjB,IAAM,EAAI,EAAG,EAAK,EAAU,MAAM,CAAE,EAAI,EAAI,IAId,KAAA,IAAxB,CAAY,CAFjB,EAAM,CAAS,CAAE,EAAG,CAAC,CAAC,CAAG,IAAM,CAAS,CAAE,EAAG,CAAC,CAAC,CAEvB,EAEvB,QAAQ,GAAG,CAAE,kBAAmB,GAIjC,CAAY,CAAE,EAAK,CAAG,EAMvB,IAAM,EAAI,EAAG,EAAK,EAAU,MAAM,CAAE,EAAI,EAAI,IAI3C,IAAM,EAAI,EAFV,EAAO,CAAS,CAAE,EAAG,CAER,EAAI,EAAG,IAMJ,KAAA,IAFf,CAAA,EAAQ,CAAY,CAFpB,EAAM,CAAI,CAAE,EAAG,CAAC,CAAC,CAAG,IAAM,CAAI,CAAE,EAAG,CAAC,CAAC,CAEV,AAAL,GAIrB,CAAA,CAAI,CAAE,EAAG,CAAG,CAFb,EAYF,IAAM,EAAI,EAAG,EAAK,EAAY,MAAM,CAAE,EAAI,EAAI,IAI7C,IAAM,EAAI,EAFV,EAAO,CAAW,CAAE,EAAG,CAEV,EAAI,EAAG,IAMJ,KAAA,IAFf,CAAA,EAAQ,CAAY,CAFpB,EAAM,CAAI,CAAE,EAAG,CAAC,CAAC,CAAG,IAAM,CAAI,CAAE,EAAG,CAAC,CAAC,CAEV,AAAL,GAIrB,CAAA,CAAI,CAAE,EAAG,CAAG,CAFb,EAUF,OAAO,EAAU,MAAM,CAAE,EAE1B,EA2DA,YAAa,SAAW,CAAG,EAE1B,OAAO,AAA0C,EAA1C,GAAM,SAAS,CAAC,WAAW,CAAC,IAAI,CAAE,EAE1C,EAOA,KAAM,SAAW,CAAC,CAAE,CAAC,EAEpB,IAAI,EAAI,EAAI,EACZ,OAAO,EAAI,EAAI,CAEhB,EAEA,KAAM,SAAW,CAAC,CAAE,CAAC,EAEpB,OAAO,EAAM,CAAA,EAAI,CAAA,EAAM,EAAI,CAE5B,EAEA,KAAM,SAAW,CAAC,CAAE,CAAC,EAEpB,OAAO,EAAI,EAAI,CAEhB,EAEA,GAAI,SAAW,CAAC,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,EAE3B,OAAO,IAAI,CAAC,IAAI,CAAE,EAAG,GAAO,IAAI,CAAC,IAAI,CAAE,EAAG,GAAO,IAAI,CAAC,IAAI,CAAE,EAAG,EAEhE,EAIA,KAAM,SAAW,CAAC,CAAE,CAAC,EAEpB,IAAI,EAAI,EAAI,EACZ,OAAO,EAAI,EAAI,EAAI,CAEpB,EAEA,KAAM,SAAW,CAAC,CAAE,CAAC,EAEpB,IAAI,EAAI,EAAI,EACZ,OAAO,EAAI,EAAI,EAAI,EAAI,CAExB,EAEA,KAAM,SAAW,CAAC,CAAE,CAAC,EAGpB,OAAO,EADC,CAAA,EAAI,CAAA,EACG,EAAI,EAAI,CAExB,EAEA,KAAM,SAAW,CAAC,CAAE,CAAC,EAEpB,OAAO,EAAI,EAAI,EAAI,CAEpB,EAEA,GAAI,SAAW,CAAC,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,EAE/B,OAAO,IAAI,CAAC,IAAI,CAAE,EAAG,GAAO,IAAI,CAAC,IAAI,CAAE,EAAG,GAAO,IAAI,CAAC,IAAI,CAAE,EAAG,GAAQ,IAAI,CAAC,IAAI,CAAE,EAAG,EAEtF,CAED,EAMA,GAAM,gBAAgB,EAEjB,GAAU,EAAE,CACZ,GAAU,CAAC,EAMf,CALI,GAAU,CAAC,GAKV,MAAM,CAAG,SAAU,CAAW,EAElC,IAAK,IAAI,EAAI,EAAG,EAAI,GAAQ,MAAM,CAAE,IACnC,EAAO,CAAE,EAAG,CAAC,MAAM,CAAE,EAEvB,EAKA,GAAK,WAAW,CAAG,SAAU,CAAS,EAEC,KAAjC,GAAQ,OAAO,CAAE,IACrB,GAAQ,IAAI,CAAE,EAEhB,EAKA,GAAK,gBAAgB,CAAG,SAAU,CAAS,EAE1C,IAAI,EAAQ,GAAQ,OAAO,CAAE,EAEf,CAAA,KAAV,GACH,GAAQ,MAAM,CAAE,EAAO,EAEzB,EAKA,GAAK,GAAG,CAAG,SAAU,CAAI,EAEM,KAAA,IAAzB,EAAO,CAAE,EAAK,IAAI,CAAE,EACxB,QAAQ,GAAG,CAAE,wCAA0C,EAAK,IAAI,CAAG,4CAEpE,EAAO,CAAE,EAAK,IAAI,CAAE,CAAG,EACvB,GAAU,EAEX,EAKA,GAAK,GAAG,CAAG,SAAU,CAAI,EAExB,GAAK,AAAgB,UAAhB,OAAO,SAEX,AAAK,EAAO,CAAE,EAAM,CAEZ,EAAO,CAAE,EAAM,EAItB,QAAQ,GAAG,CAAE,uDAAyD,GAC/D,KAUV,EAIA,GAAK,KAAK,CAAG,SAAU,CAAI,EAI1B,IAAI,EAAY,EAAE,CAElB,GAAK,aAAgB,GAAM,WAAW,CAErC,IAAK,IAAI,EAAI,EAAG,EAAI,EAAK,KAAK,CAAC,MAAM,CAAE,IAEtC,EAAU,IAAI,CAAE,EAAK,KAAK,CAAE,EAAG,OAMhC,GAAuB,EAAM,GAI9B,OAAO,CAER,EAEI,GAAwB,SAAU,CAAI,CAAE,CAAS,EAEpD,EAAU,IAAI,CAAE,GAEhB,IAAK,IAAI,EAAI,EAAG,EAAI,EAAK,QAAQ,CAAC,MAAM,CAAE,IACzC,GAAuB,EAAK,QAAQ,CAAE,EAAG,CAAE,EAE7C,EAKI,GAAW,SAAU,CAAI,EAE5B,GAAI,AAAqB,CAAA,IAArB,EAAK,WAAW,EAMpB,IAAK,IAAI,EAAI,EAAG,EAAI,EAAK,SAAS,CAAC,MAAM,CAAE,IAAO,CAEjD,IAAK,IAAI,EAAI,EAAG,EAAI,EAAK,SAAS,CAAE,EAAG,CAAC,IAAI,CAAC,MAAM,CAAE,IAUpD,GANI,EAAK,SAAS,CAAE,EAAG,CAAC,IAAI,CAAE,EAAG,CAAC,IAAI,CAAG,GACxC,CAAA,EAAK,SAAS,CAAE,EAAG,CAAC,IAAI,CAAE,EAAG,CAAC,IAAI,CAAG,CAAA,EAKlC,AAAsC,KAAA,IAAtC,EAAK,SAAS,CAAE,EAAG,CAAC,IAAI,CAAE,EAAG,CAAC,GAAG,EACpC,CAAG,CAAA,EAAK,SAAS,CAAE,EAAG,CAAC,IAAI,CAAE,EAAG,CAAC,GAAG,YAAY,GAAM,UAAS,AAAT,EAAe,CAErE,IAAI,EAAO,EAAK,SAAS,CAAE,EAAG,CAAC,IAAI,CAAE,EAAG,CAAC,GAAG,AAC5C,CAAA,EAAK,SAAS,CAAE,EAAG,CAAC,IAAI,CAAE,EAAG,CAAC,GAAG,CAAG,IAAI,GAAM,UAAU,CAAE,CAAI,CAAC,EAAE,CAAE,CAAI,CAAC,EAAE,CAAE,CAAI,CAAC,EAAE,CAAE,CAAI,CAAC,EAAE,CAE7F,CAOD,GAAI,EAAK,SAAS,CAAE,EAAG,CAAC,IAAI,CAAC,MAAM,EAAI,AAA+C,KAAA,IAA/C,EAAK,SAAS,CAAE,EAAG,CAAC,IAAI,CAAE,EAAG,CAAC,YAAY,CAAiB,CAMjG,IAAM,IAFF,EAAmB,CAAC,EAEd,EAAI,EAAG,EAAI,EAAK,SAAS,CAAE,EAAG,CAAC,IAAI,CAAC,MAAM,CAAE,IAErD,IAAM,IAAI,EAAI,EAAG,EAAI,EAAK,SAAS,CAAE,EAAG,CAAC,IAAI,CAAE,EAAG,CAAC,YAAY,CAAC,MAAM,CAAE,IAAO,CAE9E,IAAI,EAAkB,EAAK,SAAS,CAAE,EAAG,CAAC,IAAI,CAAE,EAAG,CAAC,YAAY,CAAE,EAAG,AACrE,CAAA,CAAgB,CAAE,EAAiB,CAAG,EAEvC,CAID,EAAK,SAAS,CAAE,EAAG,CAAC,gBAAgB,CAAG,EAKvC,IAAM,IAAI,EAAI,EAAG,EAAI,EAAK,SAAS,CAAE,EAAG,CAAC,IAAI,CAAC,MAAM,CAAE,IAAO,CAE5D,IAAI,EAAa,CAAC,EAElB,IAAM,IAAI,KAAmB,EAAmB,CAE/C,IAAM,IAAI,EAAI,EAAG,EAAI,EAAK,SAAS,CAAE,EAAG,CAAC,IAAI,CAAE,EAAG,CAAC,YAAY,CAAC,MAAM,CAAE,IAEvE,GAAK,EAAK,SAAS,CAAE,EAAG,CAAC,IAAI,CAAE,EAAG,CAAC,YAAY,CAAE,EAAG,GAAK,EAAkB,CAE1E,CAAU,CAAE,EAAiB,CAAG,EAAK,SAAS,CAAE,EAAG,CAAC,IAAI,CAAE,EAAG,CAAC,sBAAsB,CAAE,EAAG,CACzF,KAED,CAII,IAAM,EAAK,SAAS,CAAE,EAAG,CAAC,IAAI,CAAE,EAAG,CAAC,YAAY,CAAC,MAAM,EAE3D,CAAA,CAAU,CAAE,EAAiB,CAAG,CAAA,CAIlC,CAEA,EAAK,SAAS,CAAE,EAAG,CAAC,IAAI,CAAE,EAAG,CAAC,sBAAsB,CAAG,CAExD,CAED,CAKA,IAAM,IAAI,EAAI,EAAG,EAAI,EAAK,SAAS,CAAE,EAAG,CAAC,IAAI,CAAC,MAAM,CAAE,IAEhD,EAAK,SAAS,CAAE,EAAG,CAAC,IAAI,CAAE,EAAG,CAAC,IAAI,GAAK,EAAK,SAAS,CAAE,EAAG,CAAC,IAAI,CAAE,EAAI,EAAG,CAAC,IAAI,GAEjF,EAAK,SAAS,CAAE,EAAG,CAAC,IAAI,CAAC,MAAM,CAAE,EAAG,GACpC,KASF,IAAM,IAAI,EAAI,EAAG,EAAI,EAAK,SAAS,CAAE,EAAG,CAAC,IAAI,CAAC,MAAM,CAAE,IAErD,EAAK,SAAS,CAAE,EAAG,CAAC,IAAI,CAAE,EAAG,CAAC,KAAK,CAAG,CAIxC,CAKA,IAAI,EAAiB,SAAU,EAAK,MAAM,CAAG,EAAK,GAAG,CAAE,GAEvD,CAAA,EAAK,GAAG,CAAG,CAAC,EACZ,EAAK,GAAG,CAAC,SAAS,CAAG,EAAE,CAEvB,IAAK,IAAI,EAAI,EAAG,EAAI,EAAK,SAAS,CAAC,MAAM,CAAE,IAC1C,EAAK,GAAG,CAAC,SAAS,CAAC,IAAI,CAAE,AAAI,MAAO,GAKrC,CAAA,EAAK,WAAW,CAAG,CAAA,EAEpB,EAKA,GAAK,MAAM,CAAG,EACd,GAAK,UAAU,CAAG,EAClB,GAAK,kBAAkB,CAAG,EAEnB,IASR,GAAM,SAAS,CAAG,SAAW,CAAI,CAAE,CAAI,CAAE,CAAiB,EAEzD,IAAI,CAAC,IAAI,CAAG,EACZ,IAAI,CAAC,IAAI,CAAG,GAAM,gBAAgB,CAAC,GAAG,CAAE,GACxC,IAAI,CAAC,SAAS,CAAG,GAAM,gBAAgB,CAAC,KAAK,CAAE,GAE/C,IAAI,CAAC,WAAW,CAAG,EACnB,IAAI,CAAC,SAAS,CAAG,EAEjB,IAAI,CAAC,SAAS,CAAG,CAAA,EACjB,IAAI,CAAC,QAAQ,CAAG,CAAA,EAChB,IAAI,CAAC,IAAI,CAAG,CAAA,EAEZ,IAAI,CAAC,iBAAiB,CAAG,AAAsB,KAAA,IAAtB,EAAkC,EAAoB,GAAM,gBAAgB,CAAC,MAAM,CAE5G,IAAI,CAAC,MAAM,CAAG,EAAE,CAChB,IAAI,CAAC,MAAM,CAAG,IAAI,GAAM,OAAO,AAEhC,EAEA,GAAM,SAAS,CAAC,SAAS,CAAC,IAAI,CAAG,SAAW,CAAI,CAAE,CAAW,EAE5D,GAAK,AAAmB,CAAA,IAAnB,IAAI,CAAC,SAAS,CAAa,CAE/B,IAAI,CAAC,SAAS,CAAG,CAAA,EACjB,IAAI,CAAC,IAAI,CAAG,AAAS,KAAA,IAAT,GAAqB,EACjC,IAAI,CAAC,WAAW,CAAG,AAAgB,KAAA,IAAhB,EAA4B,EAAc,EAI7D,IAAI,EACH,EADM,EAAK,IAAI,CAAC,SAAS,CAAC,MAAM,CAGjC,IAAM,EAAI,EAAG,EAAI,EAAI,IAAO,CAE3B,EAAS,IAAI,CAAC,SAAS,CAAE,EAAG,CAEvB,IAAI,CAAC,iBAAiB,GAAK,GAAM,gBAAgB,CAAC,kBAAkB,EAExE,CAAA,EAAO,aAAa,CAAG,CAAA,CAFxB,EAMA,EAAO,gBAAgB,CAAG,CAAA,EAEK,KAAA,IAA1B,EAAO,cAAc,GAEzB,EAAO,cAAc,CAAG,CAAC,EACzB,EAAO,cAAc,CAAC,OAAO,CAAG,CAAE,IAAK,EAAG,IAAK,EAAG,IAAK,CAAE,EACzD,EAAO,cAAc,CAAC,OAAO,CAAG,CAAE,IAAK,EAAG,IAAK,EAAG,IAAK,CAAE,EACzD,EAAO,cAAc,CAAC,cAAc,CAAG,aAAkB,GAAM,IAAI,CAAG,EAAO,UAAU,CAAG,EAAO,MAAM,EAIxG,IAAI,EAAU,EAAO,cAAc,CAAC,OAAO,CACvC,EAAU,EAAO,cAAc,CAAC,OAAO,AAE3C,CAAA,EAAQ,GAAG,CAAG,IAAI,CAAC,IAAI,CAAC,SAAS,CAAE,EAAG,CAAC,IAAI,CAAE,EAAG,CAChD,EAAQ,GAAG,CAAG,IAAI,CAAC,IAAI,CAAC,SAAS,CAAE,EAAG,CAAC,IAAI,CAAE,EAAG,CAChD,EAAQ,GAAG,CAAG,IAAI,CAAC,IAAI,CAAC,SAAS,CAAE,EAAG,CAAC,IAAI,CAAE,EAAG,CAEhD,EAAQ,GAAG,CAAG,IAAI,CAAC,cAAc,CAAE,MAAO,EAAG,GAC7C,EAAQ,GAAG,CAAG,IAAI,CAAC,cAAc,CAAE,MAAO,EAAG,GAC7C,EAAQ,GAAG,CAAG,IAAI,CAAC,cAAc,CAAE,MAAO,EAAG,EAE9C,CAEA,IAAI,CAAC,MAAM,CAAE,EAEd,CAEA,IAAI,CAAC,QAAQ,CAAG,CAAA,EAEhB,GAAM,gBAAgB,CAAC,WAAW,CAAE,IAAI,CAEzC,EAGA,GAAM,SAAS,CAAC,SAAS,CAAC,KAAK,CAAG,WAE5B,AAAkB,CAAA,IAAlB,IAAI,CAAC,QAAQ,CAEjB,GAAM,gBAAgB,CAAC,WAAW,CAAE,IAAI,EAIxC,GAAM,gBAAgB,CAAC,gBAAgB,CAAE,IAAI,EAI9C,IAAI,CAAC,QAAQ,CAAG,CAAC,IAAI,CAAC,QAAQ,AAE/B,EAGA,GAAM,SAAS,CAAC,SAAS,CAAC,IAAI,CAAG,WAEhC,IAAI,CAAC,SAAS,CAAG,CAAA,EACjB,IAAI,CAAC,QAAQ,CAAI,CAAA,EACjB,GAAM,gBAAgB,CAAC,gBAAgB,CAAE,IAAI,CAE9C,EAGA,GAAM,SAAS,CAAC,SAAS,CAAC,MAAM,CAAG,SAAW,CAAW,EAIxD,GAAK,AAAmB,CAAA,IAAnB,IAAI,CAAC,SAAS,EAKnB,IACI,EACA,EACA,EACA,EAAS,EACT,EAAS,EACT,EACA,EAGA,EAAa,EACb,EAAc,EAAc,EAX5B,EAAQ,CAAE,MAAO,MAAO,MAAO,AAShB,CAAA,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,SAAS,CAK1C,IAAI,CAAC,WAAW,EAAI,EAAc,IAAI,CAAC,SAAS,CAEhD,EAAsB,IAAI,CAAC,WAAW,CAE9B,SAAU,KAAK,GAAG,CAAE,AAD5B,CAAA,EAAc,IAAI,CAAC,WAAW,CAAG,IAAI,CAAC,WAAW,CAAG,IAAI,CAAC,IAAI,CAAC,MAAM,AAAN,EACpB,IAAI,CAAC,IAAI,CAAC,GAAG,CAAE,IAAI,CAAC,IAAI,CAAC,MAAM,CAAG,IAAI,CAAC,IAAI,CAAC,GAAG,EAAI,IAG7F,IAAM,IAAI,EAAI,EAAG,EAAK,IAAI,CAAC,SAAS,CAAC,MAAM,CAAE,EAAI,EAAI,IAAO,CAG3D,EAAiB,AADjB,CAAA,EAAS,IAAI,CAAC,SAAS,CAAE,EAAG,AAAH,EACD,cAAc,CAItC,IAAM,IAAI,EAAI,EAAG,EAAI,EAAG,IAAO,CAU9B,GANA,EAAU,CAAK,CAAE,EAAG,CACpB,EAAU,EAAe,OAAO,CAAE,EAAM,CAKnC,AAJL,CAAA,EAAU,EAAe,OAAO,CAAE,EAAM,AAAN,EAIrB,IAAI,EAAI,EAAsB,CAI1C,GAAK,EAAc,GAElB,GAAK,IAAI,CAAC,IAAI,CAKb,IAHA,EAAU,IAAI,CAAC,IAAI,CAAC,SAAS,CAAE,EAAG,CAAC,IAAI,CAAE,EAAG,CAC5C,EAAU,IAAI,CAAC,cAAc,CAAE,EAAM,EAAG,GAEjC,EAAQ,IAAI,CAAG,GAErB,EAAU,EACV,EAAU,IAAI,CAAC,cAAc,CAAE,EAAM,EAAG,EAAQ,KAAK,CAAG,OAInD,CAEN,IAAI,CAAC,IAAI,GACT,MAED,OAIA,GAEC,EAAU,EACV,EAAU,IAAI,CAAC,cAAc,CAAE,EAAM,EAAG,EAAQ,KAAK,CAAG,SAEhD,EAAQ,IAAI,CAAG,EAAa,AAItC,EAAe,OAAO,CAAE,EAAM,CAAG,EACjC,EAAe,OAAO,CAAE,EAAM,CAAG,CAElC,CAGA,EAAO,gBAAgB,CAAG,CAAA,EAC1B,EAAO,sBAAsB,CAAG,CAAA,EAEhC,EAAU,AAAA,CAAA,EAAc,EAAQ,IAAI,AAAJ,EAAW,CAAA,EAAQ,IAAI,CAAG,EAAQ,IAAI,AAAJ,EAClE,EAAU,CAAO,CAAE,EAAM,CACzB,EAAU,CAAO,CAAE,EAAM,CAKpB,CAAA,EAAQ,GAAK,EAAQ,CAAA,IAEzB,QAAQ,GAAG,CAAE,wDAA0D,EAAQ,YAAc,GAC7F,EAAQ,EAAQ,EAAI,EAAI,GAMpB,AAAS,QAAT,GAEJ,EAAS,EAAO,QAAQ,CAEnB,IAAI,CAAC,iBAAiB,GAAK,GAAM,gBAAgB,CAAC,MAAM,EAE5D,EAAO,CAAC,CAAG,CAAO,CAAE,EAAG,CAAG,AAAE,CAAA,CAAO,CAAE,EAAG,CAAG,CAAO,CAAE,EAAE,AAAF,EAAQ,EAC5D,EAAO,CAAC,CAAG,CAAO,CAAE,EAAG,CAAG,AAAE,CAAA,CAAO,CAAE,EAAG,CAAG,CAAO,CAAE,EAAE,AAAF,EAAQ,EAC5D,EAAO,CAAC,CAAG,CAAO,CAAE,EAAG,CAAG,AAAE,CAAA,CAAO,CAAE,EAAG,CAAG,CAAO,CAAE,EAAE,AAAF,EAAQ,GAEjD,CAAA,IAAI,CAAC,iBAAiB,GAAK,GAAM,gBAAgB,CAAC,UAAU,EAClE,IAAI,CAAC,iBAAiB,GAAK,GAAM,gBAAgB,CAAC,kBAAkB,AAAlB,IAEvD,IAAI,CAAC,MAAM,CAAE,EAAG,CAAG,IAAI,CAAC,cAAc,CAAE,MAAO,EAAG,EAAQ,KAAK,CAAG,GAAK,GAAO,CAC9E,IAAI,CAAC,MAAM,CAAE,EAAG,CAAG,EACnB,IAAI,CAAC,MAAM,CAAE,EAAG,CAAG,EACnB,IAAI,CAAC,MAAM,CAAE,EAAG,CAAG,IAAI,CAAC,cAAc,CAAE,MAAO,EAAG,EAAQ,KAAK,CAAG,GAAK,GAAO,CAE9E,EAAQ,AAAQ,IAAR,EAAe,IAEvB,EAAe,IAAI,CAAC,qBAAqB,CAAE,IAAI,CAAC,MAAM,CAAE,GAExD,EAAO,CAAC,CAAG,CAAY,CAAE,EAAG,CAC5B,EAAO,CAAC,CAAG,CAAY,CAAE,EAAG,CAC5B,EAAO,CAAC,CAAG,CAAY,CAAE,EAAG,CAEvB,IAAI,CAAC,iBAAiB,GAAK,GAAM,gBAAgB,CAAC,kBAAkB,GAExE,EAAe,IAAI,CAAC,qBAAqB,CAAE,IAAI,CAAC,MAAM,CAAE,AAAQ,KAAR,GAExD,IAAI,CAAC,MAAM,CAAC,GAAG,CAAE,CAAY,CAAE,EAAG,CAAE,CAAY,CAAE,EAAG,CAAE,CAAY,CAAE,EAAG,EACxE,IAAI,CAAC,MAAM,CAAC,GAAG,CAAE,GACjB,IAAI,CAAC,MAAM,CAAC,CAAC,CAAG,EAChB,IAAI,CAAC,MAAM,CAAC,SAAS,GAErB,EAAQ,KAAK,KAAK,CAAE,IAAI,CAAC,MAAM,CAAC,CAAC,CAAE,IAAI,CAAC,MAAM,CAAC,CAAC,EAChD,EAAO,QAAQ,CAAC,GAAG,CAAE,EAAG,EAAO,MAMtB,AAAS,QAAT,EAEX,GAAM,UAAU,CAAC,KAAK,CAAE,EAAS,EAAS,EAAO,UAAU,CAAE,GAEzC,QAAT,IAIX,AAFA,CAAA,EAAS,EAAO,KAAK,AAAL,EAET,CAAC,CAAG,CAAO,CAAE,EAAG,CAAG,AAAE,CAAA,CAAO,CAAE,EAAG,CAAG,CAAO,CAAE,EAAE,AAAF,EAAQ,EAC5D,EAAO,CAAC,CAAG,CAAO,CAAE,EAAG,CAAG,AAAE,CAAA,CAAO,CAAE,EAAG,CAAG,CAAO,CAAE,EAAE,AAAF,EAAQ,EAC5D,EAAO,CAAC,CAAG,CAAO,CAAE,EAAG,CAAG,AAAE,CAAA,CAAO,CAAE,EAAG,CAAG,CAAO,CAAE,EAAE,AAAF,EAAQ,EAI9D,CAED,EAED,EAIA,GAAM,SAAS,CAAC,SAAS,CAAC,qBAAqB,CAAG,SAAW,CAAM,CAAE,CAAK,EAEzE,IACA,EAAO,EAAU,EAAQ,EAAI,EAC7B,EAAI,EAAI,EAAI,EAFR,EAAI,EAAE,CAAE,EAAK,EAAE,CAyBnB,OApBA,EAAW,KAAK,KAAK,CADrB,EAAU,AAAA,CAAA,EAAO,MAAM,CAAG,CAAA,EAAM,GAEhC,EAAS,EAAQ,EAEjB,CAAC,CAAE,EAAG,CAAG,AAAa,IAAb,EAAiB,EAAW,EAAW,EAChD,CAAC,CAAE,EAAG,CAAG,EACT,CAAC,CAAE,EAAG,CAAG,EAAW,EAAO,MAAM,CAAG,EAAI,EAAW,EAAW,EAC9D,CAAC,CAAE,EAAG,CAAG,EAAW,EAAO,MAAM,CAAG,EAAI,EAAW,EAAW,EAE9D,EAAK,CAAM,CAAE,CAAC,CAAE,EAAG,CAAE,CACrB,EAAK,CAAM,CAAE,CAAC,CAAE,EAAG,CAAE,CACrB,EAAK,CAAM,CAAE,CAAC,CAAE,EAAG,CAAE,CACrB,EAAK,CAAM,CAAE,CAAC,CAAE,EAAG,CAAE,CAErB,EAAK,EAAS,EACd,EAAK,EAAS,EAEd,CAAE,CAAE,EAAG,CAAG,IAAI,CAAC,WAAW,CAAE,CAAE,CAAE,EAAG,CAAE,CAAE,CAAE,EAAG,CAAE,CAAE,CAAE,EAAG,CAAE,CAAE,CAAE,EAAG,CAAE,EAAQ,EAAI,GAC5E,CAAE,CAAE,EAAG,CAAG,IAAI,CAAC,WAAW,CAAE,CAAE,CAAE,EAAG,CAAE,CAAE,CAAE,EAAG,CAAE,CAAE,CAAE,EAAG,CAAE,CAAE,CAAE,EAAG,CAAE,EAAQ,EAAI,GAC5E,CAAE,CAAE,EAAG,CAAG,IAAI,CAAC,WAAW,CAAE,CAAE,CAAE,EAAG,CAAE,CAAE,CAAE,EAAG,CAAE,CAAE,CAAE,EAAG,CAAE,CAAE,CAAE,EAAG,CAAE,EAAQ,EAAI,GAErE,CAER,EAEA,GAAM,SAAS,CAAC,SAAS,CAAC,WAAW,CAAG,SAAW,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAC,CAAE,CAAE,CAAE,CAAE,EAE3E,IAAI,EAAO,AAAA,CAAA,EAAK,CAAA,EAAO,GACtB,EAAK,AAAE,CAAA,EAAK,CAAA,EAAO,GAEpB,MAAO,AAAE,CAAA,EAAM,CAAA,EAAK,CAAA,EAAO,EAAK,CAAA,EAAO,EAAO,AAAA,CAAA,GAAQ,CAAA,EAAK,CAAA,EAAO,EAAI,EAAK,CAAA,EAAO,EAAK,EAAK,EAAI,CAEjG,EAMA,GAAM,SAAS,CAAC,SAAS,CAAC,cAAc,CAAG,SAAW,CAAI,CAAE,CAAC,CAAE,CAAG,EAEjE,IAAI,EAAO,IAAI,CAAC,IAAI,CAAC,SAAS,CAAE,EAAG,CAAC,IAAI,CAaxC,IAXK,IAAI,CAAC,iBAAiB,GAAK,GAAM,gBAAgB,CAAC,UAAU,EAC/D,IAAI,CAAC,iBAAiB,GAAK,GAAM,gBAAgB,CAAC,kBAAkB,CAErE,EAAM,EAAM,EAAK,MAAM,CAAG,EAAI,EAAM,EAAK,MAAM,CAAG,EAIlD,GAAY,EAAK,MAAM,CAIhB,EAAM,EAAK,MAAM,CAAE,IAE1B,GAAK,AAAwB,KAAA,IAAxB,CAAI,CAAE,EAAK,CAAE,EAAM,CAEvB,OAAO,CAAI,CAAE,EAAK,CAMpB,OAAO,IAAI,CAAC,IAAI,CAAC,SAAS,CAAE,EAAG,CAAC,IAAI,CAAE,EAAG,AAE1C,EAIA,GAAM,SAAS,CAAC,SAAS,CAAC,cAAc,CAAG,SAAW,CAAI,CAAE,CAAC,CAAE,CAAG,EAEjE,IAAI,EAAO,IAAI,CAAC,IAAI,CAAC,SAAS,CAAE,EAAG,CAAC,IAAI,CAcxC,IATC,EAHI,IAAI,CAAC,iBAAiB,GAAK,GAAM,gBAAgB,CAAC,UAAU,EAC/D,IAAI,CAAC,iBAAiB,GAAK,GAAM,gBAAgB,CAAC,kBAAkB,CAE/D,EAAM,EAAI,EAAM,EAIhB,GAAO,EAAI,EAAM,EAAM,EAAK,MAAM,CAKjC,GAAO,EAAG,IAEjB,GAAK,AAAwB,KAAA,IAAxB,CAAI,CAAE,EAAK,CAAE,EAAM,CAEvB,OAAO,CAAI,CAAE,EAAK,CAMpB,OAAO,IAAI,CAAC,IAAI,CAAC,SAAS,CAAE,EAAG,CAAC,IAAI,CAAE,EAAK,MAAM,CAAG,EAAG,AAExD,EASA,GAAM,iBAAiB,CAAG,SAAU,CAAI,CAAE,CAAI,CAAE,CAAU,EAEzD,IAAI,CAAC,IAAI,CAAG,EACZ,IAAI,CAAC,IAAI,CAAG,GAAM,gBAAgB,CAAC,GAAG,CAAE,GACxC,IAAI,CAAC,SAAS,CAAG,GAAM,gBAAgB,CAAC,KAAK,CAAE,GAC/C,IAAI,CAAC,WAAW,CAAG,EACnB,IAAI,CAAC,SAAS,CAAG,KACjB,IAAI,CAAC,SAAS,CAAG,CAAA,EACjB,IAAI,CAAC,QAAQ,CAAG,CAAA,EAChB,IAAI,CAAC,IAAI,CAAG,CAAA,EACZ,IAAI,CAAC,UAAU,CAAG,AAAe,KAAA,IAAf,GAA2B,EAI7C,IAAM,IAAI,EAAI,EAAG,EAAK,IAAI,CAAC,SAAS,CAAC,MAAM,CAAE,EAAI,EAAI,IAAM,CAE1D,IAAI,EAAO,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE,CAAC,IAAI,CACrC,EAAO,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE,CAAC,IAAI,CAClC,EAAM,IAAI,CAAC,SAAS,CAAC,EAAE,CAExB,GAAK,EAAK,MAAM,EAAI,EAAO,CAE1B,IAAM,IAAI,EAAI,EAAG,EAAI,EAAK,MAAM,CAAE,IAAM,CAEvC,IAAI,EAAM,CAAI,CAAE,EAAG,CAClB,EAAO,IAAI,CAAC,cAAc,CAAE,EAAK,EAAG,GAEhC,GAEJ,EAAK,KAAK,CAAE,EAId,CAEA,EAAI,gBAAgB,CAAG,CAAA,EACvB,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE,CAAC,IAAI,CAAC,YAAY,GACxC,EAAI,sBAAsB,CAAG,CAAA,CAE9B,CAED,CAED,EAIA,GAAM,iBAAiB,CAAC,SAAS,CAAC,IAAI,CAAG,SAAU,CAAI,CAAE,CAAW,EAEnE,GAAI,CAAC,IAAI,CAAC,SAAS,CAAG,CAErB,IAAI,CAAC,SAAS,CAAG,CAAA,EACjB,IAAI,CAAC,IAAI,CAAG,AAAS,KAAA,IAAT,GAAqB,EACjC,IAAI,CAAC,WAAW,CAAG,AAAgB,KAAA,IAAhB,EAA4B,EAAc,EAC7D,IAAI,CAAC,WAAW,CAAG,EACnB,IAAI,CAAC,SAAS,CAAG,IACjB,IAAI,CAAC,OAAO,CAAG,CAAC,IAAI,CAAC,SAAS,CAK9B,IAAI,EACH,EACA,EAFM,EAAK,IAAI,CAAC,SAAS,CAAC,MAAM,CAIjC,IAAM,EAAI,EAAG,EAAI,EAAI,IAAM,CAE1B,EAAS,IAAI,CAAC,SAAS,CAAE,EAAG,CAC5B,EAAO,IAAI,CAAC,IAAI,CAAC,SAAS,CAAE,EAAG,CAC/B,EAAO,aAAa,CAAG,CAAA,EAEM,KAAA,IAAxB,EAAK,cAAc,GAEvB,EAAK,cAAc,CAAG,CAAC,EACvB,EAAK,cAAc,CAAC,OAAO,CAAG,KAC9B,EAAK,cAAc,CAAC,OAAO,CAAG,KAC9B,EAAK,cAAc,CAAC,cAAc,CAAG,aAAkB,GAAM,IAAI,CAAG,EAAO,UAAU,CAAG,EAAO,MAAM,EAItG,IAAI,EAAO,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE,CAAC,IAAI,AAElC,CAAA,EAAK,MAAM,GAEd,EAAK,cAAc,CAAC,OAAO,CAAG,CAAI,CAAE,EAAG,CACvC,EAAK,cAAc,CAAC,OAAO,CAAG,CAAI,CAAE,EAAG,CAEvC,IAAI,CAAC,SAAS,CAAG,KAAK,GAAG,CAAE,CAAI,CAAC,EAAE,CAAC,IAAI,CAAE,IAAI,CAAC,SAAS,EACvD,IAAI,CAAC,OAAO,CAAG,KAAK,GAAG,CAAE,CAAI,CAAC,EAAK,MAAM,CAAG,EAAE,CAAC,IAAI,CAAE,IAAI,CAAC,OAAO,EAInE,CAEA,IAAI,CAAC,MAAM,CAAE,EAEd,CAEA,IAAI,CAAC,QAAQ,CAAG,CAAA,EAEhB,GAAM,gBAAgB,CAAC,WAAW,CAAE,IAAI,CAEzC,EAMA,GAAM,iBAAiB,CAAC,SAAS,CAAC,KAAK,CAAG,WAErC,IAAI,CAAC,QAAQ,CAEhB,GAAM,gBAAgB,CAAC,WAAW,CAAE,IAAI,EAIxC,GAAM,gBAAgB,CAAC,gBAAgB,CAAE,IAAI,EAI9C,IAAI,CAAC,QAAQ,CAAG,CAAC,IAAI,CAAC,QAAQ,AAE/B,EAKA,GAAM,iBAAiB,CAAC,SAAS,CAAC,IAAI,CAAG,WAExC,IAAI,CAAC,SAAS,CAAG,CAAA,EACjB,IAAI,CAAC,QAAQ,CAAI,CAAA,EACjB,GAAM,gBAAgB,CAAC,gBAAgB,CAAE,IAAI,EAK7C,IAAM,IAAI,EAAI,EAAG,EAAI,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAE,IAAM,CAEhD,IAAI,EAAM,IAAI,CAAC,SAAS,CAAE,EAAG,CAC/B,EAAO,IAAI,CAAC,IAAI,CAAC,SAAS,CAAE,EAAG,CAEnC,GAAK,AAAwB,KAAA,IAAxB,EAAK,cAAc,CAAiB,CAExC,IAAI,EAAW,EAAK,cAAc,CAAC,cAAc,AAE7C,CAAA,aAAe,GAAM,IAAI,EAE5B,EAAS,IAAI,CAAE,EAAI,UAAU,EAC7B,EAAI,UAAU,CAAG,IAIjB,EAAS,IAAI,CAAE,EAAI,MAAM,EACzB,EAAI,MAAM,CAAG,GAId,OAAO,EAAK,cAAc,AAE3B,CAED,CAED,EAKA,GAAM,iBAAiB,CAAC,SAAS,CAAC,MAAM,CAAG,SAAU,CAAW,EAI/D,GAAK,IAAI,CAAC,SAAS,EASnB,IAJI,EAAS,EACT,EACA,EACA,EAEA,EAAa,EACb,EAFA,EAAe,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,SAAS,CAsB1C,GAfA,IAAI,CAAC,WAAW,EAAI,EAAc,IAAI,CAAC,SAAS,CAEhD,EAAsB,IAAI,CAAC,WAAW,CACtC,CAAA,EAAsB,IAAI,CAAC,WAAW,CAAG,IAAI,CAAC,WAAW,CAAG,IAAI,CAAC,IAAI,CAAC,MAAM,AAAN,EAGnD,IAAI,CAAC,WAAW,EAElC,CAAA,EAAc,IAAI,CAAC,WAAW,CAAG,IAAI,CAAC,WAAW,CAAG,CAFrD,EAMA,EAAsB,SAAU,KAAK,GAAG,CAAE,EAAc,IAAI,CAAC,IAAI,CAAC,GAAG,CAAE,IAAI,CAAC,IAAI,CAAC,MAAM,CAAG,IAAI,CAAC,IAAI,CAAC,GAAG,EAAI,IAGtG,AAFL,CAAA,EAAa,EAAc,CAA3B,GAEe,CAAC,IAAI,CAAC,IAAI,CAAG,CAG3B,IAAM,IAAI,EAAI,EAAG,EAAK,IAAI,CAAC,SAAS,CAAC,MAAM,CAAE,EAAI,EAAI,IAAM,CAE1D,IAAI,EAAO,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE,CAAC,IAAI,CACrC,EAAO,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE,CAAC,IAAI,CAClC,EAAM,EAAK,MAAM,CAAC,EAClB,EAAM,IAAI,CAAC,SAAS,CAAC,EAAE,CAExB,GAAK,EAAK,MAAM,CAAG,CAElB,IAAM,IAAI,EAAI,EAAG,EAAI,EAAK,MAAM,CAAE,IAAM,CAEvC,IAAI,EAAM,CAAI,CAAE,EAAG,CAClB,EAAO,IAAI,CAAC,cAAc,CAAE,EAAK,EAAG,GAEhC,GACJ,EAAK,KAAK,CAAE,EAId,CAEA,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE,CAAC,IAAI,CAAC,YAAY,GACxC,EAAI,sBAAsB,CAAG,CAAA,CAE9B,CAED,CAEA,IAAI,CAAC,IAAI,GACT,MAED,CAGA,IAAK,CAAA,EAAc,IAAI,CAAC,SAAS,AAAT,GAQxB,IAAM,IAAI,EAAI,EAAG,EAAK,IAAI,CAAC,SAAS,CAAC,MAAM,CAAE,EAAI,EAAI,IAAM,CAE1D,EAAS,IAAI,CAAC,SAAS,CAAE,EAAG,CAG5B,IAAI,EAAO,AAFX,CAAA,EAAO,IAAI,CAAC,IAAI,CAAC,SAAS,CAAE,EAAG,AAAH,EAEZ,IAAI,CACnB,EAAiB,EAAK,cAAc,CAIrC,GAAK,IAAI,CAAC,UAAU,EAAI,AAA+B,KAAA,IAA/B,CAAY,CAAE,EAAG,CAAE,EAAO,CAE7C,aAAkB,GAAM,IAAI,EAE/B,EAAO,UAAU,CAAG,CAAY,CAAE,EAAG,CAAE,EAAO,CAC9C,EAAO,sBAAsB,CAAG,CAAA,IAIhC,EAAO,MAAM,CAAG,CAAY,CAAE,EAAG,CAAE,EAAO,CAC1C,EAAO,sBAAsB,CAAG,CAAA,QAM3B,GAAK,EAAK,MAAM,CAAG,CAqBzB,GAjBK,IAAI,CAAC,UAAU,EAAI,IAEnB,aAAkB,GAAM,IAAI,CAE/B,EAAO,UAAU,CAAG,EAAe,cAAc,CAIjD,EAAO,MAAM,CAAG,EAAe,cAAc,EAM/C,EAAU,EAAe,OAAO,CAChC,EAAU,EAAe,OAAO,CAE3B,GAAW,EAAU,CAIzB,GAAK,EAAQ,IAAI,EAAI,EAAsB,CAI1C,GAAK,GAAU,IAAI,CAAC,IAAI,CAKvB,IAHA,EAAU,CAAI,CAAE,EAAG,CACnB,EAAU,CAAI,CAAE,EAAG,CAEX,EAAQ,IAAI,CAAG,GAGtB,EAAU,CAAI,CAAE,AADhB,CAAA,EAAU,CAAV,EACwB,KAAK,CAAG,EAAG,MAI9B,GAAK,CAAC,EAIZ,IAFA,IAAI,EAAY,EAAK,MAAM,CAAG,EAEtB,EAAQ,IAAI,CAAG,GAAe,EAAQ,KAAK,GAAK,GAGvD,EAAU,CAAI,CAAE,AADhB,CAAA,EAAU,CAAV,EACwB,KAAK,CAAG,EAAG,AAMrC,CAAA,EAAe,OAAO,CAAG,EACzB,EAAe,OAAO,CAAG,CAE1B,CACe,EAAQ,IAAI,EAAI,EACf,EAAQ,WAAW,CAAE,EAAS,GAE9B,EAAQ,WAAW,CAAE,EAAS,EAAQ,IAAI,CAE3D,CAEA,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE,CAAC,IAAI,CAAC,YAAY,GACxC,EAAO,sBAAsB,CAAG,CAAA,CAEjC,CAED,CAIA,GAAK,IAAI,CAAC,UAAU,EAEd,AAA+B,KAAA,IAA/B,CAAY,CAAE,EAAG,CAAE,EAAO,CAAiB,CAE/C,IAAI,CAAC,SAAS,CAAE,EAAG,CAAC,iBAAiB,CAAE,CAAA,GAEvC,IAAM,IAAI,EAAI,EAAG,EAAI,IAAI,CAAC,SAAS,CAAC,MAAM,CAAE,IAEvC,IAAI,CAAC,SAAS,CAAE,EAAG,WAAY,GAAM,IAAI,CAE5C,CAAY,CAAE,EAAG,CAAE,EAAO,CAAG,IAAI,CAAC,SAAS,CAAE,EAAG,CAAC,UAAU,CAAC,KAAK,GAIjE,CAAY,CAAE,EAAG,CAAE,EAAO,CAAG,IAAI,CAAC,SAAS,CAAE,EAAG,CAAC,MAAM,CAAC,KAAK,EAMhE,GAIF,EAIA,GAAM,iBAAiB,CAAC,SAAS,CAAC,cAAc,CAAG,SAAU,CAAG,CAAE,CAAC,CAAE,CAAG,EAEvE,IAAI,EAAO,IAAI,CAAC,IAAI,CAAC,SAAS,CAAE,EAAG,CAAC,IAAI,CAGxC,IAFA,GAAY,EAAK,MAAM,CAEf,EAAM,EAAK,MAAM,CAAE,IAE1B,GAAK,CAAI,CAAE,EAAK,CAAC,SAAS,CAAE,GAE3B,OAAO,CAAI,CAAE,EAAK,CAMpB,OAAO,CAAI,CAAE,EAAG,AAEjB,EAIA,GAAM,iBAAiB,CAAC,SAAS,CAAC,cAAc,CAAG,SAAU,CAAG,CAAE,CAAC,CAAE,CAAG,EAEvE,IAAI,EAAO,IAAI,CAAC,IAAI,CAAC,SAAS,CAAE,EAAG,CAAC,IAAI,CAGxC,IAFA,EAAM,GAAO,EAAI,EAAM,EAAM,EAAK,MAAM,CAEhC,GAAO,EAAG,IAEjB,GAAK,CAAI,CAAE,EAAK,CAAC,SAAS,CAAE,GAE3B,OAAO,CAAI,CAAE,EAAK,CAMpB,OAAO,CAAI,CAAE,EAAK,MAAM,CAAG,EAAG,AAE/B,EAQA,GAAM,UAAU,CAAG,SAAW,CAAI,CAAE,CAAG,CAAE,CAAc,EAEtD,GAAM,QAAQ,CAAC,IAAI,CAAE,IAAI,EAIzB,IAAI,EAAW,IAAI,GAAM,iBAAiB,CAFhC,GAAa,EAEkC,EAAM,GAC/D,EAAS,EAAE,CAAC,GAAG,CAAE,EAAG,GAAI,GACxB,EAAS,MAAM,CAAE,IAAI,GAAM,OAAO,CAAE,EAAG,EAAG,IAC1C,IAAI,CAAC,GAAG,CAAE,GAEV,IAAI,EAAW,IAAI,GAAM,iBAAiB,CAPhC,GAAa,EAOkC,EAAM,GAC/D,EAAS,EAAE,CAAC,GAAG,CAAE,EAAG,GAAI,GACxB,EAAS,MAAM,CAAE,IAAI,GAAM,OAAO,CAAE,GAAI,EAAG,IAC3C,IAAI,CAAC,GAAG,CAAE,GAEV,IAAI,EAAW,IAAI,GAAM,iBAAiB,CAZhC,GAAa,EAYkC,EAAM,GAC/D,EAAS,EAAE,CAAC,GAAG,CAAE,EAAG,EAAG,GACvB,EAAS,MAAM,CAAE,IAAI,GAAM,OAAO,CAAE,EAAG,EAAG,IAC1C,IAAI,CAAC,GAAG,CAAE,GAEV,IAAI,EAAW,IAAI,GAAM,iBAAiB,CAjBhC,GAAa,EAiBkC,EAAM,GAC/D,EAAS,EAAE,CAAC,GAAG,CAAE,EAAG,EAAG,IACvB,EAAS,MAAM,CAAE,IAAI,GAAM,OAAO,CAAE,EAAG,GAAI,IAC3C,IAAI,CAAC,GAAG,CAAE,GAEV,IAAI,EAAW,IAAI,GAAM,iBAAiB,CAtBhC,GAAa,EAsBkC,EAAM,GAC/D,EAAS,EAAE,CAAC,GAAG,CAAE,EAAG,GAAI,GACxB,EAAS,MAAM,CAAE,IAAI,GAAM,OAAO,CAAE,EAAG,EAAG,IAC1C,IAAI,CAAC,GAAG,CAAE,GAEV,IAAI,EAAW,IAAI,GAAM,iBAAiB,CA3BhC,GAAa,EA2BkC,EAAM,GAC/D,EAAS,EAAE,CAAC,GAAG,CAAE,EAAG,GAAI,GACxB,EAAS,MAAM,CAAE,IAAI,GAAM,OAAO,CAAE,EAAG,EAAG,KAC1C,IAAI,CAAC,GAAG,CAAE,GAEV,IAAI,CAAC,YAAY,CAAG,IAAI,GAAM,qBAAqB,CAAE,EAAgB,EAAgB,CAAE,OAAQ,GAAM,SAAS,CAAE,UAAW,GAAM,YAAY,CAAE,UAAW,GAAM,YAAY,AAAC,GAE7K,IAAI,CAAC,aAAa,CAAG,SAAW,CAAQ,CAAE,CAAK,EAE9C,IAAI,EAAe,IAAI,CAAC,YAAY,CAChC,EAAkB,EAAa,eAAe,AAElD,CAAA,EAAa,eAAe,CAAG,CAAA,EAE/B,EAAa,cAAc,CAAG,EAC9B,EAAS,MAAM,CAAE,EAAO,EAAU,GAElC,EAAa,cAAc,CAAG,EAC9B,EAAS,MAAM,CAAE,EAAO,EAAU,GAElC,EAAa,cAAc,CAAG,EAC9B,EAAS,MAAM,CAAE,EAAO,EAAU,GAElC,EAAa,cAAc,CAAG,EAC9B,EAAS,MAAM,CAAE,EAAO,EAAU,GAElC,EAAa,cAAc,CAAG,EAC9B,EAAS,MAAM,CAAE,EAAO,EAAU,GAElC,EAAa,eAAe,CAAG,EAE/B,EAAa,cAAc,CAAG,EAC9B,EAAS,MAAM,CAAE,EAAO,EAAU,EAEnC,CAED,EAEA,GAAM,UAAU,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,QAAQ,CAAC,SAAS,EAYpE,GAAM,cAAc,CAAG,SAAW,CAAK,CAAE,CAAM,CAAE,CAAG,CAAE,CAAI,CAAE,CAAG,CAAE,CAAS,CAAE,CAAQ,EAEnF,GAAM,MAAM,CAAC,IAAI,CAAE,IAAI,EAEvB,IAAI,CAAC,GAAG,CAAG,EAEX,IAAI,CAAC,IAAI,CAAG,CAAC,EAAQ,EACrB,IAAI,CAAC,KAAK,CAAG,EAAQ,EACrB,IAAI,CAAC,GAAG,CAAG,EAAS,EACpB,IAAI,CAAC,MAAM,CAAG,CAAC,EAAS,EAIxB,IAAI,CAAC,OAAO,CAAG,IAAI,GAAM,kBAAkB,CAAE,CAAA,CAAA,EAAQ,CAAA,EAAK,EAAQ,EAAG,EAAS,EAAG,CAAA,CAAA,EAAS,CAAA,EAAM,EAAW,GAC3G,IAAI,CAAC,OAAO,CAAG,IAAI,GAAM,iBAAiB,CAAE,EAAK,EAAQ,EAAQ,EAAM,GAEvE,IAAI,CAAC,IAAI,CAAG,EAEZ,IAAI,CAAC,aAAa,EAInB,EAEA,GAAM,cAAc,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,MAAM,CAAC,SAAS,EAEtE,GAAM,cAAc,CAAC,SAAS,CAAC,aAAa,CAAG,WAI9C,IAAI,CAAC,IAAI,CAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAC7B,IAAI,CAAC,GAAG,CAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAE3B,IAAI,CAAC,OAAO,CAAC,GAAG,CAAI,IAAI,CAAC,GAAG,CAAG,IAAI,CAAC,IAAI,CAExC,IAAI,CAAC,OAAO,CAAC,sBAAsB,GAEnC,IAAI,CAAC,gBAAgB,CAAG,IAAI,CAAC,OAAO,CAAC,gBAAgB,CAErD,IAAI,CAAC,iBAAiB,CAAG,CAAA,EACzB,IAAI,CAAC,kBAAkB,CAAG,CAAA,CAE3B,EAEA,GAAM,cAAc,CAAC,SAAS,CAAC,cAAc,CAAG,WAI/C,IAAI,EAAM,IAAI,CAAC,GAAG,CACd,EAAS,IAAI,CAAC,OAAO,CAAC,MAAM,CAQ5B,EAAa,AAFE,CAAA,AALR,IAAI,CAAC,OAAO,CAAC,IAAI,CAClB,IAAI,CAAC,OAAO,CAAC,GAAG,AAIA,EAAQ,EAEjB,KAAK,GAAG,CAAE,EAAM,GAG7B,EAAY,AAFE,EAAI,EACS,EACF,EAE7B,GAAc,IAAI,CAAC,IAAI,CACvB,GAAa,IAAI,CAAC,IAAI,CAEtB,IAAI,CAAC,OAAO,CAAC,IAAI,CAAG,CAAC,EACrB,IAAI,CAAC,OAAO,CAAC,KAAK,CAAG,EACrB,IAAI,CAAC,OAAO,CAAC,GAAG,CAAG,EACnB,IAAI,CAAC,OAAO,CAAC,MAAM,CAAG,CAAC,EAYvB,IAAI,CAAC,OAAO,CAAC,sBAAsB,GAEnC,IAAI,CAAC,IAAI,CAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAC7B,IAAI,CAAC,GAAG,CAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAC3B,IAAI,CAAC,gBAAgB,CAAG,IAAI,CAAC,OAAO,CAAC,gBAAgB,CAErD,IAAI,CAAC,iBAAiB,CAAG,CAAA,EACzB,IAAI,CAAC,kBAAkB,CAAG,CAAA,CAE3B,EAGA,GAAM,cAAc,CAAC,SAAS,CAAC,OAAO,CAAG,SAAU,CAAK,CAAE,CAAM,EAE/D,IAAI,CAAC,OAAO,CAAC,MAAM,CAAG,EAAQ,EAC9B,IAAI,CAAC,IAAI,CAAG,CAAC,EAAQ,EACrB,IAAI,CAAC,KAAK,CAAG,EAAQ,EACrB,IAAI,CAAC,GAAG,CAAG,EAAS,EACpB,IAAI,CAAC,MAAM,CAAG,CAAC,EAAS,CAEzB,EAGA,GAAM,cAAc,CAAC,SAAS,CAAC,MAAM,CAAG,SAAU,CAAG,EAEpD,IAAI,CAAC,GAAG,CAAG,EAEN,IAAI,CAAC,iBAAiB,CAE1B,IAAI,CAAC,aAAa,GAIlB,IAAI,CAAC,cAAc,EAIrB,EAIA,GAAM,cAAc,CAAC,SAAS,CAAC,sBAAsB,CAAG,WAElD,IAAI,CAAC,iBAAiB,CAE1B,IAAI,CAAC,aAAa,IAIlB,IAAI,CAAC,aAAa,GAClB,IAAI,CAAC,cAAc,GAIrB,EAOA,GAAM,cAAc,CAAC,SAAS,CAAC,OAAO,CAAG,SAAW,CAAW,CAAE,CAAW,EAEtD,KAAA,IAAhB,GAA4B,CAAA,EAAc,EAA/C,EAEA,IAAI,EAAM,EAAI,GAAM,IAAI,CAAC,QAAQ,CAAE,KAAK,IAAI,CAAE,EAAgB,CAAA,AAAc,EAAd,CAAc,IAI5E,OAFA,IAAI,CAAC,MAAM,CAAE,GAEN,CACR,EAGA,GAAM,cAAc,CAAC,SAAS,CAAC,OAAO,CAAG,SAAU,CAAI,EAEtD,IAAI,CAAC,IAAI,CAAG,EAEP,IAAI,CAAC,iBAAiB,CAE1B,IAAI,CAAC,aAAa,GAIlB,IAAI,CAAC,cAAc,EAIrB,EAEA,GAAM,cAAc,CAAC,SAAS,CAAC,WAAW,CAAG,WAE5C,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAG,EAClB,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAG,EAClB,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAG,EAIlB,IAAI,CAAC,kBAAkB,CAAG,CAAA,CAE3B,EAEA,GAAM,cAAc,CAAC,SAAS,CAAC,UAAU,CAAG,WAE3C,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAG,EAClB,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAG,KAAK,EAAE,CACzB,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAG,EAClB,IAAI,CAAC,kBAAkB,CAAG,CAAA,CAE3B,EAEA,GAAM,cAAc,CAAC,SAAS,CAAC,UAAU,CAAG,WAE3C,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAG,EAClB,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAG,CAAE,KAAK,EAAE,CAAG,EAC9B,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAG,EAClB,IAAI,CAAC,kBAAkB,CAAG,CAAA,CAE3B,EAEA,GAAM,cAAc,CAAC,SAAS,CAAC,WAAW,CAAG,WAE5C,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAG,EAClB,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAG,KAAK,EAAE,CAAG,EAC5B,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAG,EAClB,IAAI,CAAC,kBAAkB,CAAG,CAAA,CAE3B,EAEA,GAAM,cAAc,CAAC,SAAS,CAAC,SAAS,CAAG,WAE1C,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAG,CAAE,KAAK,EAAE,CAAG,EAC9B,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAG,EAClB,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAG,EAClB,IAAI,CAAC,kBAAkB,CAAG,CAAA,CAE3B,EAEA,GAAM,cAAc,CAAC,SAAS,CAAC,YAAY,CAAG,WAE7C,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAG,KAAK,EAAE,CAAG,EAC5B,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAG,EAClB,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAG,EAClB,IAAI,CAAC,kBAAkB,CAAG,CAAA,CAE3B,EAQA,GAAM,gBAAgB,CAAG,SAAW,CAAW,CAAE,CAAW,EAE3D,GAAM,QAAQ,CAAC,IAAI,CAAE,IAAI,EAmBzB,IAAM,IAdF,EAAM,KAHD,EAIL,EAAM,KAHD,EAKL,EAAO,CAAE,CANJ,EAMU,EAAG,EAAG,CAAE,CALlB,EAKwB,EAAG,EAAG,CAAE,CAAE,CANlC,EAMuC,EAAG,EAAG,CAAE,CAAE,CALjD,EAKsD,EAAG,EAAG,CACjE,CAAE,EAPG,EAOI,EAAG,CAAE,CAAE,EANX,EAMkB,EAAG,CAAE,CAAE,EAAG,CAP5B,EAOiC,EAAG,CAAE,CAAE,EAAG,CAN3C,EAMgD,EAAG,CACxD,CAAE,EAAG,EARA,EAQO,CAAE,CAAE,EAAG,EAPd,EAOqB,CAAE,CAAE,EAAG,EAAG,CAR/B,EAQoC,CAAE,CAAE,EAAG,EAAG,CAP9C,EAOmD,CACxD,CAAE,EAAK,EAAK,EAAG,CAAE,CAAE,EAAK,EAAK,EAAG,CAAE,CAAE,CAAC,EAAK,CAAC,EAAK,EAAG,CAAE,CAAE,CAAC,EAAK,CAAC,EAAK,EAAG,CACtE,CAAE,EAAK,CAAC,EAAK,EAAG,CAAE,CAAE,EAAK,CAAC,EAAK,EAAG,CAAE,CAAE,CAAC,EAAK,EAAK,EAAG,CAAE,CAAE,CAAC,EAAK,EAAK,EAAG,CACtE,CAAE,EAAK,EAAG,EAAK,CAAE,CAAE,EAAK,EAAG,EAAK,CAAE,CAAE,CAAC,EAAK,EAAG,CAAC,EAAK,CAAE,CAAE,CAAC,EAAK,EAAG,CAAC,EAAK,CACtE,CAAE,EAAK,EAAG,CAAC,EAAK,CAAE,CAAE,EAAK,EAAG,CAAC,EAAK,CAAE,CAAE,CAAC,EAAK,EAAG,EAAK,CAAE,CAAE,CAAC,EAAK,EAAG,EAAK,CACtE,CAAE,EAAG,EAAK,EAAK,CAAE,CAAE,EAAG,EAAK,EAAK,CAAE,CAAE,EAAG,CAAC,EAAK,CAAC,EAAK,CAAE,CAAE,EAAG,CAAC,EAAK,CAAC,EAAK,CACtE,CAAE,EAAG,EAAK,CAAC,EAAK,CAAE,CAAE,EAAG,EAAK,CAAC,EAAK,CAAE,CAAE,EAAG,CAAC,EAAK,EAAK,CAAE,CAAE,EAAG,CAAC,EAAK,EAAK,CACzE,CAES,EAAI,EAAG,EAAK,EAAK,MAAM,CAAE,EAAI,EAAI,IAAO,CAEjD,IAAI,EAAI,CAAI,CAAE,EAAG,CAAE,EAAG,CAClB,EAAI,CAAI,CAAE,EAAG,CAAE,EAAG,CAClB,EAAI,CAAI,CAAE,EAAG,CAAE,EAAG,CAEtB,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAE,IAAI,GAAM,OAAO,CAAE,EAAG,EAAG,GAE9C,CAED,EAEA,GAAM,gBAAgB,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,QAAQ,CAAC,SAAS,EAI1E,GAAM,cAAc,CAAG,SAAW,CAAM,CAAE,CAAQ,CAAE,CAAU,CAAE,CAAW,EAEvE,GAAM,QAAQ,CAAC,IAAI,CAAE,IAAI,EAEzB,EAAS,GAAU,GAEnB,EAAa,AAAe,KAAA,IAAf,EAA2B,EAAa,EACrD,EAAc,AAAgB,KAAA,IAAhB,EAA4B,EAAc,AAAU,EAAV,KAAK,EAAE,CAC/D,EAAW,AAAa,KAAA,IAAb,EAAyB,KAAK,GAAG,CAAE,EAAG,GAAa,EAE9D,IAAI,EAAG,EAAM,EAAE,CACf,EAAS,IAAI,GAAM,OAAO,CAAI,EAAW,IAAI,GAAM,OAAO,CAAE,GAAK,IAKjE,IAHA,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,GACnB,EAAI,IAAI,CAAE,GAEJ,EAAI,EAAG,GAAK,EAAU,IAAO,CAE/B,IAAI,EAAS,IAAI,GAAM,OAAO,AAE9B,CAAA,EAAO,CAAC,CAAG,EAAS,KAAK,GAAG,CAAE,EAAa,EAAI,EAAW,GAC1D,EAAO,CAAC,CAAG,EAAS,KAAK,GAAG,CAAE,EAAa,EAAI,EAAW,GAE1D,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAE,GACpB,EAAI,IAAI,CAAE,IAAI,GAAM,OAAO,CAAI,AAAA,CAAA,EAAO,CAAC,CAAG,EAAS,CAAA,EAAM,EAAG,CAAI,CAAA,EAAO,CAAC,CAAG,EAAS,CAAA,EAAM,EAAI,GAElG,CAEA,IAAI,EAAI,IAAI,GAAM,OAAO,CAAE,EAAG,EAAG,IAEjC,IAAM,EAAI,EAAG,GAAK,EAAU,IAAO,CAE/B,IAAI,EAAK,EACL,EAAK,EAAI,EAGb,IAAI,CAAC,KAAK,CAAC,IAAI,CAAE,IAAI,GAAM,KAAK,CAAE,EAAI,EAF7B,EAEqC,CAAE,EAAG,EAAG,EAAG,GACzD,IAAI,CAAC,aAAa,CAAE,EAAG,CAAC,IAAI,CAAE,CAAE,CAAG,CAAE,EAAG,CAAE,CAAG,CAAE,EAAI,EAAG,CAAE,EAAU,CAEtE,CAEA,IAAI,CAAC,gBAAgB,GACrB,IAAI,CAAC,kBAAkB,GAEvB,IAAI,CAAC,cAAc,CAAG,IAAI,GAAM,MAAM,CAAE,IAAI,GAAM,OAAO,CAAI,EAEjE,EAEA,GAAM,cAAc,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,QAAQ,CAAC,SAAS,EAMxE,GAAM,YAAY,CAAG,SAAW,CAAK,CAAE,CAAM,CAAE,CAAK,CAAE,CAAa,CAAE,CAAc,CAAE,CAAa,EAEjG,GAAM,QAAQ,CAAC,IAAI,CAAE,IAAI,EAEzB,IAAI,EAAQ,IAAI,AAEhB,CAAA,IAAI,CAAC,KAAK,CAAG,EACb,IAAI,CAAC,MAAM,CAAG,EACd,IAAI,CAAC,KAAK,CAAG,EAEb,IAAI,CAAC,aAAa,CAAG,GAAiB,EACtC,IAAI,CAAC,cAAc,CAAG,GAAkB,EACxC,IAAI,CAAC,aAAa,CAAG,GAAiB,EAEtC,IAAI,EAAa,IAAI,CAAC,KAAK,CAAG,EAC1B,EAAc,IAAI,CAAC,MAAM,CAAG,EAC5B,EAAa,IAAI,CAAC,KAAK,CAAG,EAS9B,SAAS,EAAY,CAAC,CAAE,CAAC,CAAE,CAAI,CAAE,CAAI,CAAE,CAAK,CAAE,CAAM,CAAE,CAAK,CAAE,CAAa,EAEzE,IAAI,EAAG,EAAI,EACX,EAAQ,EAAM,aAAa,CAC3B,EAAQ,EAAM,cAAc,CAC5B,EAAa,EAAQ,EACrB,EAAc,EAAS,EACvB,EAAS,EAAM,QAAQ,CAAC,MAAM,AAEzB,AAAQ,CAAA,MAAR,GAAe,AAAM,MAAN,GAAiB,AAAM,MAAN,GAAa,AAAM,MAAN,EAEjD,EAAI,IAES,AAAM,MAAN,GAAa,AAAM,MAAN,GAAiB,AAAM,MAAN,GAAa,AAAM,MAAN,GAExD,EAAI,IACJ,EAAQ,EAAM,aAAa,EAEd,CAAA,AAAM,MAAN,GAAa,AAAM,MAAN,GAAiB,AAAM,MAAN,GAAa,AAAM,MAAN,CAAM,IAE9D,EAAI,IACJ,EAAQ,EAAM,aAAa,EAI5B,IAAI,EAAS,EAAQ,EACrB,EAAS,EAAQ,EACjB,EAAgB,EAAQ,EACxB,EAAiB,EAAS,EAC1B,EAAS,IAAI,GAAM,OAAO,CAI1B,IAAM,EAAK,EAFX,CAAM,CAAE,EAAG,CAAG,EAAQ,EAAI,EAAI,GAEhB,EAAK,EAAQ,IAE1B,IAAM,EAAK,EAAG,EAAK,EAAQ,IAAQ,CAElC,IAAI,EAAS,IAAI,GAAM,OAAO,AAC9B,CAAA,CAAM,CAAE,EAAG,CAAK,AAAA,CAAA,EAAK,EAAgB,CAAA,EAAe,EACpD,CAAM,CAAE,EAAG,CAAK,AAAA,CAAA,EAAK,EAAiB,CAAA,EAAgB,EACtD,CAAM,CAAE,EAAG,CAAG,EAEd,EAAM,QAAQ,CAAC,IAAI,CAAE,EAEtB,CAID,IAAM,EAAK,EAAG,EAAK,EAAO,IAEzB,IAAM,EAAK,EAAG,EAAK,EAAO,IAAO,CAEhC,IAAI,EAAI,EAAK,EAAS,EAClB,EAAI,EAAK,EAAW,CAAA,EAAK,CAAA,EACzB,EAAI,EAAO,EAAM,EAAW,CAAA,EAAK,CAAA,EACjC,EAAM,EAAK,EAAM,EAAS,EAE1B,EAAO,IAAI,GAAM,KAAK,CAAE,EAAI,EAAQ,EAAI,EAAQ,EAAI,EAAQ,EAAI,GACpE,EAAK,MAAM,CAAC,IAAI,CAAE,GAClB,EAAK,aAAa,CAAC,IAAI,CAAE,EAAO,KAAK,GAAI,EAAO,KAAK,GAAI,EAAO,KAAK,GAAI,EAAO,KAAK,IACrF,EAAK,aAAa,CAAG,EAErB,EAAM,KAAK,CAAC,IAAI,CAAE,GAClB,EAAM,aAAa,CAAE,EAAG,CAAC,IAAI,CAAE,CAC5B,IAAI,GAAM,OAAO,CAAE,EAAK,EAAO,EAAI,EAAK,GACxC,IAAI,GAAM,OAAO,CAAE,EAAK,EAAO,EAAM,AAAA,CAAA,EAAK,CAAA,EAAM,GAChD,IAAI,GAAM,OAAO,CAAE,AAAE,CAAA,EAAK,CAAA,EAAM,EAAO,EAAG,AAAE,CAAA,EAAK,CAAA,EAAM,GACvD,IAAI,GAAM,OAAO,CAAI,AAAA,CAAA,EAAK,CAAA,EAAM,EAAO,EAAI,EAAK,GAChD,CAEJ,CAIF,CAjFA,EAAY,IAAK,IAAK,GAAK,GAAK,IAAI,CAAC,KAAK,CAAE,IAAI,CAAC,MAAM,CAAE,EAAY,GACrE,EAAY,IAAK,IAAO,EAAG,GAAK,IAAI,CAAC,KAAK,CAAE,IAAI,CAAC,MAAM,CAAE,CAAE,EAAY,GACvE,EAAY,IAAK,IAAO,EAAK,EAAG,IAAI,CAAC,KAAK,CAAE,IAAI,CAAC,KAAK,CAAE,EAAa,GACrE,EAAY,IAAK,IAAO,EAAG,GAAK,IAAI,CAAC,KAAK,CAAE,IAAI,CAAC,KAAK,CAAE,CAAE,EAAa,GACvE,EAAY,IAAK,IAAO,EAAG,GAAK,IAAI,CAAC,KAAK,CAAE,IAAI,CAAC,MAAM,CAAE,EAAY,GACrE,EAAY,IAAK,IAAK,GAAK,GAAK,IAAI,CAAC,KAAK,CAAE,IAAI,CAAC,MAAM,CAAE,CAAE,EAAY,GA8EvE,IAAI,CAAC,gBAAgB,GACrB,IAAI,CAAC,aAAa,EAEnB,EAEA,GAAM,YAAY,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,QAAQ,CAAC,SAAS,EAKtE,GAAM,gBAAgB,CAAG,SAAW,CAAS,CAAE,CAAY,CAAE,CAAM,CAAE,CAAc,CAAE,CAAc,CAAE,CAAS,EAE7G,GAAM,QAAQ,CAAC,IAAI,CAAE,IAAI,EAEzB,EAAY,AAAc,KAAA,IAAd,EAA0B,EAAY,GAClD,EAAe,AAAiB,KAAA,IAAjB,EAA6B,EAAe,GAG3D,IAoCI,EAAI,EAhCJ,EAAG,EAJH,EAAa,AAFjB,CAAA,EAAS,AAAW,KAAA,IAAX,EAAuB,EAAS,GAAzC,EAE0B,EACtB,EAAY,GAAkB,EAC9B,EAAY,GAAkB,EAExB,EAAW,EAAE,CAAE,EAAM,EAAE,CAEjC,IAAM,EAAI,EAAG,GAAK,EAAW,IAAO,CAEnC,IAAI,EAAc,EAAE,CAChB,EAAS,EAAE,CAEX,EAAI,EAAI,EACR,EAAS,EAAM,CAAA,EAAe,CAAA,EAAc,EAEhD,IAAM,EAAI,EAAG,GAAK,EAAW,IAAO,CAEnC,IAAI,EAAI,EAAI,EAER,EAAS,IAAI,GAAM,OAAO,AAC9B,CAAA,EAAO,CAAC,CAAG,EAAS,KAAK,GAAG,CAAE,EAAI,KAAK,EAAE,CAAG,GAC5C,EAAO,CAAC,CAAG,CAAE,EAAI,EAAS,EAC1B,EAAO,CAAC,CAAG,EAAS,KAAK,GAAG,CAAE,EAAI,KAAK,EAAE,CAAG,GAE5C,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAE,GAEpB,EAAY,IAAI,CAAE,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAG,GACzC,EAAO,IAAI,CAAE,IAAI,GAAM,OAAO,CAAE,EAAG,EAAI,GAExC,CAEA,EAAS,IAAI,CAAE,GACf,EAAI,IAAI,CAAE,EAEX,CAEA,IAAI,EAAW,AAAE,CAAA,EAAe,CAAA,EAAc,EAG9C,IAAM,EAAI,EAAG,EAAI,EAAW,IAiB3B,IAfK,AAAc,IAAd,GAEJ,EAAK,IAAI,CAAC,QAAQ,CAAE,CAAQ,CAAE,EAAG,CAAE,EAAG,CAAE,CAAC,KAAK,GAC9C,EAAK,IAAI,CAAC,QAAQ,CAAE,CAAQ,CAAE,EAAG,CAAE,EAAI,EAAG,CAAE,CAAC,KAAK,KAIlD,EAAK,IAAI,CAAC,QAAQ,CAAE,CAAQ,CAAE,EAAG,CAAE,EAAG,CAAE,CAAC,KAAK,GAC9C,EAAK,IAAI,CAAC,QAAQ,CAAE,CAAQ,CAAE,EAAG,CAAE,EAAI,EAAG,CAAE,CAAC,KAAK,IAInD,EAAG,IAAI,CAAE,KAAK,IAAI,CAAE,EAAG,CAAC,CAAG,EAAG,CAAC,CAAG,EAAG,CAAC,CAAG,EAAG,CAAC,EAAK,GAAW,SAAS,GACtE,EAAG,IAAI,CAAE,KAAK,IAAI,CAAE,EAAG,CAAC,CAAG,EAAG,CAAC,CAAG,EAAG,CAAC,CAAG,EAAG,CAAC,EAAK,GAAW,SAAS,GAEhE,EAAI,EAAG,EAAI,EAAW,IAAO,CAElC,IAAI,EAAK,CAAQ,CAAE,EAAG,CAAE,EAAG,CACvB,EAAK,CAAQ,CAAE,EAAI,EAAG,CAAE,EAAG,CAC3B,EAAK,CAAQ,CAAE,EAAI,EAAG,CAAE,EAAI,EAAG,CAC/B,EAAK,CAAQ,CAAE,EAAG,CAAE,EAAI,EAAG,CAE3B,EAAK,EAAG,KAAK,GACb,EAAK,EAAG,KAAK,GACb,EAAK,EAAG,KAAK,GACb,EAAK,EAAG,KAAK,GAEb,EAAM,CAAG,CAAE,EAAG,CAAE,EAAG,CAAC,KAAK,GACzB,EAAM,CAAG,CAAE,EAAI,EAAG,CAAE,EAAG,CAAC,KAAK,GAC7B,EAAM,CAAG,CAAE,EAAI,EAAG,CAAE,EAAI,EAAG,CAAC,KAAK,GACjC,EAAM,CAAG,CAAE,EAAG,CAAE,EAAI,EAAG,CAAC,KAAK,GAEjC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAE,IAAI,GAAM,KAAK,CAAE,EAAI,EAAI,EAAI,EAAI,CAAE,EAAI,EAAI,EAAI,EAAI,GACpE,IAAI,CAAC,aAAa,CAAE,EAAG,CAAC,IAAI,CAAE,CAAE,EAAK,EAAK,EAAK,EAAK,CAErD,CAMD,GAAK,CAAC,GAAa,EAAY,EAI9B,IAFA,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAE,IAAI,GAAM,OAAO,CAAE,EAAG,EAAY,IAEhD,EAAI,EAAG,EAAI,EAAW,IAAO,CAElC,IAAI,EAAK,CAAQ,CAAE,EAAG,CAAE,EAAG,CACvB,EAAK,CAAQ,CAAE,EAAG,CAAE,EAAI,EAAG,CAC3B,EAAK,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAG,EAE5B,EAAK,IAAI,GAAM,OAAO,CAAE,EAAG,EAAG,GAC9B,EAAK,IAAI,GAAM,OAAO,CAAE,EAAG,EAAG,GAC9B,EAAK,IAAI,GAAM,OAAO,CAAE,EAAG,EAAG,GAE9B,EAAM,CAAG,CAAE,EAAG,CAAE,EAAG,CAAC,KAAK,GACzB,EAAM,CAAG,CAAE,EAAG,CAAE,EAAI,EAAG,CAAC,KAAK,GAC7B,EAAM,IAAI,GAAM,OAAO,CAAE,EAAI,CAAC,CAAE,GAEpC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAE,IAAI,GAAM,KAAK,CAAE,EAAI,EAAI,EAAI,CAAE,EAAI,EAAI,EAAI,GAC5D,IAAI,CAAC,aAAa,CAAE,EAAG,CAAC,IAAI,CAAE,CAAE,EAAK,EAAK,EAAK,CAEhD,CAMD,GAAK,CAAC,GAAa,EAAe,EAIjC,IAFA,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAE,IAAI,GAAM,OAAO,CAAE,EAAG,CAAE,EAAY,IAElD,EAAI,EAAG,EAAI,EAAW,IAAO,CAElC,IAAI,EAAK,CAAQ,CAAE,EAAG,CAAE,EAAI,EAAG,CAC3B,EAAK,CAAQ,CAAE,EAAG,CAAE,EAAG,CACvB,EAAK,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAG,EAE5B,EAAK,IAAI,GAAM,OAAO,CAAE,EAAG,GAAK,GAChC,EAAK,IAAI,GAAM,OAAO,CAAE,EAAG,GAAK,GAChC,EAAK,IAAI,GAAM,OAAO,CAAE,EAAG,GAAK,GAEhC,EAAM,CAAG,CAAE,EAAG,CAAE,EAAI,EAAG,CAAC,KAAK,GAC7B,EAAM,CAAG,CAAE,EAAG,CAAE,EAAG,CAAC,KAAK,GACzB,EAAM,IAAI,GAAM,OAAO,CAAE,EAAI,CAAC,CAAE,GAEpC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAE,IAAI,GAAM,KAAK,CAAE,EAAI,EAAI,EAAI,CAAE,EAAI,EAAI,EAAI,GAC5D,IAAI,CAAC,aAAa,CAAE,EAAG,CAAC,IAAI,CAAE,CAAE,EAAK,EAAK,EAAK,CAEhD,CAID,IAAI,CAAC,gBAAgB,GACrB,IAAI,CAAC,kBAAkB,EAExB,EAEA,GAAM,gBAAgB,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,QAAQ,CAAC,SAAS,EA6B1E,GAAM,eAAe,CAAG,SAAW,CAAM,CAAE,CAAO,EAEjD,GAAK,AAAqB,KAAA,IAAb,EAA2B,CACvC,EAAS,EAAE,CACX,MACD,CAEA,GAAM,QAAQ,CAAC,IAAI,CAAE,IAAI,EAEzB,EAAS,aAAkB,MAAQ,EAAS,CAAE,EAAQ,CAEtD,IAAI,CAAC,OAAO,CAAG,CAAM,CAAE,EAAO,MAAM,CAAG,EAAG,CAAC,cAAc,GAEzD,IAAI,CAAC,YAAY,CAAE,EAAQ,GAE3B,IAAI,CAAC,gBAAgB,GACrB,IAAI,CAAC,kBAAkB,EAUxB,EAEA,GAAM,eAAe,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,QAAQ,CAAC,SAAS,EAEzE,GAAM,eAAe,CAAC,SAAS,CAAC,YAAY,CAAG,SAAW,CAAM,CAAE,CAAO,EAGxE,IAAM,IAFF,EAAK,EAAO,MAAM,CAEZ,EAAI,EAAG,EAAI,EAAI,IAAO,CAC/B,IAAI,EAAQ,CAAM,CAAE,EAAG,CACvB,IAAI,CAAC,QAAQ,CAAE,EAAO,EACvB,CACD,EAEA,GAAM,eAAe,CAAC,SAAS,CAAC,QAAQ,CAAG,SAAW,CAAK,CAAE,CAAO,EAEnE,IA2WI,EA9VA,EAbA,EAAS,AAAmB,KAAA,IAAnB,EAAQ,MAAM,CAAiB,EAAQ,MAAM,CAAG,IAEzD,EAAiB,AAA2B,KAAA,IAA3B,EAAQ,cAAc,CAAiB,EAAQ,cAAc,CAAG,EACjF,EAAY,AAAsB,KAAA,IAAtB,EAAQ,SAAS,CAAiB,EAAQ,SAAS,CAAG,EAAiB,EACnF,EAAgB,AAA0B,KAAA,IAA1B,EAAQ,aAAa,CAAiB,EAAQ,aAAa,CAAG,EAE9E,EAAe,AAAyB,KAAA,IAAzB,EAAQ,YAAY,EAAiB,EAAQ,YAAY,CAExE,EAAgB,AAA0B,KAAA,IAA1B,EAAQ,aAAa,CAAiB,EAAQ,aAAa,CAAG,GAE9E,EAAQ,AAAkB,KAAA,IAAlB,EAAQ,KAAK,CAAiB,EAAQ,KAAK,CAAG,EAEtD,EAAc,EAAQ,WAAW,CACrB,EAAgB,CAAA,EAE5B,EAAW,EAAQ,QAAQ,CAC3B,EAAkB,EAAQ,eAAe,CAGzC,EAAQ,AAAwB,KAAA,IAAxB,EAAQ,WAAW,CAAiB,EAAQ,WAAW,CAAG,GAAM,eAAe,CAAC,gBAAgB,AAE9F,CAAA,IAAI,CAAC,OAAO,CAMrB,IAEJ,EAAa,EAAY,eAAe,CAAE,GAE1C,EAAgB,CAAA,EAChB,EAAe,CAAA,EAOf,EAAa,AAAmB,KAAA,IAAnB,EAAQ,MAAM,CAAiB,EAAQ,MAAM,CAAG,IAAI,GAAM,YAAY,CAAC,YAAY,CAAC,EAAa,EAAO,CAAA,GAIrH,EAAW,IAAI,GAAM,OAAO,CAC5B,EAAS,IAAI,GAAM,OAAO,CAC1B,EAAY,IAAI,GAAM,OAAO,EAMvB,IAEN,EAAgB,EAChB,EAAiB,EACjB,EAAY,GAOb,IAAI,EAAQ,IAAI,CAGZ,EAAe,IAAI,CAAC,QAAQ,CAAC,MAAM,CAEnC,EAAc,EAAM,aAAa,CAAE,GAEnC,EAAW,EAAY,KAAK,CAC5B,EAAQ,EAAY,KAAK,CAEzB,EAAU,CAAC,GAAM,KAAK,CAAC,KAAK,CAAC,WAAW,CAAE,GAE9C,GAAK,EAAU,CAMd,IAAM,EAAI,EAJV,EAAW,EAAS,OAAO,GAId,EAAK,EAAM,MAAM,CAAE,EAAI,EAAI,IAEvC,EAAQ,CAAK,CAAE,EAAG,CAEb,GAAM,KAAK,CAAC,KAAK,CAAC,WAAW,CAAE,IAEnC,CAAA,CAAK,CAAE,EAAG,CAAG,EAAM,OAAO,EAF3B,EAQD,EAAU,CAAA,CAEX,CAGA,IAAI,EAAQ,GAAM,KAAK,CAAC,KAAK,CAAC,gBAAgB,CAAG,EAAU,GAIvD,EAAU,EAEd,IAAM,EAAI,EAAG,EAAK,EAAM,MAAM,CAAG,EAAI,EAAI,IAExC,EAAQ,CAAK,CAAE,EAAG,CAElB,EAAW,EAAS,MAAM,CAAE,GAK7B,SAAS,EAAW,CAAE,CAAE,CAAG,CAAE,CAAI,EAIhC,OAFM,GAAM,QAAQ,GAAG,CAAE,OAElB,EAAI,KAAK,GAAG,cAAc,CAAE,GAAO,GAAG,CAAE,EAEhD,CAEA,IA9FI,EAAY,EAAU,EAAQ,EAmC9B,EAAO,EAAG,EA2DV,EAAG,EAAI,EAAG,EACb,EACA,EADM,EAAO,EAAS,MAAM,CACtB,EAAO,EAAM,MAAM,CA0C1B,SAAS,EAAc,CAAI,CAAE,CAAI,CAAE,CAAI,EAEtC,IAzBI,EACA,EAQA,EAKA,EACA,EAgBH,EAAG,EACH,EAAa,EACb,EARG,EAAI,GAAM,eAAe,CAAC,IAAI,CACjC,EAAI,GAAM,eAAe,CAAC,IAAI,CAC9B,EAAQ,GAAM,eAAe,CAAC,IAAI,CAClC,EAAQ,GAAM,eAAe,CAAC,IAAI,CAClC,EAAI,GAAM,eAAe,CAAC,IAAI,CAC9B,EAAI,GAAM,eAAe,CAAC,IAAI,OA6B/B,CAlBA,EAAE,GAAG,CAAE,EAAK,CAAC,CAAG,EAAK,CAAC,CAAE,EAAK,CAAC,CAAG,EAAK,CAAC,EACvC,EAAE,GAAG,CAAE,EAAK,CAAC,CAAG,EAAK,CAAC,CAAE,EAAK,CAAC,CAAG,EAAK,CAAC,EAIvC,EAAI,EAAE,SAAS,GACf,EAAI,EAAE,SAAS,GAIf,EAAM,GAAG,CAAE,CAAC,EAAE,CAAC,CAAE,EAAE,CAAC,EACpB,EAAM,GAAG,CAAE,EAAE,CAAC,CAAE,CAAC,EAAE,CAAC,EAIpB,EAAE,IAAI,CAAE,GAAO,GAAG,CAAE,GACpB,EAAE,IAAI,CAAE,GAAO,GAAG,CAAE,GAEf,EAAE,MAAM,CAAE,IAGP,EAAM,KAAK,IAMnB,EAAE,IAAI,CAAE,GAAO,GAAG,CAAE,GACpB,EAAE,IAAI,CAAE,GAAO,GAAG,CAAE,GAEpB,EAAc,EAAE,GAAG,CAAE,GACrB,EAAoB,EAAE,GAAG,CAAE,GAAI,GAAG,CAAE,GAIf,IAAhB,IAEJ,QAAQ,GAAG,CAAE,oCAER,AAAsB,IAAtB,EAEJ,QAAQ,GAAG,CAAE,yBAIb,QAAQ,GAAG,CAAE,2BAQV,AAFL,CAAA,EAAI,EAAoB,CAAxB,EAES,KA9FL,EAAS,KAAK,KAAK,CAAE,AAkGG,EAlGE,CAAC,CAAG,AAkGZ,EAlGiB,CAAC,CAAE,AAkGd,EAlGmB,CAAC,CAAG,AAkG7B,EAlGkC,CAAC,IACrD,EAAS,KAAK,KAAK,CAAE,AAiGS,EAjGJ,CAAC,CAAG,AAiGZ,EAjGiB,CAAC,CAAE,AAiGR,EAjGa,CAAC,CAAG,AAiG7B,EAjGkC,CAAC,IAIxD,CAAA,GAAU,AAAU,EAAV,KAAK,EAAE,AAAG,EASjB,EAAI,CAAE,KAAK,GAAG,CALd,EAAS,AAAE,CAAA,EAAS,CAAA,EAAW,GAM/B,EAAI,CAAE,KAAK,GAAG,CAAE,GAEV,IAAI,GAAM,OAAO,CAAE,EAAG,IAuFzB,AAFQ,EAAE,cAAc,CAAE,GAAI,GAAG,CAAE,GAEtB,GAAG,CAAE,GAAO,KAAK,EAEtC,CA5Hc,EAAQ,MAAM,CAgI5B,IAAM,IAFF,EAAmB,EAAE,CAEf,EAAI,EAAG,EAAK,EAAQ,MAAM,CAAE,EAAI,EAAK,EAAG,EAAI,EAAI,EAAG,EAAI,EAAI,IAAM,IAAM,IAE3E,IAAM,GAAK,CAAA,EAAI,CAAA,EACf,IAAM,GAAK,CAAA,EAAI,CAAA,EAKT,CAAO,CAAE,EAAG,CACZ,CAAO,CAAE,EAAG,CACZ,CAAO,CAAE,EAAG,CAEvB,CAAgB,CAAE,EAAG,CAhId,EAgI6B,CAAO,CAAE,EAAG,CAAE,CAAO,CAAE,EAAG,CAAE,CAAO,CAAE,EAAG,EAd7E,IAkByB,EAArB,EAAiB,EAAE,CAAoB,EAAoB,EAAiB,MAAM,GAEtF,IAAM,EAAI,EAAG,EAAK,EAAM,MAAM,CAAE,EAAI,EAAI,IAAO,CAM9C,IAAM,EAAI,EAJV,EAAQ,CAAK,CAAE,EAAG,CAElB,EAAmB,EAAE,CAEW,EAAI,AAAvB,CAAA,EAAK,EAAM,MAAM,AAAN,EAAiB,EAAG,EAAI,EAAI,EAAG,EAAI,EAAI,IAAM,IAAM,IAErE,IAAM,GAAK,CAAA,EAAI,CAAA,EACf,IAAM,GAAK,CAAA,EAAI,CAAA,EAGpB,CAAgB,CAAE,EAAG,CAlJf,EAkJ8B,CAAK,CAAE,EAAG,CAAE,CAAK,CAAE,EAAG,CAAE,CAAK,CAAE,EAAG,EAIvE,EAAe,IAAI,CAAE,GACrB,EAAoB,EAAkB,MAAM,CAAE,EAE/C,CAKA,IAAM,EAAI,EAAG,EAAI,EAAe,IAAO,CAYtC,IAAM,EAAI,EARV,EAAI,EAAmB,CAAA,EADvB,CAAA,EAAI,EAAI,CAAR,CAC2B,EAG3B,EAAK,EAAc,KAAK,GAAG,CAAG,EAAI,KAAK,EAAE,CAAC,GAK7B,EAAK,EAAQ,MAAM,CAAE,EAAI,EAAI,IAIzC,EAAG,AAFH,CAAA,EAAO,EAAU,CAAO,CAAE,EAAG,CAAE,CAAgB,CAAE,EAAG,CAAE,EAAtD,EAEQ,CAAC,CAAE,EAAK,CAAC,CAAG,CAAE,GAMvB,IAAM,EAAI,EAAG,EAAK,EAAM,MAAM,CAAE,EAAI,EAAI,IAKvC,IAAM,EAAI,EAHV,EAAQ,CAAK,CAAE,EAAG,CAClB,EAAmB,CAAc,CAAE,EAAG,CAEzB,EAAK,EAAM,MAAM,CAAE,EAAI,EAAI,IAKvC,EAAG,AAHH,CAAA,EAAO,EAAU,CAAK,CAAE,EAAG,CAAE,CAAgB,CAAE,EAAG,CAAE,EAApD,EAGQ,CAAC,CAAE,EAAK,CAAC,CAAG,CAAC,EAMxB,CAMA,IAAM,EAAI,EAJV,EAAK,EAIQ,EAAI,EAAM,IAEtB,EAAO,EAAe,EAAU,CAAQ,CAAE,EAAG,CAAE,CAAiB,CAAE,EAAG,CAAE,GAAO,CAAQ,CAAE,EAAG,CAErF,GAQL,EAAO,IAAI,CAAE,EAAW,OAAO,CAAC,EAAE,EAAG,cAAc,CAAC,EAAK,CAAC,EAC1D,EAAS,IAAI,CAAE,EAAW,SAAS,CAAC,EAAE,EAAG,cAAc,CAAC,EAAK,CAAC,EAE9D,EAAU,IAAI,CAAE,CAAU,CAAC,EAAE,EAAG,GAAG,CAAC,GAAQ,GAAG,CAAC,GAEhD,EAAG,EAAU,CAAC,CAAE,EAAU,CAAC,CAAE,EAAU,CAAC,GAXxC,EAAG,EAAK,CAAC,CAAE,EAAK,CAAC,CAAE,GAsBrB,IAAM,EAAI,EAAG,GAAK,EAAO,IAExB,IAAM,EAAI,EAAG,EAAI,EAAM,IAEtB,EAAO,EAAe,EAAU,CAAQ,CAAE,EAAG,CAAE,CAAiB,CAAE,EAAG,CAAE,GAAO,CAAQ,CAAE,EAAG,CAErF,GAQL,EAAO,IAAI,CAAE,EAAW,OAAO,CAAC,EAAE,EAAG,cAAc,CAAE,EAAK,CAAC,EAC3D,EAAS,IAAI,CAAE,EAAW,SAAS,CAAC,EAAE,EAAG,cAAc,CAAE,EAAK,CAAC,EAE/D,EAAU,IAAI,CAAE,CAAU,CAAC,EAAE,EAAG,GAAG,CAAE,GAAS,GAAG,CAAE,GAEnD,EAAG,EAAU,CAAC,CAAE,EAAU,CAAC,CAAE,EAAU,CAAC,GAXxC,EAAG,EAAK,CAAC,CAAE,EAAK,CAAC,CAAE,EAAS,EAAQ,GAuBvC,IAAM,EAAI,EAAgB,EAAG,GAAK,EAAG,IAAO,CAS3C,IAAM,EAAI,EANV,EAAI,EAAmB,CAAA,EADvB,CAAA,EAAI,EAAI,CAAR,CAC2B,EAE3B,EAAK,EAAY,KAAK,GAAG,CAAG,EAAI,KAAK,EAAE,CAAC,GAI3B,EAAK,EAAQ,MAAM,CAAE,EAAI,EAAI,IAGzC,EAAG,AADH,CAAA,EAAO,EAAU,CAAO,CAAE,EAAG,CAAE,CAAgB,CAAE,EAAG,CAAE,EAAtD,EACQ,CAAC,CAAE,EAAK,CAAC,CAAG,EAAS,GAM9B,IAAM,EAAI,EAAG,EAAK,EAAM,MAAM,CAAE,EAAI,EAAI,IAKvC,IAAM,EAAI,EAHV,EAAQ,CAAK,CAAE,EAAG,CAClB,EAAmB,CAAc,CAAE,EAAG,CAEzB,EAAK,EAAM,MAAM,CAAE,EAAI,EAAI,IAEvC,EAAO,EAAU,CAAK,CAAE,EAAG,CAAE,CAAgB,CAAE,EAAG,CAAE,GAE9C,EAML,EAAG,EAAK,CAAC,CAAE,EAAK,CAAC,CAAG,CAAU,CAAE,EAAQ,EAAG,CAAC,CAAC,CAAE,CAAU,CAAE,EAAQ,EAAG,CAAC,CAAC,CAAG,GAJ3E,EAAG,EAAK,CAAC,CAAE,EAAK,CAAC,CAAG,EAAS,EAYjC,CAsFA,SAAS,EAAW,CAAO,CAAE,CAAW,EAEvC,IAAI,EAAG,EAGP,IAFA,EAAI,EAAQ,MAAM,CAEV,EAAE,GAAK,GAAI,CAElB,EAAI,EACJ,CAAA,EAAI,EAAI,CAAA,EACC,GAAI,CAAA,EAAI,EAAQ,MAAM,CAAG,CAAA,EAIlC,IAAI,EAAI,EAAG,EAAK,EAAS,AAAgB,EAAhB,EAEzB,IAAM,EAAI,EAAG,EAAI,EAAI,IAAO,CAE3B,IAAI,EAAQ,EAAO,EACf,EAAQ,EAAS,CAAA,EAAI,CAAA,EAOzB,AA6BH,CAAA,SAAa,CAAC,CAAE,CAAC,CAAE,CAAC,CAAE,CAAC,CAAE,CAAW,CAAE,CAAS,CAAE,CAAW,CAAE,CAAa,CAAE,CAAa,EAEzF,GAAK,EACL,GAAK,EACL,GAAK,EACL,GAAK,EAEJ,EAAM,KAAK,CAAC,IAAI,CAAE,IAAI,GAAM,KAAK,CAAE,EAAG,EAAG,EAAG,EAAG,KAAM,KAAM,IAE3D,IAAI,EAAM,EAAM,kBAAkB,CAAE,EAAO,EAAO,EAAa,EAAS,EAAG,EAAG,EAAG,EAC7C,EAAW,EAAa,EAAe,GAC3E,EAAM,aAAa,CAAE,EAAG,CAAC,IAAI,CAAE,EAEjC,CAAA,EA/CW,EAAc,EAAI,EACrB,EAAc,EAAI,EAClB,EAAc,EAAI,EAClB,EAAc,EAAI,EAEP,EAAS,EAAG,EAAI,EAAG,EAEpC,CACD,CAED,CAGA,SAAS,EAAG,CAAC,CAAE,CAAC,CAAE,CAAC,EAElB,EAAM,QAAQ,CAAC,IAAI,CAAE,IAAI,GAAM,OAAO,CAAE,EAAG,EAAG,GAE/C,CAEA,SAAS,EAAI,CAAC,CAAE,CAAC,CAAE,CAAC,CAAE,CAAQ,EAE7B,GAAK,EACL,GAAK,EACL,GAAK,EAGL,EAAM,KAAK,CAAC,IAAI,CAAE,IAAI,GAAM,KAAK,CAAE,EAAG,EAAG,EAAG,KAAM,KAAM,IAExD,IAAI,EAAM,EAAW,EAAM,gBAAgB,CAAE,EAAO,EAAO,EAAS,EAAG,EAAG,GAAM,EAAM,aAAa,CAAE,EAAO,EAAO,EAAS,EAAG,EAAG,GAEjI,EAAM,aAAa,CAAE,EAAG,CAAC,IAAI,CAAE,EAEjC,CApIA,AASA,CAAA,WAEC,GAAK,EAAe,CAEnB,IACI,EAAS,AADD,EACC,EAIb,IAAM,EAAI,EAAG,EAAI,EAAM,IAGtB,EAAI,AADJ,CAAA,EAAO,CAAK,CAAE,EAAG,AAAH,CACN,CAAE,EAAG,CAAE,EAAQ,CAAI,CAAE,EAAG,CAAE,EAAQ,CAAI,CAAE,EAAG,CAAG,EAAQ,CAAA,GAS/D,IAAM,EAAI,EAJV,EAAS,EADD,CAAA,EAAQ,AAAgB,EAAhB,CAAgB,EAKnB,EAAI,EAAM,IAGtB,EAAI,AADJ,CAAA,EAAO,CAAK,CAAE,EAAG,AAAH,CACN,CAAE,EAAG,CAAG,EAAQ,CAAI,CAAE,EAAG,CAAG,EAAQ,CAAI,CAAE,EAAG,CAAG,EAAQ,CAAA,EAIlE,KAAO,CAIN,IAAM,EAAI,EAAG,EAAI,EAAM,IAGtB,EAAI,AADJ,CAAA,EAAO,CAAK,CAAE,EAAG,AAAH,CACN,CAAE,EAAG,CAAE,CAAI,CAAE,EAAG,CAAE,CAAI,CAAE,EAAG,CAAE,CAAA,GAMtC,IAAM,EAAI,EAAG,EAAI,EAAM,IAGtB,EAAI,AADJ,CAAA,EAAO,CAAK,CAAE,EAAG,AAAH,CACN,CAAE,EAAG,CAAG,EAAO,EAAO,CAAI,CAAE,EAAG,CAAG,EAAO,EAAO,CAAI,CAAE,EAAG,CAAG,EAAO,EAAO,CAAA,EAGpF,CAED,CAAA,IAtDA,AA0DA,WAEC,IAAI,EAAc,EAIlB,IAAM,AAHN,EAAW,EADO,GAElB,GAAe,EAAQ,MAAM,CAEvB,EAAI,EAAG,EAAK,EAAM,MAAM,CAAG,EAAI,EAAI,IAGxC,EADA,EAAQ,CAAK,CAAE,EAAG,CACA,GAGlB,GAAe,EAAM,MAAM,AAI7B,GAuED,EAEA,GAAM,eAAe,CAAC,gBAAgB,CAAG,CAExC,cAAe,SAAU,CAAQ,CAAE,CAAa,CAAE,CAAc,CAAE,CAAM,CAAE,CAAM,CAAE,CAAM,EACvF,IAAI,EAAK,EAAS,QAAQ,CAAE,EAAQ,CAAC,CAAC,CACrC,EAAK,EAAS,QAAQ,CAAE,EAAQ,CAAC,CAAC,CAElC,EAAK,EAAS,QAAQ,CAAE,EAAQ,CAAC,CAAC,CAClC,EAAK,EAAS,QAAQ,CAAE,EAAQ,CAAC,CAAC,CAElC,EAAK,EAAS,QAAQ,CAAE,EAAQ,CAAC,CAAC,CAClC,EAAK,EAAS,QAAQ,CAAE,EAAQ,CAAC,CAAC,CAEnC,MAAO,CACN,IAAI,GAAM,OAAO,CAAE,EAAI,GACvB,IAAI,GAAM,OAAO,CAAE,EAAI,GACvB,IAAI,GAAM,OAAO,CAAE,EAAI,GACvB,AAEF,EAEA,iBAAkB,SAAU,CAAQ,CAAE,CAAa,CAAE,CAAc,CAAE,CAAM,CAAE,CAAM,CAAE,CAAM,EAE1F,OAAO,IAAI,CAAC,aAAa,CAAE,EAAU,EAAe,EAAgB,EAAQ,EAAQ,EAErF,EAEA,mBAAoB,SAAU,CAAQ,CAAE,CAAa,CAAE,CAAW,CAAE,CAAc,CACpD,CAAM,CAAE,CAAM,CAAE,CAAM,CAAE,CAAM,CAAE,CAAS,CAAE,CAAW,CACtD,CAAa,CAAE,CAAa,EAEzD,IAAI,EAAK,EAAS,QAAQ,CAAE,EAAQ,CAAC,CAAC,CACrC,EAAK,EAAS,QAAQ,CAAE,EAAQ,CAAC,CAAC,CAClC,EAAK,EAAS,QAAQ,CAAE,EAAQ,CAAC,CAAC,CAElC,EAAK,EAAS,QAAQ,CAAE,EAAQ,CAAC,CAAC,CAClC,EAAK,EAAS,QAAQ,CAAE,EAAQ,CAAC,CAAC,CAClC,EAAK,EAAS,QAAQ,CAAE,EAAQ,CAAC,CAAC,CAElC,EAAK,EAAS,QAAQ,CAAE,EAAQ,CAAC,CAAC,CAClC,EAAK,EAAS,QAAQ,CAAE,EAAQ,CAAC,CAAC,CAClC,EAAK,EAAS,QAAQ,CAAE,EAAQ,CAAC,CAAC,CAElC,EAAK,EAAS,QAAQ,CAAE,EAAQ,CAAC,CAAC,CAClC,EAAK,EAAS,QAAQ,CAAE,EAAQ,CAAC,CAAC,CAClC,EAAK,EAAS,QAAQ,CAAE,EAAQ,CAAC,CAAC,QAEnC,AAAK,AAAsB,IAAtB,KAAK,GAAG,CAAE,EAAK,GACZ,CACN,IAAI,GAAM,OAAO,CAAE,EAAI,EAAI,GAC3B,IAAI,GAAM,OAAO,CAAE,EAAI,EAAI,GAC3B,IAAI,GAAM,OAAO,CAAE,EAAI,EAAI,GAC3B,IAAI,GAAM,OAAO,CAAE,EAAI,EAAI,GAC3B,CAEM,CACN,IAAI,GAAM,OAAO,CAAE,EAAI,EAAI,GAC3B,IAAI,GAAM,OAAO,CAAE,EAAI,EAAI,GAC3B,IAAI,GAAM,OAAO,CAAE,EAAI,EAAI,GAC3B,IAAI,GAAM,OAAO,CAAE,EAAI,EAAI,GAC3B,AAEH,CACD,EAEA,GAAM,eAAe,CAAC,IAAI,CAAG,IAAI,GAAM,OAAO,CAC9C,GAAM,eAAe,CAAC,IAAI,CAAG,IAAI,GAAM,OAAO,CAC9C,GAAM,eAAe,CAAC,IAAI,CAAG,IAAI,GAAM,OAAO,CAC9C,GAAM,eAAe,CAAC,IAAI,CAAG,IAAI,GAAM,OAAO,CAC9C,GAAM,eAAe,CAAC,IAAI,CAAG,IAAI,GAAM,OAAO,CAC9C,GAAM,eAAe,CAAC,IAAI,CAAG,IAAI,GAAM,OAAO,CAiB9C,GAAM,aAAa,CAAG,SAAW,CAAM,CAAE,CAAO,EAE/C,GAAM,QAAQ,CAAC,IAAI,CAAE,IAAI,EAEpB,aAAkB,OAAU,CAAA,GAAQ,CAAA,EAAS,CAAE,EAAQ,AAAA,EAE5D,IAAI,CAAC,OAAO,CAAG,CAAM,CAAE,EAAO,MAAM,CAAG,EAAG,CAAC,cAAc,GAEzD,IAAI,CAAC,YAAY,CAAE,EAAQ,GAE3B,IAAI,CAAC,gBAAgB,GACrB,IAAI,CAAC,kBAAkB,EAExB,EAEA,GAAM,aAAa,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,QAAQ,CAAC,SAAS,EAKvE,GAAM,aAAa,CAAC,SAAS,CAAC,YAAY,CAAG,SAAW,CAAM,CAAE,CAAO,EAEtE,IAAM,IAAI,EAAI,EAAG,EAAI,EAAO,MAAM,CAAE,EAAI,EAAG,IAE1C,IAAI,CAAC,QAAQ,CAAE,CAAM,CAAE,EAAG,CAAE,GAI7B,OAAO,IAAI,AAEZ,EAKA,GAAM,aAAa,CAAC,SAAS,CAAC,QAAQ,CAAG,SAAW,CAAK,CAAE,CAAO,EAEhD,KAAA,IAAZ,GAAwB,CAAA,EAAU,CAAC,CAAA,EACxC,IAAI,EAAgB,AAA0B,KAAA,IAA1B,EAAQ,aAAa,CAAiB,EAAQ,aAAa,CAAG,GAE9E,EAAW,EAAQ,QAAQ,CAC3B,EAAQ,AAAwB,KAAA,IAAxB,EAAQ,WAAW,CAAiB,GAAM,eAAe,CAAC,gBAAgB,CAAG,EAAQ,WAAW,AAE9F,CAAA,IAAI,CAAC,OAAO,CAM1B,IAAI,EAAe,IAAI,CAAC,QAAQ,CAAC,MAAM,CACnC,EAAc,EAAM,aAAa,CAAE,GAEnC,EAAW,EAAY,KAAK,CAC5B,EAAQ,EAAY,KAAK,CAEzB,EAAU,CAAC,GAAM,KAAK,CAAC,KAAK,CAAC,WAAW,CAAE,GAE9C,GAAK,EAAU,CAMd,IAAM,EAAI,EAJV,EAAW,EAAS,OAAO,GAId,EAAI,EAAM,MAAM,CAAE,EAAI,EAAG,IAErC,EAAO,CAAK,CAAE,EAAG,CAEZ,GAAM,KAAK,CAAC,KAAK,CAAC,WAAW,CAAE,IAEnC,CAAA,CAAK,CAAE,EAAG,CAAG,EAAK,OAAO,EAF1B,EAQD,EAAU,CAAA,CAEX,CAEA,IAAI,EAAQ,GAAM,KAAK,CAAC,KAAK,CAAC,gBAAgB,CAAE,EAAU,GAItD,EAAU,EAEd,IAAM,EAAI,EAAG,EAAI,EAAM,MAAM,CAAE,EAAI,EAAG,IAErC,EAAO,CAAK,CAAE,EAAG,CACjB,EAAW,EAAS,MAAM,CAAE,GAM7B,IA/CI,EAAG,EAAG,EA+CN,EACA,EADM,EAAO,EAAS,MAAM,CACtB,EAAO,EAAM,MAAM,CAG7B,IAFiB,EAAQ,MAAM,CAEzB,EAAI,EAAG,EAAI,EAAM,IAEtB,EAAO,CAAQ,CAAE,EAAG,CAEpB,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAE,IAAI,GAAM,OAAO,CAAE,EAAK,CAAC,CAAE,EAAK,CAAC,CAAE,IAIxD,IAAM,EAAI,EAAG,EAAI,EAAM,IAAM,CAI5B,IAAI,EAAI,AAFR,CAAA,EAAO,CAAK,CAAE,EAAG,AAAH,CAEF,CAAE,EAAG,CAAG,EAChB,EAAI,CAAI,CAAE,EAAG,CAAG,EAChB,EAAI,CAAI,CAAE,EAAG,CAAG,EAEpB,IAAI,CAAC,KAAK,CAAC,IAAI,CAAE,IAAI,GAAM,KAAK,CAAE,EAAG,EAAG,EAAG,KAAM,KAAM,IACvD,IAAI,CAAC,aAAa,CAAE,EAAG,CAAC,IAAI,CAAE,EAAM,gBAAgB,CAAE,IAAI,CAAE,EAAO,EAAS,EAAG,EAAG,GAEnF,CAED,EAaA,GAAM,aAAa,CAAG,SAAW,CAAM,CAAE,CAAQ,CAAE,CAAQ,CAAE,CAAS,EAErE,GAAM,QAAQ,CAAC,IAAI,CAAE,IAAI,EAEzB,EAAW,GAAY,GACvB,EAAW,GAAY,EACvB,EAAY,GAAa,EAAI,KAAK,EAAE,CAKpC,IAAM,IAHF,EAAqB,EAAQ,CAAA,EAAO,MAAM,CAAG,CAAA,EAC7C,EAAkB,EAAM,EAElB,EAAI,EAAG,EAAK,EAAU,GAAK,EAAI,IAOxC,IAAM,IALF,EAAM,EAAW,EAAI,EAAkB,EAEvC,EAAI,KAAK,GAAG,CAAE,GACjB,EAAI,KAAK,GAAG,CAAE,GAEL,EAAI,EAAG,EAAK,EAAO,MAAM,CAAE,EAAI,EAAI,IAAO,CAEnD,IAAI,EAAK,CAAM,CAAE,EAAG,CAEhB,EAAS,IAAI,GAAM,OAAO,AAE9B,CAAA,EAAO,CAAC,CAAG,EAAI,EAAG,CAAC,CAAG,EAAI,EAAG,CAAC,CAC9B,EAAO,CAAC,CAAG,EAAI,EAAG,CAAC,CAAG,EAAI,EAAG,CAAC,CAC9B,EAAO,CAAC,CAAG,EAAG,CAAC,CAEf,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAE,EAErB,CAMD,IAAM,IAFF,EAAK,EAAO,MAAM,CAEZ,EAAI,EAAG,EAAK,EAAU,EAAI,EAAI,IAEvC,IAAM,IAAI,EAAI,EAAG,EAAK,EAAO,MAAM,CAAG,EAAG,EAAI,EAAI,IAAO,CAEvD,IAAI,EAAO,EAAI,EAAK,EAEhB,EAAI,EAAO,EACX,EAAI,EAAO,EAAI,EACf,EAAI,EAAO,EAEf,IAAI,CAAC,KAAK,CAAC,IAAI,CAAE,IAAI,GAAM,KAAK,CALxB,EAK6B,EAAG,EAAG,IAE3C,IAAI,EAAK,EAAI,EACT,EAAK,EAAI,EACT,EAAK,EAAK,EACV,EAAK,EAAK,EAEd,IAAI,CAAC,aAAa,CAAE,EAAG,CAAC,IAAI,CAAE,CAE7B,IAAI,GAAM,OAAO,CAAE,EAAI,GACvB,IAAI,GAAM,OAAO,CAAE,EAAI,GACvB,IAAI,GAAM,OAAO,CAAE,EAAI,GACvB,IAAI,GAAM,OAAO,CAAE,EAAI,GAEvB,CAEF,CAID,IAAI,CAAC,aAAa,GAClB,IAAI,CAAC,gBAAgB,GACrB,IAAI,CAAC,kBAAkB,GACvB,IAAI,CAAC,oBAAoB,EAE1B,EAEA,GAAM,aAAa,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,QAAQ,CAAC,SAAS,EAMvE,GAAM,aAAa,CAAG,SAAW,CAAK,CAAE,CAAM,CAAE,CAAa,CAAE,CAAc,EAE5E,GAAM,QAAQ,CAAC,IAAI,CAAE,IAAI,EAEzB,IAAI,CAAC,KAAK,CAAG,EACb,IAAI,CAAC,MAAM,CAAG,EAEd,IAAI,CAAC,aAAa,CAAG,GAAiB,EACtC,IAAI,CAAC,cAAc,CAAG,GAAkB,EAGxC,IADI,EAAI,EACJ,EAAa,EAAQ,EACrB,EAAc,EAAS,EAEvB,EAAQ,IAAI,CAAC,aAAa,CAC1B,EAAQ,IAAI,CAAC,cAAc,CAE3B,EAAS,EAAQ,EACjB,EAAS,EAAQ,EAEjB,EAAgB,IAAI,CAAC,KAAK,CAAG,EAC7B,EAAiB,IAAI,CAAC,MAAM,CAAG,EAE/B,EAAS,IAAI,GAAM,OAAO,CAAE,EAAG,EAAG,GAEtC,IAAM,EAAK,EAAG,EAAK,EAAQ,IAE1B,IAAM,EAAK,EAAG,EAAK,EAAQ,IAAQ,CAElC,IAAI,EAAI,EAAK,EAAgB,EACzB,EAAI,EAAK,EAAiB,EAE9B,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAE,IAAI,GAAM,OAAO,CAAE,EAAG,CAAE,EAAG,GAEhD,CAID,IAAM,EAAK,EAAG,EAAK,EAAO,IAEzB,IAAM,EAAK,EAAG,EAAK,EAAO,IAAQ,CAEjC,IAAI,EAAI,EAAK,EAAS,EAClB,EAAI,EAAK,EAAW,CAAA,EAAK,CAAA,EACzB,EAAI,EAAO,EAAM,EAAW,CAAA,EAAK,CAAA,EACjC,EAAM,EAAK,EAAM,EAAS,EAE1B,EAAO,IAAI,GAAM,KAAK,CAAE,EAAG,EAAG,EAAG,GACrC,EAAK,MAAM,CAAC,IAAI,CAAE,GAClB,EAAK,aAAa,CAAC,IAAI,CAAE,EAAO,KAAK,GAAI,EAAO,KAAK,GAAI,EAAO,KAAK,GAAI,EAAO,KAAK,IAErF,IAAI,CAAC,KAAK,CAAC,IAAI,CAAE,GACjB,IAAI,CAAC,aAAa,CAAE,EAAG,CAAC,IAAI,CAAE,CAC7B,IAAI,GAAM,OAAO,CAAE,EAAK,EAAO,EAAI,EAAK,GACxC,IAAI,GAAM,OAAO,CAAE,EAAK,EAAO,EAAM,AAAA,CAAA,EAAK,CAAA,EAAM,GAChD,IAAI,GAAM,OAAO,CAAE,AAAE,CAAA,EAAK,CAAA,EAAM,EAAO,EAAI,AAAE,CAAA,EAAK,CAAA,EAAM,GACxD,IAAI,GAAM,OAAO,CAAI,AAAA,CAAA,EAAK,CAAA,EAAM,EAAO,EAAI,EAAK,GAChD,CAEF,CAID,IAAI,CAAC,gBAAgB,EAEtB,EAEA,GAAM,aAAa,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,QAAQ,CAAC,SAAS,EAKvE,GAAM,cAAc,CAAG,SAAW,CAAM,CAAE,CAAa,CAAE,CAAc,CAAE,CAAQ,CAAE,CAAS,CAAE,CAAU,CAAE,CAAW,EAEpH,GAAM,QAAQ,CAAC,IAAI,CAAE,IAAI,EAEzB,IAAI,CAAC,MAAM,CAAG,GAAU,GAExB,IAAI,CAAC,aAAa,CAAG,KAAK,GAAG,CAAE,EAAG,KAAK,KAAK,CAAE,IAAmB,GACjE,IAAI,CAAC,cAAc,CAAG,KAAK,GAAG,CAAE,EAAG,KAAK,KAAK,CAAE,IAAoB,GAEnE,EAAW,AAAa,KAAA,IAAb,EAAyB,EAAW,EAC/C,EAAY,AAAc,KAAA,IAAd,EAA0B,EAAY,AAAU,EAAV,KAAK,EAAE,CAEzD,EAAa,AAAe,KAAA,IAAf,EAA2B,EAAa,EACrD,EAAc,AAAgB,KAAA,IAAhB,EAA4B,EAAc,KAAK,EAAE,CAE/D,IAAI,EAAG,EAAG,EAAW,EAAE,CAAE,EAAM,EAAE,CAEjC,IAAM,EAAI,EAAG,GAAK,IAAI,CAAC,cAAc,CAAE,IAAO,CAE7C,IAAI,EAAc,EAAE,CAChB,EAAS,EAAE,CAEf,IAAM,EAAI,EAAG,GAAK,IAAI,CAAC,aAAa,CAAE,IAAO,CAE5C,IAAI,EAAI,EAAI,IAAI,CAAC,aAAa,CAC1B,EAAI,EAAI,IAAI,CAAC,cAAc,CAE3B,EAAS,IAAI,GAAM,OAAO,AAC9B,CAAA,EAAO,CAAC,CAAG,CAAE,IAAI,CAAC,MAAM,CAAG,KAAK,GAAG,CAAE,EAAW,EAAI,GAAc,KAAK,GAAG,CAAE,EAAa,EAAI,GAC7F,EAAO,CAAC,CAAG,IAAI,CAAC,MAAM,CAAG,KAAK,GAAG,CAAE,EAAa,EAAI,GACpD,EAAO,CAAC,CAAG,IAAI,CAAC,MAAM,CAAG,KAAK,GAAG,CAAE,EAAW,EAAI,GAAc,KAAK,GAAG,CAAE,EAAa,EAAI,GAE3F,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAE,GAEpB,EAAY,IAAI,CAAE,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAG,GACzC,EAAO,IAAI,CAAE,IAAI,GAAM,OAAO,CAAE,EAAG,EAAI,GAExC,CAEA,EAAS,IAAI,CAAE,GACf,EAAI,IAAI,CAAE,EAEX,CAEA,IAAM,EAAI,EAAG,EAAI,IAAI,CAAC,cAAc,CAAE,IAErC,IAAM,EAAI,EAAG,EAAI,IAAI,CAAC,aAAa,CAAE,IAAO,CAE3C,IAAI,EAAK,CAAQ,CAAE,EAAG,CAAE,EAAI,EAAG,CAC3B,EAAK,CAAQ,CAAE,EAAG,CAAE,EAAG,CACvB,EAAK,CAAQ,CAAE,EAAI,EAAG,CAAE,EAAG,CAC3B,EAAK,CAAQ,CAAE,EAAI,EAAG,CAAE,EAAI,EAAG,CAE/B,EAAK,IAAI,CAAC,QAAQ,CAAE,EAAI,CAAC,KAAK,GAAG,SAAS,GAC1C,EAAK,IAAI,CAAC,QAAQ,CAAE,EAAI,CAAC,KAAK,GAAG,SAAS,GAC1C,EAAK,IAAI,CAAC,QAAQ,CAAE,EAAI,CAAC,KAAK,GAAG,SAAS,GAC1C,EAAK,IAAI,CAAC,QAAQ,CAAE,EAAI,CAAC,KAAK,GAAG,SAAS,GAE1C,EAAM,CAAG,CAAE,EAAG,CAAE,EAAI,EAAG,CAAC,KAAK,GAC7B,EAAM,CAAG,CAAE,EAAG,CAAE,EAAG,CAAC,KAAK,GACzB,EAAM,CAAG,CAAE,EAAI,EAAG,CAAE,EAAG,CAAC,KAAK,GAC7B,EAAM,CAAG,CAAE,EAAI,EAAG,CAAE,EAAI,EAAG,CAAC,KAAK,EAEhC,CAAA,KAAK,GAAG,CAAE,IAAI,CAAC,QAAQ,CAAE,EAAI,CAAC,CAAC,IAAO,IAAI,CAAC,MAAM,EAErD,IAAI,CAAC,KAAK,CAAC,IAAI,CAAE,IAAI,GAAM,KAAK,CAAE,EAAI,EAAI,EAAI,CAAE,EAAI,EAAI,EAAI,GAC5D,IAAI,CAAC,aAAa,CAAE,EAAG,CAAC,IAAI,CAAE,CAAE,EAAK,EAAK,EAAK,GAEpC,KAAK,GAAG,CAAE,IAAI,CAAC,QAAQ,CAAE,EAAI,CAAC,CAAC,IAAO,IAAI,CAAC,MAAM,EAE5D,IAAI,CAAC,KAAK,CAAC,IAAI,CAAE,IAAI,GAAM,KAAK,CAAE,EAAI,EAAI,EAAI,CAAE,EAAI,EAAI,EAAI,GAC5D,IAAI,CAAC,aAAa,CAAE,EAAG,CAAC,IAAI,CAAE,CAAE,EAAK,EAAK,EAAK,IAI/C,IAAI,CAAC,KAAK,CAAC,IAAI,CAAE,IAAI,GAAM,KAAK,CAAE,EAAI,EAAI,EAAI,EAAI,CAAE,EAAI,EAAI,EAAI,EAAI,GACpE,IAAI,CAAC,aAAa,CAAE,EAAG,CAAC,IAAI,CAAE,CAAE,EAAK,EAAK,EAAK,EAAK,EAItD,CAID,IAAI,CAAC,gBAAgB,GACrB,IAAI,CAAC,kBAAkB,GAEpB,IAAI,CAAC,cAAc,CAAG,IAAI,GAAM,MAAM,CAAE,IAAI,GAAM,OAAO,CAAI,EAEjE,EAEA,GAAM,cAAc,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,QAAQ,CAAC,SAAS,EAuCxE,GAAM,YAAY,CAAG,SAAW,CAAI,CAAE,CAAU,EAE/C,IAAI,EAAa,GAAM,SAAS,CAAC,cAAc,CAAE,EAAM,EAIvD,CAAA,EAAW,MAAM,CAAG,AAAsB,KAAA,IAAtB,EAAW,MAAM,CAAiB,EAAW,MAAM,CAAG,GAIvC,KAAA,IAA9B,EAAW,cAAc,EAAiB,CAAA,EAAW,cAAc,CAAG,EAA3E,EAC8B,KAAA,IAAzB,EAAW,SAAS,EAAiB,CAAA,EAAW,SAAS,CAAG,CAAA,EAChC,KAAA,IAA5B,EAAW,YAAY,EAAiB,CAAA,EAAW,YAAY,CAAG,CAAA,CAAvE,EAEA,GAAM,eAAe,CAAC,IAAI,CAAE,IAAI,CAAE,EAAY,EAE/C,EAEA,GAAM,YAAY,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,eAAe,CAAC,SAAS,EAO7E,GAAM,aAAa,CAAG,SAAW,CAAM,CAAE,CAAI,CAAE,CAAc,CAAE,CAAe,CAAE,CAAG,EAElF,GAAM,QAAQ,CAAC,IAAI,CAAE,IAAI,EAIzB,IAAI,CAAC,MAAM,CAAG,GAAU,IACxB,IAAI,CAAC,IAAI,CAAG,GAAQ,GACpB,IAAI,CAAC,cAAc,CAAG,GAAkB,EACxC,IAAI,CAAC,eAAe,CAAG,GAAmB,EAC1C,IAAI,CAAC,GAAG,CAAG,GAAO,AAAU,EAAV,KAAK,EAAE,CAIzB,IAAM,IAFF,EAAS,IAAI,GAAM,OAAO,CAAI,EAAM,EAAE,CAAE,EAAU,EAAE,CAE9C,EAAI,EAAG,GAAK,IAAI,CAAC,cAAc,CAAE,IAE1C,IAAM,IAAI,EAAI,EAAG,GAAK,IAAI,CAAC,eAAe,CAAE,IAAO,CAElD,IAAI,EAAI,EAAI,IAAI,CAAC,eAAe,CAAG,IAAI,CAAC,GAAG,CACvC,EAAI,EAAI,IAAI,CAAC,cAAc,CAAG,KAAK,EAAE,CAAG,CAE5C,CAAA,EAAO,CAAC,CAAG,IAAI,CAAC,MAAM,CAAG,KAAK,GAAG,CAAE,GACnC,EAAO,CAAC,CAAG,IAAI,CAAC,MAAM,CAAG,KAAK,GAAG,CAAE,GAEnC,IAAI,EAAS,IAAI,GAAM,OAAO,AAC9B,CAAA,EAAO,CAAC,CAAK,AAAA,CAAA,IAAI,CAAC,MAAM,CAAG,IAAI,CAAC,IAAI,CAAG,KAAK,GAAG,CAAE,EAAA,EAAQ,KAAK,GAAG,CAAE,GACnE,EAAO,CAAC,CAAK,AAAA,CAAA,IAAI,CAAC,MAAM,CAAG,IAAI,CAAC,IAAI,CAAG,KAAK,GAAG,CAAE,EAAA,EAAQ,KAAK,GAAG,CAAE,GACnE,EAAO,CAAC,CAAG,IAAI,CAAC,IAAI,CAAG,KAAK,GAAG,CAAE,GAEjC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAE,GAEpB,EAAI,IAAI,CAAE,IAAI,GAAM,OAAO,CAAE,EAAI,IAAI,CAAC,eAAe,CAAE,EAAI,IAAI,CAAC,cAAc,GAC9E,EAAQ,IAAI,CAAE,EAAO,KAAK,GAAG,GAAG,CAAE,GAAS,SAAS,GAErD,CAID,IAAM,IAAI,EAAI,EAAG,GAAK,IAAI,CAAC,cAAc,CAAE,IAE1C,IAAM,IAAI,EAAI,EAAG,GAAK,IAAI,CAAC,eAAe,CAAE,IAAO,CAElD,IAAI,EAAM,AAAA,CAAA,IAAI,CAAC,eAAe,CAAG,CAAA,EAAM,EAAI,EAAI,EAC3C,EAAI,AAAE,CAAA,IAAI,CAAC,eAAe,CAAG,CAAA,EAAQ,CAAA,EAAI,CAAA,EAAM,EAAI,EACnD,EAAM,AAAA,CAAA,IAAI,CAAC,eAAe,CAAG,CAAA,EAAQ,CAAA,EAAI,CAAA,EAAM,EAC/C,EAAM,AAAA,CAAA,IAAI,CAAC,eAAe,CAAG,CAAA,EAAM,EAAI,EAEvC,EAAO,IAAI,GAAM,KAAK,CAAE,EAAG,EAAG,EAAG,EAAG,CAAE,CAAO,CAAE,EAAG,CAAE,CAAO,CAAE,EAAG,CAAE,CAAO,CAAE,EAAG,CAAE,CAAO,CAAE,EAAG,CAAE,EAClG,EAAK,MAAM,CAAC,GAAG,CAAE,CAAO,CAAE,EAAG,EAC7B,EAAK,MAAM,CAAC,GAAG,CAAE,CAAO,CAAE,EAAG,EAC7B,EAAK,MAAM,CAAC,GAAG,CAAE,CAAO,CAAE,EAAG,EAC7B,EAAK,MAAM,CAAC,GAAG,CAAE,CAAO,CAAE,EAAG,EAC7B,EAAK,MAAM,CAAC,SAAS,GAErB,IAAI,CAAC,KAAK,CAAC,IAAI,CAAE,GAEjB,IAAI,CAAC,aAAa,CAAE,EAAG,CAAC,IAAI,CAAE,CAAE,CAAG,CAAE,EAAG,CAAC,KAAK,GAAI,CAAG,CAAE,EAAG,CAAC,KAAK,GAAI,CAAG,CAAE,EAAG,CAAC,KAAK,GAAI,CAAG,CAAE,EAAG,CAAC,KAAK,GAAI,CACzG,CAID,IAAI,CAAC,gBAAgB,EAEtB,EAEA,GAAM,aAAa,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,QAAQ,CAAC,SAAS,EAMvE,GAAM,iBAAiB,CAAG,SAAW,CAAM,CAAE,CAAI,CAAE,CAAc,CAAE,CAAe,CAAE,CAAC,CAAE,CAAC,CAAE,CAAW,EAEpG,GAAM,QAAQ,CAAC,IAAI,CAAE,IAAI,CAIzB,CAAA,IAAI,CAAC,MAAM,CAAG,GAAU,IACxB,IAAI,CAAC,IAAI,CAAG,GAAQ,GACpB,IAAI,CAAC,cAAc,CAAG,GAAkB,GACxC,IAAI,CAAC,eAAe,CAAG,GAAmB,EAC1C,IAAI,CAAC,CAAC,CAAG,GAAK,EACd,IAAI,CAAC,CAAC,CAAG,GAAK,EACd,IAAI,CAAC,WAAW,CAAG,GAAe,EAClC,IAAI,CAAC,IAAI,CAAG,AAAI,MAAO,IAAI,CAAC,cAAc,EAM1C,IAAM,IAJF,EAAO,IAAI,GAAM,OAAO,CACxB,EAAI,IAAI,GAAM,OAAO,CACrB,EAAQ,IAAI,GAAM,OAAO,CAEnB,EAAI,EAAG,EAAI,IAAI,CAAC,cAAc,CAAE,EAAG,EAAI,CAEhD,IAAI,CAAC,IAAI,CAAE,EAAG,CAAG,AAAI,MAAO,IAAI,CAAC,eAAe,EAEhD,IAAM,IAAI,EAAI,EAAG,EAAI,IAAI,CAAC,eAAe,CAAE,EAAG,EAAI,CAEjD,IAsDa,EAAG,EAAG,EAlDf,EAAI,EAJJ,EAAI,EAAI,IAAI,CAAC,cAAc,CAAG,EAAI,IAAI,CAAC,CAAC,CAAG,KAAK,EAAE,CAClD,EAAI,EAAI,IAAI,CAAC,eAAe,CAAG,EAAI,KAAK,EAAE,CAC1C,EAAK,EAAQ,EAAG,EAAG,IAAI,CAAC,CAAC,CAAE,IAAI,CAAC,CAAC,CAAE,IAAI,CAAC,MAAM,CAAE,IAAI,CAAC,WAAW,EAChE,EAAK,EAAQ,EAAI,IAAM,EAAG,IAAI,CAAC,CAAC,CAAE,IAAI,CAAC,CAAC,CAAE,IAAI,CAAC,MAAM,CAAE,IAAI,CAAC,WAAW,EAG3E,EAAK,UAAU,CAAE,EAAI,GACrB,EAAE,UAAU,CAAE,EAAI,GAElB,EAAM,YAAY,CAAE,EAAM,GAC1B,EAAE,YAAY,CAAE,EAAO,GACvB,EAAM,SAAS,GACf,EAAE,SAAS,GAEX,EAAK,CAAE,IAAI,CAAC,IAAI,CAAG,KAAK,GAAG,CAAE,GAC7B,EAAK,IAAI,CAAC,IAAI,CAAG,KAAK,GAAG,CAAE,GAE3B,EAAG,CAAC,EAAI,EAAK,EAAE,CAAC,CAAG,EAAK,EAAM,CAAC,CAC/B,EAAG,CAAC,EAAI,EAAK,EAAE,CAAC,CAAG,EAAK,EAAM,CAAC,CAC/B,EAAG,CAAC,EAAI,EAAK,EAAE,CAAC,CAAG,EAAK,EAAM,CAAC,CAE/B,IAAI,CAAC,IAAI,CAAE,EAAG,CAAE,EAAG,EAiCN,EAjCe,EAAG,CAAC,CAiChB,EAjCkB,EAAG,CAAC,CAiCnB,EAjCqB,EAAG,CAAC,CAmCtC,AA7EI,IAAI,CA6EF,QAAQ,CAAC,IAAI,CAAE,IAAI,GAAM,OAAO,CAAE,EAAG,EAAG,IAAQ,EAjC7D,CAED,CAEA,IAAM,IAAI,EAAI,EAAG,EAAI,IAAI,CAAC,cAAc,CAAE,EAAG,EAE5C,IAAM,IAAI,EAAI,EAAG,EAAI,IAAI,CAAC,eAAe,CAAE,EAAG,EAAI,CAEjD,IAAI,EAAK,AAAE,CAAA,EAAI,CAAA,EAAM,IAAI,CAAC,cAAc,CACpC,EAAK,AAAE,CAAA,EAAI,CAAA,EAAM,IAAI,CAAC,eAAe,CAErC,EAAI,IAAI,CAAC,IAAI,CAAE,EAAG,CAAE,EAAG,CACvB,EAAI,IAAI,CAAC,IAAI,CAAE,EAAI,CAAE,EAAG,CACxB,EAAI,IAAI,CAAC,IAAI,CAAE,EAAI,CAAE,EAAI,CACzB,EAAI,IAAI,CAAC,IAAI,CAAE,EAAG,CAAE,EAAI,CAExB,EAAM,IAAI,GAAM,OAAO,CAAE,EAAI,IAAI,CAAC,cAAc,CAAE,EAAI,IAAI,CAAC,eAAe,EAC1E,EAAM,IAAI,GAAM,OAAO,CAAI,AAAA,CAAA,EAAI,CAAA,EAAM,IAAI,CAAC,cAAc,CAAE,EAAI,IAAI,CAAC,eAAe,EAClF,EAAM,IAAI,GAAM,OAAO,CAAE,AAAE,CAAA,EAAI,CAAA,EAAM,IAAI,CAAC,cAAc,CAAE,AAAE,CAAA,EAAI,CAAA,EAAM,IAAI,CAAC,eAAe,EAC1F,EAAM,IAAI,GAAM,OAAO,CAAE,EAAI,IAAI,CAAC,cAAc,CAAI,AAAA,CAAA,EAAI,CAAA,EAAM,IAAI,CAAC,eAAe,EAEtF,IAAI,CAAC,KAAK,CAAC,IAAI,CAAE,IAAI,GAAM,KAAK,CAAE,EAAG,EAAG,EAAG,IAC3C,IAAI,CAAC,aAAa,CAAE,EAAG,CAAC,IAAI,CAAE,CAAE,EAAI,EAAI,EAAK,EAAK,CAEnD,CAaD,SAAS,EAAQ,CAAC,CAAE,CAAC,CAAE,CAAI,CAAE,CAAI,CAAE,CAAM,CAAE,CAAW,EAKrD,IAAI,EAAU,EAAO,EAAO,EACxB,EAAK,KAAK,GAAG,CAAE,GAMnB,OAAO,IAAI,GAAM,OAAO,CAJf,EAAW,CAAA,EAAI,CAAA,EAAO,GANtB,KAAK,GAAG,CAAE,GAOV,EAAW,CAAA,EAAI,CAAA,EALf,KAAK,GAAG,CAAE,GAKiB,GAC3B,EAAc,EAAS,KAAK,GAAG,CAAE,GAAY,GAIvD,CAxBA,IAAI,CAAC,gBAAgB,GACrB,IAAI,CAAC,kBAAkB,GACvB,IAAI,CAAC,oBAAoB,EAwB1B,EAEA,GAAM,iBAAiB,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,QAAQ,CAAC,SAAS,EAc3E,GAAM,YAAY,CAAG,SAAU,CAAI,CAAE,CAAQ,CAAE,CAAM,CAAE,CAAc,CAAE,CAAM,CAAE,CAAK,EAEnF,GAAM,QAAQ,CAAC,IAAI,CAAE,IAAI,EAEzB,IAAI,CAAC,IAAI,CAAG,EACZ,IAAI,CAAC,QAAQ,CAAG,GAAY,GAC5B,IAAI,CAAC,MAAM,CAAG,GAAU,EACxB,IAAI,CAAC,cAAc,CAAG,GAAkB,EACxC,IAAI,CAAC,MAAM,CAAG,GAAU,CAAA,EAEnB,GAAQ,CAAA,IAAI,CAAC,KAAK,CAAG,IAAI,GAAM,QAAQ,AAA5C,EAEA,IAAI,CAAC,IAAI,CAAG,EAAE,CAEd,IA6Be,EAAG,EAAG,EA3BpB,EACA,EACA,EAMA,EAAG,EAEH,EAAI,EACJ,EACA,EAAG,EACH,EAAI,EACJ,EAAG,EAAG,EAAG,EACT,EAAK,EAAK,EAAK,EAXf,EAAY,IAAI,CAAC,QAAQ,CAAG,EAOvB,EAAO,IAAI,GAAM,OAAO,CAM1B,EAAS,IAAI,GAAM,YAAY,CAAC,YAAY,CAAE,IAAI,CAAC,IAAI,CAAE,IAAI,CAAC,QAAQ,CAAE,IAAI,CAAC,MAAM,EACtF,EAAW,EAAO,QAAQ,CAC1B,EAAU,EAAO,OAAO,CACxB,EAAY,EAAO,SAAS,CAgB7B,IAbA,IAAI,CAAC,QAAQ,CAAG,EAChB,IAAI,CAAC,OAAO,CAAG,EACf,IAAI,CAAC,SAAS,CAAG,EAWX,EAAI,EAAG,EAAI,EAAW,IAoB3B,IAlBA,IAAI,CAAC,IAAI,CAAE,EAAG,CAAG,EAAE,CAEnB,EAAI,EAAM,CAAA,EAAY,CAAA,EAEtB,EAAM,EAAK,UAAU,CAAE,GAEvB,EAAU,CAAQ,CAAE,EAAG,CACvB,EAAS,CAAO,CAAE,EAAG,CACrB,EAAW,CAAS,CAAE,EAAG,CAEpB,IAAI,CAAC,KAAK,GAEd,IAAI,CAAC,KAAK,CAAC,GAAG,CAAE,IAAI,GAAM,WAAW,CAAC,EAAS,EAAK,EAAQ,MAC5D,IAAI,CAAC,KAAK,CAAC,GAAG,CAAE,IAAI,GAAM,WAAW,CAAC,EAAQ,EAAK,EAAQ,WAC3D,IAAI,CAAC,KAAK,CAAC,GAAG,CAAE,IAAI,GAAM,WAAW,CAAC,EAAU,EAAK,EAAQ,SAIxD,EAAI,EAAG,EAAI,IAAI,CAAC,cAAc,CAAE,IAErC,EAAI,EAAI,IAAI,CAAC,cAAc,CAAG,EAAI,KAAK,EAAE,CAEzC,EAAK,CAAC,IAAI,CAAC,MAAM,CAAG,KAAK,GAAG,CAAE,GAC9B,EAAK,IAAI,CAAC,MAAM,CAAG,KAAK,GAAG,CAAE,GAE7B,EAAK,IAAI,CAAE,GACX,EAAK,CAAC,EAAI,EAAK,EAAO,CAAC,CAAG,EAAK,EAAS,CAAC,CACzC,EAAK,CAAC,EAAI,EAAK,EAAO,CAAC,CAAG,EAAK,EAAS,CAAC,CACzC,EAAK,CAAC,EAAI,EAAK,EAAO,CAAC,CAAG,EAAK,EAAS,CAAC,CAEzC,IAAI,CAAC,IAAI,CAAE,EAAG,CAAE,EAAG,EAzCN,EAyCe,EAAK,CAAC,CAzClB,EAyCoB,EAAK,CAAC,CAzCvB,EAyCyB,EAAK,CAAC,CAvC5C,AA/BI,IAAI,CA+BF,QAAQ,CAAC,IAAI,CAAE,IAAI,GAAM,OAAO,CAAE,EAAG,EAAG,IAAQ,GA+C9D,IAAM,EAAI,EAAG,EAAI,IAAI,CAAC,QAAQ,CAAE,IAE/B,IAAM,EAAI,EAAG,EAAI,IAAI,CAAC,cAAc,CAAE,IAErC,EAAO,IAAI,CAAC,MAAM,CAAK,AAAC,CAAA,EAAI,CAAA,EAAK,IAAI,CAAC,QAAQ,CAAG,EAAI,EACrD,EAAM,AAAA,CAAA,EAAI,CAAA,EAAK,IAAI,CAAC,cAAc,CAElC,EAAI,IAAI,CAAC,IAAI,CAAE,EAAG,CAAE,EAAG,CACvB,EAAI,IAAI,CAAC,IAAI,CAAE,EAAI,CAAE,EAAG,CACxB,EAAI,IAAI,CAAC,IAAI,CAAE,EAAI,CAAE,EAAI,CACzB,EAAI,IAAI,CAAC,IAAI,CAAE,EAAG,CAAE,EAAI,CAExB,EAAM,IAAI,GAAM,OAAO,CAAE,EAAI,IAAI,CAAC,QAAQ,CAAE,EAAI,IAAI,CAAC,cAAc,EACnE,EAAM,IAAI,GAAM,OAAO,CAAI,AAAA,CAAA,EAAI,CAAA,EAAM,IAAI,CAAC,QAAQ,CAAE,EAAI,IAAI,CAAC,cAAc,EAC3E,EAAM,IAAI,GAAM,OAAO,CAAE,AAAE,CAAA,EAAI,CAAA,EAAM,IAAI,CAAC,QAAQ,CAAE,AAAE,CAAA,EAAI,CAAA,EAAM,IAAI,CAAC,cAAc,EACnF,EAAM,IAAI,GAAM,OAAO,CAAE,EAAI,IAAI,CAAC,QAAQ,CAAI,AAAA,CAAA,EAAI,CAAA,EAAM,IAAI,CAAC,cAAc,EAE3E,IAAI,CAAC,KAAK,CAAC,IAAI,CAAE,IAAI,GAAM,KAAK,CAAE,EAAG,EAAG,EAAG,IAC3C,IAAI,CAAC,aAAa,CAAE,EAAG,CAAC,IAAI,CAAE,CAAE,EAAK,EAAK,EAAK,EAAK,EAKtD,IAAI,CAAC,gBAAgB,GACrB,IAAI,CAAC,kBAAkB,GACvB,IAAI,CAAC,oBAAoB,EAE1B,EAEA,GAAM,YAAY,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,QAAQ,CAAC,SAAS,EAItE,GAAM,YAAY,CAAC,YAAY,CAAG,SAAS,CAAI,CAAE,CAAQ,CAAE,CAAM,EAElD,IAAI,GAAM,OAAO,CAA/B,IAYC,EAEA,EAEA,EAAI,EAAI,EACR,EAAG,EAhBH,EAAS,IAAI,GAAM,OAAO,CAG1B,GAFW,IAAI,GAAM,OAAO,CAEjB,EAAE,EACb,EAAU,EAAE,CACZ,EAAY,EAAE,CAEd,EAAM,IAAI,GAAM,OAAO,CACvB,EAAM,IAAI,GAAM,OAAO,CAEvB,EAAY,EAAW,EAgBxB,IAAM,EAAI,EANV,IAAI,CAAC,QAAQ,CAAG,EAChB,IAAI,CAAC,OAAO,CAAG,EACf,IAAI,CAAC,SAAS,CAAG,EAIJ,EAAI,EAAW,IAE3B,EAAI,EAAM,CAAA,EAAY,CAAA,EAEtB,CAAQ,CAAE,EAAG,CAAG,EAAK,YAAY,CAAE,GACnC,CAAQ,CAAE,EAAG,CAAC,SAAS,GA8DxB,IA9BC,CAAO,CAAE,EAAG,CAAG,IAAI,GAAM,OAAO,CAChC,CAAS,CAAE,EAAG,CAAG,IAAI,GAAM,OAAO,CAClC,EAAW,OAAO,SAAS,CAC3B,EAAK,KAAK,GAAG,CAAE,CAAQ,CAAE,EAAG,CAAC,CAAC,EAC9B,EAAK,KAAK,GAAG,CAAE,CAAQ,CAAE,EAAG,CAAC,CAAC,EAC9B,EAAK,KAAK,GAAG,CAAE,CAAQ,CAAE,EAAG,CAAC,CAAC,EAEzB,GAAM,IACV,EAAW,EACX,EAAO,GAAG,CAAE,EAAG,EAAG,IAGd,GAAM,IACV,EAAW,EACX,EAAO,GAAG,CAAE,EAAG,EAAG,IAGd,GAAM,GACV,EAAO,GAAG,CAAE,EAAG,EAAG,GAGnB,EAAI,YAAY,CAAE,CAAQ,CAAE,EAAG,CAAE,GAAS,SAAS,GAEnD,CAAO,CAAE,EAAG,CAAC,YAAY,CAAE,CAAQ,CAAE,EAAG,CAAE,GAC1C,CAAS,CAAE,EAAG,CAAC,YAAY,CAAE,CAAQ,CAAE,EAAG,CAAE,CAAO,CAAE,EAAG,EAMnD,EAAI,EAAG,EAAI,EAAW,IAE3B,CAAO,CAAE,EAAG,CAAG,CAAO,CAAE,EAAE,EAAG,CAAC,KAAK,GAEnC,CAAS,CAAE,EAAG,CAAG,CAAS,CAAE,EAAE,EAAG,CAAC,KAAK,GAEvC,EAAI,YAAY,CAAE,CAAQ,CAAE,EAAE,EAAG,CAAE,CAAQ,CAAE,EAAG,EAE3C,EAAI,MAAM,GAzFL,OA2FT,EAAI,SAAS,GAEb,EAAQ,KAAK,IAAI,CAAE,CAAQ,CAAE,EAAE,EAAG,CAAC,GAAG,CAAE,CAAQ,CAAE,EAAG,GAErD,CAAO,CAAE,EAAG,CAAC,YAAY,CAAE,EAAI,gBAAgB,CAAE,EAAK,KAIvD,CAAS,CAAE,EAAG,CAAC,YAAY,CAAE,CAAQ,CAAE,EAAG,CAAE,CAAO,CAAE,EAAG,EAOzD,GAAK,EAWJ,IARA,EADQ,KAAK,IAAI,CAAE,CAAO,CAAE,EAAG,CAAC,GAAG,CAAE,CAAO,CAAE,EAAU,EAAG,GAChD,CAAA,EAAY,CAAA,EAElB,CAAQ,CAAE,EAAG,CAAC,GAAG,CAAE,EAAI,YAAY,CAAE,CAAO,CAAE,EAAG,CAAE,CAAO,CAAE,EAAU,EAAG,GAAO,GAEpF,CAAA,EAAQ,CAAC,CAFV,EAMM,EAAI,EAAG,EAAI,EAAW,IAG3B,CAAO,CAAE,EAAG,CAAC,YAAY,CAAE,EAAI,gBAAgB,CAAE,CAAQ,CAAE,EAAG,CAAE,EAAQ,IACxE,CAAS,CAAE,EAAG,CAAC,YAAY,CAAE,CAAQ,CAAE,EAAG,CAAE,CAAO,CAAE,EAAG,CAK3D,EAMA,GAAM,kBAAkB,CAAG,SAAW,CAAQ,CAAE,CAAK,CAAE,CAAM,CAAE,CAAM,EAEpE,GAAM,QAAQ,CAAC,IAAI,CAAE,IAAI,EAEzB,EAAS,GAAU,EACnB,EAAS,GAAU,EAInB,IAAM,IAFF,EAAO,IAAI,CAEL,EAAI,EAAG,EAAI,EAAS,MAAM,CAAE,EAAI,EAAG,IAE5C,EAAS,IAAI,GAAM,OAAO,CAAE,CAAQ,CAAE,EAAG,CAAE,EAAG,CAAE,CAAQ,CAAE,EAAG,CAAE,EAAG,CAAE,CAAQ,CAAE,EAAG,CAAE,EAAG,GAMvF,IAAM,IAFF,EAAY,EAAE,CAAE,EAAI,IAAI,CAAC,QAAQ,CAE3B,EAAI,EAAG,EAAI,EAAM,MAAM,CAAE,EAAI,EAAG,IAEzC,AAmCD,CAAA,SAAS,EAAM,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAM,EAEhC,GAAK,EAAS,EAAI,CAEjB,IAAI,EAAO,IAAI,GAAM,KAAK,CAAE,EAAG,KAAK,CAAE,EAAG,KAAK,CAAE,EAAG,KAAK,CAAE,CAAE,EAAG,KAAK,GAAI,EAAG,KAAK,GAAI,EAAG,KAAK,GAAI,EAChG,EAAK,QAAQ,CAAC,GAAG,CAAE,GAAK,GAAG,CAAE,GAAK,GAAG,CAAE,GAAK,YAAY,CAAE,GAC1D,EAAK,MAAM,CAAG,EAAK,QAAQ,CAAC,KAAK,GAAG,SAAS,GAC7C,EAAK,KAAK,CAAC,IAAI,CAAE,GAEjB,IAAI,EAAM,EAAS,EAAK,QAAQ,EAChC,EAAK,aAAa,CAAE,EAAG,CAAC,IAAI,CAAE,CAC7B,EAAW,EAAG,EAAE,CAAE,EAAI,GACtB,EAAW,EAAG,EAAE,CAAE,EAAI,GACtB,EAAW,EAAG,EAAE,CAAE,EAAI,GACtB,CAEF,MAEC,GAAU,EAIV,EAAM,EAAI,EAAU,EAAI,GAAM,EAAU,EAAI,GAAM,GAClD,EAAM,EAAU,EAAI,GAAM,EAAI,EAAU,EAAI,GAAM,GAClD,EAAM,EAAU,EAAI,GAAM,EAAU,EAAI,GAAM,EAAI,GAClD,EAAM,EAAU,EAAI,GAAM,EAAU,EAAI,GAAM,EAAU,EAAI,GAAM,EAIpE,CAAA,EAhEO,CAAC,CAAE,CAAK,CAAE,EAAG,CAAE,EAAG,CAAE,CAAE,CAAC,CAAE,CAAK,CAAE,EAAG,CAAE,EAAG,CAAE,CAAE,CAAC,CAAE,CAAK,CAAE,EAAG,CAAE,EAAG,CAAE,CAAE,GAIzE,IAAI,CAAC,aAAa,GAIlB,IAAM,IAAI,EAAI,EAAG,EAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAE,EAAI,EAAG,IAEjD,IAAI,CAAC,QAAQ,CAAE,EAAG,CAAC,cAAc,CAAE,GAOpC,SAAS,EAAS,CAAM,EAEvB,IAAI,EAAS,EAAO,SAAS,GAAG,KAAK,EACrC,CAAA,EAAO,KAAK,CAAG,EAAK,QAAQ,CAAC,IAAI,CAAE,GAAW,EAI9C,IAAI,EAAI,EAAS,GAAW,EAAI,KAAK,EAAE,CAAG,GACtC,EAAI,AA2ED,KAAK,KAAK,CAAE,CAAC,AA3EC,EA2EM,CAAC,CAAE,KAAK,IAAI,CAAI,AA3EtB,EA2E6B,CAAC,CAAG,AA3EjC,EA2EwC,CAAC,CAAO,AA3EhD,EA2EuD,CAAC,CAAG,AA3E3D,EA2EkE,CAAC,GA3ExD,KAAK,EAAE,CAAG,GAG1C,OAFA,EAAO,EAAE,CAAG,IAAI,GAAM,OAAO,CAAE,EAAG,EAAI,GAE/B,CAER,CAoCA,SAAS,EAAU,CAAE,CAAE,CAAE,EAElB,CAAS,CAAE,EAAG,KAAK,CAAE,EAAG,CAAA,CAAS,CAAE,EAAG,KAAK,CAAE,CAAG,EAAE,AAAF,EAChD,CAAS,CAAE,EAAG,KAAK,CAAE,EAAG,CAAA,CAAS,CAAE,EAAG,KAAK,CAAE,CAAG,EAAE,AAAF,EAEtD,IAAI,EAAM,CAAS,CAAE,EAAG,KAAK,CAAE,CAAE,EAAG,KAAK,CAAE,CAW3C,OATa,KAAA,IAAR,GAIJ,CAAA,CAAS,CAAE,EAAG,KAAK,CAAE,CAAE,EAAG,KAAK,CAAE,CAAG,CAAS,CAAE,EAAG,KAAK,CAAE,CAAE,EAAG,KAAK,CAAE,CAAG,EAAM,EAC7E,IAAI,GAAM,OAAO,GAAG,UAAU,CAAE,EAAI,GAAK,YAAY,CAAE,GADxD,EAKM,CAER,CAKA,SAAS,EAAS,CAAM,EAEvB,OAAO,KAAK,KAAK,CAAE,EAAO,CAAC,CAAE,CAAC,EAAO,CAAC,CAEvC,CAcA,SAAS,EAAW,CAAE,CAAE,CAAM,CAAE,CAAO,EAItC,OAFO,EAAU,GAAS,AAAS,IAAT,EAAG,CAAC,EAAW,CAAA,EAAK,IAAI,GAAM,OAAO,CAAE,EAAG,CAAC,CAAG,EAAG,EAAG,CAAC,CAAA,EAC3D,IAAf,EAAS,CAAC,EAAc,AAAa,IAAb,EAAO,CAAC,EAAW,CAAA,EAAK,IAAI,GAAM,OAAO,CAAE,EAAU,EAAI,KAAK,EAAE,CAAG,GAAK,EAAG,CAAC,CAAA,EAClG,CAER,CAEA,IAAI,CAAC,gBAAgB,GAElB,IAAI,CAAC,cAAc,CAAG,IAAI,GAAM,MAAM,CAAE,IAAI,GAAM,OAAO,CAAI,EAEjE,EAEA,GAAM,kBAAkB,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,QAAQ,CAAC,SAAS,EAK5E,GAAM,mBAAmB,CAAG,SAAW,CAAM,CAAE,CAAM,EAEpD,IAAI,EAAI,AAAE,CAAA,EAAI,KAAK,IAAI,CAAE,EAAA,EAAQ,EAejC,GAAM,kBAAkB,CAAC,IAAI,CAAE,IAAI,CAbpB,CACd,CAAE,GAAK,EAAI,EAAG,CAAE,CAAG,EAAG,EAAG,EAAG,CAAE,CAAE,GAAI,CAAC,EAAI,EAAG,CAAE,CAAG,EAAG,CAAC,EAAI,EAAG,CAC5D,CAAG,EAAG,GAAK,EAAG,CAAE,CAAG,EAAG,EAAG,EAAG,CAAE,CAAG,EAAG,GAAI,CAAC,EAAG,CAAE,CAAG,EAAI,EAAG,CAAC,EAAG,CAC5D,CAAG,EAAI,EAAG,GAAI,CAAE,CAAG,EAAG,EAAG,EAAG,CAAE,CAAE,CAAC,EAAI,EAAG,GAAI,CAAE,CAAE,CAAC,EAAI,EAAI,EAAG,CAC5D,CAEW,CACX,CAAE,EAAG,GAAK,EAAG,CAAE,CAAE,EAAI,EAAI,EAAG,CAAE,CAAG,EAAI,EAAI,EAAG,CAAE,CAAG,EAAI,EAAG,GAAI,CAAE,CAAG,EAAG,GAAI,GAAI,CAC5E,CAAE,EAAI,EAAI,EAAG,CAAE,CAAE,EAAG,GAAK,EAAG,CAAE,CAAE,GAAI,GAAK,EAAG,CAAE,CAAE,GAAK,EAAI,EAAG,CAAE,CAAG,EAAI,EAAI,EAAG,CAC5E,CAAE,EAAI,EAAI,EAAG,CAAE,CAAE,EAAI,EAAI,EAAG,CAAE,CAAG,EAAI,EAAI,EAAG,CAAE,CAAG,EAAI,EAAI,EAAG,CAAE,CAAG,EAAI,EAAI,EAAG,CAC5E,CAAE,EAAI,EAAI,EAAG,CAAE,CAAE,EAAI,EAAG,GAAI,CAAE,CAAG,EAAI,EAAG,GAAI,CAAE,CAAG,EAAI,EAAI,EAAG,CAAE,CAAG,EAAI,EAAI,EAAG,CAC5E,CAEqD,EAAQ,EAE/D,EAEA,GAAM,mBAAmB,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,QAAQ,CAAC,SAAS,EAK7E,GAAM,kBAAkB,CAAG,SAAW,CAAM,CAAE,CAAM,EAUnD,GAAM,kBAAkB,CAAC,IAAI,CAAE,IAAI,CARpB,CACd,CAAE,EAAG,EAAG,EAAG,CAAE,CAAE,GAAI,EAAG,EAAG,CAAE,CAAE,EAAG,EAAG,EAAG,CAAE,CAAE,EAAG,GAAI,EAAG,CAAE,CAAE,EAAG,EAAG,EAAG,CAAE,CAAE,EAAG,EAAG,GAAI,CAC/E,CAEW,CACX,CAAE,EAAG,EAAG,EAAG,CAAE,CAAE,EAAG,EAAG,EAAG,CAAE,CAAE,EAAG,EAAG,EAAG,CAAE,CAAE,EAAG,EAAG,EAAG,CAAE,CAAE,EAAG,EAAG,EAAG,CAAE,CAAE,EAAG,EAAG,EAAG,CAAE,CAAE,EAAG,EAAG,EAAG,CAAE,CAAE,EAAG,EAAG,EAAG,CACtG,CAEqD,EAAQ,EAC/D,EAEA,GAAM,kBAAkB,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,QAAQ,CAAC,SAAS,EAK5E,GAAM,mBAAmB,CAAG,SAAW,CAAM,CAAE,CAAM,EAUpD,GAAM,kBAAkB,CAAC,IAAI,CAAE,IAAI,CARpB,CACd,CAAE,EAAI,EAAI,EAAG,CAAE,CAAE,GAAI,GAAI,EAAG,CAAE,CAAE,GAAI,EAAG,GAAI,CAAE,CAAE,EAAG,GAAI,GAAI,CAC1D,CAEW,CACX,CAAE,EAAG,EAAG,EAAG,CAAE,CAAE,EAAG,EAAG,EAAG,CAAE,CAAE,EAAG,EAAG,EAAG,CAAE,CAAE,EAAG,EAAG,EAAG,CAClD,CAEqD,EAAQ,EAE/D,EAEA,GAAM,mBAAmB,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,QAAQ,CAAC,SAAS,EAU7E,GAAM,kBAAkB,CAAG,SAAW,CAAI,CAAE,CAAM,CAAE,CAAM,CAAE,CAAO,EAElE,GAAM,QAAQ,CAAC,IAAI,CAAE,IAAI,EAEzB,IAMI,EAAO,EAAG,EACP,EAmBH,EAAG,EAAG,EAAG,EACT,EAAK,EAAK,EAAK,EA3Bf,EAAQ,IAAI,CAAC,QAAQ,CACrB,EAAQ,IAAI,CAAC,KAAK,CAClB,EAAM,IAAI,CAAC,aAAa,CAAE,EAAG,CAEjC,EAAU,AAAa,KAAA,IAAb,GAAkC,EAM5C,IAAI,EAAa,EAAS,EAE1B,IAAM,EAAI,EAAG,GAAK,EAAQ,IAIzB,IAAM,EAAI,EAFV,EAAI,EAAI,EAEK,GAAK,EAAQ,IAIzB,EAAI,EAFA,EAAI,EAEK,GACb,EAAM,IAAI,CAAE,GAQd,IAAM,EAAI,EAAG,EAAI,EAAQ,IAExB,IAAM,EAAI,EAAG,EAAI,EAAQ,IAExB,EAAI,EAAI,EAAa,EACrB,EAAI,EAAI,EAAa,EAAI,EACzB,EAAK,AAAA,CAAA,EAAI,CAAA,EAAK,EAAa,EAC3B,EAAK,AAAA,CAAA,EAAI,CAAA,EAAK,EAAa,EAAI,EAE/B,EAAM,IAAI,GAAM,OAAO,CAAE,EAAI,EAAQ,EAAI,GACzC,EAAM,IAAI,GAAM,OAAO,CAAI,AAAA,CAAA,EAAI,CAAA,EAAM,EAAQ,EAAI,GACjD,EAAM,IAAI,GAAM,OAAO,CAAE,EAAI,EAAU,AAAA,CAAA,EAAI,CAAA,EAAM,GACjD,EAAM,IAAI,GAAM,OAAO,CAAI,AAAA,CAAA,EAAI,CAAA,EAAM,EAAQ,AAAE,CAAA,EAAI,CAAA,EAAM,GAEpD,GAEJ,EAAM,IAAI,CAAE,IAAI,GAAM,KAAK,CAAE,EAAG,EAAG,IACnC,EAAM,IAAI,CAAE,IAAI,GAAM,KAAK,CAAE,EAAG,EAAG,IAEnC,EAAI,IAAI,CAAE,CAAE,EAAK,EAAK,EAAK,EAC3B,EAAI,IAAI,CAAE,CAAE,EAAK,EAAK,EAAK,IAI3B,EAAM,IAAI,CAAE,IAAI,GAAM,KAAK,CAAE,EAAG,EAAG,EAAG,IACtC,EAAI,IAAI,CAAE,CAAE,EAAK,EAAK,EAAK,EAAK,GAcnC,IAAI,CAAC,gBAAgB,GACrB,IAAI,CAAC,kBAAkB,GACvB,IAAI,CAAC,oBAAoB,EAE1B,EAEA,GAAM,kBAAkB,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,QAAQ,CAAC,SAAS,EAoB5E,GAAM,cAAc,CAAG,SAAU,CAAQ,EAExC,GAAM,QAAQ,CAAC,IAAI,CAAE,IAAI,EAIzB,IAAM,IAFF,EAAQ,CAAE,CAAE,EAAG,EAAG,EAAG,CAAE,CAAE,EAAG,EAAG,EAAG,CAAE,CAE9B,EAAI,EAAG,EAAI,EAAS,MAAM,CAAE,IAErC,AAKD,CAAA,SAAmB,CAAQ,EAE1B,IAAI,EAAS,CAAQ,CAAE,EAAU,CAAC,KAAK,GAEnC,EAAM,EAAO,MAAM,EACvB,CAAA,EAAO,CAAC,EAAI,EAAM,IAClB,EAAO,CAAC,EAAI,EAAM,IAClB,EAAO,CAAC,EAAI,EAAM,IAIlB,IAAM,IAFF,EAAO,EAAE,CAEH,EAAI,EAAG,EAAI,EAAM,MAAM,EAAI,CAEpC,IAAI,EAAO,CAAK,CAAE,EAAG,CAIrB,GAAK,AAuDP,SAAkB,CAAI,CAAE,CAAM,EAE7B,IAAI,EAAK,CAAQ,CAAE,CAAI,CAAE,EAAG,CAAE,CAI1B,EAAI,AAYT,SAAiB,CAAE,CAAE,CAAE,CAAE,CAAE,EAE1B,IAAI,EAAK,IAAI,GAAM,OAAO,CACtB,EAAK,IAAI,GAAM,OAAO,CAQ1B,OANA,EAAG,UAAU,CAAE,EAAI,GACnB,EAAG,UAAU,CAAE,EAAI,GACnB,EAAG,KAAK,CAAE,GAEV,EAAG,SAAS,GAEL,CAER,EAzBiB,EAHP,CAAQ,CAAE,CAAI,CAAE,EAAG,CAAE,CACrB,CAAQ,CAAE,CAAI,CAAE,EAAG,CAAE,EAK1B,EAAO,EAAE,GAAG,CAAE,GAElB,OAAO,EAAE,GAAG,CAAE,IAAY,CAE3B,EApEgB,EAAM,GAAW,CAE9B,IAAM,IAAI,EAAI,EAAG,EAAI,EAAG,IAAM,CAM7B,IAAM,IAqFU,EAzFZ,EAAO,CAAE,CAAI,CAAE,EAAG,CAAE,CAAI,CAAE,AAAE,CAAA,EAAI,CAAA,EAAM,EAAG,CAAE,CAC3C,EAAW,CAAA,EAGL,EAAI,EAAG,EAAI,EAAK,MAAM,CAAE,IAEjC,GAqFG,CAFY,EAnFC,CAAI,CAAE,EAAG,CAqFpB,CAAE,EAAG,GAAK,AArFY,CAqFV,CAAE,EAAG,EAAI,CAAE,CAAE,EAAG,GAAK,AArFX,CAqFa,CAAE,EAAG,CArFT,CAEnC,CAAI,CAAE,EAAG,CAAG,CAAI,CAAE,EAAK,MAAM,CAAG,EAAG,CACnC,EAAK,GAAG,GACR,EAAW,CAAA,EACX,KAED,CAII,GAEJ,EAAK,IAAI,CAAE,EAIb,CAGA,CAAK,CAAE,EAAG,CAAG,CAAK,CAAE,EAAM,MAAM,CAAG,EAAG,CACtC,EAAM,GAAG,EAEV,MAEC,GAGF,CAGA,IAAM,IAAI,EAAI,EAAG,EAAI,EAAK,MAAM,CAAE,IAEjC,EAAM,IAAI,CAAE,CACX,CAAI,CAAE,EAAG,CAAE,EAAG,CACd,CAAI,CAAE,EAAG,CAAE,EAAG,CACd,EACA,CAGH,CAAA,EAxEW,GA4HX,SAAS,IAER,MAAS,AAAA,CAAA,KAAK,MAAM,GAAK,EAAA,EAAQ,EAAI,IAEtC,CAMA,SAAS,EAAU,CAAM,EAExB,IAAI,EAAM,EAAO,MAAM,GACvB,OAAO,IAAI,GAAM,OAAO,CAAE,EAAO,CAAC,CAAG,EAAK,EAAO,CAAC,CAAG,EAEtD,CAMA,IAAM,IAHF,EAAK,EACL,EAAQ,AAAI,MAAO,EAAS,MAAM,EAE5B,EAAI,EAAG,EAAI,EAAM,MAAM,CAAE,IAIjC,IAAM,IAFF,EAAO,CAAK,CAAE,EAAG,CAEX,EAAI,EAAG,EAAI,EAAG,IAEK,KAAA,IAAvB,CAAK,CAAE,CAAI,CAAE,EAAG,CAAE,GAErB,CAAK,CAAE,CAAI,CAAE,EAAG,CAAE,CAAG,IACrB,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAE,CAAQ,CAAE,CAAI,CAAE,EAAG,CAAE,GAI3C,CAAI,CAAE,EAAG,CAAG,CAAK,CAAE,CAAI,CAAE,EAAG,CAAE,CAOjC,IAAM,IAAI,EAAI,EAAG,EAAI,EAAM,MAAM,CAAE,IAElC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAE,IAAI,GAAM,KAAK,CAC9B,CAAK,CAAE,EAAG,CAAE,EAAG,CACf,CAAK,CAAE,EAAG,CAAE,EAAG,CACf,CAAK,CAAE,EAAG,CAAE,EAAG,GAMlB,IAAM,IAAI,EAAI,EAAG,EAAI,IAAI,CAAC,KAAK,CAAC,MAAM,CAAE,IAAM,CAE7C,IAAI,EAAO,IAAI,CAAC,KAAK,CAAE,EAAG,CAE1B,IAAI,CAAC,aAAa,CAAE,EAAG,CAAC,IAAI,CAAE,CAC7B,EAAU,IAAI,CAAC,QAAQ,CAAE,EAAK,CAAC,CAAE,EACjC,EAAU,IAAI,CAAC,QAAQ,CAAE,EAAK,CAAC,CAAE,EACjC,EAAU,IAAI,CAAC,QAAQ,CAAE,EAAK,CAAC,CAAE,EACjC,CAEF,CAGA,IAAI,CAAC,gBAAgB,GACrB,IAAI,CAAC,kBAAkB,GACvB,IAAI,CAAC,oBAAoB,EAE1B,EAEA,GAAM,cAAc,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,QAAQ,CAAC,SAAS,EAMxE,GAAM,UAAU,CAAG,SAAW,CAAI,EAEjC,IAAI,EAAW,IAAI,GAAM,QAAQ,CAEjC,EAAS,QAAQ,CAAC,IAAI,CACrB,IAAI,GAAM,OAAO,CAAI,IAAI,GAAM,OAAO,CAAE,GAAQ,EAAG,EAAG,GACtD,IAAI,GAAM,OAAO,CAAI,IAAI,GAAM,OAAO,CAAE,EAAG,GAAQ,EAAG,GACtD,IAAI,GAAM,OAAO,CAAI,IAAI,GAAM,OAAO,CAAE,EAAG,EAAG,GAAQ,IAGvD,EAAS,MAAM,CAAC,IAAI,CACnB,IAAI,GAAM,KAAK,CAAE,UAAY,IAAI,GAAM,KAAK,CAAE,UAC9C,IAAI,GAAM,KAAK,CAAE,OAAY,IAAI,GAAM,KAAK,CAAE,UAC9C,IAAI,GAAM,KAAK,CAAE,KAAY,IAAI,GAAM,KAAK,CAAE,QAG/C,IAAI,EAAW,IAAI,GAAM,iBAAiB,CAAE,CAAE,aAAc,GAAM,YAAY,AAAC,GAE/E,GAAM,IAAI,CAAC,IAAI,CAAE,IAAI,CAAE,EAAU,EAAU,GAAM,UAAU,CAE5D,EAEA,GAAM,UAAU,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,IAAI,CAAC,SAAS,EAehE,GAAM,WAAW,CAAG,SAAW,CAAG,CAAE,CAAM,CAAE,CAAM,CAAE,CAAG,EAEtD,GAAM,QAAQ,CAAC,IAAI,CAAE,IAAI,EAET,KAAA,IAAX,GAAuB,CAAA,EAAS,EAArC,EACa,KAAA,IAAR,GAAoB,CAAA,EAAM,QAA/B,EAEA,IAAI,EAAe,IAAI,GAAM,QAAQ,CACrC,EAAa,QAAQ,CAAC,IAAI,CAAE,IAAI,GAAM,OAAO,CAAE,EAAG,EAAG,IACrD,EAAa,QAAQ,CAAC,IAAI,CAAE,IAAI,GAAM,OAAO,CAAE,EAAG,EAAG,IAErD,IAAI,CAAC,IAAI,CAAG,IAAI,GAAM,IAAI,CAAE,EAAc,IAAI,GAAM,iBAAiB,CAAE,CAAE,MAAO,CAAI,IACpF,IAAI,CAAC,GAAG,CAAE,IAAI,CAAC,IAAI,EAEnB,IAAI,EAAe,IAAI,GAAM,gBAAgB,CAAE,EAAG,IAAM,IAAM,EAAG,EAEjE,CAAA,IAAI,CAAC,IAAI,CAAG,IAAI,GAAM,IAAI,CAAE,EAAc,IAAI,GAAM,iBAAiB,CAAE,CAAE,MAAO,CAAI,IACpF,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAE,EAAG,EAAG,GAC9B,IAAI,CAAC,GAAG,CAAE,IAAI,CAAC,IAAI,EAEd,aAAkB,GAAM,OAAO,EAAG,CAAA,IAAI,CAAC,QAAQ,CAAG,CAAvD,EAEA,IAAI,CAAC,YAAY,CAAE,GACnB,IAAI,CAAC,SAAS,CAAE,EAEjB,EAEA,GAAM,WAAW,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,QAAQ,CAAC,SAAS,EAErE,GAAM,WAAW,CAAC,SAAS,CAAC,YAAY,CAAG,SAAW,CAAG,EAErD,IAAI,EAAI,GAAM,WAAW,CAAC,IAAI,CAAC,IAAI,CAAE,GAAM,SAAS,GAEpD,GAAK,EAAE,CAAC,CAAG,KAEP,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAE,EAAG,EAAG,QAEtB,GAAK,EAAE,CAAC,CAAG,MAEd,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAE,KAAK,EAAE,CAAE,EAAG,OAE5B,CAEN,IAAI,EAAO,GAAM,WAAW,CAAC,IAAI,CAAC,GAAG,CAAE,EAAE,CAAC,CAAE,EAAG,CAAE,EAAE,CAAC,EAAG,SAAS,GAC5D,EAAU,KAAK,IAAI,CAAE,EAAE,CAAC,EACxB,EAAa,GAAM,WAAW,CAAC,IAAI,CAAC,gBAAgB,CAAE,EAAM,GAEhE,IAAI,CAAC,QAAQ,CAAC,sBAAsB,CAAE,EAAY,IAAI,CAAC,UAAU,CAErE,CAED,EAEA,GAAM,WAAW,CAAC,SAAS,CAAC,SAAS,CAAG,SAAW,CAAM,EAExD,IAAI,CAAC,KAAK,CAAC,GAAG,CAAE,EAAQ,EAAQ,EAEjC,EAEA,GAAM,WAAW,CAAC,SAAS,CAAC,QAAQ,CAAG,SAAW,CAAG,EAEpD,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,MAAM,CAAE,GACjC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,MAAM,CAAE,EAElC,EAEA,GAAM,WAAW,CAAC,IAAI,CAAG,IAAI,GAAM,OAAO,CAC1C,GAAM,WAAW,CAAC,IAAI,CAAG,IAAI,GAAM,OAAO,CAC1C,GAAM,WAAW,CAAC,IAAI,CAAG,IAAI,GAAM,UAAU,CAU7C,GAAM,YAAY,CAAG,SAAW,CAAM,EAErC,GAAM,IAAI,CAAC,IAAI,CAAE,IAAI,EAErB,IAAI,EAAQ,IAAI,CAoEhB,SAAS,EAAS,CAAC,CAAE,CAAC,CAAE,CAAG,EAE1B,EAAU,EAAG,GACb,EAAU,EAAG,EAEd,CAEA,SAAS,EAAU,CAAE,CAAE,CAAG,EAEzB,EAAM,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAE,IAAI,GAAM,OAAO,EAC/C,EAAM,QAAQ,CAAC,MAAM,CAAC,IAAI,CAAE,IAAI,GAAM,KAAK,CAAE,IAEf,KAAA,IAAzB,EAAM,QAAQ,CAAE,EAAI,EAAiB,CAAA,EAAM,QAAQ,CAAE,EAAI,CAAG,EAAE,AAAF,EAEjE,EAAM,QAAQ,CAAE,EAAI,CAAC,IAAI,CAAE,EAAM,QAAQ,CAAC,QAAQ,CAAC,MAAM,CAAG,EAE7D,CAlFA,IAAI,CAAC,QAAQ,CAAG,IAAI,GAAM,QAAQ,CAClC,IAAI,CAAC,QAAQ,CAAG,IAAI,GAAM,iBAAiB,CAAE,CAAE,MAAO,SAAU,aAAc,GAAM,UAAU,AAAC,GAC/F,IAAI,CAAC,IAAI,CAAG,GAAM,UAAU,CAE5B,IAAI,CAAC,WAAW,CAAG,EAAO,WAAW,CACrC,IAAI,CAAC,gBAAgB,CAAG,CAAA,EAExB,IAAI,CAAC,QAAQ,CAAG,CAAC,EAYjB,EAAS,KAAM,KARE,UASjB,EAAS,KAAM,KATE,UAUjB,EAAS,KAAM,KAVE,UAWjB,EAAS,KAAM,KAXE,UAejB,EAAS,KAAM,KAfE,UAgBjB,EAAS,KAAM,KAhBE,UAiBjB,EAAS,KAAM,KAjBE,UAkBjB,EAAS,KAAM,KAlBE,UAsBjB,EAAS,KAAM,KAtBE,UAuBjB,EAAS,KAAM,KAvBE,UAwBjB,EAAS,KAAM,KAxBE,UAyBjB,EAAS,KAAM,KAzBE,UA6BjB,EAAS,IAAK,KA5BA,UA6Bd,EAAS,IAAK,KA7BA,UA8Bd,EAAS,IAAK,KA9BA,UA+Bd,EAAS,IAAK,KA/BA,UAmCd,EAAS,KAAM,KAlCH,OAmCZ,EAAS,KAAM,KAnCH,OAoCZ,EAAS,KAAM,KApCH,OAwCZ,EAAS,IAAK,IAvCE,UAwChB,EAAS,IAAK,IAvCC,SA2Cf,EAAS,MAAO,MA3CD,SA4Cf,EAAS,MAAO,MA5CD,SA8Cf,EAAS,MAAO,MA9CD,SA+Cf,EAAS,MAAO,MA/CD,SAiDf,IAAI,CAAC,MAAM,CAAG,EAoBd,IAAI,CAAC,MAAM,CAAE,EAEd,EAEA,GAAM,YAAY,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,IAAI,CAAC,SAAS,EAElE,GAAM,YAAY,CAAC,SAAS,CAAC,MAAM,CAAG,WAErC,IAAI,EAAQ,IAAI,CA8ChB,SAAS,EAAU,CAAK,CAAE,CAAC,CAAE,CAAC,CAAE,CAAC,EAEhC,GAAM,YAAY,CAAC,GAAG,CAAC,GAAG,CAAE,EAAG,EAAG,GAClC,GAAM,YAAY,CAAC,WAAW,CAAC,eAAe,CAAE,GAAM,YAAY,CAAC,GAAG,CAAE,GAAM,YAAY,CAAC,GAAG,EAE9F,IAAI,EAAS,EAAM,QAAQ,CAAE,EAAO,CAEpC,GAAK,AAAW,KAAA,IAAX,EAEJ,IAAM,IAAI,EAAI,EAAG,EAAK,EAAO,MAAM,CAAE,EAAI,EAAI,IAE5C,EAAM,QAAQ,CAAC,QAAQ,CAAE,CAAM,CAAE,EAAG,CAAE,CAAC,IAAI,CAAE,GAAM,YAAY,CAAC,GAAG,CAMtE,CAxDA,GAAM,YAAY,CAAC,GAAG,CAAC,gBAAgB,CAAC,IAAI,CAAE,IAAI,CAAC,MAAM,CAAC,gBAAgB,EAI1E,EAAU,IAAK,EAAG,EAAG,IACrB,EAAU,IAAK,EAAG,EAAI,GAItB,EAAU,KAAM,GAAI,GAAI,IACxB,EAAU,KAfF,EAeY,GAAI,IACxB,EAAU,KAAM,GAhBD,EAgBS,IACxB,EAAU,KAjBF,EAAO,EAiBS,IAIxB,EAAU,KAAM,GAAI,GAAI,GACxB,EAAU,KAtBF,EAsBY,GAAI,GACxB,EAAU,KAAM,GAvBD,EAuBS,GACxB,EAAU,KAxBF,EAAO,EAwBS,GAIxB,EAAU,KAAO,GAAS,IAAS,IACnC,EAAU,KAAM,IAAU,IAAS,IACnC,EAAU,KAAa,EAAG,EAAS,IAInC,EAAU,MAAO,GAAK,EAAG,GACzB,EAAU,MAnCF,EAmCc,EAAG,GACzB,EAAU,MAAQ,EAAG,GAAI,GACzB,EAAU,MAAQ,EArCH,EAqCU,GAEzB,EAAU,MAAO,GAAK,EAAG,IACzB,EAAU,MAxCF,EAwCc,EAAG,IACzB,EAAU,MAAQ,EAAG,GAAI,IACzB,EAAU,MAAQ,EA1CH,EA0CU,IAqBzB,IAAI,CAAC,QAAQ,CAAC,kBAAkB,CAAG,CAAA,CAEpC,EAEA,GAAM,YAAY,CAAC,WAAW,CAAG,IAAI,GAAM,SAAS,CACpD,GAAM,YAAY,CAAC,GAAG,CAAG,IAAI,GAAM,OAAO,CAC1C,GAAM,YAAY,CAAC,GAAG,CAAG,IAAI,GAAM,MAAM,CAQzC,GAAM,sBAAsB,CAAG,SAAW,CAAK,CAAE,CAAU,EAE1D,GAAM,QAAQ,CAAC,IAAI,CAAE,IAAI,EAEzB,IAAI,CAAC,KAAK,CAAG,EAIb,IAAI,CAAC,QAAQ,CAAG,EAAM,QAAQ,CAI9B,IAAI,CAAC,SAAS,CAAG,IAAI,GAAM,OAAO,CAClC,IAAI,CAAC,SAAS,CAAC,UAAU,CAAE,EAAM,MAAM,CAAC,QAAQ,CAAE,EAAM,QAAQ,EAIhE,IAAI,EAAY,GAAM,IAAI,CAAC,KAAK,CAAE,EAAM,SAAS,CAAE,EAAG,EAEtD,CAAA,IAAI,CAAC,KAAK,CAAG,EAAM,KAAK,CAAC,KAAK,GAC9B,IAAI,CAAC,KAAK,CAAC,cAAc,CAAE,GAE3B,IAAI,EAAW,IAAI,CAAC,KAAK,CAAC,MAAM,GAI5B,EAAe,IAAI,GAAM,cAAc,CAAE,EAAY,GAAI,GACzD,EAAe,IAAI,GAAM,gBAAgB,CAAE,AAAa,KAAb,EAAmB,AAAa,KAAb,GAE9D,EAAe,IAAI,GAAM,iBAAiB,CAAE,CAAE,MAAO,EAAU,IAAK,CAAA,CAAM,GAC1E,EAAe,IAAI,GAAM,iBAAiB,CAAE,CAAE,MAAO,EAAU,IAAK,CAAA,CAAM,GAiB9E,GAfA,IAAI,CAAC,WAAW,CAAG,IAAI,GAAM,IAAI,CAAE,EAAc,GAEjD,IAAI,CAAC,SAAS,CAAG,IAAI,GAAM,IAAI,CAAE,EAAc,EAAc,GAAM,UAAU,EAE7E,IAAI,CAAC,GAAG,CAAE,IAAI,CAAC,WAAW,EAC1B,IAAI,CAAC,GAAG,CAAE,IAAI,CAAC,SAAS,EAExB,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,OAAO,CAAG,CAAA,EACtC,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,YAAY,CAAG,EAC3C,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,SAAS,CAAG,IAAI,CAI5C,IAAI,CAAC,YAAY,CAAG,KAEf,AAA0C,KAAA,IAA1C,EAAM,MAAM,CAAC,UAAU,CAAC,aAAa,CAAiB,CAE1D,IAAI,EAAY,IAAI,GAAM,cAAc,CAAE,EAAY,EAAG,GACrD,EAAiB,IAAI,GAAM,iBAAiB,CAAE,CAAE,MAAO,EAAU,UAAW,CAAA,EAAM,IAAK,CAAA,CAAM,EAEjG,CAAA,IAAI,CAAC,YAAY,CAAG,IAAI,GAAM,IAAI,CAAE,EAAW,GAC/C,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAG,EAAM,MAAM,CAAC,QAAQ,CAElD,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC,OAAO,CAAG,CAAA,EACvC,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC,YAAY,CAAG,EAAM,MAAM,CACxD,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC,SAAS,CAAG,IAAI,CAAC,YAAY,CAE1D,IAAI,EAAe,IAAI,GAAM,kBAAkB,CAAE,CAAE,MAAO,EAAU,SAAU,EAAG,QAAS,EAAG,QAAS,IAAM,YAAa,CAAA,EAAM,IAAK,CAAA,CAAM,GACtI,EAAe,IAAI,GAAM,QAAQ,CACrC,EAAa,QAAQ,CAAC,IAAI,CAAE,IAAI,CAAC,QAAQ,CAAC,KAAK,IAC/C,EAAa,QAAQ,CAAC,IAAI,CAAE,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,KAAK,IAC5D,EAAa,oBAAoB,GAEjC,IAAI,CAAC,UAAU,CAAG,IAAI,GAAM,IAAI,CAAE,EAAc,GAChD,IAAI,CAAC,UAAU,CAAC,UAAU,CAAC,OAAO,CAAG,CAAA,CAEtC,CAIA,IAAI,CAAC,UAAU,CAAC,OAAO,CAAG,CAAA,CAE3B,EAEA,GAAM,sBAAsB,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,QAAQ,CAAC,SAAS,EAEhF,GAAM,sBAAsB,CAAC,SAAS,CAAC,MAAM,CAAG,WAK/C,IAAI,CAAC,SAAS,CAAC,UAAU,CAAE,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,QAAQ,CAAE,IAAI,CAAC,KAAK,CAAC,QAAQ,EAI1E,IAAI,EAAY,GAAM,IAAI,CAAC,KAAK,CAAE,IAAI,CAAC,KAAK,CAAC,SAAS,CAAE,EAAG,GAE3D,IAAI,CAAC,KAAK,CAAC,IAAI,CAAE,IAAI,CAAC,KAAK,CAAC,KAAK,EACjC,IAAI,CAAC,KAAK,CAAC,cAAc,CAAE,GAE3B,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAE,IAAI,CAAC,KAAK,EAChD,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAE,IAAI,CAAC,KAAK,EAGnB,OAAtB,IAAI,CAAC,YAAY,GAErB,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAE,IAAI,CAAC,KAAK,EACjD,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAE,IAAI,CAAC,KAAK,EAI/C,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,QAAQ,CAAE,EAAG,CAAC,IAAI,CAAE,IAAI,CAAC,KAAK,CAAC,QAAQ,EAChE,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,QAAQ,CAAE,EAAG,CAAC,IAAI,CAAE,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,QAAQ,EAEvE,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,oBAAoB,GAC7C,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,kBAAkB,CAAG,CAAA,EAIhD,EAQA,GAAM,qBAAqB,CAAG,SAAW,CAAK,CAAE,CAAU,CAAE,CAAW,CAAE,CAAQ,EAEhF,GAAM,QAAQ,CAAC,IAAI,CAAE,IAAI,EAEzB,IAAI,CAAC,KAAK,CAAG,EAIb,IAAI,CAAC,QAAQ,CAAG,EAAM,QAAQ,CAI9B,IAAI,EAAY,GAAM,IAAI,CAAC,KAAK,CAAE,EAAM,SAAS,CAAE,EAAG,EAItD,CAAA,IAAI,CAAC,KAAK,CAAG,EAAM,KAAK,CAAC,KAAK,GAC9B,IAAI,CAAC,KAAK,CAAC,cAAc,CAAE,GAE3B,IAAI,EAAW,IAAI,CAAC,KAAK,CAAC,MAAM,EAIhC,CAAA,IAAI,CAAC,WAAW,CAAG,EAAM,WAAW,CAAC,KAAK,GAC1C,IAAI,CAAC,WAAW,CAAC,cAAc,CAAE,GAYjC,IAAM,IAVF,EAAiB,IAAI,CAAC,WAAW,CAAC,MAAM,GAIxC,EAAe,IAAI,GAAM,cAAc,CAAE,EAAY,GAAI,EAAG,EAAG,AAAU,EAAV,KAAK,EAAE,CAAM,EAAG,AAAU,GAAV,KAAK,EAAE,EACtF,EAAqB,IAAI,GAAM,cAAc,CAAE,EAAY,GAAI,EAAG,EAAG,AAAU,EAAV,KAAK,EAAE,CAAM,AAAU,GAAV,KAAK,EAAE,CAAQ,KAAK,EAAE,EAExG,EAAkB,IAAI,GAAM,iBAAiB,CAAE,CAAE,MAAO,EAAU,IAAK,CAAA,CAAM,GAC7E,EAAqB,IAAI,GAAM,iBAAiB,CAAE,CAAE,MAAO,EAAgB,IAAK,CAAA,CAAM,GAEhF,EAAI,EAAG,EAAK,EAAa,KAAK,CAAC,MAAM,CAAE,EAAI,EAAI,IAExD,EAAa,KAAK,CAAE,EAAG,CAAC,aAAa,CAAG,EAIzC,IAAM,IAAI,EAAI,EAAG,EAAK,EAAmB,KAAK,CAAC,MAAM,CAAE,EAAI,EAAI,IAE9D,EAAmB,KAAK,CAAE,EAAG,CAAC,aAAa,CAAG,EAI/C,GAAM,aAAa,CAAC,KAAK,CAAE,EAAc,GAEzC,IAAI,CAAC,WAAW,CAAG,IAAI,GAAM,IAAI,CAAE,EAAc,IAAI,GAAM,gBAAgB,CAAE,CAAE,EAAiB,EAAoB,GAIpH,IAAI,CAAC,UAAU,CAAG,IAAI,GAAM,WAAW,CAAE,IAAI,GAAM,OAAO,CAAE,EAAG,EAAG,GAAK,IAAI,GAAM,OAAO,CAAE,EAAG,AAAE,CAAA,EAAa,CAAA,EAAgB,IAAK,GAAK,EAAa,GACnJ,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,CAAG,KAAK,EAAE,CAEpC,IAAI,CAAC,gBAAgB,CAAG,IAAI,GAAM,WAAW,CAAE,IAAI,GAAM,OAAO,CAAE,EAAG,EAAG,GAAK,IAAI,GAAM,OAAO,CAAE,EAAG,CAAA,CAAA,AAAE,CAAA,EAAa,CAAA,EAAgB,GAAA,EAAM,GAAK,EAAa,GAE1J,IAAI,EAAQ,IAAI,GAAM,QAAQ,AAC9B,CAAA,EAAM,QAAQ,CAAC,CAAC,CAAG,CAAA,CAAA,AAAW,GAAV,KAAK,EAAE,AAA3B,EAEA,EAAM,GAAG,CAAE,IAAI,CAAC,WAAW,EAC3B,EAAM,GAAG,CAAE,IAAI,CAAC,UAAU,EAC1B,EAAM,GAAG,CAAE,IAAI,CAAC,gBAAgB,EAEhC,IAAI,CAAC,GAAG,CAAE,GAIV,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,OAAO,CAAG,CAAA,EACtC,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,YAAY,CAAG,EAC3C,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,SAAS,CAAG,IAAI,CAI5C,IAAI,CAAC,UAAU,CAAC,OAAO,CAAG,CAAA,EAI1B,IAAI,CAAC,MAAM,CAAG,IAAI,GAAM,OAAO,CAC/B,IAAI,CAAC,MAAM,CAAE,IAAI,CAAC,MAAM,CAEzB,EAEA,GAAM,qBAAqB,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,QAAQ,CAAC,SAAS,EAE/E,GAAM,qBAAqB,CAAC,SAAS,CAAC,MAAM,CAAG,WAI9C,IAAI,EAAY,GAAM,IAAI,CAAC,KAAK,CAAE,IAAI,CAAC,KAAK,CAAC,SAAS,CAAE,EAAG,GAE3D,IAAI,CAAC,KAAK,CAAC,IAAI,CAAE,IAAI,CAAC,KAAK,CAAC,KAAK,EACjC,IAAI,CAAC,KAAK,CAAC,cAAc,CAAE,GAE3B,IAAI,CAAC,WAAW,CAAC,IAAI,CAAE,IAAI,CAAC,KAAK,CAAC,WAAW,EAC7C,IAAI,CAAC,WAAW,CAAC,cAAc,CAAE,GAEjC,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,SAAS,CAAE,EAAG,CAAC,KAAK,CAAC,IAAI,CAAE,IAAI,CAAC,KAAK,EAC/D,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,SAAS,CAAE,EAAG,CAAC,KAAK,CAAC,IAAI,CAAE,IAAI,CAAC,WAAW,EAErE,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAE,IAAI,CAAC,KAAK,CAAC,MAAM,IAC3C,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAE,IAAI,CAAC,WAAW,CAAC,MAAM,IAEvD,IAAI,CAAC,MAAM,CAAE,IAAI,CAAC,MAAM,CAEzB,EAQA,GAAM,gBAAgB,CAAG,SAAW,CAAK,CAAE,CAAU,EAEpD,GAAM,QAAQ,CAAC,IAAI,CAAE,IAAI,EAEzB,IAAI,CAAC,KAAK,CAAG,EAIb,IAAI,CAAC,QAAQ,CAAG,EAAM,QAAQ,CAI9B,IAAI,EAAY,GAAM,IAAI,CAAC,KAAK,CAAE,EAAM,SAAS,CAAE,EAAG,EAEtD,CAAA,IAAI,CAAC,KAAK,CAAG,EAAM,KAAK,CAAC,KAAK,GAC9B,IAAI,CAAC,KAAK,CAAC,cAAc,CAAE,GAE3B,IAAI,EAAW,IAAI,CAAC,KAAK,CAAC,MAAM,GAI5B,EAAe,IAAI,GAAM,cAAc,CAAE,EAAY,GAAI,GACzD,EAAe,IAAI,GAAM,gBAAgB,CAAE,AAAa,KAAb,EAAmB,AAAa,KAAb,GAC9D,EAAmB,IAAI,GAAM,mBAAmB,CAAE,EAAG,GAErD,EAAe,IAAI,GAAM,iBAAiB,CAAE,CAAE,MAAO,EAAU,IAAK,CAAA,CAAM,GAC1E,EAAe,IAAI,GAAM,iBAAiB,CAAE,CAAE,MAAO,EAAU,IAAK,CAAA,CAAM,GAC1E,EAAmB,IAAI,GAAM,iBAAiB,CAAE,CAAE,MAAO,EAAU,IAAK,CAAA,EAAO,UAAW,CAAA,EAAM,QAAS,GAAK,YAAa,CAAA,CAAK,EAEpI,CAAA,IAAI,CAAC,WAAW,CAAG,IAAI,GAAM,IAAI,CAAE,EAAc,GACjD,IAAI,CAAC,SAAS,CAAG,IAAI,GAAM,IAAI,CAAE,EAAc,EAAc,GAAM,UAAU,EAC7E,IAAI,CAAC,aAAa,CAAG,IAAI,GAAM,IAAI,CAAE,EAAkB,GAEvD,IAAI,EAAI,EAAM,QAAQ,AAEjB,AAAM,CAAA,IAAN,EAEJ,IAAI,CAAC,aAAa,CAAC,OAAO,CAAG,CAAA,EAI7B,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,GAAG,CAAE,EAAG,EAAG,GAIrC,IAAI,CAAC,GAAG,CAAE,IAAI,CAAC,WAAW,EAC1B,IAAI,CAAC,GAAG,CAAE,IAAI,CAAC,SAAS,EACxB,IAAI,CAAC,GAAG,CAAE,IAAI,CAAC,aAAa,EAI5B,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,OAAO,CAAG,CAAA,EACtC,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,YAAY,CAAG,EAC3C,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,SAAS,CAAG,IAAI,CAI5C,IAAI,CAAC,UAAU,CAAC,OAAO,CAAG,CAAA,CAE3B,EAEA,GAAM,gBAAgB,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,QAAQ,CAAC,SAAS,EAE1E,GAAM,gBAAgB,CAAC,SAAS,CAAC,MAAM,CAAG,WAIzC,IAAI,EAAY,GAAM,IAAI,CAAC,KAAK,CAAE,IAAI,CAAC,KAAK,CAAC,SAAS,CAAE,EAAG,GAE3D,IAAI,CAAC,KAAK,CAAC,IAAI,CAAE,IAAI,CAAC,KAAK,CAAC,KAAK,EACjC,IAAI,CAAC,KAAK,CAAC,cAAc,CAAE,GAE3B,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAE,IAAI,CAAC,KAAK,EAChD,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAE,IAAI,CAAC,KAAK,EAC9C,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAE,IAAI,CAAC,KAAK,EAIlD,IAAI,EAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,AAEtB,AAAM,CAAA,IAAN,EAEJ,IAAI,CAAC,aAAa,CAAC,OAAO,CAAG,CAAA,GAI7B,IAAI,CAAC,aAAa,CAAC,OAAO,CAAG,CAAA,EAC7B,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,GAAG,CAAE,EAAG,EAAG,GAItC,EAQA,GAAM,eAAe,CAAG,SAAW,CAAK,CAAE,CAAU,EAEnD,GAAM,QAAQ,CAAC,IAAI,CAAE,IAAI,EAEzB,IAAI,CAAC,KAAK,CAAG,EAIb,IAAI,CAAC,QAAQ,CAAG,EAAM,QAAQ,CAI9B,IAAI,CAAC,SAAS,CAAG,IAAI,GAAM,OAAO,CAClC,IAAI,CAAC,SAAS,CAAC,UAAU,CAAE,EAAM,MAAM,CAAC,QAAQ,CAAE,EAAM,QAAQ,EAIhE,IAAI,EAAY,GAAM,IAAI,CAAC,KAAK,CAAE,EAAM,SAAS,CAAE,EAAG,EAEtD,CAAA,IAAI,CAAC,KAAK,CAAG,EAAM,KAAK,CAAC,KAAK,GAC9B,IAAI,CAAC,KAAK,CAAC,cAAc,CAAE,GAE3B,IAAI,EAAW,IAAI,CAAC,KAAK,CAAC,MAAM,GAI5B,EAAe,IAAI,GAAM,cAAc,CAAE,EAAY,GAAI,GACzD,EAAe,IAAI,GAAM,gBAAgB,CAAE,AAAa,KAAb,EAAmB,AAAa,KAAb,GAC9D,EAAe,IAAI,GAAM,gBAAgB,CAAE,KAAQ,EAAG,EAAG,EAAG,EAAG,CAAA,GAE/D,EAAa,IAAI,GAAM,OAAO,CAClC,EAAW,OAAO,CAAE,CAAC,KAAK,EAAE,CAAC,GAC7B,EAAW,SAAS,CAAE,IAAI,GAAM,OAAO,CAAE,EAAG,IAAM,IAClD,EAAa,WAAW,CAAE,GAE1B,IAAI,EAAe,IAAI,GAAM,iBAAiB,CAAE,CAAE,MAAO,EAAU,IAAK,CAAA,CAAM,GAC1E,EAAe,IAAI,GAAM,iBAAiB,CAAE,CAAE,MAAO,EAAU,IAAK,CAAA,CAAM,GAC1E,EAAe,IAAI,GAAM,iBAAiB,CAAE,CAAE,MAAO,EAAU,IAAK,CAAA,EAAO,UAAW,CAAA,EAAM,QAAS,GAAK,YAAa,CAAA,CAAK,EAEhI,CAAA,IAAI,CAAC,WAAW,CAAG,IAAI,GAAM,IAAI,CAAE,EAAc,GACjD,IAAI,CAAC,SAAS,CAAG,IAAI,GAAM,IAAI,CAAE,EAAc,GAE/C,IAAI,EAAa,EAAM,QAAQ,CAAG,EAAM,QAAQ,CAAG,IAC/C,EAAY,EAAa,KAAK,GAAG,CAAE,AAAc,GAAd,EAAM,KAAK,EAAW,EAuB7D,GAtBA,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,GAAG,CAAE,EAAW,EAAW,GAEhD,IAAI,CAAC,SAAS,CAAG,IAAI,GAAM,IAAI,CAAE,EAAc,EAAc,GAAM,UAAU,EAE7E,IAAI,CAAC,SAAS,CAAG,IAAI,GAAM,SAAS,CAEpC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAE,IAAI,CAAC,WAAW,EACpC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAE,IAAI,CAAC,SAAS,EAElC,IAAI,CAAC,GAAG,CAAE,IAAI,CAAC,SAAS,EACxB,IAAI,CAAC,GAAG,CAAE,IAAI,CAAC,SAAS,EAExB,IAAI,CAAC,MAAM,CAAE,EAAM,MAAM,CAAC,QAAQ,EAElC,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,OAAO,CAAG,CAAA,EACtC,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,YAAY,CAAG,EAC3C,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,SAAS,CAAG,IAAI,CAI5C,IAAI,CAAC,YAAY,CAAG,KAEf,AAA0C,KAAA,IAA1C,EAAM,MAAM,CAAC,UAAU,CAAC,aAAa,CAAiB,CAE1D,IAAI,EAAY,IAAI,GAAM,cAAc,CAAE,EAAY,EAAG,GACrD,EAAiB,IAAI,GAAM,iBAAiB,CAAE,CAAE,MAAO,EAAU,UAAW,CAAA,EAAM,IAAK,CAAA,CAAM,EAEjG,CAAA,IAAI,CAAC,YAAY,CAAG,IAAI,GAAM,IAAI,CAAE,EAAW,GAC/C,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAG,EAAM,MAAM,CAAC,QAAQ,CAElD,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC,OAAO,CAAG,CAAA,EACvC,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC,YAAY,CAAG,EAAM,MAAM,CACxD,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC,SAAS,CAAG,IAAI,CAAC,YAAY,CAE1D,IAAI,EAAe,IAAI,GAAM,kBAAkB,CAAE,CAAE,MAAO,EAAU,SAAU,EAAG,QAAS,EAAG,QAAS,IAAM,YAAa,CAAA,EAAM,IAAK,CAAA,CAAM,GACtI,EAAe,IAAI,GAAM,QAAQ,CACrC,EAAa,QAAQ,CAAC,IAAI,CAAE,IAAI,CAAC,QAAQ,CAAC,KAAK,IAC/C,EAAa,QAAQ,CAAC,IAAI,CAAE,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,KAAK,IAC5D,EAAa,oBAAoB,GAEjC,IAAI,CAAC,UAAU,CAAG,IAAI,GAAM,IAAI,CAAE,EAAc,GAChD,IAAI,CAAC,UAAU,CAAC,UAAU,CAAC,OAAO,CAAG,CAAA,CAEtC,CAIA,IAAI,CAAC,UAAU,CAAC,OAAO,CAAG,CAAA,CAE3B,EAEA,GAAM,eAAe,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,QAAQ,CAAC,SAAS,EAEzE,GAAM,eAAe,CAAC,SAAS,CAAC,MAAM,CAAG,WAKxC,IAAI,CAAC,SAAS,CAAC,UAAU,CAAE,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,QAAQ,CAAE,IAAI,CAAC,KAAK,CAAC,QAAQ,EAI1E,IAAI,CAAC,MAAM,CAAE,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,QAAQ,EAEvC,IAAI,EAAa,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAG,IACzD,EAAY,EAAa,KAAK,GAAG,CAAE,AAAmB,GAAnB,IAAI,CAAC,KAAK,CAAC,KAAK,EAAW,EAClE,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,GAAG,CAAE,EAAW,EAAW,GAIhD,IAAI,EAAY,GAAM,IAAI,CAAC,KAAK,CAAE,IAAI,CAAC,KAAK,CAAC,SAAS,CAAE,EAAG,GAE3D,IAAI,CAAC,KAAK,CAAC,IAAI,CAAE,IAAI,CAAC,KAAK,CAAC,KAAK,EACjC,IAAI,CAAC,KAAK,CAAC,cAAc,CAAE,GAE3B,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAE,IAAI,CAAC,KAAK,EAChD,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAE,IAAI,CAAC,KAAK,EAC9C,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAE,IAAI,CAAC,KAAK,EAGnB,OAAtB,IAAI,CAAC,YAAY,GAErB,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAE,IAAI,CAAC,KAAK,EACjD,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAE,IAAI,CAAC,KAAK,EAI/C,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,QAAQ,CAAE,EAAG,CAAC,IAAI,CAAE,IAAI,CAAC,KAAK,CAAC,QAAQ,EAChE,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,QAAQ,CAAE,EAAG,CAAC,IAAI,CAAE,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,QAAQ,EAEvE,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,oBAAoB,GAC7C,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,kBAAkB,CAAG,CAAA,EAIhD,EAKA,GAAM,qBAAqB,CAAG,WAE7B,GAAM,QAAQ,CAAC,IAAI,CAAE,IAAI,EAEzB,IAAI,CAAC,MAAM,CAAG,SAAW,CAAc,EAAK,CAE7C,EAEA,GAAM,qBAAqB,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,QAAQ,CAAC,SAAS,EAM/E,GAAM,SAAS,CAAG,SAAW,CAAO,CAAE,CAAI,CAAE,CAAQ,CAAE,CAAQ,CAAE,CAAK,EAEpE,GAAM,QAAQ,CAAC,IAAI,CAAE,IAAI,EAEzB,IAAI,CAAC,UAAU,CAAG,EAAE,CAEpB,IAAI,CAAC,cAAc,CAAG,IAAI,GAAM,OAAO,CACvC,IAAI,CAAC,oBAAoB,CAAG,KAAA,EAEZ,KAAA,IAAZ,GAEH,IAAI,CAAC,GAAG,CAAE,EAAS,EAAM,EAAU,EAAU,EAI/C,EAEA,GAAM,SAAS,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,QAAQ,CAAC,SAAS,EAOnE,GAAM,SAAS,CAAC,SAAS,CAAC,GAAG,CAAG,SAAW,CAAO,CAAE,CAAI,CAAE,CAAQ,CAAE,CAAQ,CAAE,CAAK,CAAE,CAAO,EAE9E,KAAA,IAAT,GAAqB,CAAA,EAAO,EAAhC,EACiB,KAAA,IAAb,GAAyB,CAAA,EAAW,CAAA,EACxB,KAAA,IAAZ,GAAwB,CAAA,EAAU,CAAA,EACxB,KAAA,IAAV,GAAsB,CAAA,EAAQ,IAAI,GAAM,KAAK,CAAE,SAAnD,EACiB,KAAA,IAAb,GAAyB,CAAA,EAAW,GAAM,cAAc,AAAd,EAE9C,EAAW,KAAK,GAAG,CAAE,EAAU,KAAK,GAAG,CAAE,EAAG,IAE5C,IAAI,CAAC,UAAU,CAAC,IAAI,CAAE,CAAE,QAAS,EACZ,KAAM,EACN,SAAU,EACV,EAAG,EAAG,EAAG,EAAG,EAAG,EACf,MAAO,EACP,SAAU,EACV,QAAS,EACxB,MAAO,EACQ,SAAU,CAAS,EAEzC,EAQA,GAAM,SAAS,CAAC,SAAS,CAAC,gBAAgB,CAAG,WAE5C,IACI,EADA,EAAG,EAAK,IAAI,CAAC,UAAU,CAAC,MAAM,CAE9B,EAAO,CAAA,CAAA,AAAyB,EAAxB,IAAI,CAAC,cAAc,CAAC,CAAC,AAAG,EAChC,EAAO,CAAA,CAAA,AAAyB,EAAxB,IAAI,CAAC,cAAc,CAAC,CAAC,AAAG,EAEpC,IAAK,EAAI,EAAG,EAAI,EAAI,IAInB,AAFA,CAAA,EAAQ,IAAI,CAAC,UAAU,CAAE,EAAG,AAAH,EAEnB,CAAC,CAAG,IAAI,CAAC,cAAc,CAAC,CAAC,CAAG,EAAO,EAAM,QAAQ,CACvD,EAAM,CAAC,CAAG,IAAI,CAAC,cAAc,CAAC,CAAC,CAAG,EAAO,EAAM,QAAQ,CAEvD,EAAM,cAAc,CAAG,EAAM,CAAC,CAAG,KAAK,EAAE,CAAG,IAC3C,EAAM,QAAQ,EAAI,AAAE,CAAA,EAAM,cAAc,CAAG,EAAM,QAAQ,AAAR,EAAa,GAIhE,EAiBA,GAAM,cAAc,CAAG,SAAU,CAAQ,CAAE,CAAQ,EAElD,GAAM,IAAI,CAAC,IAAI,CAAE,IAAI,CAAE,EAAU,GAEjC,IAAI,CAAC,aAAa,CAAG,CAAC,EACtB,IAAI,CAAC,cAAc,CAAG,EAAE,CAKxB,IAAI,EAAY,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,MAAM,CAE7C,EAAO,YAOX,IAAI,CAAC,eAAe,CAAE,EALL,EACF,EAAY,EAEjB,EAAY,GAGtB,IAAI,CAAC,kBAAkB,CAAE,EAAM,EAEhC,EAEA,GAAM,cAAc,CAAC,SAAS,CAAG,OAAO,MAAM,CAAE,GAAM,IAAI,CAAC,SAAS,EAEpE,GAAM,cAAc,CAAC,SAAS,CAAC,eAAe,CAAG,SAAW,CAAI,CAAE,CAAK,CAAE,CAAG,CAAE,CAAG,EAEhF,IAAI,EAAY,CAEf,WAAY,EACZ,SAAU,EAEV,OAAQ,EAAM,EAAQ,EAEtB,IAAK,EACL,SAAU,AAAE,CAAA,EAAM,CAAA,EAAU,EAE5B,UAAW,EACX,aAAc,EAEd,OAAQ,CAAA,EAER,KAAM,EACN,UAAW,EACX,OAAQ,EAER,mBAAoB,CAAA,EACpB,aAAc,CAAA,CAEf,CAEA,CAAA,IAAI,CAAC,aAAa,CAAE,EAAM,CAAG,EAC7B,IAAI,CAAC,cAAc,CAAC,IAAI,CAAE,EAE3B,EAEA,GAAM,cAAc,CAAC,SAAS,CAAC,oBAAoB,CAAG,SAAW,CAAG,EAQnE,IAAM,IAJF,EAFA,EAAU,gBAEM,EAAc,CAAC,EAE/B,EAAW,IAAI,CAAC,QAAQ,CAElB,EAAI,EAAG,EAAK,EAAS,YAAY,CAAC,MAAM,CAAE,EAAI,EAAI,IAAO,CAGlE,IAAI,EAAS,AADD,EAAS,YAAY,CAAE,EAAG,CACnB,IAAI,CAAC,KAAK,CAAE,GAE/B,GAAK,GAAU,EAAO,MAAM,CAAG,EAAI,CAElC,IAAI,EAAO,CAAM,CAAE,EAAG,AACZ,CAAA,CAAM,CAAE,EAAG,CAEd,CAAW,CAAE,EAAM,EAAG,CAAA,CAAW,CAAE,EAAM,CAAG,CAAE,MAAO,IAAU,IAAK,CAAC,GAAS,CAAA,EAErF,IAAI,EAAQ,CAAW,CAAE,EAAM,CAE1B,EAAI,EAAM,KAAK,EAAG,CAAA,EAAM,KAAK,CAAG,CAAA,EAChC,EAAI,EAAM,GAAG,EAAG,CAAA,EAAM,GAAG,CAAG,CAAA,EAE1B,GAAiB,CAAA,EAAiB,CAAzC,CAED,CAED,CAEA,IAAM,IAAI,KAAQ,EAAc,CAE/B,IAAI,EAAQ,CAAW,CAAE,EAAM,CAC/B,IAAI,CAAC,eAAe,CAAE,EAAM,EAAM,KAAK,CAAE,EAAM,GAAG,CAAE,EAErD,CAEA,IAAI,CAAC,cAAc,CAAG,CAEvB,EAEA,GAAM,cAAc,CAAC,SAAS,CAAC,4BAA4B,CAAG,SAAW,CAAI,EAE5E,IAAI,EAAY,IAAI,CAAC,aAAa,CAAE,EAAM,CAErC,IAEJ,EAAU,SAAS,CAAG,EACtB,EAAU,kBAAkB,CAAG,CAAA,EAIjC,EAEA,GAAM,cAAc,CAAC,SAAS,CAAC,6BAA6B,CAAG,SAAW,CAAI,EAE7E,IAAI,EAAY,IAAI,CAAC,aAAa,CAAE,EAAM,CAErC,IAEJ,EAAU,SAAS,CAAG,GACtB,EAAU,kBAAkB,CAAG,CAAA,EAIjC,EAEA,GAAM,cAAc,CAAC,SAAS,CAAC,eAAe,CAAG,SAAW,CAAI,CAAE,CAAG,EAEpE,IAAI,EAAY,IAAI,CAAC,aAAa,CAAE,EAAM,CAErC,IAEJ,EAAU,GAAG,CAAG,EAChB,EAAU,QAAQ,CAAG,AAAE,CAAA,EAAU,GAAG,CAAG,EAAU,KAAI,AAAJ,EAAU,EAAU,GAAG,CAI1E,EAEA,GAAM,cAAc,CAAC,SAAS,CAAC,oBAAoB,CAAG,SAAW,CAAI,CAAE,CAAQ,EAE9E,IAAI,EAAY,IAAI,CAAC,aAAa,CAAE,EAAM,CAErC,IAEJ,EAAU,QAAQ,CAAG,EACrB,EAAU,GAAG,CAAG,AAAE,CAAA,EAAU,GAAG,CAAG,EAAU,KAAI,AAAJ,EAAU,EAAU,QAAQ,CAI1E,EAEA,GAAM,cAAc,CAAC,SAAS,CAAC,kBAAkB,CAAG,SAAW,CAAI,CAAE,CAAM,EAE1E,IAAI,EAAY,IAAI,CAAC,aAAa,CAAE,EAAM,CAErC,GAEJ,CAAA,EAAU,MAAM,CAAG,CAFpB,CAMD,EAEA,GAAM,cAAc,CAAC,SAAS,CAAC,gBAAgB,CAAG,SAAW,CAAI,CAAE,CAAI,EAEtE,IAAI,EAAY,IAAI,CAAC,aAAa,CAAE,EAAM,CAErC,GAEJ,CAAA,EAAU,IAAI,CAAG,CAFlB,CAMD,EAEA,GAAM,cAAc,CAAC,SAAS,CAAC,gBAAgB,CAAG,SAAW,CAAI,EAEhE,IAAI,EAAO,EAEP,EAAY,IAAI,CAAC,aAAa,CAAE,EAAM,CAQ1C,OANK,GAEJ,CAAA,EAAO,EAAU,IAAI,AAAJ,EAIX,CAER,EAEA,GAAM,cAAc,CAAC,SAAS,CAAC,oBAAoB,CAAG,SAAW,CAAI,EAEpE,IAAI,EAAW,GAEX,EAAY,IAAI,CAAC,aAAa,CAAE,EAAM,CAQ1C,OANK,GAEJ,CAAA,EAAW,EAAU,QAAQ,AAAR,EAIf,CAER,EAEA,GAAM,cAAc,CAAC,SAAS,CAAC,aAAa,CAAG,SAAW,CAAI,EAE7D,IAAI,EAAY,IAAI,CAAC,aAAa,CAAE,EAAM,CAErC,GAEJ,EAAU,IAAI,CAAG,EACjB,EAAU,MAAM,CAAG,CAAA,GAInB,QAAQ,IAAI,CAAE,aAAe,EAAO,cAItC,EAEA,GAAM,cAAc,CAAC,SAAS,CAAC,aAAa,CAAG,SAAW,CAAI,EAE7D,IAAI,EAAY,IAAI,CAAC,aAAa,CAAE,EAAM,CAErC,GAEJ,CAAA,EAAU,MAAM,CAAG,CAAA,CAFpB,CAMD,EAEA,GAAM,cAAc,CAAC,SAAS,CAAC,MAAM,CAAG,SAAW,CAAK,EAEvD,IAAM,IAAI,EAAI,EAAG,EAAK,IAAI,CAAC,cAAc,CAAC,MAAM,CAAE,EAAI,EAAI,IAAO,CAEhE,IAAI,EAAY,IAAI,CAAC,cAAc,CAAE,EAAG,CAExC,GAAO,EAAU,MAAM,EAEvB,IAAI,EAAY,EAAU,QAAQ,CAAG,EAAU,MAAM,AAErD,CAAA,EAAU,IAAI,EAAI,EAAU,SAAS,CAAG,EAEnC,EAAU,YAAY,CAErB,CAAA,EAAU,IAAI,CAAG,EAAU,QAAQ,EAAI,EAAU,IAAI,CAAG,CAAA,IAE5D,EAAU,SAAS,EAAI,GAElB,EAAU,IAAI,CAAG,EAAU,QAAQ,GAEvC,EAAU,IAAI,CAAG,EAAU,QAAQ,CACnC,EAAU,kBAAkB,CAAG,CAAA,GAI3B,EAAU,IAAI,CAAG,IAErB,EAAU,IAAI,CAAG,EACjB,EAAU,kBAAkB,CAAG,CAAA,KAQjC,EAAU,IAAI,CAAG,EAAU,IAAI,CAAG,EAAU,QAAQ,CAE/C,EAAU,IAAI,CAAG,GAAI,CAAA,EAAU,IAAI,EAAI,EAAU,QAAQ,AAAR,GAIvD,IAAI,EAAW,EAAU,UAAU,CAAG,GAAM,IAAI,CAAC,KAAK,CAAE,KAAK,KAAK,CAAE,EAAU,IAAI,CAAG,GAAa,EAAG,EAAU,MAAM,CAAG,GACpH,EAAS,EAAU,MAAM,CAExB,IAAa,EAAU,YAAY,GAEvC,IAAI,CAAC,qBAAqB,CAAE,EAAU,SAAS,CAAE,CAAG,EACpD,IAAI,CAAC,qBAAqB,CAAE,EAAU,YAAY,CAAE,CAAG,EAAI,EAE3D,IAAI,CAAC,qBAAqB,CAAE,EAAU,CAAG,EAEzC,EAAU,SAAS,CAAG,EAAU,YAAY,CAC5C,EAAU,YAAY,CAAG,GAI1B,IAAI,EAAM,EAAY,IAAI,CAAG,EAAc,CAEtC,CAAA,EAAU,kBAAkB,EAAG,CAAA,EAAM,EAAI,CAA9C,EAEA,IAAI,CAAC,qBAAqB,CAAE,EAAU,YAAY,CAAE,CAAG,EAAM,EAC7D,IAAI,CAAC,qBAAqB,CAAE,EAAU,SAAS,CAAE,CAAK,AAAA,CAAA,EAAI,CAAA,EAAQ,EAEnE,CAED,EAMA,GAAM,eAAe,CAAG,WAEvB,IAAI,EAAK,EAAW,EAAY,EAAa,CAAC,EA+Q9C,SAAS,EAAgB,CAAM,CAAE,CAAS,EAEzC,IAAI,EAAU,EAAI,aAAa,GAE3B,EAAiB,EAAI,YAAY,CAAE,EAAI,eAAe,EACtD,EAAe,EAAI,YAAY,CAAE,EAAI,aAAa,EAElD,EAAS,aAAe,EAAY,YAaxC,OAXA,EAAI,YAAY,CAAE,EAAgB,EAAS,EAAO,cAAc,EAChE,EAAI,YAAY,CAAE,EAAc,EAAS,EAAO,YAAY,EAE5D,EAAI,aAAa,CAAE,GACnB,EAAI,aAAa,CAAE,GAEnB,EAAI,YAAY,CAAE,EAAS,GAC3B,EAAI,YAAY,CAAE,EAAS,GAE3B,EAAI,WAAW,CAAE,GAEV,CAER,CAnSA,IAAI,CAAC,IAAI,CAAG,SAAW,CAAQ,EAE9B,EAAM,EAAS,OAAO,CACtB,EAAY,EAEZ,EAAa,EAAS,YAAY,GAElC,EAAW,QAAQ,CAAG,IAAI,aAAc,IACxC,EAAW,KAAK,CAAG,IAAI,YAAa,GAEpC,IAAI,EAAI,CACR,CAAA,EAAW,QAAQ,CAAE,IAAK,CAAG,GAAI,EAAW,QAAQ,CAAE,IAAK,CAAG,GAC9D,EAAW,QAAQ,CAAE,IAAK,CAAG,EAAI,EAAW,QAAQ,CAAE,IAAK,CAAG,EAE9D,EAAW,QAAQ,CAAE,IAAK,CAAG,EAAI,EAAW,QAAQ,CAAE,IAAK,CAAG,GAC9D,EAAW,QAAQ,CAAE,IAAK,CAAG,EAAI,EAAW,QAAQ,CAAE,IAAK,CAAG,EAE9D,EAAW,QAAQ,CAAE,IAAK,CAAG,EAAI,EAAW,QAAQ,CAAE,IAAK,CAAG,EAC9D,EAAW,QAAQ,CAAE,IAAK,CAAG,EAAI,EAAW,QAAQ,CAAE,IAAK,CAAG,EAE9D,EAAW,QAAQ,CAAE,IAAK,CAAG,GAAI,EAAW,QAAQ,CAAE,IAAK,CAAG,EAC9D,EAAW,QAAQ,CAAE,IAAK,CAAG,EAAI,EAAW,QAAQ,CAAE,IAAK,CAAG,EAE9D,EAAI,EACJ,EAAW,KAAK,CAAE,IAAK,CAAG,EAAG,EAAW,KAAK,CAAE,IAAK,CAAG,EAAG,EAAW,KAAK,CAAE,IAAK,CAAG,EACpF,EAAW,KAAK,CAAE,IAAK,CAAG,EAAG,EAAW,KAAK,CAAE,IAAK,CAAG,EAAG,EAAW,KAAK,CAAE,IAAK,CAAG,EAIpF,EAAW,YAAY,CAAO,EAAI,YAAY,GAC9C,EAAW,aAAa,CAAM,EAAI,YAAY,GAE9C,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAW,YAAY,EACzD,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAW,QAAQ,CAAE,EAAI,WAAW,EAEtE,EAAI,UAAU,CAAE,EAAI,oBAAoB,CAAE,EAAW,aAAa,EAClE,EAAI,UAAU,CAAE,EAAI,oBAAoB,CAAE,EAAW,KAAK,CAAE,EAAI,WAAW,EAI3E,EAAW,WAAW,CAAQ,EAAI,aAAa,GAC/C,EAAW,gBAAgB,CAAG,EAAI,aAAa,GAE/C,EAAI,WAAW,CAAE,EAAI,UAAU,CAAE,EAAW,WAAW,EACvD,EAAI,UAAU,CAAE,EAAI,UAAU,CAAE,EAAG,EAAI,GAAG,CAAE,GAAI,GAAI,EAAG,EAAI,GAAG,CAAE,EAAI,aAAa,CAAE,MACnF,EAAI,aAAa,CAAE,EAAI,UAAU,CAAE,EAAI,cAAc,CAAE,EAAI,aAAa,EACxE,EAAI,aAAa,CAAE,EAAI,UAAU,CAAE,EAAI,cAAc,CAAE,EAAI,aAAa,EACxE,EAAI,aAAa,CAAE,EAAI,UAAU,CAAE,EAAI,kBAAkB,CAAE,EAAI,OAAO,EACtE,EAAI,aAAa,CAAE,EAAI,UAAU,CAAE,EAAI,kBAAkB,CAAE,EAAI,OAAO,EAEtE,EAAI,WAAW,CAAE,EAAI,UAAU,CAAE,EAAW,gBAAgB,EAC5D,EAAI,UAAU,CAAE,EAAI,UAAU,CAAE,EAAG,EAAI,IAAI,CAAE,GAAI,GAAI,EAAG,EAAI,IAAI,CAAE,EAAI,aAAa,CAAE,MACrF,EAAI,aAAa,CAAE,EAAI,UAAU,CAAE,EAAI,cAAc,CAAE,EAAI,aAAa,EACxE,EAAI,aAAa,CAAE,EAAI,UAAU,CAAE,EAAI,cAAc,CAAE,EAAI,aAAa,EACxE,EAAI,aAAa,CAAE,EAAI,UAAU,CAAE,EAAI,kBAAkB,CAAE,EAAI,OAAO,EACtE,EAAI,aAAa,CAAE,EAAI,UAAU,CAAE,EAAI,kBAAkB,CAAE,EAAI,OAAO,EAEjE,AAA0D,GAA1D,EAAI,YAAY,CAAE,EAAI,8BAA8B,GAExD,EAAW,gBAAgB,CAAG,CAAA,EAC9B,EAAW,OAAO,CAAG,EAAe,GAAM,YAAY,CAAE,SAAa,CAAE,KAIvE,EAAW,gBAAgB,CAAG,CAAA,EAC9B,EAAW,OAAO,CAAG,EAAe,GAAM,YAAY,CAAE,sBAA0B,CAAE,IAIrF,EAAW,UAAU,CAAG,CAAC,EACzB,EAAW,QAAQ,CAAG,CAAC,EAEvB,EAAW,UAAU,CAAC,MAAM,CAAS,EAAI,iBAAiB,CAAG,EAAW,OAAO,CAAE,YACjF,EAAW,UAAU,CAAC,EAAE,CAAa,EAAI,iBAAiB,CAAG,EAAW,OAAO,CAAE,MAEjF,EAAW,QAAQ,CAAC,UAAU,CAAO,EAAI,kBAAkB,CAAE,EAAW,OAAO,CAAE,cACjF,EAAW,QAAQ,CAAC,GAAG,CAAc,EAAI,kBAAkB,CAAE,EAAW,OAAO,CAAE,OACjF,EAAW,QAAQ,CAAC,YAAY,CAAK,EAAI,kBAAkB,CAAE,EAAW,OAAO,CAAE,gBACjF,EAAW,QAAQ,CAAC,OAAO,CAAU,EAAI,kBAAkB,CAAE,EAAW,OAAO,CAAE,WACjF,EAAW,QAAQ,CAAC,KAAK,CAAY,EAAI,kBAAkB,CAAE,EAAW,OAAO,CAAE,SACjF,EAAW,QAAQ,CAAC,KAAK,CAAY,EAAI,kBAAkB,CAAE,EAAW,OAAO,CAAE,SACjF,EAAW,QAAQ,CAAC,QAAQ,CAAS,EAAI,kBAAkB,CAAE,EAAW,OAAO,CAAE,YACjF,EAAW,QAAQ,CAAC,cAAc,CAAG,EAAI,kBAAkB,CAAE,EAAW,OAAO,CAAE,iBAElF,EAYA,IAAI,CAAC,MAAM,CAAG,SAAW,CAAK,CAAE,CAAM,CAAE,CAAa,CAAE,CAAc,EAEpE,IA0CI,EAAG,EAAG,EAAI,EAAO,EA1CjB,EAAS,EAAM,aAAa,CAC/B,EAAU,EAAO,MAAM,CAExB,GAAO,GAEP,IAAI,EAAe,IAAI,GAAM,OAAO,CAEhC,EAAY,EAAiB,EAChC,EAAoB,AAAgB,GAAhB,EACpB,EAAqB,AAAiB,GAAjB,EAElB,EAAO,GAAK,EACf,EAAQ,IAAI,GAAM,OAAO,CAAE,EAAO,EAAW,GAE1C,EAAiB,IAAI,GAAM,OAAO,CAAE,EAAG,EAAG,GAC7C,EAAuB,IAAI,GAAM,OAAO,CAAE,EAAG,GAE1C,EAAW,EAAW,QAAQ,CACjC,EAAa,EAAW,UAAU,CA0BnC,IAtBA,EAAI,UAAU,CAAE,EAAW,OAAO,EAElC,EAAI,uBAAuB,CAAE,EAAW,UAAU,CAAC,MAAM,EACzD,EAAI,uBAAuB,CAAE,EAAW,UAAU,CAAC,EAAE,EAKrD,EAAI,SAAS,CAAE,EAAS,YAAY,CAAE,GACtC,EAAI,SAAS,CAAE,EAAS,GAAG,CAAE,GAE7B,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAW,YAAY,EACzD,EAAI,mBAAmB,CAAE,EAAW,MAAM,CAAE,EAAG,EAAI,KAAK,CAAE,CAAA,EAAO,GAAO,GACxE,EAAI,mBAAmB,CAAE,EAAW,EAAE,CAAE,EAAG,EAAI,KAAK,CAAE,CAAA,EAAO,GAAO,GAEpE,EAAI,UAAU,CAAE,EAAI,oBAAoB,CAAE,EAAW,aAAa,EAElE,EAAI,OAAO,CAAE,EAAI,SAAS,EAC1B,EAAI,SAAS,CAAE,CAAA,GAIT,EAAI,EAAG,EAAI,EAAS,IAuBzB,GArBA,EAAO,GAAK,EACZ,EAAM,GAAG,CAAE,EAAO,EAAW,GAI7B,EAAQ,CAAM,CAAE,EAAG,CAEnB,EAAa,GAAG,CAAE,EAAM,WAAW,CAAC,QAAQ,CAAC,GAAG,CAAE,EAAM,WAAW,CAAC,QAAQ,CAAC,GAAG,CAAE,EAAM,WAAW,CAAC,QAAQ,CAAC,GAAG,EAEhH,EAAa,YAAY,CAAE,EAAO,kBAAkB,EACpD,EAAa,eAAe,CAAE,EAAO,gBAAgB,EAIrD,EAAe,IAAI,CAAE,GAErB,EAAqB,CAAC,CAAG,EAAe,CAAC,CAAG,EAAoB,EAChE,EAAqB,CAAC,CAAG,EAAe,CAAC,CAAG,EAAqB,EAI5D,EAAW,gBAAgB,EAC/B,EAAqB,CAAC,CAAG,GACzB,EAAqB,CAAC,CAAG,GACzB,EAAqB,CAAC,CAAG,GACzB,EAAqB,CAAC,CAAG,EAyDzB,IAAM,AArDN,EAAI,aAAa,CAAE,EAAI,QAAQ,EAC/B,EAAI,WAAW,CAAE,EAAI,UAAU,CAAE,EAAW,WAAW,EACvD,EAAI,cAAc,CAAE,EAAI,UAAU,CAAE,EAAG,EAAI,GAAG,CAAE,EAAqB,CAAC,CAAG,EAAG,EAAqB,CAAC,CAAG,EAAG,GAAI,GAAI,GAKhH,EAAI,SAAS,CAAE,EAAS,UAAU,CAAE,GACpC,EAAI,SAAS,CAAE,EAAS,KAAK,CAAE,EAAM,CAAC,CAAE,EAAM,CAAC,EAC/C,EAAI,SAAS,CAAE,EAAS,cAAc,CAAE,EAAe,CAAC,CAAE,EAAe,CAAC,CAAE,EAAe,CAAC,EAE5F,EAAI,OAAO,CAAE,EAAI,KAAK,EACtB,EAAI,MAAM,CAAE,EAAI,UAAU,EAE1B,EAAI,YAAY,CAAE,EAAI,SAAS,CAAE,EAAG,EAAI,cAAc,CAAE,GAKxD,EAAI,aAAa,CAAE,EAAI,QAAQ,EAC/B,EAAI,WAAW,CAAE,EAAI,UAAU,CAAE,EAAW,gBAAgB,EAC5D,EAAI,cAAc,CAAE,EAAI,UAAU,CAAE,EAAG,EAAI,IAAI,CAAE,EAAqB,CAAC,CAAG,EAAG,EAAqB,CAAC,CAAG,EAAG,GAAI,GAAI,GAKjH,EAAI,SAAS,CAAE,EAAS,UAAU,CAAE,GACpC,EAAI,OAAO,CAAE,EAAI,UAAU,EAE3B,EAAI,aAAa,CAAE,EAAI,QAAQ,EAC/B,EAAI,WAAW,CAAE,EAAI,UAAU,CAAE,EAAW,WAAW,EACvD,EAAI,YAAY,CAAE,EAAI,SAAS,CAAE,EAAG,EAAI,cAAc,CAAE,GAKxD,EAAM,cAAc,CAAC,IAAI,CAAE,GAEtB,EAAM,oBAAoB,CAE9B,EAAM,oBAAoB,CAAE,GAI5B,EAAM,gBAAgB,GAMvB,EAAI,SAAS,CAAE,EAAS,UAAU,CAAE,GACpC,EAAI,MAAM,CAAE,EAAI,KAAK,EAEf,EAAI,EAAG,EAAK,EAAM,UAAU,CAAC,MAAM,CAAE,EAAI,EAAI,IAI7C,AAFL,CAAA,EAAS,EAAM,UAAU,CAAE,EAAG,AAAH,EAEf,OAAO,CAAG,MAAS,EAAO,KAAK,CAAG,OAE7C,EAAe,CAAC,CAAG,EAAO,CAAC,CAC3B,EAAe,CAAC,CAAG,EAAO,CAAC,CAC3B,EAAe,CAAC,CAAG,EAAO,CAAC,CAE3B,EAAO,EAAO,IAAI,CAAG,EAAO,KAAK,CAAG,EAEpC,EAAM,CAAC,CAAG,EAAO,EACjB,EAAM,CAAC,CAAG,EAEV,EAAI,SAAS,CAAE,EAAS,cAAc,CAAE,EAAe,CAAC,CAAE,EAAe,CAAC,CAAE,EAAe,CAAC,EAC5F,EAAI,SAAS,CAAE,EAAS,KAAK,CAAE,EAAM,CAAC,CAAE,EAAM,CAAC,EAC/C,EAAI,SAAS,CAAE,EAAS,QAAQ,CAAE,EAAO,QAAQ,EAEjD,EAAI,SAAS,CAAE,EAAS,OAAO,CAAE,EAAO,OAAO,EAC/C,EAAI,SAAS,CAAE,EAAS,KAAK,CAAE,EAAO,KAAK,CAAC,CAAC,CAAE,EAAO,KAAK,CAAC,CAAC,CAAE,EAAO,KAAK,CAAC,CAAC,EAE7E,EAAU,WAAW,CAAE,EAAO,QAAQ,CAAE,EAAO,aAAa,CAAE,EAAO,QAAQ,CAAE,EAAO,QAAQ,EAC9F,EAAU,UAAU,CAAE,EAAO,OAAO,CAAE,GAEtC,EAAI,YAAY,CAAE,EAAI,SAAS,CAAE,EAAG,EAAI,cAAc,CAAE,IAY5D,EAAI,MAAM,CAAE,EAAI,SAAS,EACzB,EAAI,MAAM,CAAE,EAAI,UAAU,EAC1B,EAAI,SAAS,CAAE,CAAA,GAEhB,CA0BD,EAKA,GAAM,eAAe,CAAG,WAEvB,IAAI,EACJ,EACA,EAAgB,EAAqB,EAAoB,EAEzD,EAAW,IAAI,GAAM,OAAO,CAC5B,EAAoB,IAAI,GAAM,OAAO,CAErC,EAAO,IAAI,GAAM,OAAO,CACxB,EAAO,IAAI,GAAM,OAAO,CAExB,EAAkB,IAAI,GAAM,OAAO,AAEnC,CAAA,IAAI,CAAC,IAAI,CAAG,SAAW,CAAQ,EAE9B,EAAM,EAAS,OAAO,CACtB,EAAY,EAEZ,IAAI,EAAc,GAAM,SAAS,CAAE,SAAa,CAC5C,EAAgB,GAAM,aAAa,CAAC,KAAK,CAAE,EAAY,QAAQ,EAEnE,EAAiB,IAAI,GAAM,cAAc,CAAE,CAAE,eAAgB,EAAY,cAAc,CAAE,aAAc,EAAY,YAAY,CAAE,SAAU,CAAc,GACzJ,EAAsB,IAAI,GAAM,cAAc,CAAE,CAAE,eAAgB,EAAY,cAAc,CAAE,aAAc,EAAY,YAAY,CAAE,SAAU,EAAe,aAAc,CAAA,CAAK,GAClL,EAAqB,IAAI,GAAM,cAAc,CAAE,CAAE,eAAgB,EAAY,cAAc,CAAE,aAAc,EAAY,YAAY,CAAE,SAAU,EAAe,SAAU,CAAA,CAAK,GAC7K,EAA0B,IAAI,GAAM,cAAc,CAAE,CAAE,eAAgB,EAAY,cAAc,CAAE,aAAc,EAAY,YAAY,CAAE,SAAU,EAAe,aAAc,CAAA,EAAM,SAAU,CAAA,CAAK,GAEtM,EAAe,WAAW,CAAG,CAAA,EAC7B,EAAoB,WAAW,CAAG,CAAA,EAClC,EAAmB,WAAW,CAAG,CAAA,EACjC,EAAwB,WAAW,CAAG,CAAA,CAEvC,EAEA,IAAI,CAAC,MAAM,CAAG,SAAW,CAAK,CAAE,CAAM,EAE5B,EAAU,gBAAgB,EAAI,EAAU,mBAAmB,EAEpE,IAAI,CAAC,MAAM,CAAE,EAAO,EAErB,EAEA,IAAI,CAAC,MAAM,CAAG,SAAW,CAAK,CAAE,CAAM,EAErC,IAAI,EAAG,EAAI,EAAG,EAAI,EAElB,EAAW,EAAc,EAChB,EAAQ,EACjB,EAAa,EAAQ,EACrB,EAEA,EAAS,EAAE,CACX,EAAI,EA4BJ,IAAM,AAtBN,EAAI,UAAU,CAAE,EAAG,EAAG,EAAG,GACzB,EAAI,OAAO,CAAE,EAAI,KAAK,EAEtB,EAAI,MAAM,CAAE,EAAI,SAAS,EACzB,EAAI,SAAS,CAAE,EAAI,GAAG,EAEjB,EAAU,iBAAiB,GAAK,GAAM,aAAa,CAEvD,EAAI,QAAQ,CAAE,EAAI,KAAK,EAIvB,EAAI,QAAQ,CAAE,EAAI,IAAI,EAIvB,EAAU,YAAY,CAAE,CAAA,GAMlB,EAAI,EAAG,EAAK,EAAM,QAAQ,CAAC,MAAM,CAAE,EAAI,EAAI,IAIhD,GAAO,AAFP,CAAA,EAAQ,EAAM,QAAQ,CAAE,EAAG,AAAH,EAEX,UAAU,EAEvB,GAAO,aAAiB,GAAM,gBAAgB,EAAM,EAAM,aAAa,CAEtE,IAAM,EAAI,EAAG,EAAI,EAAM,kBAAkB,CAAE,IAAO,CAIjD,GAAO,EAAM,kBAAkB,CAAE,EAAG,CAmBnC,EAAe,EAAM,kBAAkB,CAAE,EAAG,KAnBN,CAGtC,AADA,CAAA,EAAe,AA6PpB,SAA6B,CAAK,CAAE,CAAO,EAE1C,IAAI,EAAe,IAAI,GAAM,gBAAgB,AAE7C,CAAA,EAAa,SAAS,CAAG,CAAA,EAEzB,EAAa,UAAU,CAAG,CAAA,EAC1B,EAAa,UAAU,CAAG,CAAA,EAE1B,EAAa,gBAAgB,CAAG,EAAM,gBAAgB,CACtD,EAAa,eAAe,CAAG,EAAM,eAAe,CAEpD,EAAa,gBAAgB,CAAG,EAAM,gBAAgB,CACtD,EAAa,iBAAiB,CAAG,EAAM,iBAAiB,CACxD,EAAa,kBAAkB,CAAG,EAAM,kBAAkB,CAC1D,EAAa,eAAe,CAAG,EAAM,eAAe,CAEpD,EAAa,mBAAmB,CAAG,EAAM,mBAAmB,CAE5D,EAAa,cAAc,CAAG,EAAM,cAAc,CAElD,EAAa,UAAU,CAAG,EAAM,iBAAiB,CAAE,EAAS,CAC5D,EAAa,cAAc,CAAG,EAAM,kBAAkB,CAAE,EAAS,CACjE,EAAa,eAAe,CAAG,EAAM,mBAAmB,CAAE,EAAS,CAEnE,EAAa,WAAW,CAAG,EAAE,CAC7B,EAAa,aAAa,CAAG,EAAE,CAK/B,IAAM,IAHF,EAAc,EAAa,WAAW,CACzC,EAAgB,EAAa,aAAa,CAEjC,EAAI,EAAG,EAAI,EAAG,IAEvB,CAAW,CAAE,EAAG,CAAG,IAAI,GAAM,OAAO,CACpC,CAAa,CAAE,EAAG,CAAG,IAAI,GAAM,OAAO,CANvC,IAUI,EAAQ,EAAM,kBAAkB,CAAE,EAAS,CAC3C,EAAO,EAAM,iBAAiB,CAAE,EAAS,CAY7C,OAVA,CAAa,CAAE,EAAG,CAAC,GAAG,CAAE,GAAI,GAAI,GAChC,CAAa,CAAE,EAAG,CAAC,GAAG,CAAG,EAAG,GAAI,GAChC,CAAa,CAAE,EAAG,CAAC,GAAG,CAAE,GAAK,EAAG,GAChC,CAAa,CAAE,EAAG,CAAC,GAAG,CAAG,EAAI,EAAG,GAEhC,CAAa,CAAE,EAAG,CAAC,GAAG,CAAE,GAAI,GAAI,GAChC,CAAa,CAAE,EAAG,CAAC,GAAG,CAAG,EAAG,GAAI,GAChC,CAAa,CAAE,EAAG,CAAC,GAAG,CAAE,GAAK,EAAG,GAChC,CAAa,CAAE,EAAG,CAAC,GAAG,CAAG,EAAI,EAAG,GAEzB,CAER,EAlTwC,EAAO,EAA1C,EACa,cAAc,CAAG,EAE9B,IAAI,EAAO,IAAI,GAAM,SAAS,AAC9B,CAAA,EAAK,QAAQ,CAAG,EAAM,mBAAmB,CAEzC,EAAK,GAAG,CAAE,GACV,EAAK,GAAG,CAAE,EAAa,MAAM,EAE7B,EAAO,GAAG,CAAE,GAEZ,EAAM,kBAAkB,CAAE,EAAG,CAAG,EAEhC,QAAQ,GAAG,CAAE,uBAAwB,EAEtC,CAMA,AAiSJ,CAAA,SAA6B,CAAK,CAAE,CAAO,EAE1C,IAAI,EAAe,EAAM,kBAAkB,CAAE,EAAS,CAEtD,EAAa,QAAQ,CAAC,IAAI,CAAE,EAAM,QAAQ,EAC1C,EAAa,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAE,EAAM,MAAM,CAAC,QAAQ,EACxD,EAAa,MAAM,CAAE,EAAa,MAAM,EAExC,EAAa,mBAAmB,CAAG,EAAM,mBAAmB,CAC5D,EAAa,cAAc,CAAG,EAAM,cAAc,CAElD,EAAa,UAAU,CAAG,EAAM,iBAAiB,CAAE,EAAS,CAE5D,IAAI,EAAQ,EAAM,kBAAkB,CAAE,EAAS,CAC3C,EAAO,EAAM,iBAAiB,CAAE,EAAS,CAEzC,EAAgB,EAAa,aAAa,AAE9C,CAAA,CAAa,CAAE,EAAG,CAAC,CAAC,CAAG,EACvB,CAAa,CAAE,EAAG,CAAC,CAAC,CAAG,EACvB,CAAa,CAAE,EAAG,CAAC,CAAC,CAAG,EACvB,CAAa,CAAE,EAAG,CAAC,CAAC,CAAG,EAEvB,CAAa,CAAE,EAAG,CAAC,CAAC,CAAG,EACvB,CAAa,CAAE,EAAG,CAAC,CAAC,CAAG,EACvB,CAAa,CAAE,EAAG,CAAC,CAAC,CAAG,EACvB,CAAa,CAAE,EAAG,CAAC,CAAC,CAAG,CAExB,CAAA,EA7TwB,EAAO,GAE3B,CAAM,CAAE,EAAG,CAAG,EACd,GAED,MAIA,CAAM,CAAE,EAAG,CAAG,EACd,IAQF,IAAM,EAAI,EAAG,EAAK,EAAO,MAAM,CAAE,EAAI,EAAI,IAAO,CAI/C,GAAK,CAAE,AAFP,CAAA,EAAQ,CAAM,CAAE,EAAG,AAAH,EAEH,SAAS,CAAG,CAExB,IAsVyB,EAvYpB,EAmKF,EAAgB,EAAa,EAlH5B,EAAe,GAAM,YAAY,AAEhC,CAAA,EAAU,aAAa,GAAK,GAAM,gBAAgB,EAEtD,CAAA,EAAe,GAAM,aAAa,AAAb,EAItB,IAAI,EAAO,CAAE,UAAW,EAAc,UAAW,EAAc,OAAQ,GAAM,UAAU,AAAC,CAExF,CAAA,EAAM,SAAS,CAAG,IAAI,GAAM,iBAAiB,CAAE,EAAM,cAAc,CAAE,EAAM,eAAe,CAAE,GAC5F,EAAM,aAAa,CAAG,IAAI,GAAM,OAAO,CAAE,EAAM,cAAc,CAAE,EAAM,eAAe,EAEpF,EAAM,YAAY,CAAG,IAAI,GAAM,OAAO,AAEvC,CAEA,GAAK,CAAE,EAAM,YAAY,CAAG,CAE3B,GAAK,aAAiB,GAAM,SAAS,CAEpC,EAAM,YAAY,CAAG,IAAI,GAAM,iBAAiB,CAAE,EAAM,eAAe,CAAE,EAAM,cAAc,CAAG,EAAM,eAAe,CAAE,EAAM,gBAAgB,CAAE,EAAM,eAAe,OAE9J,GAAK,aAAiB,GAAM,gBAAgB,CAElD,EAAM,YAAY,CAAG,IAAI,GAAM,kBAAkB,CAAE,EAAM,gBAAgB,CAAE,EAAM,iBAAiB,CAAE,EAAM,eAAe,CAAE,EAAM,kBAAkB,CAAE,EAAM,gBAAgB,CAAE,EAAM,eAAe,MAE5L,CAEN,QAAQ,KAAK,CAAE,qCACf,QAED,CAEA,EAAM,GAAG,CAAE,EAAM,YAAY,EAExB,EAAU,eAAe,EAAG,EAAM,iBAAiB,EAEzD,CAqDA,IAAM,AAnDD,EAAM,mBAAmB,EAAI,CAAE,EAAM,YAAY,GAErD,EAAM,YAAY,CAAG,IAAI,GAAM,YAAY,CAAE,EAAM,YAAY,EAC/D,EAAM,YAAY,CAAC,GAAG,CAAE,EAAM,YAAY,GAItC,EAAM,SAAS,EAAI,EAAa,cAAc,EAAI,GAEtD,AAwPH,SAA6B,CAAM,CAAE,CAAK,EAEzC,IAAI,EAAe,EAAM,YAAY,CACpC,EAAgB,EAAM,aAAa,CACnC,EAAc,EAAM,WAAW,CAEhC,EAAK,GAAG,CAAE,IAAU,IAAU,KAC9B,EAAK,GAAG,CAAE,CAAC,IAAU,CAAC,IAAU,CAAC,KAEjC,IAAM,IAAI,EAAI,EAAG,EAAI,EAAG,IAAO,CAE9B,IAAI,EAAI,CAAW,CAAE,EAAG,CAExB,EAAE,IAAI,CAAE,CAAa,CAAE,EAAG,EAC1B,GAAM,eAAe,CAAC,WAAW,CAAC,eAAe,CAAE,EAAG,GAEtD,EAAE,YAAY,CAAE,EAAa,kBAAkB,EAE1C,EAAE,CAAC,CAAG,EAAK,CAAC,EAAG,CAAA,EAAK,CAAC,CAAG,EAAE,CAAC,AAAD,EAC1B,EAAE,CAAC,CAAG,EAAK,CAAC,EAAG,CAAA,EAAK,CAAC,CAAG,EAAE,CAAC,AAAD,EAE1B,EAAE,CAAC,CAAG,EAAK,CAAC,EAAG,CAAA,EAAK,CAAC,CAAG,EAAE,CAAC,AAAD,EAC1B,EAAE,CAAC,CAAG,EAAK,CAAC,EAAG,CAAA,EAAK,CAAC,CAAG,EAAE,CAAC,AAAD,EAE1B,EAAE,CAAC,CAAG,EAAK,CAAC,EAAG,CAAA,EAAK,CAAC,CAAG,EAAE,CAAC,AAAD,EAC1B,EAAE,CAAC,CAAG,EAAK,CAAC,EAAG,CAAA,EAAK,CAAC,CAAG,EAAE,CAAC,AAAD,CAEhC,CAEA,EAAa,IAAI,CAAG,EAAK,CAAC,CAC1B,EAAa,KAAK,CAAG,EAAK,CAAC,CAC3B,EAAa,GAAG,CAAG,EAAK,CAAC,CACzB,EAAa,MAAM,CAAG,EAAK,CAAC,CAM5B,EAAa,sBAAsB,EAEpC,EAhSuB,EAAQ,GAI7B,EAAY,EAAM,SAAS,CAC3B,EAAe,EAAM,YAAY,CAGjC,AAFA,CAAA,EAAe,EAAM,YAAY,AAAZ,EAER,QAAQ,CAAC,qBAAqB,CAAE,EAAM,WAAW,EAC9D,EAAgB,qBAAqB,CAAE,EAAM,MAAM,CAAC,WAAW,EAC/D,EAAa,MAAM,CAAE,GACrB,EAAa,iBAAiB,GAE9B,EAAa,kBAAkB,CAAC,UAAU,CAAE,EAAa,WAAW,EAE/D,EAAM,YAAY,EAAG,CAAA,EAAM,YAAY,CAAC,OAAO,CAAG,EAAM,mBAAmB,AAAnB,EACxD,EAAM,mBAAmB,EAAG,EAAM,YAAY,CAAC,MAAM,GAI1D,EAAa,GAAG,CAAE,GAAK,EAAK,EAAK,GAC3B,EAAK,GAAK,EAAK,GACf,EAAK,EAAK,GAAK,GACf,EAAK,EAAK,EAAK,GAErB,EAAa,QAAQ,CAAE,EAAa,gBAAgB,EACpD,EAAa,QAAQ,CAAE,EAAa,kBAAkB,EAItD,EAAkB,gBAAgB,CAAE,EAAa,gBAAgB,CAAE,EAAa,kBAAkB,EAClG,EAAS,aAAa,CAAE,GAIxB,EAAU,eAAe,CAAE,GAC3B,EAAU,KAAK,GAMT,EAAI,EAAG,EAAK,AAFlB,CAAA,EAAa,EAAM,cAAc,AAAd,EAEU,MAAM,CAAE,EAAI,EAAI,IAG5C,EAAS,AADT,CAAA,EAAc,CAAU,CAAE,EAAG,AAAH,EACL,MAAM,CAE3B,EAAY,MAAM,CAAG,CAAA,EAEhB,EAAO,OAAO,EAAI,EAAO,UAAU,EAElC,CAAA,CAAI,CAAA,aAAkB,GAAM,IAAI,EAAI,aAAkB,GAAM,cAAc,AAAd,GAAoB,CAAI,EAAO,aAAa,EAAM,EAAS,gBAAgB,CAAE,EAAA,IAE7I,EAAO,gBAAgB,CAAC,gBAAgB,CAAE,EAAa,kBAAkB,CAAE,EAAO,WAAW,EAE7F,EAAY,MAAM,CAAG,CAAA,GAYxB,IAAM,EAAI,EAAG,EAAK,EAAW,MAAM,CAAE,EAAI,EAAI,IAIvC,AAFL,CAAA,EAAc,CAAU,CAAE,EAAG,AAAH,EAET,MAAM,GAEtB,EAAS,EAAY,MAAM,CAC3B,EAAS,EAAY,MAAM,CAW3B,EAkNI,CAFoB,EAhNY,GAkNzB,QAAQ,YAAY,GAAM,gBAAgB,CACrD,EAAO,QAAQ,CAAC,SAAS,CAAE,EAAG,CAC9B,EAAO,QAAQ,CAlNf,EAAc,EAAO,QAAQ,CAAC,YAAY,CAAC,MAAM,CAAG,GAAK,EAAe,YAAY,CACpF,EAAc,aAAkB,GAAM,WAAW,EAAI,EAAe,QAAQ,CAI3E,EAFI,EAAO,mBAAmB,CAEnB,EAAO,mBAAmB,CAE1B,EAEA,EAAc,EAA0B,EAExC,EAEA,EAIA,EAIP,aAAkB,GAAM,cAAc,CAE1C,EAAU,kBAAkB,CAAE,EAAc,EAAM,QAAQ,CApPxD,KAoP+D,EAAU,EAAQ,GAInF,EAAU,YAAY,CAAE,EAAc,EAAM,QAAQ,CAxPlD,KAwPyD,EAAU,EAAQ,IAYhF,IAAM,EAAI,EAAG,EAAK,AAFlB,CAAA,EAAa,EAAM,uBAAuB,AAAvB,EAEU,MAAM,CAAE,EAAI,EAAI,IAKvC,AAFL,CAAA,EAAS,AADT,CAAA,EAAc,CAAU,CAAE,EAAG,AAAH,EACL,MAAM,AAAN,EAET,OAAO,EAAI,EAAO,UAAU,GAEvC,EAAO,gBAAgB,CAAC,gBAAgB,CAAE,EAAa,kBAAkB,CAAE,EAAO,WAAW,EAE7F,EAAU,qBAAqB,CAAE,EAAc,EAAM,QAAQ,CA7Q1D,KA6QiE,EAAgB,GAMvF,CAIA,IAAI,EAAa,EAAU,aAAa,GACxC,EAAa,EAAU,aAAa,GAEpC,EAAI,UAAU,CAAE,EAAW,CAAC,CAAE,EAAW,CAAC,CAAE,EAAW,CAAC,CAAE,GAC1D,EAAI,MAAM,CAAE,EAAI,KAAK,EAEhB,EAAU,iBAAiB,GAAK,GAAM,aAAa,EAEvD,EAAI,QAAQ,CAAE,EAAI,IAAI,CAIxB,CAgJD,EAEA,GAAM,eAAe,CAAC,WAAW,CAAG,IAAI,GAAM,SAAS,CAMvD,GAAM,YAAY,CAAG,WAEpB,IAAI,EAAK,EAAW,EAAY,EAAU,CAAC,EA2R3C,SAAS,EAAoB,CAAC,CAAE,CAAC,SAEhC,AAAK,EAAE,CAAC,GAAK,EAAE,CAAC,CAER,EAAE,CAAC,CAAG,EAAE,CAAC,CAIT,EAAE,EAAE,CAAG,EAAE,EAAE,AAIpB,CArSA,IAAI,CAAC,IAAI,CAAG,SAAW,CAAQ,EAE9B,EAAM,EAAS,OAAO,CACtB,EAAY,EAEZ,EAAa,EAAS,YAAY,GAElC,EAAQ,QAAQ,CAAG,IAAI,aAAc,IACrC,EAAQ,KAAK,CAAM,IAAI,YAAa,GAEpC,IAuPwB,EAEpB,EAEA,EACA,EAEA,EA9PA,EAAI,CAER,CAAA,EAAQ,QAAQ,CAAE,IAAK,CAAG,GAAI,EAAQ,QAAQ,CAAE,IAAK,CAAG,GACxD,EAAQ,QAAQ,CAAE,IAAK,CAAG,EAAI,EAAQ,QAAQ,CAAE,IAAK,CAAG,EAExD,EAAQ,QAAQ,CAAE,IAAK,CAAG,EAAI,EAAQ,QAAQ,CAAE,IAAK,CAAG,GACxD,EAAQ,QAAQ,CAAE,IAAK,CAAG,EAAI,EAAQ,QAAQ,CAAE,IAAK,CAAG,EAExD,EAAQ,QAAQ,CAAE,IAAK,CAAG,EAAI,EAAQ,QAAQ,CAAE,IAAK,CAAG,EACxD,EAAQ,QAAQ,CAAE,IAAK,CAAG,EAAI,EAAQ,QAAQ,CAAE,IAAK,CAAG,EAExD,EAAQ,QAAQ,CAAE,IAAK,CAAG,GAAI,EAAQ,QAAQ,CAAE,IAAK,CAAG,EACxD,EAAQ,QAAQ,CAAE,IAAK,CAAG,EAAI,EAAQ,QAAQ,CAAE,IAAK,CAAG,EAExD,EAAI,EAEJ,EAAQ,KAAK,CAAE,IAAK,CAAG,EAAG,EAAQ,KAAK,CAAE,IAAK,CAAG,EAAG,EAAQ,KAAK,CAAE,IAAK,CAAG,EAC3E,EAAQ,KAAK,CAAE,IAAK,CAAG,EAAG,EAAQ,KAAK,CAAE,IAAK,CAAG,EAAG,EAAQ,KAAK,CAAE,IAAK,CAAG,EAE3E,EAAQ,YAAY,CAAI,EAAI,YAAY,GACxC,EAAQ,aAAa,CAAG,EAAI,YAAY,GAExC,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAQ,YAAY,EACtD,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAQ,QAAQ,CAAE,EAAI,WAAW,EAEnE,EAAI,UAAU,CAAE,EAAI,oBAAoB,CAAE,EAAQ,aAAa,EAC/D,EAAI,UAAU,CAAE,EAAI,oBAAoB,CAAE,EAAQ,KAAK,CAAE,EAAI,WAAW,EAExE,EAAQ,OAAO,EA2NS,EA3NS,GAAM,YAAY,CAAE,MAAU,CA6N3D,EAAU,EAAI,aAAa,GAE3B,EAAiB,EAAI,YAAY,CAAE,EAAI,eAAe,EACtD,EAAe,EAAI,YAAY,CAAE,EAAI,aAAa,EAElD,EAAS,aAlOoD,EAkOzB,YAExC,EAAI,YAAY,CAAE,EAAgB,EAAS,EAAO,cAAc,EAChE,EAAI,YAAY,CAAE,EAAc,EAAS,EAAO,YAAY,EAE5D,EAAI,aAAa,CAAE,GACnB,EAAI,aAAa,CAAE,GAEnB,EAAI,YAAY,CAAE,EAAS,GAC3B,EAAI,YAAY,CAAE,EAAS,GAE3B,EAAI,WAAW,CAAE,GAEV,GA7OP,EAAQ,UAAU,CAAG,CAAC,EACtB,EAAQ,QAAQ,CAAG,CAAC,EAEpB,EAAQ,UAAU,CAAC,QAAQ,CAAa,EAAI,iBAAiB,CAAG,EAAQ,OAAO,CAAE,YACjF,EAAQ,UAAU,CAAC,EAAE,CAAmB,EAAI,iBAAiB,CAAG,EAAQ,OAAO,CAAE,MAEjF,EAAQ,QAAQ,CAAC,QAAQ,CAAe,EAAI,kBAAkB,CAAE,EAAQ,OAAO,CAAE,YACjF,EAAQ,QAAQ,CAAC,OAAO,CAAgB,EAAI,kBAAkB,CAAE,EAAQ,OAAO,CAAE,WAEjF,EAAQ,QAAQ,CAAC,QAAQ,CAAe,EAAI,kBAAkB,CAAE,EAAQ,OAAO,CAAE,YACjF,EAAQ,QAAQ,CAAC,KAAK,CAAkB,EAAI,kBAAkB,CAAE,EAAQ,OAAO,CAAE,SACjF,EAAQ,QAAQ,CAAC,SAAS,CAAc,EAAI,kBAAkB,CAAE,EAAQ,OAAO,CAAE,aAEjF,EAAQ,QAAQ,CAAC,KAAK,CAAkB,EAAI,kBAAkB,CAAE,EAAQ,OAAO,CAAE,SACjF,EAAQ,QAAQ,CAAC,GAAG,CAAoB,EAAI,kBAAkB,CAAE,EAAQ,OAAO,CAAE,OACjF,EAAQ,QAAQ,CAAC,OAAO,CAAgB,EAAI,kBAAkB,CAAE,EAAQ,OAAO,CAAE,WAEjF,EAAQ,QAAQ,CAAC,oBAAoB,CAAG,EAAI,kBAAkB,CAAE,EAAQ,OAAO,CAAE,wBACjF,EAAQ,QAAQ,CAAC,eAAe,CAAQ,EAAI,kBAAkB,CAAE,EAAQ,OAAO,CAAE,mBACjF,EAAQ,QAAQ,CAAC,cAAc,CAAS,EAAI,kBAAkB,CAAE,EAAQ,OAAO,CAAE,kBACjF,EAAQ,QAAQ,CAAC,eAAe,CAAQ,EAAI,kBAAkB,CAAE,EAAQ,OAAO,CAAE,mBACjF,EAAQ,QAAQ,CAAC,gBAAgB,CAAO,EAAI,kBAAkB,CAAE,EAAQ,OAAO,CAAE,oBAEjF,EAAQ,QAAQ,CAAC,OAAO,CAAU,EAAI,kBAAkB,CAAE,EAAQ,OAAO,CAAE,WAC3E,EAAQ,QAAQ,CAAC,UAAU,CAAO,EAAI,kBAAkB,CAAE,EAAQ,OAAO,CAAE,cAC3E,EAAQ,QAAQ,CAAC,OAAO,CAAU,EAAI,kBAAkB,CAAE,EAAQ,OAAO,CAAE,WAC3E,EAAQ,QAAQ,CAAC,MAAM,CAAU,EAAI,kBAAkB,CAAE,EAAQ,OAAO,CAAE,UAC1E,EAAQ,QAAQ,CAAC,QAAQ,CAAU,EAAI,kBAAkB,CAAE,EAAQ,OAAO,CAAE,YAE5E,EAAQ,QAAQ,CAAC,SAAS,CAAU,EAAI,kBAAkB,CAAE,EAAQ,OAAO,CAAE,YAE9E,EAEA,IAAI,CAAC,MAAM,CAAG,SAAW,CAAK,CAAE,CAAM,CAAE,CAAa,CAAE,CAAc,EAEpE,IAAI,EAAU,EAAM,cAAc,CACjC,EAAW,EAAQ,MAAM,CAE1B,GAAO,GAEP,IAAI,EAAa,EAAQ,UAAU,CAClC,EAAW,EAAQ,QAAQ,CAExB,EAAY,EAAiB,EAE7B,EAAoB,AAAgB,GAAhB,EACvB,EAAqB,AAAiB,GAAjB,EAItB,EAAI,UAAU,CAAE,EAAQ,OAAO,EAE/B,EAAI,uBAAuB,CAAE,EAAW,QAAQ,EAChD,EAAI,uBAAuB,CAAE,EAAW,EAAE,EAE1C,EAAI,OAAO,CAAE,EAAI,SAAS,EAC1B,EAAI,MAAM,CAAE,EAAI,KAAK,EAErB,EAAI,UAAU,CAAE,EAAI,YAAY,CAAE,EAAQ,YAAY,EACtD,EAAI,mBAAmB,CAAE,EAAW,QAAQ,CAAE,EAAG,EAAI,KAAK,CAAE,CAAA,EAAO,GAAO,GAC1E,EAAI,mBAAmB,CAAE,EAAW,EAAE,CAAE,EAAG,EAAI,KAAK,CAAE,CAAA,EAAO,GAAO,GAEpE,EAAI,UAAU,CAAE,EAAI,oBAAoB,CAAE,EAAQ,aAAa,EAE/D,EAAI,gBAAgB,CAAE,EAAS,gBAAgB,CAAE,CAAA,EAAO,EAAO,gBAAgB,CAAC,QAAQ,EAExF,EAAI,aAAa,CAAE,EAAI,QAAQ,EAC/B,EAAI,SAAS,CAAE,EAAS,GAAG,CAAE,GAE7B,IAAI,EAAa,EACb,EAAe,EACf,EAAM,EAAM,GAAG,CAEd,GAEJ,EAAI,SAAS,CAAE,EAAS,QAAQ,CAAE,EAAI,KAAK,CAAC,CAAC,CAAE,EAAI,KAAK,CAAC,CAAC,CAAE,EAAI,KAAK,CAAC,CAAC,EAElE,aAAe,GAAM,GAAG,EAE5B,EAAI,SAAS,CAAE,EAAS,OAAO,CAAE,EAAI,IAAI,EACzC,EAAI,SAAS,CAAE,EAAS,MAAM,CAAE,EAAI,GAAG,EAEvC,EAAI,SAAS,CAAE,EAAS,OAAO,CAAE,GACjC,EAAa,EACb,EAAe,GAEJ,aAAe,GAAM,OAAO,GAEvC,EAAI,SAAS,CAAE,EAAS,UAAU,CAAE,EAAI,OAAO,EAE/C,EAAI,SAAS,CAAE,EAAS,OAAO,CAAE,GACjC,EAAa,EACb,EAAe,KAMhB,EAAI,SAAS,CAAE,EAAS,OAAO,CAAE,GACjC,EAAa,EACb,EAAe,GAOhB,IAAI,EAAG,EAAQ,EAA0B,EAAM,EAAS,EAAQ,EAAE,CAElE,IAAK,EAAI,EAAG,EAAI,EAAU,IAGzB,EAAW,AADX,CAAA,EAAS,CAAO,CAAE,EAAG,AAAH,EACA,QAAQ,CAEnB,EAAO,OAAO,EAAI,AAAqB,IAArB,EAAS,OAAO,GAElC,EAAS,oBAAoB,CAOnC,EAAO,CAAC,CAAG,CAAE,EAAO,QAAQ,CAAC,CAAC,EAL9B,EAAO,gBAAgB,CAAC,gBAAgB,CAAE,EAAO,kBAAkB,CAAE,EAAO,WAAW,EACvF,EAAO,CAAC,CAAG,CAAE,EAAO,gBAAgB,CAAC,QAAQ,CAAE,GAAI,GAcrD,IAJA,EAAQ,IAAI,CAAE,GAIT,EAAI,EAAG,EAAI,EAAU,IAGzB,EAAW,AADX,CAAA,EAAS,CAAO,CAAE,EAAG,AAAH,EACA,QAAQ,CAEnB,EAAO,OAAO,EAAI,AAAqB,IAArB,EAAS,OAAO,EAEpC,EAAS,GAAG,EAAI,EAAS,GAAG,CAAC,KAAK,EAAI,EAAS,GAAG,CAAC,KAAK,CAAC,KAAK,GAElE,EAAI,SAAS,CAAE,EAAS,SAAS,CAAE,EAAS,SAAS,EAEhD,AAAkC,CAAA,IAAlC,EAAS,oBAAoB,EAEjC,EAAI,SAAS,CAAE,EAAS,oBAAoB,CAAE,GAC9C,EAAI,SAAS,CACZ,EAAS,cAAc,CACrB,AAAA,CAAA,EAAS,QAAQ,CAAC,CAAC,CAAG,EAAU,gBAAgB,CAAK,CAAA,EAAuB,EAC9E,AAAE,CAAA,EAAuB,EAAO,QAAQ,CAAC,CAAC,CAAG,EAAU,gBAAiB,AAAjB,EAAuB,EAC9E,KAAK,GAAG,CAAE,EAAG,KAAK,GAAG,CAAE,EAAG,EAAO,QAAQ,CAAC,CAAC,IAG5C,CAAK,CAAE,EAAG,CAAG,EAAU,gBAAgB,CACvC,CAAK,CAAE,EAAG,CAAG,EAAU,gBAAgB,GAIvC,EAAI,SAAS,CAAE,EAAS,oBAAoB,CAAE,GAC9C,EAAI,SAAS,CAAE,EAAS,eAAe,CAAE,EAAS,eAAe,CAAG,EAAI,GACxE,EAAI,gBAAgB,CAAE,EAAS,eAAe,CAAE,CAAA,EAAO,EAAO,gBAAgB,CAAC,QAAQ,EAEvF,CAAK,CAAE,EAAG,CAAG,EACb,CAAK,CAAE,EAAG,CAAG,GAcT,KARJ,EAFI,EAAM,GAAG,EAAI,EAAS,GAAG,CAEnB,EAIA,KAMV,EAAI,SAAS,CAAE,EAAS,OAAO,CAAE,GACjC,EAAa,GAId,EAAO,EAAM,CAAA,EAAS,eAAe,CAAG,EAAiB,CAAA,EAEzD,CAAK,CAAE,EAAG,EAAI,EAAO,EAAY,EAAO,KAAK,CAAC,CAAC,CAC/C,CAAK,CAAE,EAAG,EAAI,EAAO,EAAO,KAAK,CAAC,CAAC,CAEnC,EAAI,SAAS,CAAE,EAAS,OAAO,CAAE,EAAS,OAAO,CAAC,CAAC,CAAE,EAAS,OAAO,CAAC,CAAC,EACvE,EAAI,SAAS,CAAE,EAAS,QAAQ,CAAE,EAAS,QAAQ,CAAC,CAAC,CAAE,EAAS,QAAQ,CAAC,CAAC,EAC1E,EAAI,SAAS,CAAE,EAAS,SAAS,CAAE,EAAS,SAAS,CAAC,CAAC,CAAE,EAAS,SAAS,CAAC,CAAC,EAE7E,EAAI,SAAS,CAAE,EAAS,OAAO,CAAE,EAAS,OAAO,EACjD,EAAI,SAAS,CAAE,EAAS,KAAK,CAAE,EAAS,KAAK,CAAC,CAAC,CAAE,EAAS,KAAK,CAAC,CAAC,CAAE,EAAS,KAAK,CAAC,CAAC,EAEnF,EAAI,SAAS,CAAE,EAAS,QAAQ,CAAE,EAAO,QAAQ,EACjD,EAAI,UAAU,CAAE,EAAS,KAAK,CAAE,GAEhC,EAAU,WAAW,CAAE,EAAS,QAAQ,CAAE,EAAS,aAAa,CAAE,EAAS,QAAQ,CAAE,EAAS,QAAQ,EACtG,EAAU,YAAY,CAAE,EAAS,SAAS,EAC1C,EAAU,aAAa,CAAE,EAAS,UAAU,EAC5C,EAAU,UAAU,CAAE,EAAS,GAAG,CAAE,GAEpC,EAAI,YAAY,CAAE,EAAI,SAAS,CAAE,EAAG,EAAI,cAAc,CAAE,IAQ1D,EAAI,MAAM,CAAE,EAAI,SAAS,EAE1B,CAwCD,EAKA,GAAM,eAAe,CAAG,WAEvB,IAAI,CAAC,OAAO,CAAG,CAAA,EACf,IAAI,CAAC,YAAY,CAAG,KAEpB,IAAI,EACJ,EACA,EAAgB,EAAqB,EAAoB,EAEzD,EAAW,IAAI,GAAM,OAAO,CAC5B,EAAoB,IAAI,GAAM,OAAO,AAErC,CAAA,IAAI,CAAC,IAAI,CAAG,SAAW,CAAQ,EAE9B,EAAM,EAAS,OAAO,CACtB,EAAY,EAEZ,IAAI,EAAc,GAAM,SAAS,CAAE,SAAa,CAC5C,EAAgB,GAAM,aAAa,CAAC,KAAK,CAAE,EAAY,QAAQ,EAEnE,EAAiB,IAAI,GAAM,cAAc,CAAE,CAAE,eAAgB,EAAY,cAAc,CAAE,aAAc,EAAY,YAAY,CAAE,SAAU,CAAc,GACzJ,EAAsB,IAAI,GAAM,cAAc,CAAE,CAAE,eAAgB,EAAY,cAAc,CAAE,aAAc,EAAY,YAAY,CAAE,SAAU,EAAe,aAAc,CAAA,CAAK,GAClL,EAAqB,IAAI,GAAM,cAAc,CAAE,CAAE,eAAgB,EAAY,cAAc,CAAE,aAAc,EAAY,YAAY,CAAE,SAAU,EAAe,SAAU,CAAA,CAAK,GAC7K,EAA0B,IAAI,GAAM,cAAc,CAAE,CAAE,eAAgB,EAAY,cAAc,CAAE,aAAc,EAAY,YAAY,CAAE,SAAU,EAAe,aAAc,CAAA,EAAM,SAAU,CAAA,CAAK,GAEtM,EAAe,WAAW,CAAG,CAAA,EAC7B,EAAoB,WAAW,CAAG,CAAA,EAClC,EAAmB,WAAW,CAAG,CAAA,EACjC,EAAwB,WAAW,CAAG,CAAA,CAEvC,EAEA,IAAI,CAAC,MAAM,CAAG,SAAW,CAAK,CAAE,CAAM,EAE9B,IAAI,CAAC,OAAO,EAEnB,IAAI,CAAC,MAAM,CAAE,EAAO,EAErB,EAEA,IAAI,CAAC,MAAM,CAAG,SAAW,CAAK,CAAE,CAAM,EAqCrC,IAAM,AAzBN,EAAI,UAAU,CAAE,EAAG,EAAG,EAAG,GACzB,EAAI,OAAO,CAAE,EAAI,KAAK,EAEtB,EAAU,YAAY,CAAE,CAAA,GAInB,EAAU,eAAe,EAAG,EAAM,iBAAiB,GAIxD,EAAO,kBAAkB,CAAC,UAAU,CAAE,EAAO,WAAW,EAExD,EAAkB,gBAAgB,CAAE,EAAO,gBAAgB,CAAE,EAAO,kBAAkB,EACtF,EAAS,aAAa,CAAE,GAIxB,EAAU,eAAe,CAAE,IAAI,CAAC,YAAY,EAC5C,EAAU,KAAK,GAMT,EAAI,EAAG,EAAK,AAFlB,CAAA,EAAa,EAAM,cAAc,AAAd,EAEU,MAAM,CAAE,EAAI,EAAI,IAG5C,EAAS,AADT,CAAA,EAAc,CAAU,CAAE,EAAG,AAAH,EACL,MAAM,CAE3B,EAAY,MAAM,CAAG,CAAA,EAEhB,EAAO,OAAO,EAEb,CAAA,CAAI,CAAA,aAAkB,GAAM,IAAI,EAAI,aAAkB,GAAM,cAAc,AAAd,GAAoB,CAAI,EAAO,aAAa,EAAM,EAAS,gBAAgB,CAAE,EAAA,IAE7I,EAAO,gBAAgB,CAAC,gBAAgB,CAAE,EAAO,kBAAkB,CAAE,EAAO,WAAW,EAEvF,EAAY,MAAM,CAAG,CAAA,GAYxB,IAAM,EAAI,EAAG,EAAK,EAAW,MAAM,CAAE,EAAI,EAAI,IAI5C,GAAK,AAFL,CAAA,EAAc,CAAU,CAAE,EAAG,AAAH,EAET,MAAM,CAAG,KAgFA,EAzEzB,GALA,EAAS,EAAY,MAAM,CAC3B,EAAS,EAAY,MAAM,CAItB,aAAkB,GAAM,cAAc,EAAI,CAAC,EAAO,mBAAmB,CAAG,SAE7E,CAAA,EAyEK,CAFoB,EAvEW,GAyExB,QAAQ,YAAY,GAAM,gBAAgB,CACrD,EAAO,QAAQ,CAAC,SAAS,CAAE,EAAG,CAC9B,EAAO,QAAQ,AA3EhB,GAEsB,EAAU,gBAAgB,CAAE,EAAO,QAAQ,EAEjE,EAAc,EAAO,QAAQ,CAAC,YAAY,CAAC,MAAM,CAAG,GAAK,EAAe,YAAY,CACpF,EAAc,aAAkB,GAAM,WAAW,EAAI,EAAe,QAAQ,CAI3E,EAFI,EAAO,mBAAmB,CAEnB,EAAO,mBAAmB,CAE1B,EAEA,EAAc,EAA0B,EAExC,EAEA,EAIA,EAIP,aAAkB,GAAM,cAAc,CAE1C,EAAU,kBAAkB,CAAE,EAAQ,EAAM,QAAQ,CA9FjD,KA8FwD,EAAU,EAAQ,GAI7E,EAAU,YAAY,CAAE,EAAQ,EAAM,QAAQ,CAlG3C,KAkGkD,EAAU,EAAQ,EAIzE,CAQD,IAAM,EAAI,EAAG,EAAK,AAFlB,CAAA,EAAa,EAAM,uBAAuB,AAAvB,EAEU,MAAM,CAAE,EAAI,EAAI,IAKvC,AAFL,CAAA,EAAS,AADT,CAAA,EAAc,CAAU,CAAE,EAAG,AAAH,EACL,MAAM,AAAN,EAET,OAAO,GAElB,EAAO,gBAAgB,CAAC,gBAAgB,CAAE,EAAO,kBAAkB,CAAE,EAAO,WAAW,EAEvF,EAAU,qBAAqB,CAAE,EAAQ,EAAM,QAAQ,CAvHnD,KAuH0D,EAAgB,IAQhF,IA3EI,EAAgB,EAAa,EA1DtB,EAAG,EAEL,EAAQ,EACjB,EAAa,EACb,EAiII,EAAa,EAAU,aAAa,GACxC,EAAa,EAAU,aAAa,GAEpC,EAAI,UAAU,CAAE,EAAW,CAAC,CAAE,EAAW,CAAC,CAAE,EAAW,CAAC,CAAE,GAC1D,EAAI,MAAM,CAAE,EAAI,KAAK,CAEtB,CAaD,EAOA,GAAM,YAAY,CAAG,CAEpB,uBAA0B,CAEzB,aAAc,+lCAkDd,eAAgB,8bAuCjB,EAGA,UAAa,CAEZ,aAAc,6dAgCd,eAAgB,wuBAiDjB,CAED,EAOA,GAAM,YAAY,CAAG,CAEpB,OAAU,CAET,aAAc,4gCA+Cd,eAAgB,kzBAgDjB,CAED","sources":["<anon>","lib/three.js"],"sourcesContent":["/**\n * @author mrdoob / http://mrdoob.com/\n * @author Larry Battle / http://bateru.com/news\n */ var THREE = THREE || {\n    REVISION: \"56\"\n};\nself.console = self.console || {\n    info: function() {},\n    log: function() {},\n    debug: function() {},\n    warn: function() {},\n    error: function() {}\n};\nself.Int32Array = self.Int32Array || Array;\nself.Float32Array = self.Float32Array || Array;\nString.prototype.trim = String.prototype.trim || function() {\n    return this.replace(/^\\s+|\\s+$/g, \"\");\n};\n// based on https://github.com/documentcloud/underscore/blob/bf657be243a075b5e72acc8a83e6f12a564d8f55/underscore.js#L767\nTHREE.extend = function(obj, source) {\n    // ECMAScript5 compatibility based on: http://www.nczonline.net/blog/2012/12/11/are-your-mixins-ecmascript-5-compatible/\n    if (Object.keys) {\n        var keys = Object.keys(source);\n        for(var i = 0, il = keys.length; i < il; i++){\n            var prop = keys[i];\n            Object.defineProperty(obj, prop, Object.getOwnPropertyDescriptor(source, prop));\n        }\n    } else {\n        var safeHasOwnProperty = {}.hasOwnProperty;\n        for(var prop in source)if (safeHasOwnProperty.call(source, prop)) obj[prop] = source[prop];\n    }\n    return obj;\n};\n// http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating\n// requestAnimationFrame polyfill by Erik Mller\n// fixes from Paul Irish and Tino Zijdel\n(function() {\n    var lastTime = 0;\n    var vendors = [\n        \"ms\",\n        \"moz\",\n        \"webkit\",\n        \"o\"\n    ];\n    for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x){\n        window.requestAnimationFrame = window[vendors[x] + \"RequestAnimationFrame\"];\n        window.cancelAnimationFrame = window[vendors[x] + \"CancelAnimationFrame\"] || window[vendors[x] + \"CancelRequestAnimationFrame\"];\n    }\n    if (window.requestAnimationFrame === undefined) window.requestAnimationFrame = function(callback) {\n        var currTime = Date.now(), timeToCall = Math.max(0, 16 - (currTime - lastTime));\n        var id = window.setTimeout(function() {\n            callback(currTime + timeToCall);\n        }, timeToCall);\n        lastTime = currTime + timeToCall;\n        return id;\n    };\n    window.cancelAnimationFrame = window.cancelAnimationFrame || function(id) {\n        window.clearTimeout(id);\n    };\n})();\n// GL STATE CONSTANTS\nTHREE.CullFaceNone = 0;\nTHREE.CullFaceBack = 1;\nTHREE.CullFaceFront = 2;\nTHREE.CullFaceFrontBack = 3;\nTHREE.FrontFaceDirectionCW = 0;\nTHREE.FrontFaceDirectionCCW = 1;\n// SHADOWING TYPES\nTHREE.BasicShadowMap = 0;\nTHREE.PCFShadowMap = 1;\nTHREE.PCFSoftShadowMap = 2;\n// MATERIAL CONSTANTS\n// side\nTHREE.FrontSide = 0;\nTHREE.BackSide = 1;\nTHREE.DoubleSide = 2;\n// shading\nTHREE.NoShading = 0;\nTHREE.FlatShading = 1;\nTHREE.SmoothShading = 2;\n// colors\nTHREE.NoColors = 0;\nTHREE.FaceColors = 1;\nTHREE.VertexColors = 2;\n// blending modes\nTHREE.NoBlending = 0;\nTHREE.NormalBlending = 1;\nTHREE.AdditiveBlending = 2;\nTHREE.SubtractiveBlending = 3;\nTHREE.MultiplyBlending = 4;\nTHREE.CustomBlending = 5;\n// custom blending equations\n// (numbers start from 100 not to clash with other\n//  mappings to OpenGL constants defined in Texture.js)\nTHREE.AddEquation = 100;\nTHREE.SubtractEquation = 101;\nTHREE.ReverseSubtractEquation = 102;\n// custom blending destination factors\nTHREE.ZeroFactor = 200;\nTHREE.OneFactor = 201;\nTHREE.SrcColorFactor = 202;\nTHREE.OneMinusSrcColorFactor = 203;\nTHREE.SrcAlphaFactor = 204;\nTHREE.OneMinusSrcAlphaFactor = 205;\nTHREE.DstAlphaFactor = 206;\nTHREE.OneMinusDstAlphaFactor = 207;\n// custom blending source factors\n//THREE.ZeroFactor = 200;\n//THREE.OneFactor = 201;\n//THREE.SrcAlphaFactor = 204;\n//THREE.OneMinusSrcAlphaFactor = 205;\n//THREE.DstAlphaFactor = 206;\n//THREE.OneMinusDstAlphaFactor = 207;\nTHREE.DstColorFactor = 208;\nTHREE.OneMinusDstColorFactor = 209;\nTHREE.SrcAlphaSaturateFactor = 210;\n// TEXTURE CONSTANTS\nTHREE.MultiplyOperation = 0;\nTHREE.MixOperation = 1;\nTHREE.AddOperation = 2;\n// Mapping modes\nTHREE.UVMapping = function() {};\nTHREE.CubeReflectionMapping = function() {};\nTHREE.CubeRefractionMapping = function() {};\nTHREE.SphericalReflectionMapping = function() {};\nTHREE.SphericalRefractionMapping = function() {};\n// Wrapping modes\nTHREE.RepeatWrapping = 1000;\nTHREE.ClampToEdgeWrapping = 1001;\nTHREE.MirroredRepeatWrapping = 1002;\n// Filters\nTHREE.NearestFilter = 1003;\nTHREE.NearestMipMapNearestFilter = 1004;\nTHREE.NearestMipMapLinearFilter = 1005;\nTHREE.LinearFilter = 1006;\nTHREE.LinearMipMapNearestFilter = 1007;\nTHREE.LinearMipMapLinearFilter = 1008;\n// Data types\nTHREE.UnsignedByteType = 1009;\nTHREE.ByteType = 1010;\nTHREE.ShortType = 1011;\nTHREE.UnsignedShortType = 1012;\nTHREE.IntType = 1013;\nTHREE.UnsignedIntType = 1014;\nTHREE.FloatType = 1015;\n// Pixel types\n//THREE.UnsignedByteType = 1009;\nTHREE.UnsignedShort4444Type = 1016;\nTHREE.UnsignedShort5551Type = 1017;\nTHREE.UnsignedShort565Type = 1018;\n// Pixel formats\nTHREE.AlphaFormat = 1019;\nTHREE.RGBFormat = 1020;\nTHREE.RGBAFormat = 1021;\nTHREE.LuminanceFormat = 1022;\nTHREE.LuminanceAlphaFormat = 1023;\n// Compressed texture formats\nTHREE.RGB_S3TC_DXT1_Format = 2001;\nTHREE.RGBA_S3TC_DXT1_Format = 2002;\nTHREE.RGBA_S3TC_DXT3_Format = 2003;\nTHREE.RGBA_S3TC_DXT5_Format = 2004;\n/*\n// Potential future PVRTC compressed texture formats\nTHREE.RGB_PVRTC_4BPPV1_Format = 2100;\nTHREE.RGB_PVRTC_2BPPV1_Format = 2101;\nTHREE.RGBA_PVRTC_4BPPV1_Format = 2102;\nTHREE.RGBA_PVRTC_2BPPV1_Format = 2103;\n*/ /**\n * @author mrdoob / http://mrdoob.com/\n */ THREE.Color = function(value) {\n    if (value !== undefined) this.set(value);\n    return this;\n};\nTHREE.extend(THREE.Color.prototype, {\n    r: 1,\n    g: 1,\n    b: 1,\n    set: function(value) {\n        switch(typeof value){\n            case \"number\":\n                this.setHex(value);\n                break;\n            case \"string\":\n                this.setStyle(value);\n                break;\n        }\n    },\n    setHex: function(hex) {\n        hex = Math.floor(hex);\n        this.r = (hex >> 16 & 255) / 255;\n        this.g = (hex >> 8 & 255) / 255;\n        this.b = (hex & 255) / 255;\n        return this;\n    },\n    setRGB: function(r, g, b) {\n        this.r = r;\n        this.g = g;\n        this.b = b;\n        return this;\n    },\n    setHSV: function(h, s, v) {\n        console.log(\"DEPRECATED: Color's .setHSV() will be removed. Use .setHSL( h, s, l ) instead.\");\n        return this.setHSL(h, s * v / ((h = (2 - s) * v) < 1 ? h : 2 - h), h / 2); // https://gist.github.com/xpansive/1337890\n    },\n    setHSL: function(h, s, l) {\n        // h,s,l ranges are in 0.0 - 1.0\n        if (s === 0) this.r = this.g = this.b = l;\n        else {\n            var hue2rgb = function(p, q, t) {\n                if (t < 0) t += 1;\n                if (t > 1) t -= 1;\n                if (t < 1 / 6) return p + (q - p) * 6 * t;\n                if (t < 0.5) return q;\n                if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);\n                return p;\n            };\n            var p = l <= 0.5 ? l * (1 + s) : l + s - l * s;\n            var q = 2 * l - p;\n            this.r = hue2rgb(q, p, h + 1 / 3);\n            this.g = hue2rgb(q, p, h);\n            this.b = hue2rgb(q, p, h - 1 / 3);\n        }\n        return this;\n    },\n    setStyle: function(style) {\n        // rgb(255,0,0)\n        if (/^rgb\\((\\d+),(\\d+),(\\d+)\\)$/i.test(style)) {\n            var color = /^rgb\\((\\d+),(\\d+),(\\d+)\\)$/i.exec(style);\n            this.r = Math.min(255, parseInt(color[1], 10)) / 255;\n            this.g = Math.min(255, parseInt(color[2], 10)) / 255;\n            this.b = Math.min(255, parseInt(color[3], 10)) / 255;\n            return this;\n        }\n        // rgb(100%,0%,0%)\n        if (/^rgb\\((\\d+)\\%,(\\d+)\\%,(\\d+)\\%\\)$/i.test(style)) {\n            var color = /^rgb\\((\\d+)\\%,(\\d+)\\%,(\\d+)\\%\\)$/i.exec(style);\n            this.r = Math.min(100, parseInt(color[1], 10)) / 100;\n            this.g = Math.min(100, parseInt(color[2], 10)) / 100;\n            this.b = Math.min(100, parseInt(color[3], 10)) / 100;\n            return this;\n        }\n        // #ff0000\n        if (/^\\#([0-9a-f]{6})$/i.test(style)) {\n            var color = /^\\#([0-9a-f]{6})$/i.exec(style);\n            this.setHex(parseInt(color[1], 16));\n            return this;\n        }\n        // #f00\n        if (/^\\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test(style)) {\n            var color = /^\\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec(style);\n            this.setHex(parseInt(color[1] + color[1] + color[2] + color[2] + color[3] + color[3], 16));\n            return this;\n        }\n        // red\n        if (/^(\\w+)$/i.test(style)) {\n            this.setHex(THREE.ColorKeywords[style]);\n            return this;\n        }\n    },\n    copy: function(color) {\n        this.r = color.r;\n        this.g = color.g;\n        this.b = color.b;\n        return this;\n    },\n    copyGammaToLinear: function(color) {\n        this.r = color.r * color.r;\n        this.g = color.g * color.g;\n        this.b = color.b * color.b;\n        return this;\n    },\n    copyLinearToGamma: function(color) {\n        this.r = Math.sqrt(color.r);\n        this.g = Math.sqrt(color.g);\n        this.b = Math.sqrt(color.b);\n        return this;\n    },\n    convertGammaToLinear: function() {\n        var r = this.r, g = this.g, b = this.b;\n        this.r = r * r;\n        this.g = g * g;\n        this.b = b * b;\n        return this;\n    },\n    convertLinearToGamma: function() {\n        this.r = Math.sqrt(this.r);\n        this.g = Math.sqrt(this.g);\n        this.b = Math.sqrt(this.b);\n        return this;\n    },\n    getHex: function() {\n        return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;\n    },\n    getHexString: function() {\n        return (\"000000\" + this.getHex().toString(16)).slice(-6);\n    },\n    getHSL: function() {\n        var hsl = {\n            h: 0,\n            s: 0,\n            l: 0\n        };\n        return function() {\n            // h,s,l ranges are in 0.0 - 1.0\n            var r = this.r, g = this.g, b = this.b;\n            var max = Math.max(r, g, b);\n            var min = Math.min(r, g, b);\n            var hue, saturation;\n            var lightness = (min + max) / 2.0;\n            if (min === max) {\n                hue = 0;\n                saturation = 0;\n            } else {\n                var delta = max - min;\n                saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);\n                switch(max){\n                    case r:\n                        hue = (g - b) / delta + (g < b ? 6 : 0);\n                        break;\n                    case g:\n                        hue = (b - r) / delta + 2;\n                        break;\n                    case b:\n                        hue = (r - g) / delta + 4;\n                        break;\n                }\n                hue /= 6;\n            }\n            hsl.h = hue;\n            hsl.s = saturation;\n            hsl.l = lightness;\n            return hsl;\n        };\n    }(),\n    getStyle: function() {\n        return \"rgb(\" + (this.r * 255 | 0) + \",\" + (this.g * 255 | 0) + \",\" + (this.b * 255 | 0) + \")\";\n    },\n    offsetHSL: function(h, s, l) {\n        var hsl = this.getHSL();\n        hsl.h += h;\n        hsl.s += s;\n        hsl.l += l;\n        this.setHSL(hsl.h, hsl.s, hsl.l);\n        return this;\n    },\n    add: function(color) {\n        this.r += color.r;\n        this.g += color.g;\n        this.b += color.b;\n        return this;\n    },\n    addColors: function(color1, color2) {\n        this.r = color1.r + color2.r;\n        this.g = color1.g + color2.g;\n        this.b = color1.b + color2.b;\n        return this;\n    },\n    addScalar: function(s) {\n        this.r += s;\n        this.g += s;\n        this.b += s;\n        return this;\n    },\n    multiply: function(color) {\n        this.r *= color.r;\n        this.g *= color.g;\n        this.b *= color.b;\n        return this;\n    },\n    multiplyScalar: function(s) {\n        this.r *= s;\n        this.g *= s;\n        this.b *= s;\n        return this;\n    },\n    lerp: function(color, alpha) {\n        this.r += (color.r - this.r) * alpha;\n        this.g += (color.g - this.g) * alpha;\n        this.b += (color.b - this.b) * alpha;\n        return this;\n    },\n    clone: function() {\n        return new THREE.Color().setRGB(this.r, this.g, this.b);\n    }\n});\nTHREE.ColorKeywords = {\n    \"aliceblue\": 0xF0F8FF,\n    \"antiquewhite\": 0xFAEBD7,\n    \"aqua\": 0x00FFFF,\n    \"aquamarine\": 0x7FFFD4,\n    \"azure\": 0xF0FFFF,\n    \"beige\": 0xF5F5DC,\n    \"bisque\": 0xFFE4C4,\n    \"black\": 0x000000,\n    \"blanchedalmond\": 0xFFEBCD,\n    \"blue\": 0x0000FF,\n    \"blueviolet\": 0x8A2BE2,\n    \"brown\": 0xA52A2A,\n    \"burlywood\": 0xDEB887,\n    \"cadetblue\": 0x5F9EA0,\n    \"chartreuse\": 0x7FFF00,\n    \"chocolate\": 0xD2691E,\n    \"coral\": 0xFF7F50,\n    \"cornflowerblue\": 0x6495ED,\n    \"cornsilk\": 0xFFF8DC,\n    \"crimson\": 0xDC143C,\n    \"cyan\": 0x00FFFF,\n    \"darkblue\": 0x00008B,\n    \"darkcyan\": 0x008B8B,\n    \"darkgoldenrod\": 0xB8860B,\n    \"darkgray\": 0xA9A9A9,\n    \"darkgreen\": 0x006400,\n    \"darkgrey\": 0xA9A9A9,\n    \"darkkhaki\": 0xBDB76B,\n    \"darkmagenta\": 0x8B008B,\n    \"darkolivegreen\": 0x556B2F,\n    \"darkorange\": 0xFF8C00,\n    \"darkorchid\": 0x9932CC,\n    \"darkred\": 0x8B0000,\n    \"darksalmon\": 0xE9967A,\n    \"darkseagreen\": 0x8FBC8F,\n    \"darkslateblue\": 0x483D8B,\n    \"darkslategray\": 0x2F4F4F,\n    \"darkslategrey\": 0x2F4F4F,\n    \"darkturquoise\": 0x00CED1,\n    \"darkviolet\": 0x9400D3,\n    \"deeppink\": 0xFF1493,\n    \"deepskyblue\": 0x00BFFF,\n    \"dimgray\": 0x696969,\n    \"dimgrey\": 0x696969,\n    \"dodgerblue\": 0x1E90FF,\n    \"firebrick\": 0xB22222,\n    \"floralwhite\": 0xFFFAF0,\n    \"forestgreen\": 0x228B22,\n    \"fuchsia\": 0xFF00FF,\n    \"gainsboro\": 0xDCDCDC,\n    \"ghostwhite\": 0xF8F8FF,\n    \"gold\": 0xFFD700,\n    \"goldenrod\": 0xDAA520,\n    \"gray\": 0x808080,\n    \"green\": 0x008000,\n    \"greenyellow\": 0xADFF2F,\n    \"grey\": 0x808080,\n    \"honeydew\": 0xF0FFF0,\n    \"hotpink\": 0xFF69B4,\n    \"indianred\": 0xCD5C5C,\n    \"indigo\": 0x4B0082,\n    \"ivory\": 0xFFFFF0,\n    \"khaki\": 0xF0E68C,\n    \"lavender\": 0xE6E6FA,\n    \"lavenderblush\": 0xFFF0F5,\n    \"lawngreen\": 0x7CFC00,\n    \"lemonchiffon\": 0xFFFACD,\n    \"lightblue\": 0xADD8E6,\n    \"lightcoral\": 0xF08080,\n    \"lightcyan\": 0xE0FFFF,\n    \"lightgoldenrodyellow\": 0xFAFAD2,\n    \"lightgray\": 0xD3D3D3,\n    \"lightgreen\": 0x90EE90,\n    \"lightgrey\": 0xD3D3D3,\n    \"lightpink\": 0xFFB6C1,\n    \"lightsalmon\": 0xFFA07A,\n    \"lightseagreen\": 0x20B2AA,\n    \"lightskyblue\": 0x87CEFA,\n    \"lightslategray\": 0x778899,\n    \"lightslategrey\": 0x778899,\n    \"lightsteelblue\": 0xB0C4DE,\n    \"lightyellow\": 0xFFFFE0,\n    \"lime\": 0x00FF00,\n    \"limegreen\": 0x32CD32,\n    \"linen\": 0xFAF0E6,\n    \"magenta\": 0xFF00FF,\n    \"maroon\": 0x800000,\n    \"mediumaquamarine\": 0x66CDAA,\n    \"mediumblue\": 0x0000CD,\n    \"mediumorchid\": 0xBA55D3,\n    \"mediumpurple\": 0x9370DB,\n    \"mediumseagreen\": 0x3CB371,\n    \"mediumslateblue\": 0x7B68EE,\n    \"mediumspringgreen\": 0x00FA9A,\n    \"mediumturquoise\": 0x48D1CC,\n    \"mediumvioletred\": 0xC71585,\n    \"midnightblue\": 0x191970,\n    \"mintcream\": 0xF5FFFA,\n    \"mistyrose\": 0xFFE4E1,\n    \"moccasin\": 0xFFE4B5,\n    \"navajowhite\": 0xFFDEAD,\n    \"navy\": 0x000080,\n    \"oldlace\": 0xFDF5E6,\n    \"olive\": 0x808000,\n    \"olivedrab\": 0x6B8E23,\n    \"orange\": 0xFFA500,\n    \"orangered\": 0xFF4500,\n    \"orchid\": 0xDA70D6,\n    \"palegoldenrod\": 0xEEE8AA,\n    \"palegreen\": 0x98FB98,\n    \"paleturquoise\": 0xAFEEEE,\n    \"palevioletred\": 0xDB7093,\n    \"papayawhip\": 0xFFEFD5,\n    \"peachpuff\": 0xFFDAB9,\n    \"peru\": 0xCD853F,\n    \"pink\": 0xFFC0CB,\n    \"plum\": 0xDDA0DD,\n    \"powderblue\": 0xB0E0E6,\n    \"purple\": 0x800080,\n    \"red\": 0xFF0000,\n    \"rosybrown\": 0xBC8F8F,\n    \"royalblue\": 0x4169E1,\n    \"saddlebrown\": 0x8B4513,\n    \"salmon\": 0xFA8072,\n    \"sandybrown\": 0xF4A460,\n    \"seagreen\": 0x2E8B57,\n    \"seashell\": 0xFFF5EE,\n    \"sienna\": 0xA0522D,\n    \"silver\": 0xC0C0C0,\n    \"skyblue\": 0x87CEEB,\n    \"slateblue\": 0x6A5ACD,\n    \"slategray\": 0x708090,\n    \"slategrey\": 0x708090,\n    \"snow\": 0xFFFAFA,\n    \"springgreen\": 0x00FF7F,\n    \"steelblue\": 0x4682B4,\n    \"tan\": 0xD2B48C,\n    \"teal\": 0x008080,\n    \"thistle\": 0xD8BFD8,\n    \"tomato\": 0xFF6347,\n    \"turquoise\": 0x40E0D0,\n    \"violet\": 0xEE82EE,\n    \"wheat\": 0xF5DEB3,\n    \"white\": 0xFFFFFF,\n    \"whitesmoke\": 0xF5F5F5,\n    \"yellow\": 0xFFFF00,\n    \"yellowgreen\": 0x9ACD32\n};\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author bhouston / http://exocortex.com\n */ THREE.Quaternion = function(x, y, z, w) {\n    this.x = x || 0;\n    this.y = y || 0;\n    this.z = z || 0;\n    this.w = w !== undefined ? w : 1;\n};\nTHREE.extend(THREE.Quaternion.prototype, {\n    set: function(x, y, z, w) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.w = w;\n        return this;\n    },\n    copy: function(q) {\n        this.x = q.x;\n        this.y = q.y;\n        this.z = q.z;\n        this.w = q.w;\n        return this;\n    },\n    setFromEuler: function(v, order) {\n        // http://www.mathworks.com/matlabcentral/fileexchange/\n        // \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n        //\tcontent/SpinCalc.m\n        var c1 = Math.cos(v.x / 2);\n        var c2 = Math.cos(v.y / 2);\n        var c3 = Math.cos(v.z / 2);\n        var s1 = Math.sin(v.x / 2);\n        var s2 = Math.sin(v.y / 2);\n        var s3 = Math.sin(v.z / 2);\n        if (order === undefined || order === \"XYZ\") {\n            this.x = s1 * c2 * c3 + c1 * s2 * s3;\n            this.y = c1 * s2 * c3 - s1 * c2 * s3;\n            this.z = c1 * c2 * s3 + s1 * s2 * c3;\n            this.w = c1 * c2 * c3 - s1 * s2 * s3;\n        } else if (order === \"YXZ\") {\n            this.x = s1 * c2 * c3 + c1 * s2 * s3;\n            this.y = c1 * s2 * c3 - s1 * c2 * s3;\n            this.z = c1 * c2 * s3 - s1 * s2 * c3;\n            this.w = c1 * c2 * c3 + s1 * s2 * s3;\n        } else if (order === \"ZXY\") {\n            this.x = s1 * c2 * c3 - c1 * s2 * s3;\n            this.y = c1 * s2 * c3 + s1 * c2 * s3;\n            this.z = c1 * c2 * s3 + s1 * s2 * c3;\n            this.w = c1 * c2 * c3 - s1 * s2 * s3;\n        } else if (order === \"ZYX\") {\n            this.x = s1 * c2 * c3 - c1 * s2 * s3;\n            this.y = c1 * s2 * c3 + s1 * c2 * s3;\n            this.z = c1 * c2 * s3 - s1 * s2 * c3;\n            this.w = c1 * c2 * c3 + s1 * s2 * s3;\n        } else if (order === \"YZX\") {\n            this.x = s1 * c2 * c3 + c1 * s2 * s3;\n            this.y = c1 * s2 * c3 + s1 * c2 * s3;\n            this.z = c1 * c2 * s3 - s1 * s2 * c3;\n            this.w = c1 * c2 * c3 - s1 * s2 * s3;\n        } else if (order === \"XZY\") {\n            this.x = s1 * c2 * c3 - c1 * s2 * s3;\n            this.y = c1 * s2 * c3 - s1 * c2 * s3;\n            this.z = c1 * c2 * s3 + s1 * s2 * c3;\n            this.w = c1 * c2 * c3 + s1 * s2 * s3;\n        }\n        return this;\n    },\n    setFromAxisAngle: function(axis, angle) {\n        // from http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n        // axis have to be normalized\n        var halfAngle = angle / 2, s = Math.sin(halfAngle);\n        this.x = axis.x * s;\n        this.y = axis.y * s;\n        this.z = axis.z * s;\n        this.w = Math.cos(halfAngle);\n        return this;\n    },\n    setFromRotationMatrix: function(m) {\n        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n        var te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33, s;\n        if (trace > 0) {\n            s = 0.5 / Math.sqrt(trace + 1.0);\n            this.w = 0.25 / s;\n            this.x = (m32 - m23) * s;\n            this.y = (m13 - m31) * s;\n            this.z = (m21 - m12) * s;\n        } else if (m11 > m22 && m11 > m33) {\n            s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);\n            this.w = (m32 - m23) / s;\n            this.x = 0.25 * s;\n            this.y = (m12 + m21) / s;\n            this.z = (m13 + m31) / s;\n        } else if (m22 > m33) {\n            s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);\n            this.w = (m13 - m31) / s;\n            this.x = (m12 + m21) / s;\n            this.y = 0.25 * s;\n            this.z = (m23 + m32) / s;\n        } else {\n            s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);\n            this.w = (m21 - m12) / s;\n            this.x = (m13 + m31) / s;\n            this.y = (m23 + m32) / s;\n            this.z = 0.25 * s;\n        }\n        return this;\n    },\n    inverse: function() {\n        this.conjugate().normalize();\n        return this;\n    },\n    conjugate: function() {\n        this.x *= -1;\n        this.y *= -1;\n        this.z *= -1;\n        return this;\n    },\n    lengthSq: function() {\n        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n    },\n    length: function() {\n        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\n    },\n    normalize: function() {\n        var l = this.length();\n        if (l === 0) {\n            this.x = 0;\n            this.y = 0;\n            this.z = 0;\n            this.w = 1;\n        } else {\n            l = 1 / l;\n            this.x = this.x * l;\n            this.y = this.y * l;\n            this.z = this.z * l;\n            this.w = this.w * l;\n        }\n        return this;\n    },\n    multiply: function(q, p) {\n        if (p !== undefined) {\n            console.warn(\"DEPRECATED: Quaternion's .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.\");\n            return this.multiplyQuaternions(q, p);\n        }\n        return this.multiplyQuaternions(this, q);\n    },\n    multiplyQuaternions: function(a, b) {\n        // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n        var qax = a.x, qay = a.y, qaz = a.z, qaw = a.w;\n        var qbx = b.x, qby = b.y, qbz = b.z, qbw = b.w;\n        this.x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n        this.y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n        this.z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n        this.w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n        return this;\n    },\n    multiplyVector3: function(vector) {\n        console.warn(\"DEPRECATED: Quaternion's .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.\");\n        return vector.applyQuaternion(this);\n    },\n    slerp: function(qb, t) {\n        var x = this.x, y = this.y, z = this.z, w = this.w;\n        // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n        var cosHalfTheta = w * qb.w + x * qb.x + y * qb.y + z * qb.z;\n        if (cosHalfTheta < 0) {\n            this.w = -qb.w;\n            this.x = -qb.x;\n            this.y = -qb.y;\n            this.z = -qb.z;\n            cosHalfTheta = -cosHalfTheta;\n        } else this.copy(qb);\n        if (cosHalfTheta >= 1.0) {\n            this.w = w;\n            this.x = x;\n            this.y = y;\n            this.z = z;\n            return this;\n        }\n        var halfTheta = Math.acos(cosHalfTheta);\n        var sinHalfTheta = Math.sqrt(1.0 - cosHalfTheta * cosHalfTheta);\n        if (Math.abs(sinHalfTheta) < 0.001) {\n            this.w = 0.5 * (w + this.w);\n            this.x = 0.5 * (x + this.x);\n            this.y = 0.5 * (y + this.y);\n            this.z = 0.5 * (z + this.z);\n            return this;\n        }\n        var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;\n        this.w = w * ratioA + this.w * ratioB;\n        this.x = x * ratioA + this.x * ratioB;\n        this.y = y * ratioA + this.y * ratioB;\n        this.z = z * ratioA + this.z * ratioB;\n        return this;\n    },\n    equals: function(v) {\n        return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;\n    },\n    clone: function() {\n        return new THREE.Quaternion(this.x, this.y, this.z, this.w);\n    }\n});\nTHREE.Quaternion.slerp = function(qa, qb, qm, t) {\n    return qm.copy(qa).slerp(qb, t);\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author philogb / http://blog.thejit.org/\n * @author egraether / http://egraether.com/\n * @author zz85 / http://www.lab4games.net/zz85/blog\n */ THREE.Vector2 = function(x, y) {\n    this.x = x || 0;\n    this.y = y || 0;\n};\nTHREE.extend(THREE.Vector2.prototype, {\n    set: function(x, y) {\n        this.x = x;\n        this.y = y;\n        return this;\n    },\n    setX: function(x) {\n        this.x = x;\n        return this;\n    },\n    setY: function(y) {\n        this.y = y;\n        return this;\n    },\n    setComponent: function(index, value) {\n        switch(index){\n            case 0:\n                this.x = value;\n                break;\n            case 1:\n                this.y = value;\n                break;\n            default:\n                throw new Error(\"index is out of range: \" + index);\n        }\n    },\n    getComponent: function(index) {\n        switch(index){\n            case 0:\n                return this.x;\n            case 1:\n                return this.y;\n            default:\n                throw new Error(\"index is out of range: \" + index);\n        }\n    },\n    copy: function(v) {\n        this.x = v.x;\n        this.y = v.y;\n        return this;\n    },\n    add: function(v, w) {\n        if (w !== undefined) {\n            console.warn(\"DEPRECATED: Vector2's .add() now only accepts one argument. Use .addVectors( a, b ) instead.\");\n            return this.addVectors(v, w);\n        }\n        this.x += v.x;\n        this.y += v.y;\n        return this;\n    },\n    addVectors: function(a, b) {\n        this.x = a.x + b.x;\n        this.y = a.y + b.y;\n        return this;\n    },\n    addScalar: function(s) {\n        this.x += s;\n        this.y += s;\n        return this;\n    },\n    sub: function(v, w) {\n        if (w !== undefined) {\n            console.warn(\"DEPRECATED: Vector2's .sub() now only accepts one argument. Use .subVectors( a, b ) instead.\");\n            return this.subVectors(v, w);\n        }\n        this.x -= v.x;\n        this.y -= v.y;\n        return this;\n    },\n    subVectors: function(a, b) {\n        this.x = a.x - b.x;\n        this.y = a.y - b.y;\n        return this;\n    },\n    multiplyScalar: function(s) {\n        this.x *= s;\n        this.y *= s;\n        return this;\n    },\n    divideScalar: function(s) {\n        if (s !== 0) {\n            this.x /= s;\n            this.y /= s;\n        } else this.set(0, 0);\n        return this;\n    },\n    min: function(v) {\n        if (this.x > v.x) this.x = v.x;\n        if (this.y > v.y) this.y = v.y;\n        return this;\n    },\n    max: function(v) {\n        if (this.x < v.x) this.x = v.x;\n        if (this.y < v.y) this.y = v.y;\n        return this;\n    },\n    clamp: function(min, max) {\n        // This function assumes min < max, if this assumption isn't true it will not operate correctly\n        if (this.x < min.x) this.x = min.x;\n        else if (this.x > max.x) this.x = max.x;\n        if (this.y < min.y) this.y = min.y;\n        else if (this.y > max.y) this.y = max.y;\n        return this;\n    },\n    negate: function() {\n        return this.multiplyScalar(-1);\n    },\n    dot: function(v) {\n        return this.x * v.x + this.y * v.y;\n    },\n    lengthSq: function() {\n        return this.x * this.x + this.y * this.y;\n    },\n    length: function() {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    },\n    normalize: function() {\n        return this.divideScalar(this.length());\n    },\n    distanceTo: function(v) {\n        return Math.sqrt(this.distanceToSquared(v));\n    },\n    distanceToSquared: function(v) {\n        var dx = this.x - v.x, dy = this.y - v.y;\n        return dx * dx + dy * dy;\n    },\n    setLength: function(l) {\n        var oldLength = this.length();\n        if (oldLength !== 0 && l !== oldLength) this.multiplyScalar(l / oldLength);\n        return this;\n    },\n    lerp: function(v, alpha) {\n        this.x += (v.x - this.x) * alpha;\n        this.y += (v.y - this.y) * alpha;\n        return this;\n    },\n    equals: function(v) {\n        return v.x === this.x && v.y === this.y;\n    },\n    toArray: function() {\n        return [\n            this.x,\n            this.y\n        ];\n    },\n    clone: function() {\n        return new THREE.Vector2(this.x, this.y);\n    }\n});\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author *kile / http://kile.stravaganza.org/\n * @author philogb / http://blog.thejit.org/\n * @author mikael emtinger / http://gomo.se/\n * @author egraether / http://egraether.com/\n * @author WestLangley / http://github.com/WestLangley\n */ THREE.Vector3 = function(x, y, z) {\n    this.x = x || 0;\n    this.y = y || 0;\n    this.z = z || 0;\n};\nTHREE.extend(THREE.Vector3.prototype, {\n    set: function(x, y, z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        return this;\n    },\n    setX: function(x) {\n        this.x = x;\n        return this;\n    },\n    setY: function(y) {\n        this.y = y;\n        return this;\n    },\n    setZ: function(z) {\n        this.z = z;\n        return this;\n    },\n    setComponent: function(index, value) {\n        switch(index){\n            case 0:\n                this.x = value;\n                break;\n            case 1:\n                this.y = value;\n                break;\n            case 2:\n                this.z = value;\n                break;\n            default:\n                throw new Error(\"index is out of range: \" + index);\n        }\n    },\n    getComponent: function(index) {\n        switch(index){\n            case 0:\n                return this.x;\n            case 1:\n                return this.y;\n            case 2:\n                return this.z;\n            default:\n                throw new Error(\"index is out of range: \" + index);\n        }\n    },\n    copy: function(v) {\n        this.x = v.x;\n        this.y = v.y;\n        this.z = v.z;\n        return this;\n    },\n    add: function(v, w) {\n        if (w !== undefined) {\n            console.warn(\"DEPRECATED: Vector3's .add() now only accepts one argument. Use .addVectors( a, b ) instead.\");\n            return this.addVectors(v, w);\n        }\n        this.x += v.x;\n        this.y += v.y;\n        this.z += v.z;\n        return this;\n    },\n    addScalar: function(s) {\n        this.x += s;\n        this.y += s;\n        this.z += s;\n        return this;\n    },\n    addVectors: function(a, b) {\n        this.x = a.x + b.x;\n        this.y = a.y + b.y;\n        this.z = a.z + b.z;\n        return this;\n    },\n    sub: function(v, w) {\n        if (w !== undefined) {\n            console.warn(\"DEPRECATED: Vector3's .sub() now only accepts one argument. Use .subVectors( a, b ) instead.\");\n            return this.subVectors(v, w);\n        }\n        this.x -= v.x;\n        this.y -= v.y;\n        this.z -= v.z;\n        return this;\n    },\n    subVectors: function(a, b) {\n        this.x = a.x - b.x;\n        this.y = a.y - b.y;\n        this.z = a.z - b.z;\n        return this;\n    },\n    multiply: function(v, w) {\n        if (w !== undefined) {\n            console.warn(\"DEPRECATED: Vector3's .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.\");\n            return this.multiplyVectors(v, w);\n        }\n        this.x *= v.x;\n        this.y *= v.y;\n        this.z *= v.z;\n        return this;\n    },\n    multiplyScalar: function(s) {\n        this.x *= s;\n        this.y *= s;\n        this.z *= s;\n        return this;\n    },\n    multiplyVectors: function(a, b) {\n        this.x = a.x * b.x;\n        this.y = a.y * b.y;\n        this.z = a.z * b.z;\n        return this;\n    },\n    applyMatrix3: function(m) {\n        var x = this.x;\n        var y = this.y;\n        var z = this.z;\n        var e = m.elements;\n        this.x = e[0] * x + e[3] * y + e[6] * z;\n        this.y = e[1] * x + e[4] * y + e[7] * z;\n        this.z = e[2] * x + e[5] * y + e[8] * z;\n        return this;\n    },\n    applyMatrix4: function(m) {\n        // input: THREE.Matrix4 affine matrix\n        var x = this.x, y = this.y, z = this.z;\n        var e = m.elements;\n        this.x = e[0] * x + e[4] * y + e[8] * z + e[12];\n        this.y = e[1] * x + e[5] * y + e[9] * z + e[13];\n        this.z = e[2] * x + e[6] * y + e[10] * z + e[14];\n        return this;\n    },\n    applyProjection: function(m) {\n        // input: THREE.Matrix4 projection matrix\n        var x = this.x, y = this.y, z = this.z;\n        var e = m.elements;\n        var d = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]); // perspective divide\n        this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * d;\n        this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * d;\n        this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * d;\n        return this;\n    },\n    applyQuaternion: function(q) {\n        var x = this.x;\n        var y = this.y;\n        var z = this.z;\n        var qx = q.x;\n        var qy = q.y;\n        var qz = q.z;\n        var qw = q.w;\n        // calculate quat * vector\n        var ix = qw * x + qy * z - qz * y;\n        var iy = qw * y + qz * x - qx * z;\n        var iz = qw * z + qx * y - qy * x;\n        var iw = -qx * x - qy * y - qz * z;\n        // calculate result * inverse quat\n        this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n        this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n        this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n        return this;\n    },\n    applyEuler: function() {\n        var q1 = new THREE.Quaternion();\n        return function(v, eulerOrder) {\n            var quaternion = q1.setFromEuler(v, eulerOrder);\n            this.applyQuaternion(quaternion);\n            return this;\n        };\n    }(),\n    applyAxisAngle: function() {\n        var q1 = new THREE.Quaternion();\n        return function(axis, angle) {\n            var quaternion = q1.setFromAxisAngle(axis, angle);\n            this.applyQuaternion(quaternion);\n            return this;\n        };\n    }(),\n    transformDirection: function(m) {\n        // input: THREE.Matrix4 affine matrix\n        // vector interpreted as a direction\n        var x = this.x, y = this.y, z = this.z;\n        var e = m.elements;\n        this.x = e[0] * x + e[4] * y + e[8] * z;\n        this.y = e[1] * x + e[5] * y + e[9] * z;\n        this.z = e[2] * x + e[6] * y + e[10] * z;\n        this.normalize();\n        return this;\n    },\n    divide: function(v) {\n        this.x /= v.x;\n        this.y /= v.y;\n        this.z /= v.z;\n        return this;\n    },\n    divideScalar: function(s) {\n        if (s !== 0) {\n            this.x /= s;\n            this.y /= s;\n            this.z /= s;\n        } else {\n            this.x = 0;\n            this.y = 0;\n            this.z = 0;\n        }\n        return this;\n    },\n    min: function(v) {\n        if (this.x > v.x) this.x = v.x;\n        if (this.y > v.y) this.y = v.y;\n        if (this.z > v.z) this.z = v.z;\n        return this;\n    },\n    max: function(v) {\n        if (this.x < v.x) this.x = v.x;\n        if (this.y < v.y) this.y = v.y;\n        if (this.z < v.z) this.z = v.z;\n        return this;\n    },\n    clamp: function(min, max) {\n        // This function assumes min < max, if this assumption isn't true it will not operate correctly\n        if (this.x < min.x) this.x = min.x;\n        else if (this.x > max.x) this.x = max.x;\n        if (this.y < min.y) this.y = min.y;\n        else if (this.y > max.y) this.y = max.y;\n        if (this.z < min.z) this.z = min.z;\n        else if (this.z > max.z) this.z = max.z;\n        return this;\n    },\n    negate: function() {\n        return this.multiplyScalar(-1);\n    },\n    dot: function(v) {\n        return this.x * v.x + this.y * v.y + this.z * v.z;\n    },\n    lengthSq: function() {\n        return this.x * this.x + this.y * this.y + this.z * this.z;\n    },\n    length: function() {\n        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n    },\n    lengthManhattan: function() {\n        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);\n    },\n    normalize: function() {\n        return this.divideScalar(this.length());\n    },\n    setLength: function(l) {\n        var oldLength = this.length();\n        if (oldLength !== 0 && l !== oldLength) this.multiplyScalar(l / oldLength);\n        return this;\n    },\n    lerp: function(v, alpha) {\n        this.x += (v.x - this.x) * alpha;\n        this.y += (v.y - this.y) * alpha;\n        this.z += (v.z - this.z) * alpha;\n        return this;\n    },\n    cross: function(v, w) {\n        if (w !== undefined) {\n            console.warn(\"DEPRECATED: Vector3's .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.\");\n            return this.crossVectors(v, w);\n        }\n        var x = this.x, y = this.y, z = this.z;\n        this.x = y * v.z - z * v.y;\n        this.y = z * v.x - x * v.z;\n        this.z = x * v.y - y * v.x;\n        return this;\n    },\n    crossVectors: function(a, b) {\n        this.x = a.y * b.z - a.z * b.y;\n        this.y = a.z * b.x - a.x * b.z;\n        this.z = a.x * b.y - a.y * b.x;\n        return this;\n    },\n    projectOnVector: function() {\n        var v1 = new THREE.Vector3();\n        return function(vector) {\n            v1.copy(vector).normalize();\n            var d = this.dot(v1);\n            return this.copy(v1).multiplyScalar(d);\n        };\n    }(),\n    projectOnPlane: function() {\n        var v1 = new THREE.Vector3();\n        return function(planeNormal) {\n            v1.copy(this).projectOnVector(planeNormal);\n            return this.sub(v1);\n        };\n    }(),\n    reflect: function() {\n        var v1 = new THREE.Vector3();\n        return function(vector) {\n            v1.copy(this).projectOnVector(vector).multiplyScalar(2);\n            return this.subVectors(v1, this);\n        };\n    }(),\n    angleTo: function(v) {\n        var theta = this.dot(v) / (this.length() * v.length());\n        // clamp, to handle numerical problems\n        return Math.acos(THREE.Math.clamp(theta, -1, 1));\n    },\n    distanceTo: function(v) {\n        return Math.sqrt(this.distanceToSquared(v));\n    },\n    distanceToSquared: function(v) {\n        var dx = this.x - v.x;\n        var dy = this.y - v.y;\n        var dz = this.z - v.z;\n        return dx * dx + dy * dy + dz * dz;\n    },\n    getPositionFromMatrix: function(m) {\n        this.x = m.elements[12];\n        this.y = m.elements[13];\n        this.z = m.elements[14];\n        return this;\n    },\n    setEulerFromRotationMatrix: function(m, order) {\n        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n        // clamp, to handle numerical problems\n        function clamp(x) {\n            return Math.min(Math.max(x, -1), 1);\n        }\n        var te = m.elements;\n        var m11 = te[0], m12 = te[4], m13 = te[8];\n        var m21 = te[1], m22 = te[5], m23 = te[9];\n        var m31 = te[2], m32 = te[6], m33 = te[10];\n        if (order === undefined || order === \"XYZ\") {\n            this.y = Math.asin(clamp(m13));\n            if (Math.abs(m13) < 0.99999) {\n                this.x = Math.atan2(-m23, m33);\n                this.z = Math.atan2(-m12, m11);\n            } else {\n                this.x = Math.atan2(m32, m22);\n                this.z = 0;\n            }\n        } else if (order === \"YXZ\") {\n            this.x = Math.asin(-clamp(m23));\n            if (Math.abs(m23) < 0.99999) {\n                this.y = Math.atan2(m13, m33);\n                this.z = Math.atan2(m21, m22);\n            } else {\n                this.y = Math.atan2(-m31, m11);\n                this.z = 0;\n            }\n        } else if (order === \"ZXY\") {\n            this.x = Math.asin(clamp(m32));\n            if (Math.abs(m32) < 0.99999) {\n                this.y = Math.atan2(-m31, m33);\n                this.z = Math.atan2(-m12, m22);\n            } else {\n                this.y = 0;\n                this.z = Math.atan2(m21, m11);\n            }\n        } else if (order === \"ZYX\") {\n            this.y = Math.asin(-clamp(m31));\n            if (Math.abs(m31) < 0.99999) {\n                this.x = Math.atan2(m32, m33);\n                this.z = Math.atan2(m21, m11);\n            } else {\n                this.x = 0;\n                this.z = Math.atan2(-m12, m22);\n            }\n        } else if (order === \"YZX\") {\n            this.z = Math.asin(clamp(m21));\n            if (Math.abs(m21) < 0.99999) {\n                this.x = Math.atan2(-m23, m22);\n                this.y = Math.atan2(-m31, m11);\n            } else {\n                this.x = 0;\n                this.y = Math.atan2(m13, m33);\n            }\n        } else if (order === \"XZY\") {\n            this.z = Math.asin(-clamp(m12));\n            if (Math.abs(m12) < 0.99999) {\n                this.x = Math.atan2(m32, m22);\n                this.y = Math.atan2(m13, m11);\n            } else {\n                this.x = Math.atan2(-m23, m33);\n                this.y = 0;\n            }\n        }\n        return this;\n    },\n    setEulerFromQuaternion: function(q, order) {\n        // q is assumed to be normalized\n        // clamp, to handle numerical problems\n        function clamp(x) {\n            return Math.min(Math.max(x, -1), 1);\n        }\n        // http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/content/SpinCalc.m\n        var sqx = q.x * q.x;\n        var sqy = q.y * q.y;\n        var sqz = q.z * q.z;\n        var sqw = q.w * q.w;\n        if (order === undefined || order === \"XYZ\") {\n            this.x = Math.atan2(2 * (q.x * q.w - q.y * q.z), sqw - sqx - sqy + sqz);\n            this.y = Math.asin(clamp(2 * (q.x * q.z + q.y * q.w)));\n            this.z = Math.atan2(2 * (q.z * q.w - q.x * q.y), sqw + sqx - sqy - sqz);\n        } else if (order === \"YXZ\") {\n            this.x = Math.asin(clamp(2 * (q.x * q.w - q.y * q.z)));\n            this.y = Math.atan2(2 * (q.x * q.z + q.y * q.w), sqw - sqx - sqy + sqz);\n            this.z = Math.atan2(2 * (q.x * q.y + q.z * q.w), sqw - sqx + sqy - sqz);\n        } else if (order === \"ZXY\") {\n            this.x = Math.asin(clamp(2 * (q.x * q.w + q.y * q.z)));\n            this.y = Math.atan2(2 * (q.y * q.w - q.z * q.x), sqw - sqx - sqy + sqz);\n            this.z = Math.atan2(2 * (q.z * q.w - q.x * q.y), sqw - sqx + sqy - sqz);\n        } else if (order === \"ZYX\") {\n            this.x = Math.atan2(2 * (q.x * q.w + q.z * q.y), sqw - sqx - sqy + sqz);\n            this.y = Math.asin(clamp(2 * (q.y * q.w - q.x * q.z)));\n            this.z = Math.atan2(2 * (q.x * q.y + q.z * q.w), sqw + sqx - sqy - sqz);\n        } else if (order === \"YZX\") {\n            this.x = Math.atan2(2 * (q.x * q.w - q.z * q.y), sqw - sqx + sqy - sqz);\n            this.y = Math.atan2(2 * (q.y * q.w - q.x * q.z), sqw + sqx - sqy - sqz);\n            this.z = Math.asin(clamp(2 * (q.x * q.y + q.z * q.w)));\n        } else if (order === \"XZY\") {\n            this.x = Math.atan2(2 * (q.x * q.w + q.y * q.z), sqw - sqx + sqy - sqz);\n            this.y = Math.atan2(2 * (q.x * q.z + q.y * q.w), sqw + sqx - sqy - sqz);\n            this.z = Math.asin(clamp(2 * (q.z * q.w - q.x * q.y)));\n        }\n        return this;\n    },\n    getScaleFromMatrix: function(m) {\n        var sx = this.set(m.elements[0], m.elements[1], m.elements[2]).length();\n        var sy = this.set(m.elements[4], m.elements[5], m.elements[6]).length();\n        var sz = this.set(m.elements[8], m.elements[9], m.elements[10]).length();\n        this.x = sx;\n        this.y = sy;\n        this.z = sz;\n        return this;\n    },\n    equals: function(v) {\n        return v.x === this.x && v.y === this.y && v.z === this.z;\n    },\n    toArray: function() {\n        return [\n            this.x,\n            this.y,\n            this.z\n        ];\n    },\n    clone: function() {\n        return new THREE.Vector3(this.x, this.y, this.z);\n    }\n});\n/**\n * @author supereggbert / http://www.paulbrunt.co.uk/\n * @author philogb / http://blog.thejit.org/\n * @author mikael emtinger / http://gomo.se/\n * @author egraether / http://egraether.com/\n * @author WestLangley / http://github.com/WestLangley\n */ THREE.Vector4 = function(x, y, z, w) {\n    this.x = x || 0;\n    this.y = y || 0;\n    this.z = z || 0;\n    this.w = w !== undefined ? w : 1;\n};\nTHREE.extend(THREE.Vector4.prototype, {\n    set: function(x, y, z, w) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.w = w;\n        return this;\n    },\n    setX: function(x) {\n        this.x = x;\n        return this;\n    },\n    setY: function(y) {\n        this.y = y;\n        return this;\n    },\n    setZ: function(z) {\n        this.z = z;\n        return this;\n    },\n    setW: function(w) {\n        this.w = w;\n        return this;\n    },\n    setComponent: function(index, value) {\n        switch(index){\n            case 0:\n                this.x = value;\n                break;\n            case 1:\n                this.y = value;\n                break;\n            case 2:\n                this.z = value;\n                break;\n            case 3:\n                this.w = value;\n                break;\n            default:\n                throw new Error(\"index is out of range: \" + index);\n        }\n    },\n    getComponent: function(index) {\n        switch(index){\n            case 0:\n                return this.x;\n            case 1:\n                return this.y;\n            case 2:\n                return this.z;\n            case 3:\n                return this.w;\n            default:\n                throw new Error(\"index is out of range: \" + index);\n        }\n    },\n    copy: function(v) {\n        this.x = v.x;\n        this.y = v.y;\n        this.z = v.z;\n        this.w = v.w !== undefined ? v.w : 1;\n        return this;\n    },\n    add: function(v, w) {\n        if (w !== undefined) {\n            console.warn(\"DEPRECATED: Vector4's .add() now only accepts one argument. Use .addVectors( a, b ) instead.\");\n            return this.addVectors(v, w);\n        }\n        this.x += v.x;\n        this.y += v.y;\n        this.z += v.z;\n        this.w += v.w;\n        return this;\n    },\n    addScalar: function(s) {\n        this.x += s;\n        this.y += s;\n        this.z += s;\n        this.w += s;\n        return this;\n    },\n    addVectors: function(a, b) {\n        this.x = a.x + b.x;\n        this.y = a.y + b.y;\n        this.z = a.z + b.z;\n        this.w = a.w + b.w;\n        return this;\n    },\n    sub: function(v, w) {\n        if (w !== undefined) {\n            console.warn(\"DEPRECATED: Vector4's .sub() now only accepts one argument. Use .subVectors( a, b ) instead.\");\n            return this.subVectors(v, w);\n        }\n        this.x -= v.x;\n        this.y -= v.y;\n        this.z -= v.z;\n        this.w -= v.w;\n        return this;\n    },\n    subVectors: function(a, b) {\n        this.x = a.x - b.x;\n        this.y = a.y - b.y;\n        this.z = a.z - b.z;\n        this.w = a.w - b.w;\n        return this;\n    },\n    multiplyScalar: function(s) {\n        this.x *= s;\n        this.y *= s;\n        this.z *= s;\n        this.w *= s;\n        return this;\n    },\n    applyMatrix4: function(m) {\n        var x = this.x;\n        var y = this.y;\n        var z = this.z;\n        var w = this.w;\n        var e = m.elements;\n        this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;\n        this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;\n        this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;\n        this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;\n        return this;\n    },\n    divideScalar: function(s) {\n        if (s !== 0) {\n            this.x /= s;\n            this.y /= s;\n            this.z /= s;\n            this.w /= s;\n        } else {\n            this.x = 0;\n            this.y = 0;\n            this.z = 0;\n            this.w = 1;\n        }\n        return this;\n    },\n    setAxisAngleFromQuaternion: function(q) {\n        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\n        // q is assumed to be normalized\n        this.w = 2 * Math.acos(q.w);\n        var s = Math.sqrt(1 - q.w * q.w);\n        if (s < 0.0001) {\n            this.x = 1;\n            this.y = 0;\n            this.z = 0;\n        } else {\n            this.x = q.x / s;\n            this.y = q.y / s;\n            this.z = q.z / s;\n        }\n        return this;\n    },\n    setAxisAngleFromRotationMatrix: function(m) {\n        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\n        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n        var angle, x, y, z, epsilon = 0.01, epsilon2 = 0.1, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];\n        if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {\n            // singularity found\n            // first check for identity matrix which must have +1 for all terms\n            // in leading diagonal and zero in other terms\n            if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {\n                // this singularity is identity matrix so angle = 0\n                this.set(1, 0, 0, 0);\n                return this; // zero angle, arbitrary axis\n            }\n            // otherwise this singularity is angle = 180\n            angle = Math.PI;\n            var xx = (m11 + 1) / 2;\n            var yy = (m22 + 1) / 2;\n            var zz = (m33 + 1) / 2;\n            var xy = (m12 + m21) / 4;\n            var xz = (m13 + m31) / 4;\n            var yz = (m23 + m32) / 4;\n            if (xx > yy && xx > zz) {\n                if (xx < epsilon) {\n                    x = 0;\n                    y = 0.707106781;\n                    z = 0.707106781;\n                } else {\n                    x = Math.sqrt(xx);\n                    y = xy / x;\n                    z = xz / x;\n                }\n            } else if (yy > zz) {\n                if (yy < epsilon) {\n                    x = 0.707106781;\n                    y = 0;\n                    z = 0.707106781;\n                } else {\n                    y = Math.sqrt(yy);\n                    x = xy / y;\n                    z = yz / y;\n                }\n            } else if (zz < epsilon) {\n                x = 0.707106781;\n                y = 0.707106781;\n                z = 0;\n            } else {\n                z = Math.sqrt(zz);\n                x = xz / z;\n                y = yz / z;\n            }\n            this.set(x, y, z, angle);\n            return this; // return 180 deg rotation\n        }\n        // as we have reached here there are no singularities so we can handle normally\n        var s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12)); // used to normalize\n        if (Math.abs(s) < 0.001) s = 1;\n        // prevent divide by zero, should not happen if matrix is orthogonal and should be\n        // caught by singularity test above, but I've left it in just in case\n        this.x = (m32 - m23) / s;\n        this.y = (m13 - m31) / s;\n        this.z = (m21 - m12) / s;\n        this.w = Math.acos((m11 + m22 + m33 - 1) / 2);\n        return this;\n    },\n    min: function(v) {\n        if (this.x > v.x) this.x = v.x;\n        if (this.y > v.y) this.y = v.y;\n        if (this.z > v.z) this.z = v.z;\n        if (this.w > v.w) this.w = v.w;\n        return this;\n    },\n    max: function(v) {\n        if (this.x < v.x) this.x = v.x;\n        if (this.y < v.y) this.y = v.y;\n        if (this.z < v.z) this.z = v.z;\n        if (this.w < v.w) this.w = v.w;\n        return this;\n    },\n    clamp: function(min, max) {\n        // This function assumes min < max, if this assumption isn't true it will not operate correctly\n        if (this.x < min.x) this.x = min.x;\n        else if (this.x > max.x) this.x = max.x;\n        if (this.y < min.y) this.y = min.y;\n        else if (this.y > max.y) this.y = max.y;\n        if (this.z < min.z) this.z = min.z;\n        else if (this.z > max.z) this.z = max.z;\n        if (this.w < min.w) this.w = min.w;\n        else if (this.w > max.w) this.w = max.w;\n        return this;\n    },\n    negate: function() {\n        return this.multiplyScalar(-1);\n    },\n    dot: function(v) {\n        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n    },\n    lengthSq: function() {\n        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n    },\n    length: function() {\n        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\n    },\n    lengthManhattan: function() {\n        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);\n    },\n    normalize: function() {\n        return this.divideScalar(this.length());\n    },\n    setLength: function(l) {\n        var oldLength = this.length();\n        if (oldLength !== 0 && l !== oldLength) this.multiplyScalar(l / oldLength);\n        return this;\n    },\n    lerp: function(v, alpha) {\n        this.x += (v.x - this.x) * alpha;\n        this.y += (v.y - this.y) * alpha;\n        this.z += (v.z - this.z) * alpha;\n        this.w += (v.w - this.w) * alpha;\n        return this;\n    },\n    equals: function(v) {\n        return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;\n    },\n    toArray: function() {\n        return [\n            this.x,\n            this.y,\n            this.z,\n            this.w\n        ];\n    },\n    clone: function() {\n        return new THREE.Vector4(this.x, this.y, this.z, this.w);\n    }\n});\n/**\n * @author bhouston / http://exocortex.com\n */ THREE.Box2 = function(min, max) {\n    this.min = min !== undefined ? min : new THREE.Vector2(Infinity, Infinity);\n    this.max = max !== undefined ? max : new THREE.Vector2(-Infinity, -Infinity);\n};\nTHREE.extend(THREE.Box2.prototype, {\n    set: function(min, max) {\n        this.min.copy(min);\n        this.max.copy(max);\n        return this;\n    },\n    setFromPoints: function(points) {\n        if (points.length > 0) {\n            var point = points[0];\n            this.min.copy(point);\n            this.max.copy(point);\n            for(var i = 1, il = points.length; i < il; i++){\n                point = points[i];\n                if (point.x < this.min.x) this.min.x = point.x;\n                else if (point.x > this.max.x) this.max.x = point.x;\n                if (point.y < this.min.y) this.min.y = point.y;\n                else if (point.y > this.max.y) this.max.y = point.y;\n            }\n        } else this.makeEmpty();\n        return this;\n    },\n    setFromCenterAndSize: function() {\n        var v1 = new THREE.Vector2();\n        return function(center, size) {\n            var halfSize = v1.copy(size).multiplyScalar(0.5);\n            this.min.copy(center).sub(halfSize);\n            this.max.copy(center).add(halfSize);\n            return this;\n        };\n    }(),\n    copy: function(box) {\n        this.min.copy(box.min);\n        this.max.copy(box.max);\n        return this;\n    },\n    makeEmpty: function() {\n        this.min.x = this.min.y = Infinity;\n        this.max.x = this.max.y = -Infinity;\n        return this;\n    },\n    empty: function() {\n        // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n        return this.max.x < this.min.x || this.max.y < this.min.y;\n    },\n    center: function(optionalTarget) {\n        var result = optionalTarget || new THREE.Vector2();\n        return result.addVectors(this.min, this.max).multiplyScalar(0.5);\n    },\n    size: function(optionalTarget) {\n        var result = optionalTarget || new THREE.Vector2();\n        return result.subVectors(this.max, this.min);\n    },\n    expandByPoint: function(point) {\n        this.min.min(point);\n        this.max.max(point);\n        return this;\n    },\n    expandByVector: function(vector) {\n        this.min.sub(vector);\n        this.max.add(vector);\n        return this;\n    },\n    expandByScalar: function(scalar) {\n        this.min.addScalar(-scalar);\n        this.max.addScalar(scalar);\n        return this;\n    },\n    containsPoint: function(point) {\n        if (point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y) return false;\n        return true;\n    },\n    containsBox: function(box) {\n        if (this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y) return true;\n        return false;\n    },\n    getParameter: function(point) {\n        // This can potentially have a divide by zero if the box\n        // has a size dimension of 0.\n        return new THREE.Vector2((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));\n    },\n    isIntersectionBox: function(box) {\n        // using 6 splitting planes to rule out intersections.\n        if (box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y) return false;\n        return true;\n    },\n    clampPoint: function(point, optionalTarget) {\n        var result = optionalTarget || new THREE.Vector2();\n        return result.copy(point).clamp(this.min, this.max);\n    },\n    distanceToPoint: function() {\n        var v1 = new THREE.Vector2();\n        return function(point) {\n            var clampedPoint = v1.copy(point).clamp(this.min, this.max);\n            return clampedPoint.sub(point).length();\n        };\n    }(),\n    intersect: function(box) {\n        this.min.max(box.min);\n        this.max.min(box.max);\n        return this;\n    },\n    union: function(box) {\n        this.min.min(box.min);\n        this.max.max(box.max);\n        return this;\n    },\n    translate: function(offset) {\n        this.min.add(offset);\n        this.max.add(offset);\n        return this;\n    },\n    equals: function(box) {\n        return box.min.equals(this.min) && box.max.equals(this.max);\n    },\n    clone: function() {\n        return new THREE.Box2().copy(this);\n    }\n});\n/**\n * @author bhouston / http://exocortex.com\n */ THREE.Box3 = function(min, max) {\n    this.min = min !== undefined ? min : new THREE.Vector3(Infinity, Infinity, Infinity);\n    this.max = max !== undefined ? max : new THREE.Vector3(-Infinity, -Infinity, -Infinity);\n};\nTHREE.extend(THREE.Box3.prototype, {\n    set: function(min, max) {\n        this.min.copy(min);\n        this.max.copy(max);\n        return this;\n    },\n    setFromPoints: function(points) {\n        if (points.length > 0) {\n            var point = points[0];\n            this.min.copy(point);\n            this.max.copy(point);\n            for(var i = 1, il = points.length; i < il; i++){\n                point = points[i];\n                if (point.x < this.min.x) this.min.x = point.x;\n                else if (point.x > this.max.x) this.max.x = point.x;\n                if (point.y < this.min.y) this.min.y = point.y;\n                else if (point.y > this.max.y) this.max.y = point.y;\n                if (point.z < this.min.z) this.min.z = point.z;\n                else if (point.z > this.max.z) this.max.z = point.z;\n            }\n        } else this.makeEmpty();\n        return this;\n    },\n    setFromCenterAndSize: function() {\n        var v1 = new THREE.Vector3();\n        return function(center, size) {\n            var halfSize = v1.copy(size).multiplyScalar(0.5);\n            this.min.copy(center).sub(halfSize);\n            this.max.copy(center).add(halfSize);\n            return this;\n        };\n    }(),\n    copy: function(box) {\n        this.min.copy(box.min);\n        this.max.copy(box.max);\n        return this;\n    },\n    makeEmpty: function() {\n        this.min.x = this.min.y = this.min.z = Infinity;\n        this.max.x = this.max.y = this.max.z = -Infinity;\n        return this;\n    },\n    empty: function() {\n        // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;\n    },\n    center: function(optionalTarget) {\n        var result = optionalTarget || new THREE.Vector3();\n        return result.addVectors(this.min, this.max).multiplyScalar(0.5);\n    },\n    size: function(optionalTarget) {\n        var result = optionalTarget || new THREE.Vector3();\n        return result.subVectors(this.max, this.min);\n    },\n    expandByPoint: function(point) {\n        this.min.min(point);\n        this.max.max(point);\n        return this;\n    },\n    expandByVector: function(vector) {\n        this.min.sub(vector);\n        this.max.add(vector);\n        return this;\n    },\n    expandByScalar: function(scalar) {\n        this.min.addScalar(-scalar);\n        this.max.addScalar(scalar);\n        return this;\n    },\n    containsPoint: function(point) {\n        if (point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z) return false;\n        return true;\n    },\n    containsBox: function(box) {\n        if (this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z) return true;\n        return false;\n    },\n    getParameter: function(point) {\n        // This can potentially have a divide by zero if the box\n        // has a size dimension of 0.\n        return new THREE.Vector3((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));\n    },\n    isIntersectionBox: function(box) {\n        // using 6 splitting planes to rule out intersections.\n        if (box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z) return false;\n        return true;\n    },\n    clampPoint: function(point, optionalTarget) {\n        var result = optionalTarget || new THREE.Vector3();\n        return result.copy(point).clamp(this.min, this.max);\n    },\n    distanceToPoint: function() {\n        var v1 = new THREE.Vector3();\n        return function(point) {\n            var clampedPoint = v1.copy(point).clamp(this.min, this.max);\n            return clampedPoint.sub(point).length();\n        };\n    }(),\n    getBoundingSphere: function() {\n        var v1 = new THREE.Vector3();\n        return function(optionalTarget) {\n            var result = optionalTarget || new THREE.Sphere();\n            result.center = this.center();\n            result.radius = this.size(v1).length() * 0.5;\n            return result;\n        };\n    }(),\n    intersect: function(box) {\n        this.min.max(box.min);\n        this.max.min(box.max);\n        return this;\n    },\n    union: function(box) {\n        this.min.min(box.min);\n        this.max.max(box.max);\n        return this;\n    },\n    applyMatrix4: function() {\n        var points = [\n            new THREE.Vector3(),\n            new THREE.Vector3(),\n            new THREE.Vector3(),\n            new THREE.Vector3(),\n            new THREE.Vector3(),\n            new THREE.Vector3(),\n            new THREE.Vector3(),\n            new THREE.Vector3()\n        ];\n        return function(matrix) {\n            // NOTE: I am using a binary pattern to specify all 2^3 combinations below\n            points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000\n            points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001\n            points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010\n            points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011\n            points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100\n            points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101\n            points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110\n            points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111\n            this.makeEmpty();\n            this.setFromPoints(points);\n            return this;\n        };\n    }(),\n    translate: function(offset) {\n        this.min.add(offset);\n        this.max.add(offset);\n        return this;\n    },\n    equals: function(box) {\n        return box.min.equals(this.min) && box.max.equals(this.max);\n    },\n    clone: function() {\n        return new THREE.Box3().copy(this);\n    }\n});\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author bhouston / http://exocortex.com\n */ THREE.Matrix3 = function(n11, n12, n13, n21, n22, n23, n31, n32, n33) {\n    this.elements = new Float32Array(9);\n    this.set(n11 !== undefined ? n11 : 1, n12 || 0, n13 || 0, n21 || 0, n22 !== undefined ? n22 : 1, n23 || 0, n31 || 0, n32 || 0, n33 !== undefined ? n33 : 1);\n};\nTHREE.extend(THREE.Matrix3.prototype, {\n    set: function(n11, n12, n13, n21, n22, n23, n31, n32, n33) {\n        var te = this.elements;\n        te[0] = n11;\n        te[3] = n12;\n        te[6] = n13;\n        te[1] = n21;\n        te[4] = n22;\n        te[7] = n23;\n        te[2] = n31;\n        te[5] = n32;\n        te[8] = n33;\n        return this;\n    },\n    identity: function() {\n        this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);\n        return this;\n    },\n    copy: function(m) {\n        var me = m.elements;\n        this.set(me[0], me[3], me[6], me[1], me[4], me[7], me[2], me[5], me[8]);\n        return this;\n    },\n    multiplyVector3: function(vector) {\n        console.warn(\"DEPRECATED: Matrix3's .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.\");\n        return vector.applyMatrix3(this);\n    },\n    multiplyVector3Array: function() {\n        var v1 = new THREE.Vector3();\n        return function(a) {\n            for(var i = 0, il = a.length; i < il; i += 3){\n                v1.x = a[i];\n                v1.y = a[i + 1];\n                v1.z = a[i + 2];\n                v1.applyMatrix3(this);\n                a[i] = v1.x;\n                a[i + 1] = v1.y;\n                a[i + 2] = v1.z;\n            }\n            return a;\n        };\n    }(),\n    multiplyScalar: function(s) {\n        var te = this.elements;\n        te[0] *= s;\n        te[3] *= s;\n        te[6] *= s;\n        te[1] *= s;\n        te[4] *= s;\n        te[7] *= s;\n        te[2] *= s;\n        te[5] *= s;\n        te[8] *= s;\n        return this;\n    },\n    determinant: function() {\n        var te = this.elements;\n        var a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i = te[8];\n        return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\n    },\n    getInverse: function(matrix, throwOnInvertible) {\n        // input: THREE.Matrix4\n        // ( based on http://code.google.com/p/webgl-mjs/ )\n        var me = matrix.elements;\n        var te = this.elements;\n        te[0] = me[10] * me[5] - me[6] * me[9];\n        te[1] = -me[10] * me[1] + me[2] * me[9];\n        te[2] = me[6] * me[1] - me[2] * me[5];\n        te[3] = -me[10] * me[4] + me[6] * me[8];\n        te[4] = me[10] * me[0] - me[2] * me[8];\n        te[5] = -me[6] * me[0] + me[2] * me[4];\n        te[6] = me[9] * me[4] - me[5] * me[8];\n        te[7] = -me[9] * me[0] + me[1] * me[8];\n        te[8] = me[5] * me[0] - me[1] * me[4];\n        var det = me[0] * te[0] + me[1] * te[3] + me[2] * te[6];\n        // no inverse\n        if (det === 0) {\n            var msg = \"Matrix3.getInverse(): can't invert matrix, determinant is 0\";\n            if (throwOnInvertible || false) throw new Error(msg);\n            else console.warn(msg);\n            this.identity();\n            return this;\n        }\n        this.multiplyScalar(1.0 / det);\n        return this;\n    },\n    transpose: function() {\n        var tmp, m = this.elements;\n        tmp = m[1];\n        m[1] = m[3];\n        m[3] = tmp;\n        tmp = m[2];\n        m[2] = m[6];\n        m[6] = tmp;\n        tmp = m[5];\n        m[5] = m[7];\n        m[7] = tmp;\n        return this;\n    },\n    getNormalMatrix: function(m) {\n        // input: THREE.Matrix4\n        this.getInverse(m).transpose();\n        return this;\n    },\n    transposeIntoArray: function(r) {\n        var m = this.elements;\n        r[0] = m[0];\n        r[1] = m[3];\n        r[2] = m[6];\n        r[3] = m[1];\n        r[4] = m[4];\n        r[5] = m[7];\n        r[6] = m[2];\n        r[7] = m[5];\n        r[8] = m[8];\n        return this;\n    },\n    clone: function() {\n        var te = this.elements;\n        return new THREE.Matrix3(te[0], te[3], te[6], te[1], te[4], te[7], te[2], te[5], te[8]);\n    }\n});\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author supereggbert / http://www.paulbrunt.co.uk/\n * @author philogb / http://blog.thejit.org/\n * @author jordi_ros / http://plattsoft.com\n * @author D1plo1d / http://github.com/D1plo1d\n * @author alteredq / http://alteredqualia.com/\n * @author mikael emtinger / http://gomo.se/\n * @author timknip / http://www.floorplanner.com/\n * @author bhouston / http://exocortex.com\n */ THREE.Matrix4 = function(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {\n    var te = this.elements = new Float32Array(16);\n    // TODO: if n11 is undefined, then just set to identity, otherwise copy all other values into matrix\n    //   we should not support semi specification of Matrix4, it is just weird.\n    te[0] = n11 !== undefined ? n11 : 1;\n    te[4] = n12 || 0;\n    te[8] = n13 || 0;\n    te[12] = n14 || 0;\n    te[1] = n21 || 0;\n    te[5] = n22 !== undefined ? n22 : 1;\n    te[9] = n23 || 0;\n    te[13] = n24 || 0;\n    te[2] = n31 || 0;\n    te[6] = n32 || 0;\n    te[10] = n33 !== undefined ? n33 : 1;\n    te[14] = n34 || 0;\n    te[3] = n41 || 0;\n    te[7] = n42 || 0;\n    te[11] = n43 || 0;\n    te[15] = n44 !== undefined ? n44 : 1;\n};\nTHREE.extend(THREE.Matrix4.prototype, {\n    set: function(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {\n        var te = this.elements;\n        te[0] = n11;\n        te[4] = n12;\n        te[8] = n13;\n        te[12] = n14;\n        te[1] = n21;\n        te[5] = n22;\n        te[9] = n23;\n        te[13] = n24;\n        te[2] = n31;\n        te[6] = n32;\n        te[10] = n33;\n        te[14] = n34;\n        te[3] = n41;\n        te[7] = n42;\n        te[11] = n43;\n        te[15] = n44;\n        return this;\n    },\n    identity: function() {\n        this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n        return this;\n    },\n    copy: function(m) {\n        var me = m.elements;\n        this.set(me[0], me[4], me[8], me[12], me[1], me[5], me[9], me[13], me[2], me[6], me[10], me[14], me[3], me[7], me[11], me[15]);\n        return this;\n    },\n    setRotationFromEuler: function(v, order) {\n        var te = this.elements;\n        var x = v.x, y = v.y, z = v.z;\n        var a = Math.cos(x), b = Math.sin(x);\n        var c = Math.cos(y), d = Math.sin(y);\n        var e = Math.cos(z), f = Math.sin(z);\n        if (order === undefined || order === \"XYZ\") {\n            var ae = a * e, af = a * f, be = b * e, bf = b * f;\n            te[0] = c * e;\n            te[4] = -c * f;\n            te[8] = d;\n            te[1] = af + be * d;\n            te[5] = ae - bf * d;\n            te[9] = -b * c;\n            te[2] = bf - ae * d;\n            te[6] = be + af * d;\n            te[10] = a * c;\n        } else if (order === \"YXZ\") {\n            var ce = c * e, cf = c * f, de = d * e, df = d * f;\n            te[0] = ce + df * b;\n            te[4] = de * b - cf;\n            te[8] = a * d;\n            te[1] = a * f;\n            te[5] = a * e;\n            te[9] = -b;\n            te[2] = cf * b - de;\n            te[6] = df + ce * b;\n            te[10] = a * c;\n        } else if (order === \"ZXY\") {\n            var ce = c * e, cf = c * f, de = d * e, df = d * f;\n            te[0] = ce - df * b;\n            te[4] = -a * f;\n            te[8] = de + cf * b;\n            te[1] = cf + de * b;\n            te[5] = a * e;\n            te[9] = df - ce * b;\n            te[2] = -a * d;\n            te[6] = b;\n            te[10] = a * c;\n        } else if (order === \"ZYX\") {\n            var ae = a * e, af = a * f, be = b * e, bf = b * f;\n            te[0] = c * e;\n            te[4] = be * d - af;\n            te[8] = ae * d + bf;\n            te[1] = c * f;\n            te[5] = bf * d + ae;\n            te[9] = af * d - be;\n            te[2] = -d;\n            te[6] = b * c;\n            te[10] = a * c;\n        } else if (order === \"YZX\") {\n            var ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n            te[0] = c * e;\n            te[4] = bd - ac * f;\n            te[8] = bc * f + ad;\n            te[1] = f;\n            te[5] = a * e;\n            te[9] = -b * e;\n            te[2] = -d * e;\n            te[6] = ad * f + bc;\n            te[10] = ac - bd * f;\n        } else if (order === \"XZY\") {\n            var ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n            te[0] = c * e;\n            te[4] = -f;\n            te[8] = d * e;\n            te[1] = ac * f + bd;\n            te[5] = a * e;\n            te[9] = ad * f - bc;\n            te[2] = bc * f - ad;\n            te[6] = b * e;\n            te[10] = bd * f + ac;\n        }\n        return this;\n    },\n    setRotationFromQuaternion: function(q) {\n        var te = this.elements;\n        var x = q.x, y = q.y, z = q.z, w = q.w;\n        var x2 = x + x, y2 = y + y, z2 = z + z;\n        var xx = x * x2, xy = x * y2, xz = x * z2;\n        var yy = y * y2, yz = y * z2, zz = z * z2;\n        var wx = w * x2, wy = w * y2, wz = w * z2;\n        te[0] = 1 - (yy + zz);\n        te[4] = xy - wz;\n        te[8] = xz + wy;\n        te[1] = xy + wz;\n        te[5] = 1 - (xx + zz);\n        te[9] = yz - wx;\n        te[2] = xz - wy;\n        te[6] = yz + wx;\n        te[10] = 1 - (xx + yy);\n        return this;\n    },\n    lookAt: function() {\n        var x = new THREE.Vector3();\n        var y = new THREE.Vector3();\n        var z = new THREE.Vector3();\n        return function(eye, target, up) {\n            var te = this.elements;\n            z.subVectors(eye, target).normalize();\n            if (z.length() === 0) z.z = 1;\n            x.crossVectors(up, z).normalize();\n            if (x.length() === 0) {\n                z.x += 0.0001;\n                x.crossVectors(up, z).normalize();\n            }\n            y.crossVectors(z, x);\n            te[0] = x.x;\n            te[4] = y.x;\n            te[8] = z.x;\n            te[1] = x.y;\n            te[5] = y.y;\n            te[9] = z.y;\n            te[2] = x.z;\n            te[6] = y.z;\n            te[10] = z.z;\n            return this;\n        };\n    }(),\n    multiply: function(m, n) {\n        if (n !== undefined) {\n            console.warn(\"DEPRECATED: Matrix4's .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.\");\n            return this.multiplyMatrices(m, n);\n        }\n        return this.multiplyMatrices(this, m);\n    },\n    multiplyMatrices: function(a, b) {\n        var ae = a.elements;\n        var be = b.elements;\n        var te = this.elements;\n        var a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];\n        var a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];\n        var a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];\n        var a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];\n        var b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];\n        var b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];\n        var b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];\n        var b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];\n        te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n        te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n        te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n        te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n        te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n        te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n        te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n        te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n        te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n        te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n        te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n        te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n        te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n        te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n        te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n        te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n        return this;\n    },\n    multiplyToArray: function(a, b, r) {\n        var te = this.elements;\n        this.multiplyMatrices(a, b);\n        r[0] = te[0];\n        r[1] = te[1];\n        r[2] = te[2];\n        r[3] = te[3];\n        r[4] = te[4];\n        r[5] = te[5];\n        r[6] = te[6];\n        r[7] = te[7];\n        r[8] = te[8];\n        r[9] = te[9];\n        r[10] = te[10];\n        r[11] = te[11];\n        r[12] = te[12];\n        r[13] = te[13];\n        r[14] = te[14];\n        r[15] = te[15];\n        return this;\n    },\n    multiplyScalar: function(s) {\n        var te = this.elements;\n        te[0] *= s;\n        te[4] *= s;\n        te[8] *= s;\n        te[12] *= s;\n        te[1] *= s;\n        te[5] *= s;\n        te[9] *= s;\n        te[13] *= s;\n        te[2] *= s;\n        te[6] *= s;\n        te[10] *= s;\n        te[14] *= s;\n        te[3] *= s;\n        te[7] *= s;\n        te[11] *= s;\n        te[15] *= s;\n        return this;\n    },\n    multiplyVector3: function(vector) {\n        console.warn(\"DEPRECATED: Matrix4's .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.\");\n        return vector.applyProjection(this);\n    },\n    multiplyVector4: function(vector) {\n        console.warn(\"DEPRECATED: Matrix4's .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.\");\n        return vector.applyMatrix4(this);\n    },\n    multiplyVector3Array: function() {\n        var v1 = new THREE.Vector3();\n        return function(a) {\n            for(var i = 0, il = a.length; i < il; i += 3){\n                v1.x = a[i];\n                v1.y = a[i + 1];\n                v1.z = a[i + 2];\n                v1.applyProjection(this);\n                a[i] = v1.x;\n                a[i + 1] = v1.y;\n                a[i + 2] = v1.z;\n            }\n            return a;\n        };\n    }(),\n    rotateAxis: function(v) {\n        var te = this.elements;\n        var vx = v.x, vy = v.y, vz = v.z;\n        v.x = vx * te[0] + vy * te[4] + vz * te[8];\n        v.y = vx * te[1] + vy * te[5] + vz * te[9];\n        v.z = vx * te[2] + vy * te[6] + vz * te[10];\n        v.normalize();\n        return v;\n    },\n    crossVector: function(a) {\n        var te = this.elements;\n        var v = new THREE.Vector4();\n        v.x = te[0] * a.x + te[4] * a.y + te[8] * a.z + te[12] * a.w;\n        v.y = te[1] * a.x + te[5] * a.y + te[9] * a.z + te[13] * a.w;\n        v.z = te[2] * a.x + te[6] * a.y + te[10] * a.z + te[14] * a.w;\n        v.w = a.w ? te[3] * a.x + te[7] * a.y + te[11] * a.z + te[15] * a.w : 1;\n        return v;\n    },\n    determinant: function() {\n        var te = this.elements;\n        var n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];\n        var n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];\n        var n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];\n        var n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];\n        //TODO: make this more efficient\n        //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\n        return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);\n    },\n    transpose: function() {\n        var te = this.elements;\n        var tmp;\n        tmp = te[1];\n        te[1] = te[4];\n        te[4] = tmp;\n        tmp = te[2];\n        te[2] = te[8];\n        te[8] = tmp;\n        tmp = te[6];\n        te[6] = te[9];\n        te[9] = tmp;\n        tmp = te[3];\n        te[3] = te[12];\n        te[12] = tmp;\n        tmp = te[7];\n        te[7] = te[13];\n        te[13] = tmp;\n        tmp = te[11];\n        te[11] = te[14];\n        te[14] = tmp;\n        return this;\n    },\n    flattenToArray: function(flat) {\n        var te = this.elements;\n        flat[0] = te[0];\n        flat[1] = te[1];\n        flat[2] = te[2];\n        flat[3] = te[3];\n        flat[4] = te[4];\n        flat[5] = te[5];\n        flat[6] = te[6];\n        flat[7] = te[7];\n        flat[8] = te[8];\n        flat[9] = te[9];\n        flat[10] = te[10];\n        flat[11] = te[11];\n        flat[12] = te[12];\n        flat[13] = te[13];\n        flat[14] = te[14];\n        flat[15] = te[15];\n        return flat;\n    },\n    flattenToArrayOffset: function(flat, offset) {\n        var te = this.elements;\n        flat[offset] = te[0];\n        flat[offset + 1] = te[1];\n        flat[offset + 2] = te[2];\n        flat[offset + 3] = te[3];\n        flat[offset + 4] = te[4];\n        flat[offset + 5] = te[5];\n        flat[offset + 6] = te[6];\n        flat[offset + 7] = te[7];\n        flat[offset + 8] = te[8];\n        flat[offset + 9] = te[9];\n        flat[offset + 10] = te[10];\n        flat[offset + 11] = te[11];\n        flat[offset + 12] = te[12];\n        flat[offset + 13] = te[13];\n        flat[offset + 14] = te[14];\n        flat[offset + 15] = te[15];\n        return flat;\n    },\n    getPosition: function() {\n        var v1 = new THREE.Vector3();\n        return function() {\n            console.warn(\"DEPRECATED: Matrix4's .getPosition() has been removed. Use Vector3.getPositionFromMatrix( matrix ) instead.\");\n            var te = this.elements;\n            return v1.set(te[12], te[13], te[14]);\n        };\n    }(),\n    setPosition: function(v) {\n        var te = this.elements;\n        te[12] = v.x;\n        te[13] = v.y;\n        te[14] = v.z;\n        return this;\n    },\n    getInverse: function(m, throwOnInvertible) {\n        // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n        var te = this.elements;\n        var me = m.elements;\n        var n11 = me[0], n12 = me[4], n13 = me[8], n14 = me[12];\n        var n21 = me[1], n22 = me[5], n23 = me[9], n24 = me[13];\n        var n31 = me[2], n32 = me[6], n33 = me[10], n34 = me[14];\n        var n41 = me[3], n42 = me[7], n43 = me[11], n44 = me[15];\n        te[0] = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;\n        te[4] = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;\n        te[8] = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;\n        te[12] = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n        te[1] = n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;\n        te[5] = n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;\n        te[9] = n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;\n        te[13] = n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;\n        te[2] = n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;\n        te[6] = n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;\n        te[10] = n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;\n        te[14] = n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;\n        te[3] = n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;\n        te[7] = n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;\n        te[11] = n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;\n        te[15] = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;\n        var det = me[0] * te[0] + me[1] * te[4] + me[2] * te[8] + me[3] * te[12];\n        if (det == 0) {\n            var msg = \"Matrix4.getInverse(): can't invert matrix, determinant is 0\";\n            if (throwOnInvertible || false) throw new Error(msg);\n            else console.warn(msg);\n            this.identity();\n            return this;\n        }\n        this.multiplyScalar(1 / det);\n        return this;\n    },\n    compose: function() {\n        var mRotation = new THREE.Matrix4(), mScale = new THREE.Matrix4();\n        return function(translation, rotation, scale) {\n            var te = this.elements;\n            mRotation.identity();\n            mRotation.setRotationFromQuaternion(rotation);\n            mScale.makeScale(scale.x, scale.y, scale.z);\n            this.multiplyMatrices(mRotation, mScale);\n            te[12] = translation.x;\n            te[13] = translation.y;\n            te[14] = translation.z;\n            return this;\n        };\n    }(),\n    decompose: function() {\n        var x = new THREE.Vector3(), y = new THREE.Vector3(), z = new THREE.Vector3(), matrix = new THREE.Matrix4();\n        return function(translation, rotation, scale) {\n            var te = this.elements;\n            // grab the axis vectors\n            x.set(te[0], te[1], te[2]);\n            y.set(te[4], te[5], te[6]);\n            z.set(te[8], te[9], te[10]);\n            translation = translation instanceof THREE.Vector3 ? translation : new THREE.Vector3();\n            rotation = rotation instanceof THREE.Quaternion ? rotation : new THREE.Quaternion();\n            scale = scale instanceof THREE.Vector3 ? scale : new THREE.Vector3();\n            scale.x = x.length();\n            scale.y = y.length();\n            scale.z = z.length();\n            translation.x = te[12];\n            translation.y = te[13];\n            translation.z = te[14];\n            // scale the rotation part\n            matrix.copy(this);\n            matrix.elements[0] /= scale.x;\n            matrix.elements[1] /= scale.x;\n            matrix.elements[2] /= scale.x;\n            matrix.elements[4] /= scale.y;\n            matrix.elements[5] /= scale.y;\n            matrix.elements[6] /= scale.y;\n            matrix.elements[8] /= scale.z;\n            matrix.elements[9] /= scale.z;\n            matrix.elements[10] /= scale.z;\n            rotation.setFromRotationMatrix(matrix);\n            return [\n                translation,\n                rotation,\n                scale\n            ];\n        };\n    }(),\n    extractPosition: function(m) {\n        var te = this.elements;\n        var me = m.elements;\n        te[12] = me[12];\n        te[13] = me[13];\n        te[14] = me[14];\n        return this;\n    },\n    extractRotation: function() {\n        var v1 = new THREE.Vector3();\n        return function(m) {\n            var te = this.elements;\n            var me = m.elements;\n            var scaleX = 1 / v1.set(me[0], me[1], me[2]).length();\n            var scaleY = 1 / v1.set(me[4], me[5], me[6]).length();\n            var scaleZ = 1 / v1.set(me[8], me[9], me[10]).length();\n            te[0] = me[0] * scaleX;\n            te[1] = me[1] * scaleX;\n            te[2] = me[2] * scaleX;\n            te[4] = me[4] * scaleY;\n            te[5] = me[5] * scaleY;\n            te[6] = me[6] * scaleY;\n            te[8] = me[8] * scaleZ;\n            te[9] = me[9] * scaleZ;\n            te[10] = me[10] * scaleZ;\n            return this;\n        };\n    }(),\n    translate: function(v) {\n        var te = this.elements;\n        var x = v.x, y = v.y, z = v.z;\n        te[12] = te[0] * x + te[4] * y + te[8] * z + te[12];\n        te[13] = te[1] * x + te[5] * y + te[9] * z + te[13];\n        te[14] = te[2] * x + te[6] * y + te[10] * z + te[14];\n        te[15] = te[3] * x + te[7] * y + te[11] * z + te[15];\n        return this;\n    },\n    rotateX: function(angle) {\n        var te = this.elements;\n        var m12 = te[4];\n        var m22 = te[5];\n        var m32 = te[6];\n        var m42 = te[7];\n        var m13 = te[8];\n        var m23 = te[9];\n        var m33 = te[10];\n        var m43 = te[11];\n        var c = Math.cos(angle);\n        var s = Math.sin(angle);\n        te[4] = c * m12 + s * m13;\n        te[5] = c * m22 + s * m23;\n        te[6] = c * m32 + s * m33;\n        te[7] = c * m42 + s * m43;\n        te[8] = c * m13 - s * m12;\n        te[9] = c * m23 - s * m22;\n        te[10] = c * m33 - s * m32;\n        te[11] = c * m43 - s * m42;\n        return this;\n    },\n    rotateY: function(angle) {\n        var te = this.elements;\n        var m11 = te[0];\n        var m21 = te[1];\n        var m31 = te[2];\n        var m41 = te[3];\n        var m13 = te[8];\n        var m23 = te[9];\n        var m33 = te[10];\n        var m43 = te[11];\n        var c = Math.cos(angle);\n        var s = Math.sin(angle);\n        te[0] = c * m11 - s * m13;\n        te[1] = c * m21 - s * m23;\n        te[2] = c * m31 - s * m33;\n        te[3] = c * m41 - s * m43;\n        te[8] = c * m13 + s * m11;\n        te[9] = c * m23 + s * m21;\n        te[10] = c * m33 + s * m31;\n        te[11] = c * m43 + s * m41;\n        return this;\n    },\n    rotateZ: function(angle) {\n        var te = this.elements;\n        var m11 = te[0];\n        var m21 = te[1];\n        var m31 = te[2];\n        var m41 = te[3];\n        var m12 = te[4];\n        var m22 = te[5];\n        var m32 = te[6];\n        var m42 = te[7];\n        var c = Math.cos(angle);\n        var s = Math.sin(angle);\n        te[0] = c * m11 + s * m12;\n        te[1] = c * m21 + s * m22;\n        te[2] = c * m31 + s * m32;\n        te[3] = c * m41 + s * m42;\n        te[4] = c * m12 - s * m11;\n        te[5] = c * m22 - s * m21;\n        te[6] = c * m32 - s * m31;\n        te[7] = c * m42 - s * m41;\n        return this;\n    },\n    rotateByAxis: function(axis, angle) {\n        var te = this.elements;\n        // optimize by checking axis\n        if (axis.x === 1 && axis.y === 0 && axis.z === 0) return this.rotateX(angle);\n        else if (axis.x === 0 && axis.y === 1 && axis.z === 0) return this.rotateY(angle);\n        else if (axis.x === 0 && axis.y === 0 && axis.z === 1) return this.rotateZ(angle);\n        var x = axis.x, y = axis.y, z = axis.z;\n        var n = Math.sqrt(x * x + y * y + z * z);\n        x /= n;\n        y /= n;\n        z /= n;\n        var xx = x * x, yy = y * y, zz = z * z;\n        var c = Math.cos(angle);\n        var s = Math.sin(angle);\n        var oneMinusCosine = 1 - c;\n        var xy = x * y * oneMinusCosine;\n        var xz = x * z * oneMinusCosine;\n        var yz = y * z * oneMinusCosine;\n        var xs = x * s;\n        var ys = y * s;\n        var zs = z * s;\n        var r11 = xx + (1 - xx) * c;\n        var r21 = xy + zs;\n        var r31 = xz - ys;\n        var r12 = xy - zs;\n        var r22 = yy + (1 - yy) * c;\n        var r32 = yz + xs;\n        var r13 = xz + ys;\n        var r23 = yz - xs;\n        var r33 = zz + (1 - zz) * c;\n        var m11 = te[0], m21 = te[1], m31 = te[2], m41 = te[3];\n        var m12 = te[4], m22 = te[5], m32 = te[6], m42 = te[7];\n        var m13 = te[8], m23 = te[9], m33 = te[10], m43 = te[11];\n        te[0] = r11 * m11 + r21 * m12 + r31 * m13;\n        te[1] = r11 * m21 + r21 * m22 + r31 * m23;\n        te[2] = r11 * m31 + r21 * m32 + r31 * m33;\n        te[3] = r11 * m41 + r21 * m42 + r31 * m43;\n        te[4] = r12 * m11 + r22 * m12 + r32 * m13;\n        te[5] = r12 * m21 + r22 * m22 + r32 * m23;\n        te[6] = r12 * m31 + r22 * m32 + r32 * m33;\n        te[7] = r12 * m41 + r22 * m42 + r32 * m43;\n        te[8] = r13 * m11 + r23 * m12 + r33 * m13;\n        te[9] = r13 * m21 + r23 * m22 + r33 * m23;\n        te[10] = r13 * m31 + r23 * m32 + r33 * m33;\n        te[11] = r13 * m41 + r23 * m42 + r33 * m43;\n        return this;\n    },\n    scale: function(v) {\n        var te = this.elements;\n        var x = v.x, y = v.y, z = v.z;\n        te[0] *= x;\n        te[4] *= y;\n        te[8] *= z;\n        te[1] *= x;\n        te[5] *= y;\n        te[9] *= z;\n        te[2] *= x;\n        te[6] *= y;\n        te[10] *= z;\n        te[3] *= x;\n        te[7] *= y;\n        te[11] *= z;\n        return this;\n    },\n    getMaxScaleOnAxis: function() {\n        var te = this.elements;\n        var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];\n        var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];\n        var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];\n        return Math.sqrt(Math.max(scaleXSq, Math.max(scaleYSq, scaleZSq)));\n    },\n    makeTranslation: function(x, y, z) {\n        this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);\n        return this;\n    },\n    makeRotationX: function(theta) {\n        var c = Math.cos(theta), s = Math.sin(theta);\n        this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);\n        return this;\n    },\n    makeRotationY: function(theta) {\n        var c = Math.cos(theta), s = Math.sin(theta);\n        this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);\n        return this;\n    },\n    makeRotationZ: function(theta) {\n        var c = Math.cos(theta), s = Math.sin(theta);\n        this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n        return this;\n    },\n    makeRotationAxis: function(axis, angle) {\n        // Based on http://www.gamedev.net/reference/articles/article1199.asp\n        var c = Math.cos(angle);\n        var s = Math.sin(angle);\n        var t = 1 - c;\n        var x = axis.x, y = axis.y, z = axis.z;\n        var tx = t * x, ty = t * y;\n        this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);\n        return this;\n    },\n    makeScale: function(x, y, z) {\n        this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);\n        return this;\n    },\n    makeFrustum: function(left, right, bottom, top, near, far) {\n        var te = this.elements;\n        var x = 2 * near / (right - left);\n        var y = 2 * near / (top - bottom);\n        var a = (right + left) / (right - left);\n        var b = (top + bottom) / (top - bottom);\n        var c = -(far + near) / (far - near);\n        var d = -2 * far * near / (far - near);\n        te[0] = x;\n        te[4] = 0;\n        te[8] = a;\n        te[12] = 0;\n        te[1] = 0;\n        te[5] = y;\n        te[9] = b;\n        te[13] = 0;\n        te[2] = 0;\n        te[6] = 0;\n        te[10] = c;\n        te[14] = d;\n        te[3] = 0;\n        te[7] = 0;\n        te[11] = -1;\n        te[15] = 0;\n        return this;\n    },\n    makePerspective: function(fov, aspect, near, far) {\n        var ymax = near * Math.tan(THREE.Math.degToRad(fov * 0.5));\n        var ymin = -ymax;\n        var xmin = ymin * aspect;\n        var xmax = ymax * aspect;\n        return this.makeFrustum(xmin, xmax, ymin, ymax, near, far);\n    },\n    makeOrthographic: function(left, right, top, bottom, near, far) {\n        var te = this.elements;\n        var w = right - left;\n        var h = top - bottom;\n        var p = far - near;\n        var x = (right + left) / w;\n        var y = (top + bottom) / h;\n        var z = (far + near) / p;\n        te[0] = 2 / w;\n        te[4] = 0;\n        te[8] = 0;\n        te[12] = -x;\n        te[1] = 0;\n        te[5] = 2 / h;\n        te[9] = 0;\n        te[13] = -y;\n        te[2] = 0;\n        te[6] = 0;\n        te[10] = -2 / p;\n        te[14] = -z;\n        te[3] = 0;\n        te[7] = 0;\n        te[11] = 0;\n        te[15] = 1;\n        return this;\n    },\n    clone: function() {\n        var te = this.elements;\n        return new THREE.Matrix4(te[0], te[4], te[8], te[12], te[1], te[5], te[9], te[13], te[2], te[6], te[10], te[14], te[3], te[7], te[11], te[15]);\n    }\n});\n/**\n * @author bhouston / http://exocortex.com\n */ THREE.Ray = function(origin, direction) {\n    this.origin = origin !== undefined ? origin : new THREE.Vector3();\n    this.direction = direction !== undefined ? direction : new THREE.Vector3();\n};\nTHREE.extend(THREE.Ray.prototype, {\n    set: function(origin, direction) {\n        this.origin.copy(origin);\n        this.direction.copy(direction);\n        return this;\n    },\n    copy: function(ray) {\n        this.origin.copy(ray.origin);\n        this.direction.copy(ray.direction);\n        return this;\n    },\n    at: function(t, optionalTarget) {\n        var result = optionalTarget || new THREE.Vector3();\n        return result.copy(this.direction).multiplyScalar(t).add(this.origin);\n    },\n    recast: function() {\n        var v1 = new THREE.Vector3();\n        return function(t) {\n            this.origin.copy(this.at(t, v1));\n            return this;\n        };\n    }(),\n    closestPointToPoint: function(point, optionalTarget) {\n        var result = optionalTarget || new THREE.Vector3();\n        result.subVectors(point, this.origin);\n        var directionDistance = result.dot(this.direction);\n        return result.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);\n    },\n    distanceToPoint: function() {\n        var v1 = new THREE.Vector3();\n        return function(point) {\n            var directionDistance = v1.subVectors(point, this.origin).dot(this.direction);\n            v1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);\n            return v1.distanceTo(point);\n        };\n    }(),\n    isIntersectionSphere: function(sphere) {\n        return this.distanceToPoint(sphere.center) <= sphere.radius;\n    },\n    isIntersectionPlane: function(plane) {\n        // check if the line and plane are non-perpendicular, if they\n        // eventually they will intersect.\n        var denominator = plane.normal.dot(this.direction);\n        if (denominator != 0) return true;\n        // line is coplanar, return origin\n        if (plane.distanceToPoint(this.origin) == 0) return true;\n        return false;\n    },\n    distanceToPlane: function(plane) {\n        var denominator = plane.normal.dot(this.direction);\n        if (denominator == 0) {\n            // line is coplanar, return origin\n            if (plane.distanceToPoint(this.origin) == 0) return 0;\n            // Unsure if this is the correct method to handle this case.\n            return undefined;\n        }\n        var t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;\n        return t;\n    },\n    intersectPlane: function(plane, optionalTarget) {\n        var t = this.distanceToPlane(plane);\n        if (t === undefined) return undefined;\n        return this.at(t, optionalTarget);\n    },\n    applyMatrix4: function(matrix4) {\n        this.direction.add(this.origin).applyMatrix4(matrix4);\n        this.origin.applyMatrix4(matrix4);\n        this.direction.sub(this.origin);\n        return this;\n    },\n    equals: function(ray) {\n        return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);\n    },\n    clone: function() {\n        return new THREE.Ray().copy(this);\n    }\n});\n/**\n * @author bhouston / http://exocortex.com\n * @author mrdoob / http://mrdoob.com/\n */ THREE.Sphere = function(center, radius) {\n    this.center = center !== undefined ? center : new THREE.Vector3();\n    this.radius = radius !== undefined ? radius : 0;\n};\nTHREE.extend(THREE.Sphere.prototype, {\n    set: function(center, radius) {\n        this.center.copy(center);\n        this.radius = radius;\n        return this;\n    },\n    setFromCenterAndPoints: function(center, points) {\n        var maxRadiusSq = 0;\n        for(var i = 0, il = points.length; i < il; i++){\n            var radiusSq = center.distanceToSquared(points[i]);\n            maxRadiusSq = Math.max(maxRadiusSq, radiusSq);\n        }\n        this.center = center;\n        this.radius = Math.sqrt(maxRadiusSq);\n        return this;\n    },\n    copy: function(sphere) {\n        this.center.copy(sphere.center);\n        this.radius = sphere.radius;\n        return this;\n    },\n    empty: function() {\n        return this.radius <= 0;\n    },\n    containsPoint: function(point) {\n        return point.distanceToSquared(this.center) <= this.radius * this.radius;\n    },\n    distanceToPoint: function(point) {\n        return point.distanceTo(this.center) - this.radius;\n    },\n    intersectsSphere: function(sphere) {\n        var radiusSum = this.radius + sphere.radius;\n        return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;\n    },\n    clampPoint: function(point, optionalTarget) {\n        var deltaLengthSq = this.center.distanceToSquared(point);\n        var result = optionalTarget || new THREE.Vector3();\n        result.copy(point);\n        if (deltaLengthSq > this.radius * this.radius) {\n            result.sub(this.center).normalize();\n            result.multiplyScalar(this.radius).add(this.center);\n        }\n        return result;\n    },\n    getBoundingBox: function(optionalTarget) {\n        var box = optionalTarget || new THREE.Box3();\n        box.set(this.center, this.center);\n        box.expandByScalar(this.radius);\n        return box;\n    },\n    applyMatrix4: function(matrix) {\n        this.center.applyMatrix4(matrix);\n        this.radius = this.radius * matrix.getMaxScaleOnAxis();\n        return this;\n    },\n    translate: function(offset) {\n        this.center.add(offset);\n        return this;\n    },\n    equals: function(sphere) {\n        return sphere.center.equals(this.center) && sphere.radius === this.radius;\n    },\n    clone: function() {\n        return new THREE.Sphere().copy(this);\n    }\n});\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author bhouston / http://exocortex.com\n */ THREE.Frustum = function(p0, p1, p2, p3, p4, p5) {\n    this.planes = [\n        p0 !== undefined ? p0 : new THREE.Plane(),\n        p1 !== undefined ? p1 : new THREE.Plane(),\n        p2 !== undefined ? p2 : new THREE.Plane(),\n        p3 !== undefined ? p3 : new THREE.Plane(),\n        p4 !== undefined ? p4 : new THREE.Plane(),\n        p5 !== undefined ? p5 : new THREE.Plane()\n    ];\n};\nTHREE.extend(THREE.Frustum.prototype, {\n    set: function(p0, p1, p2, p3, p4, p5) {\n        var planes = this.planes;\n        planes[0].copy(p0);\n        planes[1].copy(p1);\n        planes[2].copy(p2);\n        planes[3].copy(p3);\n        planes[4].copy(p4);\n        planes[5].copy(p5);\n        return this;\n    },\n    copy: function(frustum) {\n        var planes = this.planes;\n        for(var i = 0; i < 6; i++)planes[i].copy(frustum.planes[i]);\n        return this;\n    },\n    setFromMatrix: function(m) {\n        var planes = this.planes;\n        var me = m.elements;\n        var me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];\n        var me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];\n        var me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];\n        var me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];\n        planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();\n        planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();\n        planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();\n        planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();\n        planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();\n        planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();\n        return this;\n    },\n    intersectsObject: function() {\n        var center = new THREE.Vector3();\n        return function(object) {\n            // this method is expanded inlined for performance reasons.\n            var matrix = object.matrixWorld;\n            var planes = this.planes;\n            var negRadius = -object.geometry.boundingSphere.radius * matrix.getMaxScaleOnAxis();\n            center.getPositionFromMatrix(matrix);\n            for(var i = 0; i < 6; i++){\n                var distance = planes[i].distanceToPoint(center);\n                if (distance < negRadius) return false;\n            }\n            return true;\n        };\n    }(),\n    intersectsSphere: function(sphere) {\n        var planes = this.planes;\n        var center = sphere.center;\n        var negRadius = -sphere.radius;\n        for(var i = 0; i < 6; i++){\n            var distance = planes[i].distanceToPoint(center);\n            if (distance < negRadius) return false;\n        }\n        return true;\n    },\n    containsPoint: function(point) {\n        var planes = this.planes;\n        for(var i = 0; i < 6; i++){\n            if (planes[i].distanceToPoint(point) < 0) return false;\n        }\n        return true;\n    },\n    clone: function() {\n        return new THREE.Frustum().copy(this);\n    }\n});\n/**\n * @author bhouston / http://exocortex.com\n */ THREE.Plane = function(normal, constant) {\n    this.normal = normal !== undefined ? normal : new THREE.Vector3(1, 0, 0);\n    this.constant = constant !== undefined ? constant : 0;\n};\nTHREE.extend(THREE.Plane.prototype, {\n    set: function(normal, constant) {\n        this.normal.copy(normal);\n        this.constant = constant;\n        return this;\n    },\n    setComponents: function(x, y, z, w) {\n        this.normal.set(x, y, z);\n        this.constant = w;\n        return this;\n    },\n    setFromNormalAndCoplanarPoint: function(normal, point) {\n        this.normal.copy(normal);\n        this.constant = -point.dot(this.normal); // must be this.normal, not normal, as this.normal is normalized\n        return this;\n    },\n    setFromCoplanarPoints: function() {\n        var v1 = new THREE.Vector3();\n        var v2 = new THREE.Vector3();\n        return function(a, b, c) {\n            var normal = v1.subVectors(c, b).cross(v2.subVectors(a, b)).normalize();\n            // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n            this.setFromNormalAndCoplanarPoint(normal, a);\n            return this;\n        };\n    }(),\n    copy: function(plane) {\n        this.normal.copy(plane.normal);\n        this.constant = plane.constant;\n        return this;\n    },\n    normalize: function() {\n        // Note: will lead to a divide by zero if the plane is invalid.\n        var inverseNormalLength = 1.0 / this.normal.length();\n        this.normal.multiplyScalar(inverseNormalLength);\n        this.constant *= inverseNormalLength;\n        return this;\n    },\n    negate: function() {\n        this.constant *= -1;\n        this.normal.negate();\n        return this;\n    },\n    distanceToPoint: function(point) {\n        return this.normal.dot(point) + this.constant;\n    },\n    distanceToSphere: function(sphere) {\n        return this.distanceToPoint(sphere.center) - sphere.radius;\n    },\n    projectPoint: function(point, optionalTarget) {\n        return this.orthoPoint(point, optionalTarget).sub(point).negate();\n    },\n    orthoPoint: function(point, optionalTarget) {\n        var perpendicularMagnitude = this.distanceToPoint(point);\n        var result = optionalTarget || new THREE.Vector3();\n        return result.copy(this.normal).multiplyScalar(perpendicularMagnitude);\n    },\n    isIntersectionLine: function(line) {\n        // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n        var startSign = this.distanceToPoint(line.start);\n        var endSign = this.distanceToPoint(line.end);\n        return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;\n    },\n    intersectLine: function() {\n        var v1 = new THREE.Vector3();\n        return function(line, optionalTarget) {\n            var result = optionalTarget || new THREE.Vector3();\n            var direction = line.delta(v1);\n            var denominator = this.normal.dot(direction);\n            if (denominator == 0) {\n                // line is coplanar, return origin\n                if (this.distanceToPoint(line.start) == 0) return result.copy(line.start);\n                // Unsure if this is the correct method to handle this case.\n                return undefined;\n            }\n            var t = -(line.start.dot(this.normal) + this.constant) / denominator;\n            if (t < 0 || t > 1) return undefined;\n            return result.copy(direction).multiplyScalar(t).add(line.start);\n        };\n    }(),\n    coplanarPoint: function(optionalTarget) {\n        var result = optionalTarget || new THREE.Vector3();\n        return result.copy(this.normal).multiplyScalar(-this.constant);\n    },\n    applyMatrix4: function() {\n        var v1 = new THREE.Vector3();\n        var v2 = new THREE.Vector3();\n        return function(matrix, optionalNormalMatrix) {\n            // compute new normal based on theory here:\n            // http://www.songho.ca/opengl/gl_normaltransform.html\n            optionalNormalMatrix = optionalNormalMatrix || new THREE.Matrix3().getInverse(matrix).transpose();\n            var newNormal = v1.copy(this.normal).applyMatrix3(optionalNormalMatrix);\n            var newCoplanarPoint = this.coplanarPoint(v2);\n            newCoplanarPoint.applyMatrix4(matrix);\n            this.setFromNormalAndCoplanarPoint(newNormal, newCoplanarPoint);\n            return this;\n        };\n    }(),\n    translate: function(offset) {\n        this.constant = this.constant - offset.dot(this.normal);\n        return this;\n    },\n    equals: function(plane) {\n        return plane.normal.equals(this.normal) && plane.constant == this.constant;\n    },\n    clone: function() {\n        return new THREE.Plane().copy(this);\n    }\n});\n/**\n * @author alteredq / http://alteredqualia.com/\n */ THREE.Math = {\n    // Clamp value to range <a, b>\n    clamp: function(x, a, b) {\n        return x < a ? a : x > b ? b : x;\n    },\n    // Clamp value to range <a, inf)\n    clampBottom: function(x, a) {\n        return x < a ? a : x;\n    },\n    // Linear mapping from range <a1, a2> to range <b1, b2>\n    mapLinear: function(x, a1, a2, b1, b2) {\n        return b1 + (x - a1) * (b2 - b1) / (a2 - a1);\n    },\n    // http://en.wikipedia.org/wiki/Smoothstep\n    smoothstep: function(x, min, max) {\n        if (x <= min) return 0;\n        if (x >= max) return 1;\n        x = (x - min) / (max - min);\n        return x * x * (3 - 2 * x);\n    },\n    smootherstep: function(x, min, max) {\n        if (x <= min) return 0;\n        if (x >= max) return 1;\n        x = (x - min) / (max - min);\n        return x * x * x * (x * (x * 6 - 15) + 10);\n    },\n    // Random float from <0, 1> with 16 bits of randomness\n    // (standard Math.random() creates repetitive patterns when applied over larger space)\n    random16: function() {\n        return (65280 * Math.random() + 255 * Math.random()) / 65535;\n    },\n    // Random integer from <low, high> interval\n    randInt: function(low, high) {\n        return low + Math.floor(Math.random() * (high - low + 1));\n    },\n    // Random float from <low, high> interval\n    randFloat: function(low, high) {\n        return low + Math.random() * (high - low);\n    },\n    // Random float from <-range/2, range/2> interval\n    randFloatSpread: function(range) {\n        return range * (0.5 - Math.random());\n    },\n    sign: function(x) {\n        return x < 0 ? -1 : x > 0 ? 1 : 0;\n    },\n    degToRad: function() {\n        var degreeToRadiansFactor = Math.PI / 180;\n        return function(degrees) {\n            return degrees * degreeToRadiansFactor;\n        };\n    }(),\n    radToDeg: function() {\n        var radianToDegreesFactor = 180 / Math.PI;\n        return function(radians) {\n            return radians * radianToDegreesFactor;\n        };\n    }()\n};\n/**\n * Spline from Tween.js, slightly optimized (and trashed)\n * http://sole.github.com/tween.js/examples/05_spline.html\n *\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */ THREE.Spline = function(points) {\n    this.points = points;\n    var c = [], v3 = {\n        x: 0,\n        y: 0,\n        z: 0\n    }, point, intPoint, weight, w2, w3, pa, pb, pc, pd;\n    this.initFromArray = function(a) {\n        this.points = [];\n        for(var i = 0; i < a.length; i++)this.points[i] = {\n            x: a[i][0],\n            y: a[i][1],\n            z: a[i][2]\n        };\n    };\n    this.getPoint = function(k) {\n        point = (this.points.length - 1) * k;\n        intPoint = Math.floor(point);\n        weight = point - intPoint;\n        c[0] = intPoint === 0 ? intPoint : intPoint - 1;\n        c[1] = intPoint;\n        c[2] = intPoint > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;\n        c[3] = intPoint > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;\n        pa = this.points[c[0]];\n        pb = this.points[c[1]];\n        pc = this.points[c[2]];\n        pd = this.points[c[3]];\n        w2 = weight * weight;\n        w3 = weight * w2;\n        v3.x = interpolate(pa.x, pb.x, pc.x, pd.x, weight, w2, w3);\n        v3.y = interpolate(pa.y, pb.y, pc.y, pd.y, weight, w2, w3);\n        v3.z = interpolate(pa.z, pb.z, pc.z, pd.z, weight, w2, w3);\n        return v3;\n    };\n    this.getControlPointsArray = function() {\n        var i, p, l = this.points.length, coords = [];\n        for(i = 0; i < l; i++){\n            p = this.points[i];\n            coords[i] = [\n                p.x,\n                p.y,\n                p.z\n            ];\n        }\n        return coords;\n    };\n    // approximate length by summing linear segments\n    this.getLength = function(nSubDivisions) {\n        var i, index, nSamples, position, point = 0, intPoint = 0, oldIntPoint = 0, oldPosition = new THREE.Vector3(), tmpVec = new THREE.Vector3(), chunkLengths = [], totalLength = 0;\n        // first point has 0 length\n        chunkLengths[0] = 0;\n        if (!nSubDivisions) nSubDivisions = 100;\n        nSamples = this.points.length * nSubDivisions;\n        oldPosition.copy(this.points[0]);\n        for(i = 1; i < nSamples; i++){\n            index = i / nSamples;\n            position = this.getPoint(index);\n            tmpVec.copy(position);\n            totalLength += tmpVec.distanceTo(oldPosition);\n            oldPosition.copy(position);\n            point = (this.points.length - 1) * index;\n            intPoint = Math.floor(point);\n            if (intPoint != oldIntPoint) {\n                chunkLengths[intPoint] = totalLength;\n                oldIntPoint = intPoint;\n            }\n        }\n        // last point ends with total length\n        chunkLengths[chunkLengths.length] = totalLength;\n        return {\n            chunks: chunkLengths,\n            total: totalLength\n        };\n    };\n    this.reparametrizeByArcLength = function(samplingCoef) {\n        var i, j, index, indexCurrent, indexNext, linearDistance, realDistance, sampling, position, newpoints = [], tmpVec = new THREE.Vector3(), sl = this.getLength();\n        newpoints.push(tmpVec.copy(this.points[0]).clone());\n        for(i = 1; i < this.points.length; i++){\n            //tmpVec.copy( this.points[ i - 1 ] );\n            //linearDistance = tmpVec.distanceTo( this.points[ i ] );\n            realDistance = sl.chunks[i] - sl.chunks[i - 1];\n            sampling = Math.ceil(samplingCoef * realDistance / sl.total);\n            indexCurrent = (i - 1) / (this.points.length - 1);\n            indexNext = i / (this.points.length - 1);\n            for(j = 1; j < sampling - 1; j++){\n                index = indexCurrent + j * (1 / sampling) * (indexNext - indexCurrent);\n                position = this.getPoint(index);\n                newpoints.push(tmpVec.copy(position).clone());\n            }\n            newpoints.push(tmpVec.copy(this.points[i]).clone());\n        }\n        this.points = newpoints;\n    };\n    // Catmull-Rom\n    function interpolate(p0, p1, p2, p3, t, t2, t3) {\n        var v0 = (p2 - p0) * 0.5, v1 = (p3 - p1) * 0.5;\n        return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;\n    }\n};\n/**\n * @author bhouston / http://exocortex.com\n * @author mrdoob / http://mrdoob.com/\n */ THREE.Triangle = function(a, b, c) {\n    this.a = a !== undefined ? a : new THREE.Vector3();\n    this.b = b !== undefined ? b : new THREE.Vector3();\n    this.c = c !== undefined ? c : new THREE.Vector3();\n};\nTHREE.Triangle.normal = function() {\n    var v0 = new THREE.Vector3();\n    return function(a, b, c, optionalTarget) {\n        var result = optionalTarget || new THREE.Vector3();\n        result.subVectors(c, b);\n        v0.subVectors(a, b);\n        result.cross(v0);\n        var resultLengthSq = result.lengthSq();\n        if (resultLengthSq > 0) return result.multiplyScalar(1 / Math.sqrt(resultLengthSq));\n        return result.set(0, 0, 0);\n    };\n}();\n// static/instance method to calculate barycoordinates\n// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\nTHREE.Triangle.barycoordFromPoint = function() {\n    var v0 = new THREE.Vector3(), v1 = new THREE.Vector3(), v2 = new THREE.Vector3();\n    return function(point, a, b, c, optionalTarget) {\n        v0.subVectors(c, a);\n        v1.subVectors(b, a);\n        v2.subVectors(point, a);\n        var dot00 = v0.dot(v0);\n        var dot01 = v0.dot(v1);\n        var dot02 = v0.dot(v2);\n        var dot11 = v1.dot(v1);\n        var dot12 = v1.dot(v2);\n        var denom = dot00 * dot11 - dot01 * dot01;\n        var result = optionalTarget || new THREE.Vector3();\n        // colinear or singular triangle\n        if (denom == 0) // arbitrary location outside of triangle?\n        // not sure if this is the best idea, maybe should be returning undefined\n        return result.set(-2, -1, -1);\n        var invDenom = 1 / denom;\n        var u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n        var v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n        // barycoordinates must always sum to 1\n        return result.set(1 - u - v, v, u);\n    };\n}();\nTHREE.Triangle.containsPoint = function() {\n    var v1 = new THREE.Vector3();\n    return function(point, a, b, c) {\n        var result = THREE.Triangle.barycoordFromPoint(point, a, b, c, v1);\n        return result.x >= 0 && result.y >= 0 && result.x + result.y <= 1;\n    };\n}();\nTHREE.extend(THREE.Triangle.prototype, {\n    constructor: THREE.Triangle,\n    set: function(a, b, c) {\n        this.a.copy(a);\n        this.b.copy(b);\n        this.c.copy(c);\n        return this;\n    },\n    setFromPointsAndIndices: function(points, i0, i1, i2) {\n        this.a.copy(points[i0]);\n        this.b.copy(points[i1]);\n        this.c.copy(points[i2]);\n        return this;\n    },\n    copy: function(triangle) {\n        this.a.copy(triangle.a);\n        this.b.copy(triangle.b);\n        this.c.copy(triangle.c);\n        return this;\n    },\n    area: function() {\n        var v0 = new THREE.Vector3();\n        var v1 = new THREE.Vector3();\n        return function() {\n            v0.subVectors(this.c, this.b);\n            v1.subVectors(this.a, this.b);\n            return v0.cross(v1).length() * 0.5;\n        };\n    }(),\n    midpoint: function(optionalTarget) {\n        var result = optionalTarget || new THREE.Vector3();\n        return result.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);\n    },\n    normal: function(optionalTarget) {\n        return THREE.Triangle.normal(this.a, this.b, this.c, optionalTarget);\n    },\n    plane: function(optionalTarget) {\n        var result = optionalTarget || new THREE.Plane();\n        return result.setFromCoplanarPoints(this.a, this.b, this.c);\n    },\n    barycoordFromPoint: function(point, optionalTarget) {\n        return THREE.Triangle.barycoordFromPoint(point, this.a, this.b, this.c, optionalTarget);\n    },\n    containsPoint: function(point) {\n        return THREE.Triangle.containsPoint(point, this.a, this.b, this.c);\n    },\n    equals: function(triangle) {\n        return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);\n    },\n    clone: function() {\n        return new THREE.Triangle().copy(this);\n    }\n});\n/**\n * @author mrdoob / http://mrdoob.com/\n */ THREE.Vertex = function(v) {\n    console.warn(\"THREE.Vertex has been DEPRECATED. Use THREE.Vector3 instead.\");\n    return v;\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n */ THREE.UV = function(u, v) {\n    console.warn(\"THREE.UV has been DEPRECATED. Use THREE.Vector2 instead.\");\n    return new THREE.Vector2(u, v);\n};\n/**\n * @author alteredq / http://alteredqualia.com/\n */ THREE.Clock = function(autoStart) {\n    this.autoStart = autoStart !== undefined ? autoStart : true;\n    this.startTime = 0;\n    this.oldTime = 0;\n    this.elapsedTime = 0;\n    this.running = false;\n};\nTHREE.extend(THREE.Clock.prototype, {\n    start: function() {\n        this.startTime = window.performance !== undefined && window.performance.now !== undefined ? window.performance.now() : Date.now();\n        this.oldTime = this.startTime;\n        this.running = true;\n    },\n    stop: function() {\n        this.getElapsedTime();\n        this.running = false;\n    },\n    getElapsedTime: function() {\n        this.getDelta();\n        return this.elapsedTime;\n    },\n    getDelta: function() {\n        var diff = 0;\n        if (this.autoStart && !this.running) this.start();\n        if (this.running) {\n            var newTime = window.performance !== undefined && window.performance.now !== undefined ? window.performance.now() : Date.now();\n            diff = 0.001 * (newTime - this.oldTime);\n            this.oldTime = newTime;\n            this.elapsedTime += diff;\n        }\n        return diff;\n    }\n});\n/**\n * https://github.com/mrdoob/eventdispatcher.js/\n */ THREE.EventDispatcher = function() {\n    var listeners = {};\n    this.addEventListener = function(type, listener) {\n        if (listeners[type] === undefined) listeners[type] = [];\n        if (listeners[type].indexOf(listener) === -1) listeners[type].push(listener);\n    };\n    this.removeEventListener = function(type, listener) {\n        var index = listeners[type].indexOf(listener);\n        if (index !== -1) listeners[type].splice(index, 1);\n    };\n    this.dispatchEvent = function(event) {\n        var listenerArray = listeners[event.type];\n        if (listenerArray !== undefined) {\n            event.target = this;\n            for(var i = 0, l = listenerArray.length; i < l; i++)listenerArray[i].call(this, event);\n        }\n    };\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author bhouston / http://exocortex.com/\n */ (function(THREE) {\n    THREE.Raycaster = function(origin, direction, near, far) {\n        this.ray = new THREE.Ray(origin, direction);\n        // normalized ray.direction required for accurate distance calculations\n        if (this.ray.direction.lengthSq() > 0) this.ray.direction.normalize();\n        this.near = near || 0;\n        this.far = far || Infinity;\n    };\n    var sphere = new THREE.Sphere();\n    var localRay = new THREE.Ray();\n    var facePlane = new THREE.Plane();\n    var intersectPoint = new THREE.Vector3();\n    var matrixPosition = new THREE.Vector3();\n    var inverseMatrix = new THREE.Matrix4();\n    var descSort = function(a, b) {\n        return a.distance - b.distance;\n    };\n    var intersectObject = function(object, raycaster, intersects) {\n        if (object instanceof THREE.Particle) {\n            matrixPosition.getPositionFromMatrix(object.matrixWorld);\n            var distance = raycaster.ray.distanceToPoint(matrixPosition);\n            if (distance > object.scale.x) return intersects;\n            intersects.push({\n                distance: distance,\n                point: object.position,\n                face: null,\n                object: object\n            });\n        } else if (object instanceof THREE.Mesh) {\n            // Checking boundingSphere distance to ray\n            matrixPosition.getPositionFromMatrix(object.matrixWorld);\n            sphere.set(matrixPosition, object.geometry.boundingSphere.radius * object.matrixWorld.getMaxScaleOnAxis());\n            if (!raycaster.ray.isIntersectionSphere(sphere)) return intersects;\n            // Checking faces\n            var geometry = object.geometry;\n            var vertices = geometry.vertices;\n            var isFaceMaterial = object.material instanceof THREE.MeshFaceMaterial;\n            var objectMaterials = isFaceMaterial === true ? object.material.materials : null;\n            var side = object.material.side;\n            var a, b, c, d;\n            var precision = raycaster.precision;\n            object.matrixRotationWorld.extractRotation(object.matrixWorld);\n            inverseMatrix.getInverse(object.matrixWorld);\n            localRay.copy(raycaster.ray).applyMatrix4(inverseMatrix);\n            for(var f = 0, fl = geometry.faces.length; f < fl; f++){\n                var face = geometry.faces[f];\n                var material = isFaceMaterial === true ? objectMaterials[face.materialIndex] : object.material;\n                if (material === undefined) continue;\n                facePlane.setFromNormalAndCoplanarPoint(face.normal, vertices[face.a]);\n                var planeDistance = localRay.distanceToPlane(facePlane);\n                // bail if raycaster and plane are parallel\n                if (Math.abs(planeDistance) < precision) continue;\n                // if negative distance, then plane is behind raycaster\n                if (planeDistance < 0) continue;\n                // check if we hit the wrong side of a single sided face\n                side = material.side;\n                if (side !== THREE.DoubleSide) {\n                    var planeSign = localRay.direction.dot(facePlane.normal);\n                    if (!(side === THREE.FrontSide ? planeSign < 0 : planeSign > 0)) continue;\n                }\n                // this can be done using the planeDistance from localRay because localRay wasn't normalized, but ray was\n                if (planeDistance < raycaster.near || planeDistance > raycaster.far) continue;\n                intersectPoint = localRay.at(planeDistance, intersectPoint); // passing in intersectPoint avoids a copy\n                if (face instanceof THREE.Face3) {\n                    a = vertices[face.a];\n                    b = vertices[face.b];\n                    c = vertices[face.c];\n                    if (!THREE.Triangle.containsPoint(intersectPoint, a, b, c)) continue;\n                } else if (face instanceof THREE.Face4) {\n                    a = vertices[face.a];\n                    b = vertices[face.b];\n                    c = vertices[face.c];\n                    d = vertices[face.d];\n                    if (!THREE.Triangle.containsPoint(intersectPoint, a, b, d) && !THREE.Triangle.containsPoint(intersectPoint, b, c, d)) continue;\n                } else // This is added because if we call out of this if/else group when none of the cases\n                //    match it will add a point to the intersection list erroneously.\n                throw Error(\"face type not supported\");\n                intersects.push({\n                    distance: planeDistance,\n                    point: raycaster.ray.at(planeDistance),\n                    face: face,\n                    faceIndex: f,\n                    object: object\n                });\n            }\n        }\n    };\n    var intersectDescendants = function(object, raycaster, intersects) {\n        var descendants = object.getDescendants();\n        for(var i = 0, l = descendants.length; i < l; i++)intersectObject(descendants[i], raycaster, intersects);\n    };\n    //\n    THREE.Raycaster.prototype.precision = 0.0001;\n    THREE.Raycaster.prototype.set = function(origin, direction) {\n        this.ray.set(origin, direction);\n        // normalized ray.direction required for accurate distance calculations\n        if (this.ray.direction.length() > 0) this.ray.direction.normalize();\n    };\n    THREE.Raycaster.prototype.intersectObject = function(object, recursive) {\n        var intersects = [];\n        if (recursive === true) intersectDescendants(object, this, intersects);\n        intersectObject(object, this, intersects);\n        intersects.sort(descSort);\n        return intersects;\n    };\n    THREE.Raycaster.prototype.intersectObjects = function(objects, recursive) {\n        var intersects = [];\n        for(var i = 0, l = objects.length; i < l; i++){\n            intersectObject(objects[i], this, intersects);\n            if (recursive === true) intersectDescendants(objects[i], this, intersects);\n        }\n        intersects.sort(descSort);\n        return intersects;\n    };\n})(THREE);\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */ THREE.Object3D = function() {\n    this.id = THREE.Object3DIdCount++;\n    this.name = \"\";\n    this.properties = {};\n    this.parent = undefined;\n    this.children = [];\n    this.up = new THREE.Vector3(0, 1, 0);\n    this.position = new THREE.Vector3();\n    this.rotation = new THREE.Vector3();\n    this.eulerOrder = THREE.Object3D.defaultEulerOrder;\n    this.scale = new THREE.Vector3(1, 1, 1);\n    this.renderDepth = null;\n    this.rotationAutoUpdate = true;\n    this.matrix = new THREE.Matrix4();\n    this.matrixWorld = new THREE.Matrix4();\n    this.matrixRotationWorld = new THREE.Matrix4();\n    this.matrixAutoUpdate = true;\n    this.matrixWorldNeedsUpdate = true;\n    this.quaternion = new THREE.Quaternion();\n    this.useQuaternion = false;\n    this.visible = true;\n    this.castShadow = false;\n    this.receiveShadow = false;\n    this.frustumCulled = true;\n    this._vector = new THREE.Vector3();\n};\nTHREE.Object3D.prototype = {\n    constructor: THREE.Object3D,\n    applyMatrix: function(matrix) {\n        this.matrix.multiplyMatrices(matrix, this.matrix);\n        this.scale.getScaleFromMatrix(this.matrix);\n        var mat = new THREE.Matrix4().extractRotation(this.matrix);\n        this.rotation.setEulerFromRotationMatrix(mat, this.eulerOrder);\n        this.position.getPositionFromMatrix(this.matrix);\n    },\n    translate: function(distance, axis) {\n        this.matrix.rotateAxis(axis);\n        this.position.add(axis.multiplyScalar(distance));\n    },\n    translateX: function(distance) {\n        this.translate(distance, this._vector.set(1, 0, 0));\n    },\n    translateY: function(distance) {\n        this.translate(distance, this._vector.set(0, 1, 0));\n    },\n    translateZ: function(distance) {\n        this.translate(distance, this._vector.set(0, 0, 1));\n    },\n    localToWorld: function(vector) {\n        return vector.applyMatrix4(this.matrixWorld);\n    },\n    worldToLocal: function(vector) {\n        return vector.applyMatrix4(THREE.Object3D.__m1.getInverse(this.matrixWorld));\n    },\n    lookAt: function(vector) {\n        // TODO: Add hierarchy support.\n        this.matrix.lookAt(vector, this.position, this.up);\n        if (this.rotationAutoUpdate) {\n            if (this.useQuaternion === false) this.rotation.setEulerFromRotationMatrix(this.matrix, this.eulerOrder);\n            else this.quaternion.copy(this.matrix.decompose()[1]);\n        }\n    },\n    add: function(object) {\n        if (object === this) {\n            console.warn(\"THREE.Object3D.add: An object can't be added as a child of itself.\");\n            return;\n        }\n        if (object instanceof THREE.Object3D) {\n            if (object.parent !== undefined) object.parent.remove(object);\n            object.parent = this;\n            this.children.push(object);\n            // add to scene\n            var scene = this;\n            while(scene.parent !== undefined)scene = scene.parent;\n            if (scene !== undefined && scene instanceof THREE.Scene) scene.__addObject(object);\n        }\n    },\n    remove: function(object) {\n        var index = this.children.indexOf(object);\n        if (index !== -1) {\n            object.parent = undefined;\n            this.children.splice(index, 1);\n            // remove from scene\n            var scene = this;\n            while(scene.parent !== undefined)scene = scene.parent;\n            if (scene !== undefined && scene instanceof THREE.Scene) scene.__removeObject(object);\n        }\n    },\n    traverse: function(callback) {\n        callback(this);\n        for(var i = 0, l = this.children.length; i < l; i++)this.children[i].traverse(callback);\n    },\n    getChildByName: function(name, recursive) {\n        for(var i = 0, l = this.children.length; i < l; i++){\n            var child = this.children[i];\n            if (child.name === name) return child;\n            if (recursive === true) {\n                child = child.getChildByName(name, recursive);\n                if (child !== undefined) return child;\n            }\n        }\n        return undefined;\n    },\n    getDescendants: function(array) {\n        if (array === undefined) array = [];\n        Array.prototype.push.apply(array, this.children);\n        for(var i = 0, l = this.children.length; i < l; i++)this.children[i].getDescendants(array);\n        return array;\n    },\n    updateMatrix: function() {\n        this.matrix.setPosition(this.position);\n        if (this.useQuaternion === false) this.matrix.setRotationFromEuler(this.rotation, this.eulerOrder);\n        else this.matrix.setRotationFromQuaternion(this.quaternion);\n        if (this.scale.x !== 1 || this.scale.y !== 1 || this.scale.z !== 1) this.matrix.scale(this.scale);\n        this.matrixWorldNeedsUpdate = true;\n    },\n    updateMatrixWorld: function(force) {\n        if (this.matrixAutoUpdate === true) this.updateMatrix();\n        if (this.matrixWorldNeedsUpdate === true || force === true) {\n            if (this.parent === undefined) this.matrixWorld.copy(this.matrix);\n            else this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\n            this.matrixWorldNeedsUpdate = false;\n            force = true;\n        }\n        // update children\n        for(var i = 0, l = this.children.length; i < l; i++)this.children[i].updateMatrixWorld(force);\n    },\n    clone: function(object) {\n        if (object === undefined) object = new THREE.Object3D();\n        object.name = this.name;\n        object.up.copy(this.up);\n        object.position.copy(this.position);\n        if (object.rotation instanceof THREE.Vector3) object.rotation.copy(this.rotation); // because of Sprite madness\n        object.eulerOrder = this.eulerOrder;\n        object.scale.copy(this.scale);\n        object.renderDepth = this.renderDepth;\n        object.rotationAutoUpdate = this.rotationAutoUpdate;\n        object.matrix.copy(this.matrix);\n        object.matrixWorld.copy(this.matrixWorld);\n        object.matrixRotationWorld.copy(this.matrixRotationWorld);\n        object.matrixAutoUpdate = this.matrixAutoUpdate;\n        object.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate;\n        object.quaternion.copy(this.quaternion);\n        object.useQuaternion = this.useQuaternion;\n        object.visible = this.visible;\n        object.castShadow = this.castShadow;\n        object.receiveShadow = this.receiveShadow;\n        object.frustumCulled = this.frustumCulled;\n        for(var i = 0; i < this.children.length; i++){\n            var child = this.children[i];\n            object.add(child.clone());\n        }\n        return object;\n    }\n};\nTHREE.Object3D.__m1 = new THREE.Matrix4();\nTHREE.Object3D.defaultEulerOrder = \"XYZ\", THREE.Object3DIdCount = 0;\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author supereggbert / http://www.paulbrunt.co.uk/\n * @author julianwa / https://github.com/julianwa\n */ THREE.Projector = function() {\n    var _object, _objectCount, _objectPool = [], _objectPoolLength = 0, _vertex, _vertexCount, _vertexPool = [], _vertexPoolLength = 0, _face, _face3Count, _face3Pool = [], _face3PoolLength = 0, _face4Count, _face4Pool = [], _face4PoolLength = 0, _line, _lineCount, _linePool = [], _linePoolLength = 0, _particle, _particleCount, _particlePool = [], _particlePoolLength = 0, _renderData = {\n        objects: [],\n        sprites: [],\n        lights: [],\n        elements: []\n    }, _vector3 = new THREE.Vector3(), _vector4 = new THREE.Vector4(), _clipBox = new THREE.Box3(new THREE.Vector3(-1, -1, -1), new THREE.Vector3(1, 1, 1)), _boundingBox = new THREE.Box3(), _points3 = new Array(3), _points4 = new Array(4), _viewMatrix = new THREE.Matrix4(), _viewProjectionMatrix = new THREE.Matrix4(), _modelMatrix, _modelViewProjectionMatrix = new THREE.Matrix4(), _normalMatrix = new THREE.Matrix3(), _normalViewMatrix = new THREE.Matrix3(), _centroid = new THREE.Vector3(), _frustum = new THREE.Frustum(), _clippedVertex1PositionScreen = new THREE.Vector4(), _clippedVertex2PositionScreen = new THREE.Vector4();\n    this.projectVector = function(vector, camera) {\n        camera.matrixWorldInverse.getInverse(camera.matrixWorld);\n        _viewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);\n        return vector.applyProjection(_viewProjectionMatrix);\n    };\n    this.unprojectVector = function(vector, camera) {\n        camera.projectionMatrixInverse.getInverse(camera.projectionMatrix);\n        _viewProjectionMatrix.multiplyMatrices(camera.matrixWorld, camera.projectionMatrixInverse);\n        return vector.applyProjection(_viewProjectionMatrix);\n    };\n    this.pickingRay = function(vector, camera) {\n        // set two vectors with opposing z values\n        vector.z = -1;\n        var end = new THREE.Vector3(vector.x, vector.y, 1.0);\n        this.unprojectVector(vector, camera);\n        this.unprojectVector(end, camera);\n        // find direction from vector to end\n        end.sub(vector).normalize();\n        return new THREE.Raycaster(vector, end);\n    };\n    var projectGraph = function(root, sortObjects) {\n        _objectCount = 0;\n        _renderData.objects.length = 0;\n        _renderData.sprites.length = 0;\n        _renderData.lights.length = 0;\n        var projectObject = function(parent) {\n            for(var c = 0, cl = parent.children.length; c < cl; c++){\n                var object = parent.children[c];\n                if (object.visible === false) continue;\n                if (object instanceof THREE.Light) _renderData.lights.push(object);\n                else if (object instanceof THREE.Mesh || object instanceof THREE.Line) {\n                    if (object.frustumCulled === false || _frustum.intersectsObject(object) === true) {\n                        _object = getNextObjectInPool();\n                        _object.object = object;\n                        if (object.renderDepth !== null) _object.z = object.renderDepth;\n                        else {\n                            _vector3.getPositionFromMatrix(object.matrixWorld);\n                            _vector3.applyProjection(_viewProjectionMatrix);\n                            _object.z = _vector3.z;\n                        }\n                        _renderData.objects.push(_object);\n                    }\n                } else if (object instanceof THREE.Sprite || object instanceof THREE.Particle) {\n                    _object = getNextObjectInPool();\n                    _object.object = object;\n                    // TODO: Find an elegant and performant solution and remove this dupe code.\n                    if (object.renderDepth !== null) _object.z = object.renderDepth;\n                    else {\n                        _vector3.getPositionFromMatrix(object.matrixWorld);\n                        _vector3.applyProjection(_viewProjectionMatrix);\n                        _object.z = _vector3.z;\n                    }\n                    _renderData.sprites.push(_object);\n                } else {\n                    _object = getNextObjectInPool();\n                    _object.object = object;\n                    if (object.renderDepth !== null) _object.z = object.renderDepth;\n                    else {\n                        _vector3.getPositionFromMatrix(object.matrixWorld);\n                        _vector3.applyProjection(_viewProjectionMatrix);\n                        _object.z = _vector3.z;\n                    }\n                    _renderData.objects.push(_object);\n                }\n                projectObject(object);\n            }\n        };\n        projectObject(root);\n        if (sortObjects === true) _renderData.objects.sort(painterSort);\n        return _renderData;\n    };\n    this.projectScene = function(scene, camera, sortObjects, sortElements) {\n        var visible = false, o, ol, v, vl, f, fl, n, nl, c, cl, u, ul, object, geometry, vertices, faces, face, faceVertexNormals, faceVertexUvs, uvs, v1, v2, v3, v4, isFaceMaterial, objectMaterials;\n        _face3Count = 0;\n        _face4Count = 0;\n        _lineCount = 0;\n        _particleCount = 0;\n        _renderData.elements.length = 0;\n        scene.updateMatrixWorld();\n        if (camera.parent === undefined) camera.updateMatrixWorld();\n        _viewMatrix.copy(camera.matrixWorldInverse.getInverse(camera.matrixWorld));\n        _viewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, _viewMatrix);\n        _normalViewMatrix.getInverse(_viewMatrix);\n        _normalViewMatrix.transpose();\n        _frustum.setFromMatrix(_viewProjectionMatrix);\n        _renderData = projectGraph(scene, sortObjects);\n        for(o = 0, ol = _renderData.objects.length; o < ol; o++){\n            object = _renderData.objects[o].object;\n            _modelMatrix = object.matrixWorld;\n            _vertexCount = 0;\n            if (object instanceof THREE.Mesh) {\n                geometry = object.geometry;\n                vertices = geometry.vertices;\n                faces = geometry.faces;\n                faceVertexUvs = geometry.faceVertexUvs;\n                _normalMatrix.getInverse(_modelMatrix);\n                _normalMatrix.transpose();\n                isFaceMaterial = object.material instanceof THREE.MeshFaceMaterial;\n                objectMaterials = isFaceMaterial === true ? object.material : null;\n                for(v = 0, vl = vertices.length; v < vl; v++){\n                    _vertex = getNextVertexInPool();\n                    _vertex.positionWorld.copy(vertices[v]).applyMatrix4(_modelMatrix);\n                    _vertex.positionScreen.copy(_vertex.positionWorld).applyMatrix4(_viewProjectionMatrix);\n                    _vertex.positionScreen.x /= _vertex.positionScreen.w;\n                    _vertex.positionScreen.y /= _vertex.positionScreen.w;\n                    _vertex.positionScreen.z /= _vertex.positionScreen.w;\n                    _vertex.visible = !(_vertex.positionScreen.x < -1 || _vertex.positionScreen.x > 1 || _vertex.positionScreen.y < -1 || _vertex.positionScreen.y > 1 || _vertex.positionScreen.z < -1 || _vertex.positionScreen.z > 1);\n                }\n                for(f = 0, fl = faces.length; f < fl; f++){\n                    face = faces[f];\n                    var material = isFaceMaterial === true ? objectMaterials.materials[face.materialIndex] : object.material;\n                    if (material === undefined) continue;\n                    var side = material.side;\n                    if (face instanceof THREE.Face3) {\n                        v1 = _vertexPool[face.a];\n                        v2 = _vertexPool[face.b];\n                        v3 = _vertexPool[face.c];\n                        _points3[0] = v1.positionScreen;\n                        _points3[1] = v2.positionScreen;\n                        _points3[2] = v3.positionScreen;\n                        if (v1.visible === true || v2.visible === true || v3.visible === true || _clipBox.isIntersectionBox(_boundingBox.setFromPoints(_points3))) {\n                            visible = (v3.positionScreen.x - v1.positionScreen.x) * (v2.positionScreen.y - v1.positionScreen.y) - (v3.positionScreen.y - v1.positionScreen.y) * (v2.positionScreen.x - v1.positionScreen.x) < 0;\n                            if (side === THREE.DoubleSide || visible === (side === THREE.FrontSide)) {\n                                _face = getNextFace3InPool();\n                                _face.v1.copy(v1);\n                                _face.v2.copy(v2);\n                                _face.v3.copy(v3);\n                            } else continue;\n                        } else continue;\n                    } else if (face instanceof THREE.Face4) {\n                        v1 = _vertexPool[face.a];\n                        v2 = _vertexPool[face.b];\n                        v3 = _vertexPool[face.c];\n                        v4 = _vertexPool[face.d];\n                        _points4[0] = v1.positionScreen;\n                        _points4[1] = v2.positionScreen;\n                        _points4[2] = v3.positionScreen;\n                        _points4[3] = v4.positionScreen;\n                        if (v1.visible === true || v2.visible === true || v3.visible === true || v4.visible === true || _clipBox.isIntersectionBox(_boundingBox.setFromPoints(_points4))) {\n                            visible = (v4.positionScreen.x - v1.positionScreen.x) * (v2.positionScreen.y - v1.positionScreen.y) - (v4.positionScreen.y - v1.positionScreen.y) * (v2.positionScreen.x - v1.positionScreen.x) < 0 || (v2.positionScreen.x - v3.positionScreen.x) * (v4.positionScreen.y - v3.positionScreen.y) - (v2.positionScreen.y - v3.positionScreen.y) * (v4.positionScreen.x - v3.positionScreen.x) < 0;\n                            if (side === THREE.DoubleSide || visible === (side === THREE.FrontSide)) {\n                                _face = getNextFace4InPool();\n                                _face.v1.copy(v1);\n                                _face.v2.copy(v2);\n                                _face.v3.copy(v3);\n                                _face.v4.copy(v4);\n                            } else continue;\n                        } else continue;\n                    }\n                    _face.normalModel.copy(face.normal);\n                    if (visible === false && (side === THREE.BackSide || side === THREE.DoubleSide)) _face.normalModel.negate();\n                    _face.normalModel.applyMatrix3(_normalMatrix).normalize();\n                    _face.normalModelView.copy(_face.normalModel).applyMatrix3(_normalViewMatrix);\n                    _face.centroidModel.copy(face.centroid).applyMatrix4(_modelMatrix);\n                    faceVertexNormals = face.vertexNormals;\n                    for(n = 0, nl = faceVertexNormals.length; n < nl; n++){\n                        var normalModel = _face.vertexNormalsModel[n];\n                        normalModel.copy(faceVertexNormals[n]);\n                        if (visible === false && (side === THREE.BackSide || side === THREE.DoubleSide)) normalModel.negate();\n                        normalModel.applyMatrix3(_normalMatrix).normalize();\n                        var normalModelView = _face.vertexNormalsModelView[n];\n                        normalModelView.copy(normalModel).applyMatrix3(_normalViewMatrix);\n                    }\n                    _face.vertexNormalsLength = faceVertexNormals.length;\n                    for(c = 0, cl = faceVertexUvs.length; c < cl; c++){\n                        uvs = faceVertexUvs[c][f];\n                        if (uvs === undefined) continue;\n                        for(u = 0, ul = uvs.length; u < ul; u++)_face.uvs[c][u] = uvs[u];\n                    }\n                    _face.color = face.color;\n                    _face.material = material;\n                    _centroid.copy(_face.centroidModel).applyProjection(_viewProjectionMatrix);\n                    _face.z = _centroid.z;\n                    _renderData.elements.push(_face);\n                }\n            } else if (object instanceof THREE.Line) {\n                _modelViewProjectionMatrix.multiplyMatrices(_viewProjectionMatrix, _modelMatrix);\n                vertices = object.geometry.vertices;\n                v1 = getNextVertexInPool();\n                v1.positionScreen.copy(vertices[0]).applyMatrix4(_modelViewProjectionMatrix);\n                // Handle LineStrip and LinePieces\n                var step = object.type === THREE.LinePieces ? 2 : 1;\n                for(v = 1, vl = vertices.length; v < vl; v++){\n                    v1 = getNextVertexInPool();\n                    v1.positionScreen.copy(vertices[v]).applyMatrix4(_modelViewProjectionMatrix);\n                    if ((v + 1) % step > 0) continue;\n                    v2 = _vertexPool[_vertexCount - 2];\n                    _clippedVertex1PositionScreen.copy(v1.positionScreen);\n                    _clippedVertex2PositionScreen.copy(v2.positionScreen);\n                    if (clipLine(_clippedVertex1PositionScreen, _clippedVertex2PositionScreen) === true) {\n                        // Perform the perspective divide\n                        _clippedVertex1PositionScreen.multiplyScalar(1 / _clippedVertex1PositionScreen.w);\n                        _clippedVertex2PositionScreen.multiplyScalar(1 / _clippedVertex2PositionScreen.w);\n                        _line = getNextLineInPool();\n                        _line.v1.positionScreen.copy(_clippedVertex1PositionScreen);\n                        _line.v2.positionScreen.copy(_clippedVertex2PositionScreen);\n                        _line.z = Math.max(_clippedVertex1PositionScreen.z, _clippedVertex2PositionScreen.z);\n                        _line.material = object.material;\n                        _renderData.elements.push(_line);\n                    }\n                }\n            }\n        }\n        for(o = 0, ol = _renderData.sprites.length; o < ol; o++){\n            object = _renderData.sprites[o].object;\n            _modelMatrix = object.matrixWorld;\n            if (object instanceof THREE.Particle) {\n                _vector4.set(_modelMatrix.elements[12], _modelMatrix.elements[13], _modelMatrix.elements[14], 1);\n                _vector4.applyMatrix4(_viewProjectionMatrix);\n                _vector4.z /= _vector4.w;\n                if (_vector4.z > 0 && _vector4.z < 1) {\n                    _particle = getNextParticleInPool();\n                    _particle.object = object;\n                    _particle.x = _vector4.x / _vector4.w;\n                    _particle.y = _vector4.y / _vector4.w;\n                    _particle.z = _vector4.z;\n                    _particle.rotation = object.rotation.z;\n                    _particle.scale.x = object.scale.x * Math.abs(_particle.x - (_vector4.x + camera.projectionMatrix.elements[0]) / (_vector4.w + camera.projectionMatrix.elements[12]));\n                    _particle.scale.y = object.scale.y * Math.abs(_particle.y - (_vector4.y + camera.projectionMatrix.elements[5]) / (_vector4.w + camera.projectionMatrix.elements[13]));\n                    _particle.material = object.material;\n                    _renderData.elements.push(_particle);\n                }\n            }\n        }\n        if (sortElements === true) _renderData.elements.sort(painterSort);\n        return _renderData;\n    };\n    // Pools\n    function getNextObjectInPool() {\n        if (_objectCount === _objectPoolLength) {\n            var object = new THREE.RenderableObject();\n            _objectPool.push(object);\n            _objectPoolLength++;\n            _objectCount++;\n            return object;\n        }\n        return _objectPool[_objectCount++];\n    }\n    function getNextVertexInPool() {\n        if (_vertexCount === _vertexPoolLength) {\n            var vertex = new THREE.RenderableVertex();\n            _vertexPool.push(vertex);\n            _vertexPoolLength++;\n            _vertexCount++;\n            return vertex;\n        }\n        return _vertexPool[_vertexCount++];\n    }\n    function getNextFace3InPool() {\n        if (_face3Count === _face3PoolLength) {\n            var face = new THREE.RenderableFace3();\n            _face3Pool.push(face);\n            _face3PoolLength++;\n            _face3Count++;\n            return face;\n        }\n        return _face3Pool[_face3Count++];\n    }\n    function getNextFace4InPool() {\n        if (_face4Count === _face4PoolLength) {\n            var face = new THREE.RenderableFace4();\n            _face4Pool.push(face);\n            _face4PoolLength++;\n            _face4Count++;\n            return face;\n        }\n        return _face4Pool[_face4Count++];\n    }\n    function getNextLineInPool() {\n        if (_lineCount === _linePoolLength) {\n            var line = new THREE.RenderableLine();\n            _linePool.push(line);\n            _linePoolLength++;\n            _lineCount++;\n            return line;\n        }\n        return _linePool[_lineCount++];\n    }\n    function getNextParticleInPool() {\n        if (_particleCount === _particlePoolLength) {\n            var particle = new THREE.RenderableParticle();\n            _particlePool.push(particle);\n            _particlePoolLength++;\n            _particleCount++;\n            return particle;\n        }\n        return _particlePool[_particleCount++];\n    }\n    //\n    function painterSort(a, b) {\n        return b.z - a.z;\n    }\n    function clipLine(s1, s2) {\n        var alpha1 = 0, alpha2 = 1, // Calculate the boundary coordinate of each vertex for the near and far clip planes,\n        // Z = -1 and Z = +1, respectively.\n        bc1near = s1.z + s1.w, bc2near = s2.z + s2.w, bc1far = -s1.z + s1.w, bc2far = -s2.z + s2.w;\n        if (bc1near >= 0 && bc2near >= 0 && bc1far >= 0 && bc2far >= 0) // Both vertices lie entirely within all clip planes.\n        return true;\n        else if (bc1near < 0 && bc2near < 0 || bc1far < 0 && bc2far < 0) // Both vertices lie entirely outside one of the clip planes.\n        return false;\n        else {\n            // The line segment spans at least one clip plane.\n            if (bc1near < 0) // v1 lies outside the near plane, v2 inside\n            alpha1 = Math.max(alpha1, bc1near / (bc1near - bc2near));\n            else if (bc2near < 0) // v2 lies outside the near plane, v1 inside\n            alpha2 = Math.min(alpha2, bc1near / (bc1near - bc2near));\n            if (bc1far < 0) // v1 lies outside the far plane, v2 inside\n            alpha1 = Math.max(alpha1, bc1far / (bc1far - bc2far));\n            else if (bc2far < 0) // v2 lies outside the far plane, v2 inside\n            alpha2 = Math.min(alpha2, bc1far / (bc1far - bc2far));\n            if (alpha2 < alpha1) // The line segment spans two boundaries, but is outside both of them.\n            // (This can't happen when we're only clipping against just near/far but good\n            //  to leave the check here for future usage if other clip planes are added.)\n            return false;\n            else {\n                // Update the s1 and s2 vertices to match the clipped line segment.\n                s1.lerp(s2, alpha1);\n                s2.lerp(s1, 1 - alpha2);\n                return true;\n            }\n        }\n    }\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */ THREE.Face3 = function(a, b, c, normal, color, materialIndex) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();\n    this.vertexNormals = normal instanceof Array ? normal : [];\n    this.color = color instanceof THREE.Color ? color : new THREE.Color();\n    this.vertexColors = color instanceof Array ? color : [];\n    this.vertexTangents = [];\n    this.materialIndex = materialIndex !== undefined ? materialIndex : 0;\n    this.centroid = new THREE.Vector3();\n};\nTHREE.Face3.prototype = {\n    constructor: THREE.Face3,\n    clone: function() {\n        var face = new THREE.Face3(this.a, this.b, this.c);\n        face.normal.copy(this.normal);\n        face.color.copy(this.color);\n        face.centroid.copy(this.centroid);\n        face.materialIndex = this.materialIndex;\n        var i, il;\n        for(i = 0, il = this.vertexNormals.length; i < il; i++)face.vertexNormals[i] = this.vertexNormals[i].clone();\n        for(i = 0, il = this.vertexColors.length; i < il; i++)face.vertexColors[i] = this.vertexColors[i].clone();\n        for(i = 0, il = this.vertexTangents.length; i < il; i++)face.vertexTangents[i] = this.vertexTangents[i].clone();\n        return face;\n    }\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */ THREE.Face4 = function(a, b, c, d, normal, color, materialIndex) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.d = d;\n    this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();\n    this.vertexNormals = normal instanceof Array ? normal : [];\n    this.color = color instanceof THREE.Color ? color : new THREE.Color();\n    this.vertexColors = color instanceof Array ? color : [];\n    this.vertexTangents = [];\n    this.materialIndex = materialIndex !== undefined ? materialIndex : 0;\n    this.centroid = new THREE.Vector3();\n};\nTHREE.Face4.prototype = {\n    constructor: THREE.Face4,\n    clone: function() {\n        var face = new THREE.Face4(this.a, this.b, this.c, this.d);\n        face.normal.copy(this.normal);\n        face.color.copy(this.color);\n        face.centroid.copy(this.centroid);\n        face.materialIndex = this.materialIndex;\n        var i, il;\n        for(i = 0, il = this.vertexNormals.length; i < il; i++)face.vertexNormals[i] = this.vertexNormals[i].clone();\n        for(i = 0, il = this.vertexColors.length; i < il; i++)face.vertexColors[i] = this.vertexColors[i].clone();\n        for(i = 0, il = this.vertexTangents.length; i < il; i++)face.vertexTangents[i] = this.vertexTangents[i].clone();\n        return face;\n    }\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author kile / http://kile.stravaganza.org/\n * @author alteredq / http://alteredqualia.com/\n * @author mikael emtinger / http://gomo.se/\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * @author bhouston / http://exocortex.com\n */ THREE.Geometry = function() {\n    THREE.EventDispatcher.call(this);\n    this.id = THREE.GeometryIdCount++;\n    this.name = \"\";\n    this.vertices = [];\n    this.colors = []; // one-to-one vertex colors, used in ParticleSystem, Line and Ribbon\n    this.normals = []; // one-to-one vertex normals, used in Ribbon\n    this.faces = [];\n    this.faceUvs = [\n        []\n    ];\n    this.faceVertexUvs = [\n        []\n    ];\n    this.morphTargets = [];\n    this.morphColors = [];\n    this.morphNormals = [];\n    this.skinWeights = [];\n    this.skinIndices = [];\n    this.lineDistances = [];\n    this.boundingBox = null;\n    this.boundingSphere = null;\n    this.hasTangents = false;\n    this.dynamic = true; // the intermediate typed arrays will be deleted when set to false\n    // update flags\n    this.verticesNeedUpdate = false;\n    this.elementsNeedUpdate = false;\n    this.uvsNeedUpdate = false;\n    this.normalsNeedUpdate = false;\n    this.tangentsNeedUpdate = false;\n    this.colorsNeedUpdate = false;\n    this.lineDistancesNeedUpdate = false;\n    this.buffersNeedUpdate = false;\n};\nTHREE.Geometry.prototype = {\n    constructor: THREE.Geometry,\n    applyMatrix: function(matrix) {\n        var normalMatrix = new THREE.Matrix3().getInverse(matrix).transpose();\n        for(var i = 0, il = this.vertices.length; i < il; i++){\n            var vertex = this.vertices[i];\n            vertex.applyMatrix4(matrix);\n        }\n        for(var i = 0, il = this.faces.length; i < il; i++){\n            var face = this.faces[i];\n            face.normal.applyMatrix3(normalMatrix).normalize();\n            for(var j = 0, jl = face.vertexNormals.length; j < jl; j++)face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();\n            face.centroid.applyMatrix4(matrix);\n        }\n    },\n    computeCentroids: function() {\n        var f, fl, face;\n        for(f = 0, fl = this.faces.length; f < fl; f++){\n            face = this.faces[f];\n            face.centroid.set(0, 0, 0);\n            if (face instanceof THREE.Face3) {\n                face.centroid.add(this.vertices[face.a]);\n                face.centroid.add(this.vertices[face.b]);\n                face.centroid.add(this.vertices[face.c]);\n                face.centroid.divideScalar(3);\n            } else if (face instanceof THREE.Face4) {\n                face.centroid.add(this.vertices[face.a]);\n                face.centroid.add(this.vertices[face.b]);\n                face.centroid.add(this.vertices[face.c]);\n                face.centroid.add(this.vertices[face.d]);\n                face.centroid.divideScalar(4);\n            }\n        }\n    },\n    computeFaceNormals: function() {\n        var cb = new THREE.Vector3(), ab = new THREE.Vector3();\n        for(var f = 0, fl = this.faces.length; f < fl; f++){\n            var face = this.faces[f];\n            var vA = this.vertices[face.a];\n            var vB = this.vertices[face.b];\n            var vC = this.vertices[face.c];\n            cb.subVectors(vC, vB);\n            ab.subVectors(vA, vB);\n            cb.cross(ab);\n            cb.normalize();\n            face.normal.copy(cb);\n        }\n    },\n    computeVertexNormals: function(areaWeighted) {\n        var v, vl, f, fl, face, vertices;\n        // create internal buffers for reuse when calling this method repeatedly\n        // (otherwise memory allocation / deallocation every frame is big resource hog)\n        if (this.__tmpVertices === undefined) {\n            this.__tmpVertices = new Array(this.vertices.length);\n            vertices = this.__tmpVertices;\n            for(v = 0, vl = this.vertices.length; v < vl; v++)vertices[v] = new THREE.Vector3();\n            for(f = 0, fl = this.faces.length; f < fl; f++){\n                face = this.faces[f];\n                if (face instanceof THREE.Face3) face.vertexNormals = [\n                    new THREE.Vector3(),\n                    new THREE.Vector3(),\n                    new THREE.Vector3()\n                ];\n                else if (face instanceof THREE.Face4) face.vertexNormals = [\n                    new THREE.Vector3(),\n                    new THREE.Vector3(),\n                    new THREE.Vector3(),\n                    new THREE.Vector3()\n                ];\n            }\n        } else {\n            vertices = this.__tmpVertices;\n            for(v = 0, vl = this.vertices.length; v < vl; v++)vertices[v].set(0, 0, 0);\n        }\n        if (areaWeighted) {\n            // vertex normals weighted by triangle areas\n            // http://www.iquilezles.org/www/articles/normals/normals.htm\n            var vA, vB, vC, vD;\n            var cb = new THREE.Vector3(), ab = new THREE.Vector3(), db = new THREE.Vector3(), dc = new THREE.Vector3(), bc = new THREE.Vector3();\n            for(f = 0, fl = this.faces.length; f < fl; f++){\n                face = this.faces[f];\n                if (face instanceof THREE.Face3) {\n                    vA = this.vertices[face.a];\n                    vB = this.vertices[face.b];\n                    vC = this.vertices[face.c];\n                    cb.subVectors(vC, vB);\n                    ab.subVectors(vA, vB);\n                    cb.cross(ab);\n                    vertices[face.a].add(cb);\n                    vertices[face.b].add(cb);\n                    vertices[face.c].add(cb);\n                } else if (face instanceof THREE.Face4) {\n                    vA = this.vertices[face.a];\n                    vB = this.vertices[face.b];\n                    vC = this.vertices[face.c];\n                    vD = this.vertices[face.d];\n                    // abd\n                    db.subVectors(vD, vB);\n                    ab.subVectors(vA, vB);\n                    db.cross(ab);\n                    vertices[face.a].add(db);\n                    vertices[face.b].add(db);\n                    vertices[face.d].add(db);\n                    // bcd\n                    dc.subVectors(vD, vC);\n                    bc.subVectors(vB, vC);\n                    dc.cross(bc);\n                    vertices[face.b].add(dc);\n                    vertices[face.c].add(dc);\n                    vertices[face.d].add(dc);\n                }\n            }\n        } else for(f = 0, fl = this.faces.length; f < fl; f++){\n            face = this.faces[f];\n            if (face instanceof THREE.Face3) {\n                vertices[face.a].add(face.normal);\n                vertices[face.b].add(face.normal);\n                vertices[face.c].add(face.normal);\n            } else if (face instanceof THREE.Face4) {\n                vertices[face.a].add(face.normal);\n                vertices[face.b].add(face.normal);\n                vertices[face.c].add(face.normal);\n                vertices[face.d].add(face.normal);\n            }\n        }\n        for(v = 0, vl = this.vertices.length; v < vl; v++)vertices[v].normalize();\n        for(f = 0, fl = this.faces.length; f < fl; f++){\n            face = this.faces[f];\n            if (face instanceof THREE.Face3) {\n                face.vertexNormals[0].copy(vertices[face.a]);\n                face.vertexNormals[1].copy(vertices[face.b]);\n                face.vertexNormals[2].copy(vertices[face.c]);\n            } else if (face instanceof THREE.Face4) {\n                face.vertexNormals[0].copy(vertices[face.a]);\n                face.vertexNormals[1].copy(vertices[face.b]);\n                face.vertexNormals[2].copy(vertices[face.c]);\n                face.vertexNormals[3].copy(vertices[face.d]);\n            }\n        }\n    },\n    computeMorphNormals: function() {\n        var i, il, f, fl, face;\n        // save original normals\n        // - create temp variables on first access\n        //   otherwise just copy (for faster repeated calls)\n        for(f = 0, fl = this.faces.length; f < fl; f++){\n            face = this.faces[f];\n            if (!face.__originalFaceNormal) face.__originalFaceNormal = face.normal.clone();\n            else face.__originalFaceNormal.copy(face.normal);\n            if (!face.__originalVertexNormals) face.__originalVertexNormals = [];\n            for(i = 0, il = face.vertexNormals.length; i < il; i++)if (!face.__originalVertexNormals[i]) face.__originalVertexNormals[i] = face.vertexNormals[i].clone();\n            else face.__originalVertexNormals[i].copy(face.vertexNormals[i]);\n        }\n        // use temp geometry to compute face and vertex normals for each morph\n        var tmpGeo = new THREE.Geometry();\n        tmpGeo.faces = this.faces;\n        for(i = 0, il = this.morphTargets.length; i < il; i++){\n            // create on first access\n            if (!this.morphNormals[i]) {\n                this.morphNormals[i] = {};\n                this.morphNormals[i].faceNormals = [];\n                this.morphNormals[i].vertexNormals = [];\n                var dstNormalsFace = this.morphNormals[i].faceNormals;\n                var dstNormalsVertex = this.morphNormals[i].vertexNormals;\n                var faceNormal, vertexNormals;\n                for(f = 0, fl = this.faces.length; f < fl; f++){\n                    face = this.faces[f];\n                    faceNormal = new THREE.Vector3();\n                    if (face instanceof THREE.Face3) vertexNormals = {\n                        a: new THREE.Vector3(),\n                        b: new THREE.Vector3(),\n                        c: new THREE.Vector3()\n                    };\n                    else vertexNormals = {\n                        a: new THREE.Vector3(),\n                        b: new THREE.Vector3(),\n                        c: new THREE.Vector3(),\n                        d: new THREE.Vector3()\n                    };\n                    dstNormalsFace.push(faceNormal);\n                    dstNormalsVertex.push(vertexNormals);\n                }\n            }\n            var morphNormals = this.morphNormals[i];\n            // set vertices to morph target\n            tmpGeo.vertices = this.morphTargets[i].vertices;\n            // compute morph normals\n            tmpGeo.computeFaceNormals();\n            tmpGeo.computeVertexNormals();\n            // store morph normals\n            var faceNormal, vertexNormals;\n            for(f = 0, fl = this.faces.length; f < fl; f++){\n                face = this.faces[f];\n                faceNormal = morphNormals.faceNormals[f];\n                vertexNormals = morphNormals.vertexNormals[f];\n                faceNormal.copy(face.normal);\n                if (face instanceof THREE.Face3) {\n                    vertexNormals.a.copy(face.vertexNormals[0]);\n                    vertexNormals.b.copy(face.vertexNormals[1]);\n                    vertexNormals.c.copy(face.vertexNormals[2]);\n                } else {\n                    vertexNormals.a.copy(face.vertexNormals[0]);\n                    vertexNormals.b.copy(face.vertexNormals[1]);\n                    vertexNormals.c.copy(face.vertexNormals[2]);\n                    vertexNormals.d.copy(face.vertexNormals[3]);\n                }\n            }\n        }\n        // restore original normals\n        for(f = 0, fl = this.faces.length; f < fl; f++){\n            face = this.faces[f];\n            face.normal = face.__originalFaceNormal;\n            face.vertexNormals = face.__originalVertexNormals;\n        }\n    },\n    computeTangents: function() {\n        // based on http://www.terathon.com/code/tangent.html\n        // tangents go to vertices\n        var f, fl, v, vl, i, il, vertexIndex, face, uv, vA, vB, vC, uvA, uvB, uvC, x1, x2, y1, y2, z1, z2, s1, s2, t1, t2, r, t, test, tan1 = [], tan2 = [], sdir = new THREE.Vector3(), tdir = new THREE.Vector3(), tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3(), n = new THREE.Vector3(), w;\n        for(v = 0, vl = this.vertices.length; v < vl; v++){\n            tan1[v] = new THREE.Vector3();\n            tan2[v] = new THREE.Vector3();\n        }\n        function handleTriangle(context, a, b, c, ua, ub, uc) {\n            vA = context.vertices[a];\n            vB = context.vertices[b];\n            vC = context.vertices[c];\n            uvA = uv[ua];\n            uvB = uv[ub];\n            uvC = uv[uc];\n            x1 = vB.x - vA.x;\n            x2 = vC.x - vA.x;\n            y1 = vB.y - vA.y;\n            y2 = vC.y - vA.y;\n            z1 = vB.z - vA.z;\n            z2 = vC.z - vA.z;\n            s1 = uvB.x - uvA.x;\n            s2 = uvC.x - uvA.x;\n            t1 = uvB.y - uvA.y;\n            t2 = uvC.y - uvA.y;\n            r = 1.0 / (s1 * t2 - s2 * t1);\n            sdir.set((t2 * x1 - t1 * x2) * r, (t2 * y1 - t1 * y2) * r, (t2 * z1 - t1 * z2) * r);\n            tdir.set((s1 * x2 - s2 * x1) * r, (s1 * y2 - s2 * y1) * r, (s1 * z2 - s2 * z1) * r);\n            tan1[a].add(sdir);\n            tan1[b].add(sdir);\n            tan1[c].add(sdir);\n            tan2[a].add(tdir);\n            tan2[b].add(tdir);\n            tan2[c].add(tdir);\n        }\n        for(f = 0, fl = this.faces.length; f < fl; f++){\n            face = this.faces[f];\n            uv = this.faceVertexUvs[0][f]; // use UV layer 0 for tangents\n            if (face instanceof THREE.Face3) handleTriangle(this, face.a, face.b, face.c, 0, 1, 2);\n            else if (face instanceof THREE.Face4) {\n                handleTriangle(this, face.a, face.b, face.d, 0, 1, 3);\n                handleTriangle(this, face.b, face.c, face.d, 1, 2, 3);\n            }\n        }\n        var faceIndex = [\n            \"a\",\n            \"b\",\n            \"c\",\n            \"d\"\n        ];\n        for(f = 0, fl = this.faces.length; f < fl; f++){\n            face = this.faces[f];\n            for(i = 0; i < face.vertexNormals.length; i++){\n                n.copy(face.vertexNormals[i]);\n                vertexIndex = face[faceIndex[i]];\n                t = tan1[vertexIndex];\n                // Gram-Schmidt orthogonalize\n                tmp.copy(t);\n                tmp.sub(n.multiplyScalar(n.dot(t))).normalize();\n                // Calculate handedness\n                tmp2.crossVectors(face.vertexNormals[i], t);\n                test = tmp2.dot(tan2[vertexIndex]);\n                w = test < 0.0 ? -1 : 1.0;\n                face.vertexTangents[i] = new THREE.Vector4(tmp.x, tmp.y, tmp.z, w);\n            }\n        }\n        this.hasTangents = true;\n    },\n    computeLineDistances: function() {\n        var d = 0;\n        var vertices = this.vertices;\n        for(var i = 0, il = vertices.length; i < il; i++){\n            if (i > 0) d += vertices[i].distanceTo(vertices[i - 1]);\n            this.lineDistances[i] = d;\n        }\n    },\n    computeBoundingBox: function() {\n        if (this.boundingBox === null) this.boundingBox = new THREE.Box3();\n        this.boundingBox.setFromPoints(this.vertices);\n    },\n    computeBoundingSphere: function() {\n        if (this.boundingSphere === null) this.boundingSphere = new THREE.Sphere();\n        this.boundingSphere.setFromCenterAndPoints(this.boundingSphere.center, this.vertices);\n    },\n    /*\n\t * Checks for duplicate vertices with hashmap.\n\t * Duplicated vertices are removed\n\t * and faces' vertices are updated.\n\t */ mergeVertices: function() {\n        var verticesMap = {}; // Hashmap for looking up vertice by position coordinates (and making sure they are unique)\n        var unique = [], changes = [];\n        var v, key;\n        var precisionPoints = 4; // number of decimal points, eg. 4 for epsilon of 0.0001\n        var precision = Math.pow(10, precisionPoints);\n        var i, il, face;\n        var indices, k, j, jl, u;\n        // reset cache of vertices as it now will be changing.\n        this.__tmpVertices = undefined;\n        for(i = 0, il = this.vertices.length; i < il; i++){\n            v = this.vertices[i];\n            key = [\n                Math.round(v.x * precision),\n                Math.round(v.y * precision),\n                Math.round(v.z * precision)\n            ].join(\"_\");\n            if (verticesMap[key] === undefined) {\n                verticesMap[key] = i;\n                unique.push(this.vertices[i]);\n                changes[i] = unique.length - 1;\n            } else //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\n            changes[i] = changes[verticesMap[key]];\n        }\n        // if faces are completely degenerate after merging vertices, we\n        // have to remove them from the geometry.\n        var faceIndicesToRemove = [];\n        for(i = 0, il = this.faces.length; i < il; i++){\n            face = this.faces[i];\n            if (face instanceof THREE.Face3) {\n                face.a = changes[face.a];\n                face.b = changes[face.b];\n                face.c = changes[face.c];\n                indices = [\n                    face.a,\n                    face.b,\n                    face.c\n                ];\n                var dupIndex = -1;\n                // if any duplicate vertices are found in a Face3\n                // we have to remove the face as nothing can be saved\n                for(var n = 0; n < 3; n++)if (indices[n] == indices[(n + 1) % 3]) {\n                    dupIndex = n;\n                    faceIndicesToRemove.push(i);\n                    break;\n                }\n            } else if (face instanceof THREE.Face4) {\n                face.a = changes[face.a];\n                face.b = changes[face.b];\n                face.c = changes[face.c];\n                face.d = changes[face.d];\n                // check dups in (a, b, c, d) and convert to -> face3\n                indices = [\n                    face.a,\n                    face.b,\n                    face.c,\n                    face.d\n                ];\n                var dupIndex = -1;\n                for(var n = 0; n < 4; n++)if (indices[n] == indices[(n + 1) % 4]) {\n                    // if more than one duplicated vertex is found\n                    // we can't generate any valid Face3's, thus\n                    // we need to remove this face complete.\n                    if (dupIndex >= 0) faceIndicesToRemove.push(i);\n                    dupIndex = n;\n                }\n                if (dupIndex >= 0) {\n                    indices.splice(dupIndex, 1);\n                    var newFace = new THREE.Face3(indices[0], indices[1], indices[2], face.normal, face.color, face.materialIndex);\n                    for(j = 0, jl = this.faceVertexUvs.length; j < jl; j++){\n                        u = this.faceVertexUvs[j][i];\n                        if (u) u.splice(dupIndex, 1);\n                    }\n                    if (face.vertexNormals && face.vertexNormals.length > 0) {\n                        newFace.vertexNormals = face.vertexNormals;\n                        newFace.vertexNormals.splice(dupIndex, 1);\n                    }\n                    if (face.vertexColors && face.vertexColors.length > 0) {\n                        newFace.vertexColors = face.vertexColors;\n                        newFace.vertexColors.splice(dupIndex, 1);\n                    }\n                    this.faces[i] = newFace;\n                }\n            }\n        }\n        for(i = faceIndicesToRemove.length - 1; i >= 0; i--){\n            this.faces.splice(i, 1);\n            for(j = 0, jl = this.faceVertexUvs.length; j < jl; j++)this.faceVertexUvs[j].splice(i, 1);\n        }\n        // Use unique set of vertices\n        var diff = this.vertices.length - unique.length;\n        this.vertices = unique;\n        return diff;\n    },\n    clone: function() {\n        var geometry = new THREE.Geometry();\n        var vertices = this.vertices;\n        for(var i = 0, il = vertices.length; i < il; i++)geometry.vertices.push(vertices[i].clone());\n        var faces = this.faces;\n        for(var i = 0, il = faces.length; i < il; i++)geometry.faces.push(faces[i].clone());\n        var uvs = this.faceVertexUvs[0];\n        for(var i = 0, il = uvs.length; i < il; i++){\n            var uv = uvs[i], uvCopy = [];\n            for(var j = 0, jl = uv.length; j < jl; j++)uvCopy.push(new THREE.Vector2(uv[j].x, uv[j].y));\n            geometry.faceVertexUvs[0].push(uvCopy);\n        }\n        return geometry;\n    },\n    dispose: function() {\n        this.dispatchEvent({\n            type: \"dispose\"\n        });\n    }\n};\nTHREE.GeometryIdCount = 0;\n/**\n * @author alteredq / http://alteredqualia.com/\n */ THREE.BufferGeometry = function() {\n    THREE.EventDispatcher.call(this);\n    this.id = THREE.GeometryIdCount++;\n    // attributes\n    this.attributes = {};\n    // attributes typed arrays are kept only if dynamic flag is set\n    this.dynamic = false;\n    // offsets for chunks when using indexed elements\n    this.offsets = [];\n    // boundings\n    this.boundingBox = null;\n    this.boundingSphere = null;\n    this.hasTangents = false;\n    // for compatibility\n    this.morphTargets = [];\n};\nTHREE.BufferGeometry.prototype = {\n    constructor: THREE.BufferGeometry,\n    applyMatrix: function(matrix) {\n        var positionArray;\n        var normalArray;\n        if (this.attributes[\"position\"]) positionArray = this.attributes[\"position\"].array;\n        if (this.attributes[\"normal\"]) normalArray = this.attributes[\"normal\"].array;\n        if (positionArray !== undefined) {\n            matrix.multiplyVector3Array(positionArray);\n            this.verticesNeedUpdate = true;\n        }\n        if (normalArray !== undefined) {\n            var normalMatrix = new THREE.Matrix3();\n            normalMatrix.getInverse(matrix).transpose();\n            normalMatrix.multiplyVector3Array(normalArray);\n            this.normalizeNormals();\n            this.normalsNeedUpdate = true;\n        }\n    },\n    computeBoundingBox: function() {\n        if (this.boundingBox === null) this.boundingBox = new THREE.Box3();\n        var positions = this.attributes[\"position\"].array;\n        if (positions) {\n            var bb = this.boundingBox;\n            var x, y, z;\n            if (positions.length >= 3) {\n                bb.min.x = bb.max.x = positions[0];\n                bb.min.y = bb.max.y = positions[1];\n                bb.min.z = bb.max.z = positions[2];\n            }\n            for(var i = 3, il = positions.length; i < il; i += 3){\n                x = positions[i];\n                y = positions[i + 1];\n                z = positions[i + 2];\n                // bounding box\n                if (x < bb.min.x) bb.min.x = x;\n                else if (x > bb.max.x) bb.max.x = x;\n                if (y < bb.min.y) bb.min.y = y;\n                else if (y > bb.max.y) bb.max.y = y;\n                if (z < bb.min.z) bb.min.z = z;\n                else if (z > bb.max.z) bb.max.z = z;\n            }\n        }\n        if (positions === undefined || positions.length === 0) {\n            this.boundingBox.min.set(0, 0, 0);\n            this.boundingBox.max.set(0, 0, 0);\n        }\n    },\n    computeBoundingSphere: function() {\n        if (this.boundingSphere === null) this.boundingSphere = new THREE.Sphere();\n        var positions = this.attributes[\"position\"].array;\n        if (positions) {\n            var radiusSq, maxRadiusSq = 0;\n            var x, y, z;\n            for(var i = 0, il = positions.length; i < il; i += 3){\n                x = positions[i];\n                y = positions[i + 1];\n                z = positions[i + 2];\n                radiusSq = x * x + y * y + z * z;\n                if (radiusSq > maxRadiusSq) maxRadiusSq = radiusSq;\n            }\n            this.boundingSphere.radius = Math.sqrt(maxRadiusSq);\n        }\n    },\n    computeVertexNormals: function() {\n        if (this.attributes[\"position\"]) {\n            var i, il;\n            var j, jl;\n            var nVertexElements = this.attributes[\"position\"].array.length;\n            if (this.attributes[\"normal\"] === undefined) this.attributes[\"normal\"] = {\n                itemSize: 3,\n                array: new Float32Array(nVertexElements),\n                numItems: nVertexElements\n            };\n            else // reset existing normals to zero\n            for(i = 0, il = this.attributes[\"normal\"].array.length; i < il; i++)this.attributes[\"normal\"].array[i] = 0;\n            var positions = this.attributes[\"position\"].array;\n            var normals = this.attributes[\"normal\"].array;\n            var vA, vB, vC, x, y, z, pA = new THREE.Vector3(), pB = new THREE.Vector3(), pC = new THREE.Vector3(), cb = new THREE.Vector3(), ab = new THREE.Vector3();\n            // indexed elements\n            if (this.attributes[\"index\"]) {\n                var indices = this.attributes[\"index\"].array;\n                var offsets = this.offsets;\n                for(j = 0, jl = offsets.length; j < jl; ++j){\n                    var start = offsets[j].start;\n                    var count = offsets[j].count;\n                    var index = offsets[j].index;\n                    for(i = start, il = start + count; i < il; i += 3){\n                        vA = index + indices[i];\n                        vB = index + indices[i + 1];\n                        vC = index + indices[i + 2];\n                        x = positions[vA * 3];\n                        y = positions[vA * 3 + 1];\n                        z = positions[vA * 3 + 2];\n                        pA.set(x, y, z);\n                        x = positions[vB * 3];\n                        y = positions[vB * 3 + 1];\n                        z = positions[vB * 3 + 2];\n                        pB.set(x, y, z);\n                        x = positions[vC * 3];\n                        y = positions[vC * 3 + 1];\n                        z = positions[vC * 3 + 2];\n                        pC.set(x, y, z);\n                        cb.subVectors(pC, pB);\n                        ab.subVectors(pA, pB);\n                        cb.cross(ab);\n                        normals[vA * 3] += cb.x;\n                        normals[vA * 3 + 1] += cb.y;\n                        normals[vA * 3 + 2] += cb.z;\n                        normals[vB * 3] += cb.x;\n                        normals[vB * 3 + 1] += cb.y;\n                        normals[vB * 3 + 2] += cb.z;\n                        normals[vC * 3] += cb.x;\n                        normals[vC * 3 + 1] += cb.y;\n                        normals[vC * 3 + 2] += cb.z;\n                    }\n                }\n            // non-indexed elements (unconnected triangle soup)\n            } else for(i = 0, il = positions.length; i < il; i += 9){\n                x = positions[i];\n                y = positions[i + 1];\n                z = positions[i + 2];\n                pA.set(x, y, z);\n                x = positions[i + 3];\n                y = positions[i + 4];\n                z = positions[i + 5];\n                pB.set(x, y, z);\n                x = positions[i + 6];\n                y = positions[i + 7];\n                z = positions[i + 8];\n                pC.set(x, y, z);\n                cb.subVectors(pC, pB);\n                ab.subVectors(pA, pB);\n                cb.cross(ab);\n                normals[i] = cb.x;\n                normals[i + 1] = cb.y;\n                normals[i + 2] = cb.z;\n                normals[i + 3] = cb.x;\n                normals[i + 4] = cb.y;\n                normals[i + 5] = cb.z;\n                normals[i + 6] = cb.x;\n                normals[i + 7] = cb.y;\n                normals[i + 8] = cb.z;\n            }\n            this.normalizeNormals();\n            this.normalsNeedUpdate = true;\n        }\n    },\n    normalizeNormals: function() {\n        var normals = this.attributes[\"normal\"].array;\n        var x, y, z, n;\n        for(var i = 0, il = normals.length; i < il; i += 3){\n            x = normals[i];\n            y = normals[i + 1];\n            z = normals[i + 2];\n            n = 1.0 / Math.sqrt(x * x + y * y + z * z);\n            normals[i] *= n;\n            normals[i + 1] *= n;\n            normals[i + 2] *= n;\n        }\n    },\n    computeTangents: function() {\n        // based on http://www.terathon.com/code/tangent.html\n        // (per vertex tangents)\n        if (this.attributes[\"index\"] === undefined || this.attributes[\"position\"] === undefined || this.attributes[\"normal\"] === undefined || this.attributes[\"uv\"] === undefined) {\n            console.warn(\"Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()\");\n            return;\n        }\n        var indices = this.attributes[\"index\"].array;\n        var positions = this.attributes[\"position\"].array;\n        var normals = this.attributes[\"normal\"].array;\n        var uvs = this.attributes[\"uv\"].array;\n        var nVertices = positions.length / 3;\n        if (this.attributes[\"tangent\"] === undefined) {\n            var nTangentElements = 4 * nVertices;\n            this.attributes[\"tangent\"] = {\n                itemSize: 4,\n                array: new Float32Array(nTangentElements),\n                numItems: nTangentElements\n            };\n        }\n        var tangents = this.attributes[\"tangent\"].array;\n        var tan1 = [], tan2 = [];\n        for(var k = 0; k < nVertices; k++){\n            tan1[k] = new THREE.Vector3();\n            tan2[k] = new THREE.Vector3();\n        }\n        var xA, yA, zA, xB, yB, zB, xC, yC, zC, uA, vA, uB, vB, uC, vC, x1, x2, y1, y2, z1, z2, s1, s2, t1, t2, r;\n        var sdir = new THREE.Vector3(), tdir = new THREE.Vector3();\n        function handleTriangle(a, b, c) {\n            xA = positions[a * 3];\n            yA = positions[a * 3 + 1];\n            zA = positions[a * 3 + 2];\n            xB = positions[b * 3];\n            yB = positions[b * 3 + 1];\n            zB = positions[b * 3 + 2];\n            xC = positions[c * 3];\n            yC = positions[c * 3 + 1];\n            zC = positions[c * 3 + 2];\n            uA = uvs[a * 2];\n            vA = uvs[a * 2 + 1];\n            uB = uvs[b * 2];\n            vB = uvs[b * 2 + 1];\n            uC = uvs[c * 2];\n            vC = uvs[c * 2 + 1];\n            x1 = xB - xA;\n            x2 = xC - xA;\n            y1 = yB - yA;\n            y2 = yC - yA;\n            z1 = zB - zA;\n            z2 = zC - zA;\n            s1 = uB - uA;\n            s2 = uC - uA;\n            t1 = vB - vA;\n            t2 = vC - vA;\n            r = 1.0 / (s1 * t2 - s2 * t1);\n            sdir.set((t2 * x1 - t1 * x2) * r, (t2 * y1 - t1 * y2) * r, (t2 * z1 - t1 * z2) * r);\n            tdir.set((s1 * x2 - s2 * x1) * r, (s1 * y2 - s2 * y1) * r, (s1 * z2 - s2 * z1) * r);\n            tan1[a].add(sdir);\n            tan1[b].add(sdir);\n            tan1[c].add(sdir);\n            tan2[a].add(tdir);\n            tan2[b].add(tdir);\n            tan2[c].add(tdir);\n        }\n        var i, il;\n        var j, jl;\n        var iA, iB, iC;\n        var offsets = this.offsets;\n        for(j = 0, jl = offsets.length; j < jl; ++j){\n            var start = offsets[j].start;\n            var count = offsets[j].count;\n            var index = offsets[j].index;\n            for(i = start, il = start + count; i < il; i += 3){\n                iA = index + indices[i];\n                iB = index + indices[i + 1];\n                iC = index + indices[i + 2];\n                handleTriangle(iA, iB, iC);\n            }\n        }\n        var tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3();\n        var n = new THREE.Vector3(), n2 = new THREE.Vector3();\n        var w, t, test;\n        function handleVertex(v) {\n            n.x = normals[v * 3];\n            n.y = normals[v * 3 + 1];\n            n.z = normals[v * 3 + 2];\n            n2.copy(n);\n            t = tan1[v];\n            // Gram-Schmidt orthogonalize\n            tmp.copy(t);\n            tmp.sub(n.multiplyScalar(n.dot(t))).normalize();\n            // Calculate handedness\n            tmp2.crossVectors(n2, t);\n            test = tmp2.dot(tan2[v]);\n            w = test < 0.0 ? -1 : 1.0;\n            tangents[v * 4] = tmp.x;\n            tangents[v * 4 + 1] = tmp.y;\n            tangents[v * 4 + 2] = tmp.z;\n            tangents[v * 4 + 3] = w;\n        }\n        for(j = 0, jl = offsets.length; j < jl; ++j){\n            var start = offsets[j].start;\n            var count = offsets[j].count;\n            var index = offsets[j].index;\n            for(i = start, il = start + count; i < il; i += 3){\n                iA = index + indices[i];\n                iB = index + indices[i + 1];\n                iC = index + indices[i + 2];\n                handleVertex(iA);\n                handleVertex(iB);\n                handleVertex(iC);\n            }\n        }\n        this.hasTangents = true;\n        this.tangentsNeedUpdate = true;\n    },\n    dispose: function() {\n        this.dispatchEvent({\n            type: \"dispose\"\n        });\n    }\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author mikael emtinger / http://gomo.se/\n */ THREE.Camera = function() {\n    THREE.Object3D.call(this);\n    this.matrixWorldInverse = new THREE.Matrix4();\n    this.projectionMatrix = new THREE.Matrix4();\n    this.projectionMatrixInverse = new THREE.Matrix4();\n};\nTHREE.Camera.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.Camera.prototype.lookAt = function(vector) {\n    // TODO: Add hierarchy support.\n    this.matrix.lookAt(this.position, vector, this.up);\n    if (this.rotationAutoUpdate === true) {\n        if (this.useQuaternion === false) this.rotation.setEulerFromRotationMatrix(this.matrix, this.eulerOrder);\n        else this.quaternion.copy(this.matrix.decompose()[1]);\n    }\n};\n/**\n * @author alteredq / http://alteredqualia.com/\n */ THREE.OrthographicCamera = function(left, right, top, bottom, near, far) {\n    THREE.Camera.call(this);\n    this.left = left;\n    this.right = right;\n    this.top = top;\n    this.bottom = bottom;\n    this.near = near !== undefined ? near : 0.1;\n    this.far = far !== undefined ? far : 2000;\n    this.updateProjectionMatrix();\n};\nTHREE.OrthographicCamera.prototype = Object.create(THREE.Camera.prototype);\nTHREE.OrthographicCamera.prototype.updateProjectionMatrix = function() {\n    this.projectionMatrix.makeOrthographic(this.left, this.right, this.top, this.bottom, this.near, this.far);\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author greggman / http://games.greggman.com/\n * @author zz85 / http://www.lab4games.net/zz85/blog\n */ THREE.PerspectiveCamera = function(fov, aspect, near, far) {\n    THREE.Camera.call(this);\n    this.fov = fov !== undefined ? fov : 50;\n    this.aspect = aspect !== undefined ? aspect : 1;\n    this.near = near !== undefined ? near : 0.1;\n    this.far = far !== undefined ? far : 2000;\n    this.updateProjectionMatrix();\n};\nTHREE.PerspectiveCamera.prototype = Object.create(THREE.Camera.prototype);\n/**\n * Uses Focal Length (in mm) to estimate and set FOV\n * 35mm (fullframe) camera is used if frame size is not specified;\n * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html\n */ THREE.PerspectiveCamera.prototype.setLens = function(focalLength, frameHeight) {\n    if (frameHeight === undefined) frameHeight = 24;\n    this.fov = 2 * THREE.Math.radToDeg(Math.atan(frameHeight / (focalLength * 2)));\n    this.updateProjectionMatrix();\n};\n/**\n * Sets an offset in a larger frustum. This is useful for multi-window or\n * multi-monitor/multi-machine setups.\n *\n * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\n * the monitors are in grid like this\n *\n *   +---+---+---+\n *   | A | B | C |\n *   +---+---+---+\n *   | D | E | F |\n *   +---+---+---+\n *\n * then for each monitor you would call it like this\n *\n *   var w = 1920;\n *   var h = 1080;\n *   var fullWidth = w * 3;\n *   var fullHeight = h * 2;\n *\n *   --A--\n *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n *   --B--\n *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n *   --C--\n *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n *   --D--\n *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n *   --E--\n *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n *   --F--\n *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n *\n *   Note there is no reason monitors have to be the same size or in a grid.\n */ THREE.PerspectiveCamera.prototype.setViewOffset = function(fullWidth, fullHeight, x, y, width, height) {\n    this.fullWidth = fullWidth;\n    this.fullHeight = fullHeight;\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    this.updateProjectionMatrix();\n};\nTHREE.PerspectiveCamera.prototype.updateProjectionMatrix = function() {\n    if (this.fullWidth) {\n        var aspect = this.fullWidth / this.fullHeight;\n        var top = Math.tan(THREE.Math.degToRad(this.fov * 0.5)) * this.near;\n        var bottom = -top;\n        var left = aspect * bottom;\n        var right = aspect * top;\n        var width = Math.abs(right - left);\n        var height = Math.abs(top - bottom);\n        this.projectionMatrix.makeFrustum(left + this.x * width / this.fullWidth, left + (this.x + this.width) * width / this.fullWidth, top - (this.y + this.height) * height / this.fullHeight, top - this.y * height / this.fullHeight, this.near, this.far);\n    } else this.projectionMatrix.makePerspective(this.fov, this.aspect, this.near, this.far);\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */ THREE.Light = function(hex) {\n    THREE.Object3D.call(this);\n    this.color = new THREE.Color(hex);\n};\nTHREE.Light.prototype = Object.create(THREE.Object3D.prototype);\n/**\n * @author mrdoob / http://mrdoob.com/\n */ THREE.AmbientLight = function(hex) {\n    THREE.Light.call(this, hex);\n};\nTHREE.AmbientLight.prototype = Object.create(THREE.Light.prototype);\n/**\n * @author MPanknin / http://www.redplant.de/\n * @author alteredq / http://alteredqualia.com/\n */ THREE.AreaLight = function(hex, intensity) {\n    THREE.Light.call(this, hex);\n    this.normal = new THREE.Vector3(0, -1, 0);\n    this.right = new THREE.Vector3(1, 0, 0);\n    this.intensity = intensity !== undefined ? intensity : 1;\n    this.width = 1.0;\n    this.height = 1.0;\n    this.constantAttenuation = 1.5;\n    this.linearAttenuation = 0.5;\n    this.quadraticAttenuation = 0.1;\n};\nTHREE.AreaLight.prototype = Object.create(THREE.Light.prototype);\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */ THREE.DirectionalLight = function(hex, intensity) {\n    THREE.Light.call(this, hex);\n    this.position = new THREE.Vector3(0, 1, 0);\n    this.target = new THREE.Object3D();\n    this.intensity = intensity !== undefined ? intensity : 1;\n    this.castShadow = false;\n    this.onlyShadow = false;\n    //\n    this.shadowCameraNear = 50;\n    this.shadowCameraFar = 5000;\n    this.shadowCameraLeft = -500;\n    this.shadowCameraRight = 500;\n    this.shadowCameraTop = 500;\n    this.shadowCameraBottom = -500;\n    this.shadowCameraVisible = false;\n    this.shadowBias = 0;\n    this.shadowDarkness = 0.5;\n    this.shadowMapWidth = 512;\n    this.shadowMapHeight = 512;\n    //\n    this.shadowCascade = false;\n    this.shadowCascadeOffset = new THREE.Vector3(0, 0, -1000);\n    this.shadowCascadeCount = 2;\n    this.shadowCascadeBias = [\n        0,\n        0,\n        0\n    ];\n    this.shadowCascadeWidth = [\n        512,\n        512,\n        512\n    ];\n    this.shadowCascadeHeight = [\n        512,\n        512,\n        512\n    ];\n    this.shadowCascadeNearZ = [\n        -1,\n        0.990,\n        0.998\n    ];\n    this.shadowCascadeFarZ = [\n        0.990,\n        0.998,\n        1.000\n    ];\n    this.shadowCascadeArray = [];\n    //\n    this.shadowMap = null;\n    this.shadowMapSize = null;\n    this.shadowCamera = null;\n    this.shadowMatrix = null;\n};\nTHREE.DirectionalLight.prototype = Object.create(THREE.Light.prototype);\n/**\n * @author alteredq / http://alteredqualia.com/\n */ THREE.HemisphereLight = function(skyColorHex, groundColorHex, intensity) {\n    THREE.Light.call(this, skyColorHex);\n    this.groundColor = new THREE.Color(groundColorHex);\n    this.position = new THREE.Vector3(0, 100, 0);\n    this.intensity = intensity !== undefined ? intensity : 1;\n};\nTHREE.HemisphereLight.prototype = Object.create(THREE.Light.prototype);\n/**\n * @author mrdoob / http://mrdoob.com/\n */ THREE.PointLight = function(hex, intensity, distance) {\n    THREE.Light.call(this, hex);\n    this.position = new THREE.Vector3(0, 0, 0);\n    this.intensity = intensity !== undefined ? intensity : 1;\n    this.distance = distance !== undefined ? distance : 0;\n};\nTHREE.PointLight.prototype = Object.create(THREE.Light.prototype);\n/**\n * @author alteredq / http://alteredqualia.com/\n */ THREE.SpotLight = function(hex, intensity, distance, angle, exponent) {\n    THREE.Light.call(this, hex);\n    this.position = new THREE.Vector3(0, 1, 0);\n    this.target = new THREE.Object3D();\n    this.intensity = intensity !== undefined ? intensity : 1;\n    this.distance = distance !== undefined ? distance : 0;\n    this.angle = angle !== undefined ? angle : Math.PI / 2;\n    this.exponent = exponent !== undefined ? exponent : 10;\n    this.castShadow = false;\n    this.onlyShadow = false;\n    //\n    this.shadowCameraNear = 50;\n    this.shadowCameraFar = 5000;\n    this.shadowCameraFov = 50;\n    this.shadowCameraVisible = false;\n    this.shadowBias = 0;\n    this.shadowDarkness = 0.5;\n    this.shadowMapWidth = 512;\n    this.shadowMapHeight = 512;\n    //\n    this.shadowMap = null;\n    this.shadowMapSize = null;\n    this.shadowCamera = null;\n    this.shadowMatrix = null;\n};\nTHREE.SpotLight.prototype = Object.create(THREE.Light.prototype);\n/**\n * @author alteredq / http://alteredqualia.com/\n */ THREE.Loader = function(showStatus) {\n    this.showStatus = showStatus;\n    this.statusDomElement = showStatus ? THREE.Loader.prototype.addStatusElement() : null;\n    this.onLoadStart = function() {};\n    this.onLoadProgress = function() {};\n    this.onLoadComplete = function() {};\n};\nTHREE.Loader.prototype = {\n    constructor: THREE.Loader,\n    crossOrigin: \"anonymous\",\n    addStatusElement: function() {\n        var e = document.createElement(\"div\");\n        e.style.position = \"absolute\";\n        e.style.right = \"0px\";\n        e.style.top = \"0px\";\n        e.style.fontSize = \"0.8em\";\n        e.style.textAlign = \"left\";\n        e.style.background = \"rgba(0,0,0,0.25)\";\n        e.style.color = \"#fff\";\n        e.style.width = \"120px\";\n        e.style.padding = \"0.5em 0.5em 0.5em 0.5em\";\n        e.style.zIndex = 1000;\n        e.innerHTML = \"Loading ...\";\n        return e;\n    },\n    updateProgress: function(progress) {\n        var message = \"Loaded \";\n        if (progress.total) message += (100 * progress.loaded / progress.total).toFixed(0) + \"%\";\n        else message += (progress.loaded / 1000).toFixed(2) + \" KB\";\n        this.statusDomElement.innerHTML = message;\n    },\n    extractUrlBase: function(url) {\n        var parts = url.split(\"/\");\n        parts.pop();\n        return (parts.length < 1 ? \".\" : parts.join(\"/\")) + \"/\";\n    },\n    initMaterials: function(materials, texturePath) {\n        var array = [];\n        for(var i = 0; i < materials.length; ++i)array[i] = THREE.Loader.prototype.createMaterial(materials[i], texturePath);\n        return array;\n    },\n    needsTangents: function(materials) {\n        for(var i = 0, il = materials.length; i < il; i++){\n            var m = materials[i];\n            if (m instanceof THREE.ShaderMaterial) return true;\n        }\n        return false;\n    },\n    createMaterial: function(m, texturePath) {\n        var _this = this;\n        function is_pow2(n) {\n            var l = Math.log(n) / Math.LN2;\n            return Math.floor(l) == l;\n        }\n        function nearest_pow2(n) {\n            var l = Math.log(n) / Math.LN2;\n            return Math.pow(2, Math.round(l));\n        }\n        function load_image(where, url) {\n            var image = new Image();\n            image.onload = function() {\n                if (!is_pow2(this.width) || !is_pow2(this.height)) {\n                    var width = nearest_pow2(this.width);\n                    var height = nearest_pow2(this.height);\n                    where.image.width = width;\n                    where.image.height = height;\n                    where.image.getContext(\"2d\").drawImage(this, 0, 0, width, height);\n                } else where.image = this;\n                where.needsUpdate = true;\n            };\n            image.crossOrigin = _this.crossOrigin;\n            image.src = url;\n        }\n        function create_texture(where, name, sourceFile, repeat, offset, wrap, anisotropy) {\n            var isCompressed = /\\.dds$/i.test(sourceFile);\n            var fullPath = texturePath + \"/\" + sourceFile;\n            if (isCompressed) {\n                var texture = THREE.ImageUtils.loadCompressedTexture(fullPath);\n                where[name] = texture;\n            } else {\n                var texture = document.createElement(\"canvas\");\n                where[name] = new THREE.Texture(texture);\n            }\n            where[name].sourceFile = sourceFile;\n            if (repeat) {\n                where[name].repeat.set(repeat[0], repeat[1]);\n                if (repeat[0] !== 1) where[name].wrapS = THREE.RepeatWrapping;\n                if (repeat[1] !== 1) where[name].wrapT = THREE.RepeatWrapping;\n            }\n            if (offset) where[name].offset.set(offset[0], offset[1]);\n            if (wrap) {\n                var wrapMap = {\n                    \"repeat\": THREE.RepeatWrapping,\n                    \"mirror\": THREE.MirroredRepeatWrapping\n                };\n                if (wrapMap[wrap[0]] !== undefined) where[name].wrapS = wrapMap[wrap[0]];\n                if (wrapMap[wrap[1]] !== undefined) where[name].wrapT = wrapMap[wrap[1]];\n            }\n            if (anisotropy) where[name].anisotropy = anisotropy;\n            if (!isCompressed) load_image(where[name], fullPath);\n        }\n        function rgb2hex(rgb) {\n            return (rgb[0] * 255 << 16) + (rgb[1] * 255 << 8) + rgb[2] * 255;\n        }\n        // defaults\n        var mtype = \"MeshLambertMaterial\";\n        var mpars = {\n            color: 0xeeeeee,\n            opacity: 1.0,\n            map: null,\n            lightMap: null,\n            normalMap: null,\n            bumpMap: null,\n            wireframe: false\n        };\n        // parameters from model file\n        if (m.shading) {\n            var shading = m.shading.toLowerCase();\n            if (shading === \"phong\") mtype = \"MeshPhongMaterial\";\n            else if (shading === \"basic\") mtype = \"MeshBasicMaterial\";\n        }\n        if (m.blending !== undefined && THREE[m.blending] !== undefined) mpars.blending = THREE[m.blending];\n        if (m.transparent !== undefined || m.opacity < 1.0) mpars.transparent = m.transparent;\n        if (m.depthTest !== undefined) mpars.depthTest = m.depthTest;\n        if (m.depthWrite !== undefined) mpars.depthWrite = m.depthWrite;\n        if (m.visible !== undefined) mpars.visible = m.visible;\n        if (m.flipSided !== undefined) mpars.side = THREE.BackSide;\n        if (m.doubleSided !== undefined) mpars.side = THREE.DoubleSide;\n        if (m.wireframe !== undefined) mpars.wireframe = m.wireframe;\n        if (m.vertexColors !== undefined) {\n            if (m.vertexColors === \"face\") mpars.vertexColors = THREE.FaceColors;\n            else if (m.vertexColors) mpars.vertexColors = THREE.VertexColors;\n        }\n        // colors\n        if (m.colorDiffuse) mpars.color = rgb2hex(m.colorDiffuse);\n        else if (m.DbgColor) mpars.color = m.DbgColor;\n        if (m.colorSpecular) mpars.specular = rgb2hex(m.colorSpecular);\n        if (m.colorAmbient) mpars.ambient = rgb2hex(m.colorAmbient);\n        // modifiers\n        if (m.transparency) mpars.opacity = m.transparency;\n        if (m.specularCoef) mpars.shininess = m.specularCoef;\n        // textures\n        if (m.mapDiffuse && texturePath) create_texture(mpars, \"map\", m.mapDiffuse, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy);\n        if (m.mapLight && texturePath) create_texture(mpars, \"lightMap\", m.mapLight, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy);\n        if (m.mapBump && texturePath) create_texture(mpars, \"bumpMap\", m.mapBump, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy);\n        if (m.mapNormal && texturePath) create_texture(mpars, \"normalMap\", m.mapNormal, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy);\n        if (m.mapSpecular && texturePath) create_texture(mpars, \"specularMap\", m.mapSpecular, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy);\n        //\n        if (m.mapBumpScale) mpars.bumpScale = m.mapBumpScale;\n        // special case for normal mapped material\n        if (m.mapNormal) {\n            var shader = THREE.ShaderLib[\"normalmap\"];\n            var uniforms = THREE.UniformsUtils.clone(shader.uniforms);\n            uniforms[\"tNormal\"].value = mpars.normalMap;\n            if (m.mapNormalFactor) uniforms[\"uNormalScale\"].value.set(m.mapNormalFactor, m.mapNormalFactor);\n            if (mpars.map) {\n                uniforms[\"tDiffuse\"].value = mpars.map;\n                uniforms[\"enableDiffuse\"].value = true;\n            }\n            if (mpars.specularMap) {\n                uniforms[\"tSpecular\"].value = mpars.specularMap;\n                uniforms[\"enableSpecular\"].value = true;\n            }\n            if (mpars.lightMap) {\n                uniforms[\"tAO\"].value = mpars.lightMap;\n                uniforms[\"enableAO\"].value = true;\n            }\n            // for the moment don't handle displacement texture\n            uniforms[\"uDiffuseColor\"].value.setHex(mpars.color);\n            uniforms[\"uSpecularColor\"].value.setHex(mpars.specular);\n            uniforms[\"uAmbientColor\"].value.setHex(mpars.ambient);\n            uniforms[\"uShininess\"].value = mpars.shininess;\n            if (mpars.opacity !== undefined) uniforms[\"uOpacity\"].value = mpars.opacity;\n            var parameters = {\n                fragmentShader: shader.fragmentShader,\n                vertexShader: shader.vertexShader,\n                uniforms: uniforms,\n                lights: true,\n                fog: true\n            };\n            var material = new THREE.ShaderMaterial(parameters);\n            if (mpars.transparent) material.transparent = true;\n        } else var material = new THREE[mtype](mpars);\n        if (m.DbgName !== undefined) material.name = m.DbgName;\n        return material;\n    }\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n */ THREE.ImageLoader = function() {\n    THREE.EventDispatcher.call(this);\n    this.crossOrigin = null;\n};\nTHREE.ImageLoader.prototype = {\n    constructor: THREE.ImageLoader,\n    load: function(url, image) {\n        var scope = this;\n        if (image === undefined) image = new Image();\n        image.addEventListener(\"load\", function() {\n            scope.dispatchEvent({\n                type: \"load\",\n                content: image\n            });\n        }, false);\n        image.addEventListener(\"error\", function() {\n            scope.dispatchEvent({\n                type: \"error\",\n                message: \"Couldn't load URL [\" + url + \"]\"\n            });\n        }, false);\n        if (scope.crossOrigin) image.crossOrigin = scope.crossOrigin;\n        image.src = url;\n    }\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */ THREE.JSONLoader = function(showStatus) {\n    THREE.Loader.call(this, showStatus);\n    this.withCredentials = false;\n};\nTHREE.JSONLoader.prototype = Object.create(THREE.Loader.prototype);\nTHREE.JSONLoader.prototype.load = function(url, callback, texturePath) {\n    var scope = this;\n    // todo: unify load API to for easier SceneLoader use\n    texturePath = texturePath && typeof texturePath === \"string\" ? texturePath : this.extractUrlBase(url);\n    this.onLoadStart();\n    this.loadAjaxJSON(this, url, callback, texturePath);\n};\nTHREE.JSONLoader.prototype.loadAjaxJSON = function(context, url, callback, texturePath, callbackProgress) {\n    var xhr = new XMLHttpRequest();\n    var length = 0;\n    xhr.onreadystatechange = function() {\n        if (xhr.readyState === xhr.DONE) {\n            if (xhr.status === 200 || xhr.status === 0) {\n                if (xhr.responseText) {\n                    var json = JSON.parse(xhr.responseText);\n                    context.createModel(json, callback, texturePath);\n                } else console.warn(\"THREE.JSONLoader: [\" + url + \"] seems to be unreachable or file there is empty\");\n                // in context of more complex asset initialization\n                // do not block on single failed file\n                // maybe should go even one more level up\n                context.onLoadComplete();\n            } else console.error(\"THREE.JSONLoader: Couldn't load [\" + url + \"] [\" + xhr.status + \"]\");\n        } else if (xhr.readyState === xhr.LOADING) {\n            if (callbackProgress) {\n                if (length === 0) length = xhr.getResponseHeader(\"Content-Length\");\n                callbackProgress({\n                    total: length,\n                    loaded: xhr.responseText.length\n                });\n            }\n        } else if (xhr.readyState === xhr.HEADERS_RECEIVED) length = xhr.getResponseHeader(\"Content-Length\");\n    };\n    xhr.open(\"GET\", url, true);\n    xhr.withCredentials = this.withCredentials;\n    xhr.send(null);\n};\nTHREE.JSONLoader.prototype.createModel = function(json, callback, texturePath) {\n    var scope = this, geometry = new THREE.Geometry(), scale = json.scale !== undefined ? 1.0 / json.scale : 1.0;\n    parseModel(scale);\n    parseSkin();\n    parseMorphing(scale);\n    geometry.computeCentroids();\n    geometry.computeFaceNormals();\n    function parseModel(scale) {\n        function isBitSet(value, position) {\n            return value & 1 << position;\n        }\n        var i, j, fi, offset, zLength, nVertices, colorIndex, normalIndex, uvIndex, materialIndex, type, isQuad, hasMaterial, hasFaceUv, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor, vertex, face, color, normal, uvLayer, uvs, u, v, faces = json.faces, vertices = json.vertices, normals = json.normals, colors = json.colors, nUvLayers = 0;\n        // disregard empty arrays\n        for(i = 0; i < json.uvs.length; i++)if (json.uvs[i].length) nUvLayers++;\n        for(i = 0; i < nUvLayers; i++){\n            geometry.faceUvs[i] = [];\n            geometry.faceVertexUvs[i] = [];\n        }\n        offset = 0;\n        zLength = vertices.length;\n        while(offset < zLength){\n            vertex = new THREE.Vector3();\n            vertex.x = vertices[offset++] * scale;\n            vertex.y = vertices[offset++] * scale;\n            vertex.z = vertices[offset++] * scale;\n            geometry.vertices.push(vertex);\n        }\n        offset = 0;\n        zLength = faces.length;\n        while(offset < zLength){\n            type = faces[offset++];\n            isQuad = isBitSet(type, 0);\n            hasMaterial = isBitSet(type, 1);\n            hasFaceUv = isBitSet(type, 2);\n            hasFaceVertexUv = isBitSet(type, 3);\n            hasFaceNormal = isBitSet(type, 4);\n            hasFaceVertexNormal = isBitSet(type, 5);\n            hasFaceColor = isBitSet(type, 6);\n            hasFaceVertexColor = isBitSet(type, 7);\n            //console.log(\"type\", type, \"bits\", isQuad, hasMaterial, hasFaceUv, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);\n            if (isQuad) {\n                face = new THREE.Face4();\n                face.a = faces[offset++];\n                face.b = faces[offset++];\n                face.c = faces[offset++];\n                face.d = faces[offset++];\n                nVertices = 4;\n            } else {\n                face = new THREE.Face3();\n                face.a = faces[offset++];\n                face.b = faces[offset++];\n                face.c = faces[offset++];\n                nVertices = 3;\n            }\n            if (hasMaterial) {\n                materialIndex = faces[offset++];\n                face.materialIndex = materialIndex;\n            }\n            // to get face <=> uv index correspondence\n            fi = geometry.faces.length;\n            if (hasFaceUv) for(i = 0; i < nUvLayers; i++){\n                uvLayer = json.uvs[i];\n                uvIndex = faces[offset++];\n                u = uvLayer[uvIndex * 2];\n                v = uvLayer[uvIndex * 2 + 1];\n                geometry.faceUvs[i][fi] = new THREE.Vector2(u, v);\n            }\n            if (hasFaceVertexUv) for(i = 0; i < nUvLayers; i++){\n                uvLayer = json.uvs[i];\n                uvs = [];\n                for(j = 0; j < nVertices; j++){\n                    uvIndex = faces[offset++];\n                    u = uvLayer[uvIndex * 2];\n                    v = uvLayer[uvIndex * 2 + 1];\n                    uvs[j] = new THREE.Vector2(u, v);\n                }\n                geometry.faceVertexUvs[i][fi] = uvs;\n            }\n            if (hasFaceNormal) {\n                normalIndex = faces[offset++] * 3;\n                normal = new THREE.Vector3();\n                normal.x = normals[normalIndex++];\n                normal.y = normals[normalIndex++];\n                normal.z = normals[normalIndex];\n                face.normal = normal;\n            }\n            if (hasFaceVertexNormal) for(i = 0; i < nVertices; i++){\n                normalIndex = faces[offset++] * 3;\n                normal = new THREE.Vector3();\n                normal.x = normals[normalIndex++];\n                normal.y = normals[normalIndex++];\n                normal.z = normals[normalIndex];\n                face.vertexNormals.push(normal);\n            }\n            if (hasFaceColor) {\n                colorIndex = faces[offset++];\n                color = new THREE.Color(colors[colorIndex]);\n                face.color = color;\n            }\n            if (hasFaceVertexColor) for(i = 0; i < nVertices; i++){\n                colorIndex = faces[offset++];\n                color = new THREE.Color(colors[colorIndex]);\n                face.vertexColors.push(color);\n            }\n            geometry.faces.push(face);\n        }\n    }\n    function parseSkin() {\n        var i, l, x, y, z, w, a, b, c, d;\n        if (json.skinWeights) for(i = 0, l = json.skinWeights.length; i < l; i += 2){\n            x = json.skinWeights[i];\n            y = json.skinWeights[i + 1];\n            z = 0;\n            w = 0;\n            geometry.skinWeights.push(new THREE.Vector4(x, y, z, w));\n        }\n        if (json.skinIndices) for(i = 0, l = json.skinIndices.length; i < l; i += 2){\n            a = json.skinIndices[i];\n            b = json.skinIndices[i + 1];\n            c = 0;\n            d = 0;\n            geometry.skinIndices.push(new THREE.Vector4(a, b, c, d));\n        }\n        geometry.bones = json.bones;\n        geometry.animation = json.animation;\n    }\n    function parseMorphing(scale) {\n        if (json.morphTargets !== undefined) {\n            var i, l, v, vl, dstVertices, srcVertices;\n            for(i = 0, l = json.morphTargets.length; i < l; i++){\n                geometry.morphTargets[i] = {};\n                geometry.morphTargets[i].name = json.morphTargets[i].name;\n                geometry.morphTargets[i].vertices = [];\n                dstVertices = geometry.morphTargets[i].vertices;\n                srcVertices = json.morphTargets[i].vertices;\n                for(v = 0, vl = srcVertices.length; v < vl; v += 3){\n                    var vertex = new THREE.Vector3();\n                    vertex.x = srcVertices[v] * scale;\n                    vertex.y = srcVertices[v + 1] * scale;\n                    vertex.z = srcVertices[v + 2] * scale;\n                    dstVertices.push(vertex);\n                }\n            }\n        }\n        if (json.morphColors !== undefined) {\n            var i, l, c, cl, dstColors, srcColors, color;\n            for(i = 0, l = json.morphColors.length; i < l; i++){\n                geometry.morphColors[i] = {};\n                geometry.morphColors[i].name = json.morphColors[i].name;\n                geometry.morphColors[i].colors = [];\n                dstColors = geometry.morphColors[i].colors;\n                srcColors = json.morphColors[i].colors;\n                for(c = 0, cl = srcColors.length; c < cl; c += 3){\n                    color = new THREE.Color(0xffaa00);\n                    color.setRGB(srcColors[c], srcColors[c + 1], srcColors[c + 2]);\n                    dstColors.push(color);\n                }\n            }\n        }\n    }\n    var materials = this.initMaterials(json.materials, texturePath);\n    if (this.needsTangents(materials)) geometry.computeTangents();\n    callback(geometry, materials);\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n */ THREE.LoadingMonitor = function() {\n    THREE.EventDispatcher.call(this);\n    var scope = this;\n    var loaded = 0;\n    var total = 0;\n    var onLoad = function(event) {\n        loaded++;\n        scope.dispatchEvent({\n            type: \"progress\",\n            loaded: loaded,\n            total: total\n        });\n        if (loaded === total) scope.dispatchEvent({\n            type: \"load\"\n        });\n    };\n    this.add = function(loader) {\n        total++;\n        loader.addEventListener(\"load\", onLoad, false);\n    };\n};\n/**\n * @author alteredq / http://alteredqualia.com/\n */ THREE.SceneLoader = function() {\n    this.onLoadStart = function() {};\n    this.onLoadProgress = function() {};\n    this.onLoadComplete = function() {};\n    this.callbackSync = function() {};\n    this.callbackProgress = function() {};\n    this.geometryHandlerMap = {};\n    this.hierarchyHandlerMap = {};\n    this.addGeometryHandler(\"ascii\", THREE.JSONLoader);\n};\nTHREE.SceneLoader.prototype.constructor = THREE.SceneLoader;\nTHREE.SceneLoader.prototype.load = function(url, callbackFinished) {\n    var scope = this;\n    var xhr = new XMLHttpRequest();\n    xhr.onreadystatechange = function() {\n        if (xhr.readyState === 4) {\n            if (xhr.status === 200 || xhr.status === 0) {\n                var json = JSON.parse(xhr.responseText);\n                scope.parse(json, callbackFinished, url);\n            } else console.error(\"THREE.SceneLoader: Couldn't load [\" + url + \"] [\" + xhr.status + \"]\");\n        }\n    };\n    xhr.open(\"GET\", url, true);\n    xhr.send(null);\n};\nTHREE.SceneLoader.prototype.addGeometryHandler = function(typeID, loaderClass) {\n    this.geometryHandlerMap[typeID] = {\n        \"loaderClass\": loaderClass\n    };\n};\nTHREE.SceneLoader.prototype.addHierarchyHandler = function(typeID, loaderClass) {\n    this.hierarchyHandlerMap[typeID] = {\n        \"loaderClass\": loaderClass\n    };\n};\nTHREE.SceneLoader.prototype.parse = function(json, callbackFinished, url) {\n    var scope = this;\n    var urlBase = THREE.Loader.prototype.extractUrlBase(url);\n    var geometry, material, camera, fog, texture, images, color, light, hex, intensity, counter_models, counter_textures, total_models, total_textures, result;\n    var target_array = [];\n    var data = json;\n    // async geometry loaders\n    for(var typeID in this.geometryHandlerMap){\n        var loaderClass = this.geometryHandlerMap[typeID][\"loaderClass\"];\n        this.geometryHandlerMap[typeID][\"loaderObject\"] = new loaderClass();\n    }\n    // async hierachy loaders\n    for(var typeID in this.hierarchyHandlerMap){\n        var loaderClass = this.hierarchyHandlerMap[typeID][\"loaderClass\"];\n        this.hierarchyHandlerMap[typeID][\"loaderObject\"] = new loaderClass();\n    }\n    counter_models = 0;\n    counter_textures = 0;\n    result = {\n        scene: new THREE.Scene(),\n        geometries: {},\n        face_materials: {},\n        materials: {},\n        textures: {},\n        objects: {},\n        cameras: {},\n        lights: {},\n        fogs: {},\n        empties: {},\n        groups: {}\n    };\n    if (data.transform) {\n        var position = data.transform.position, rotation = data.transform.rotation, scale = data.transform.scale;\n        if (position) result.scene.position.set(position[0], position[1], position[2]);\n        if (rotation) result.scene.rotation.set(rotation[0], rotation[1], rotation[2]);\n        if (scale) result.scene.scale.set(scale[0], scale[1], scale[2]);\n        if (position || rotation || scale) {\n            result.scene.updateMatrix();\n            result.scene.updateMatrixWorld();\n        }\n    }\n    function get_url(source_url, url_type) {\n        if (url_type == \"relativeToHTML\") return source_url;\n        else return urlBase + \"/\" + source_url;\n    }\n    // toplevel loader function, delegates to handle_children\n    function handle_objects() {\n        handle_children(result.scene, data.objects);\n    }\n    // handle all the children from the loaded json and attach them to given parent\n    function handle_children(parent, children) {\n        var mat, dst, pos, rot, scl, quat;\n        for(var objID in children)// check by id if child has already been handled,\n        // if not, create new object\n        if (result.objects[objID] === undefined) {\n            var objJSON = children[objID];\n            var object = null;\n            // meshes\n            if (objJSON.type && objJSON.type in scope.hierarchyHandlerMap) {\n                if (objJSON.loading === undefined) {\n                    var reservedTypes = {\n                        \"type\": 1,\n                        \"url\": 1,\n                        \"material\": 1,\n                        \"position\": 1,\n                        \"rotation\": 1,\n                        \"scale\": 1,\n                        \"visible\": 1,\n                        \"children\": 1,\n                        \"properties\": 1,\n                        \"skin\": 1,\n                        \"morph\": 1,\n                        \"mirroredLoop\": 1,\n                        \"duration\": 1\n                    };\n                    var loaderParameters = {};\n                    for(var parType in objJSON)if (!(parType in reservedTypes)) loaderParameters[parType] = objJSON[parType];\n                    material = result.materials[objJSON.material];\n                    objJSON.loading = true;\n                    var loader = scope.hierarchyHandlerMap[objJSON.type][\"loaderObject\"];\n                    // ColladaLoader\n                    if (loader.options) loader.load(get_url(objJSON.url, data.urlBaseType), create_callback_hierachy(objID, parent, material, objJSON));\n                    else loader.load(get_url(objJSON.url, data.urlBaseType), create_callback_hierachy(objID, parent, material, objJSON), loaderParameters);\n                }\n            } else if (objJSON.geometry !== undefined) {\n                geometry = result.geometries[objJSON.geometry];\n                // geometry already loaded\n                if (geometry) {\n                    var needsTangents = false;\n                    material = result.materials[objJSON.material];\n                    needsTangents = material instanceof THREE.ShaderMaterial;\n                    pos = objJSON.position;\n                    rot = objJSON.rotation;\n                    scl = objJSON.scale;\n                    mat = objJSON.matrix;\n                    quat = objJSON.quaternion;\n                    // use materials from the model file\n                    // if there is no material specified in the object\n                    if (!objJSON.material) material = new THREE.MeshFaceMaterial(result.face_materials[objJSON.geometry]);\n                    // use materials from the model file\n                    // if there is just empty face material\n                    // (must create new material as each model has its own face material)\n                    if (material instanceof THREE.MeshFaceMaterial && material.materials.length === 0) material = new THREE.MeshFaceMaterial(result.face_materials[objJSON.geometry]);\n                    if (material instanceof THREE.MeshFaceMaterial) for(var i = 0; i < material.materials.length; i++)needsTangents = needsTangents || material.materials[i] instanceof THREE.ShaderMaterial;\n                    if (needsTangents) geometry.computeTangents();\n                    if (objJSON.skin) object = new THREE.SkinnedMesh(geometry, material);\n                    else if (objJSON.morph) {\n                        object = new THREE.MorphAnimMesh(geometry, material);\n                        if (objJSON.duration !== undefined) object.duration = objJSON.duration;\n                        if (objJSON.time !== undefined) object.time = objJSON.time;\n                        if (objJSON.mirroredLoop !== undefined) object.mirroredLoop = objJSON.mirroredLoop;\n                        if (material.morphNormals) geometry.computeMorphNormals();\n                    } else object = new THREE.Mesh(geometry, material);\n                    object.name = objID;\n                    if (mat) {\n                        object.matrixAutoUpdate = false;\n                        object.matrix.set(mat[0], mat[1], mat[2], mat[3], mat[4], mat[5], mat[6], mat[7], mat[8], mat[9], mat[10], mat[11], mat[12], mat[13], mat[14], mat[15]);\n                    } else {\n                        object.position.set(pos[0], pos[1], pos[2]);\n                        if (quat) {\n                            object.quaternion.set(quat[0], quat[1], quat[2], quat[3]);\n                            object.useQuaternion = true;\n                        } else object.rotation.set(rot[0], rot[1], rot[2]);\n                        object.scale.set(scl[0], scl[1], scl[2]);\n                    }\n                    object.visible = objJSON.visible;\n                    object.castShadow = objJSON.castShadow;\n                    object.receiveShadow = objJSON.receiveShadow;\n                    parent.add(object);\n                    result.objects[objID] = object;\n                }\n            // lights\n            } else if (objJSON.type === \"DirectionalLight\" || objJSON.type === \"PointLight\" || objJSON.type === \"AmbientLight\") {\n                hex = objJSON.color !== undefined ? objJSON.color : 0xffffff;\n                intensity = objJSON.intensity !== undefined ? objJSON.intensity : 1;\n                if (objJSON.type === \"DirectionalLight\") {\n                    pos = objJSON.direction;\n                    light = new THREE.DirectionalLight(hex, intensity);\n                    light.position.set(pos[0], pos[1], pos[2]);\n                    if (objJSON.target) {\n                        target_array.push({\n                            \"object\": light,\n                            \"targetName\": objJSON.target\n                        });\n                        // kill existing default target\n                        // otherwise it gets added to scene when parent gets added\n                        light.target = null;\n                    }\n                } else if (objJSON.type === \"PointLight\") {\n                    pos = objJSON.position;\n                    dst = objJSON.distance;\n                    light = new THREE.PointLight(hex, intensity, dst);\n                    light.position.set(pos[0], pos[1], pos[2]);\n                } else if (objJSON.type === \"AmbientLight\") light = new THREE.AmbientLight(hex);\n                parent.add(light);\n                light.name = objID;\n                result.lights[objID] = light;\n                result.objects[objID] = light;\n            // cameras\n            } else if (objJSON.type === \"PerspectiveCamera\" || objJSON.type === \"OrthographicCamera\") {\n                if (objJSON.type === \"PerspectiveCamera\") camera = new THREE.PerspectiveCamera(objJSON.fov, objJSON.aspect, objJSON.near, objJSON.far);\n                else if (objJSON.type === \"OrthographicCamera\") camera = new THREE.OrthographicCamera(objJSON.left, objJSON.right, objJSON.top, objJSON.bottom, objJSON.near, objJSON.far);\n                pos = objJSON.position;\n                camera.position.set(pos[0], pos[1], pos[2]);\n                parent.add(camera);\n                camera.name = objID;\n                result.cameras[objID] = camera;\n                result.objects[objID] = camera;\n            // pure Object3D\n            } else {\n                pos = objJSON.position;\n                rot = objJSON.rotation;\n                scl = objJSON.scale;\n                quat = objJSON.quaternion;\n                object = new THREE.Object3D();\n                object.name = objID;\n                object.position.set(pos[0], pos[1], pos[2]);\n                if (quat) {\n                    object.quaternion.set(quat[0], quat[1], quat[2], quat[3]);\n                    object.useQuaternion = true;\n                } else object.rotation.set(rot[0], rot[1], rot[2]);\n                object.scale.set(scl[0], scl[1], scl[2]);\n                object.visible = objJSON.visible !== undefined ? objJSON.visible : false;\n                parent.add(object);\n                result.objects[objID] = object;\n                result.empties[objID] = object;\n            }\n            if (object) {\n                if (objJSON.properties !== undefined) for(var key in objJSON.properties){\n                    var value = objJSON.properties[key];\n                    object.properties[key] = value;\n                }\n                if (objJSON.groups !== undefined) for(var i = 0; i < objJSON.groups.length; i++){\n                    var groupID = objJSON.groups[i];\n                    if (result.groups[groupID] === undefined) result.groups[groupID] = [];\n                    result.groups[groupID].push(objID);\n                }\n                if (objJSON.children !== undefined) handle_children(object, objJSON.children);\n            }\n        }\n    }\n    function handle_mesh(geo, mat, id) {\n        result.geometries[id] = geo;\n        result.face_materials[id] = mat;\n        handle_objects();\n    }\n    function handle_hierarchy(node, id, parent, material, obj) {\n        var p = obj.position;\n        var r = obj.rotation;\n        var q = obj.quaternion;\n        var s = obj.scale;\n        node.position.set(p[0], p[1], p[2]);\n        if (q) {\n            node.quaternion.set(q[0], q[1], q[2], q[3]);\n            node.useQuaternion = true;\n        } else node.rotation.set(r[0], r[1], r[2]);\n        node.scale.set(s[0], s[1], s[2]);\n        // override children materials\n        // if object material was specified in JSON explicitly\n        if (material) node.traverse(function(child) {\n            child.material = material;\n        });\n        // override children visibility\n        // with root node visibility as specified in JSON\n        var visible = obj.visible !== undefined ? obj.visible : true;\n        node.traverse(function(child) {\n            child.visible = visible;\n        });\n        parent.add(node);\n        node.name = id;\n        result.objects[id] = node;\n        handle_objects();\n    }\n    function create_callback_geometry(id) {\n        return function(geo, mat) {\n            handle_mesh(geo, mat, id);\n            counter_models -= 1;\n            scope.onLoadComplete();\n            async_callback_gate();\n        };\n    }\n    function create_callback_hierachy(id, parent, material, obj) {\n        return function(event) {\n            var result;\n            // loaders which use EventDispatcher\n            if (event.content) result = event.content;\n            else if (event.dae) result = event.scene;\n            else result = event;\n            handle_hierarchy(result, id, parent, material, obj);\n            counter_models -= 1;\n            scope.onLoadComplete();\n            async_callback_gate();\n        };\n    }\n    function create_callback_embed(id) {\n        return function(geo, mat) {\n            result.geometries[id] = geo;\n            result.face_materials[id] = mat;\n        };\n    }\n    function async_callback_gate() {\n        var progress = {\n            totalModels: total_models,\n            totalTextures: total_textures,\n            loadedModels: total_models - counter_models,\n            loadedTextures: total_textures - counter_textures\n        };\n        scope.callbackProgress(progress, result);\n        scope.onLoadProgress();\n        if (counter_models === 0 && counter_textures === 0) {\n            finalize();\n            callbackFinished(result);\n        }\n    }\n    function finalize() {\n        // take care of targets which could be asynchronously loaded objects\n        for(var i = 0; i < target_array.length; i++){\n            var ta = target_array[i];\n            var target = result.objects[ta.targetName];\n            if (target) ta.object.target = target;\n            else {\n                // if there was error and target of specified name doesn't exist in the scene file\n                // create instead dummy target\n                // (target must be added to scene explicitly as parent is already added)\n                ta.object.target = new THREE.Object3D();\n                result.scene.add(ta.object.target);\n            }\n            ta.object.target.properties.targetInverse = ta.object;\n        }\n    }\n    var callbackTexture = function(count) {\n        counter_textures -= count;\n        async_callback_gate();\n        scope.onLoadComplete();\n    };\n    // must use this instead of just directly calling callbackTexture\n    // because of closure in the calling context loop\n    var generateTextureCallback = function(count) {\n        return function() {\n            callbackTexture(count);\n        };\n    };\n    // first go synchronous elements\n    // fogs\n    var fogID, fogJSON;\n    for(fogID in data.fogs){\n        fogJSON = data.fogs[fogID];\n        if (fogJSON.type === \"linear\") fog = new THREE.Fog(0x000000, fogJSON.near, fogJSON.far);\n        else if (fogJSON.type === \"exp2\") fog = new THREE.FogExp2(0x000000, fogJSON.density);\n        color = fogJSON.color;\n        fog.color.setRGB(color[0], color[1], color[2]);\n        result.fogs[fogID] = fog;\n    }\n    // now come potentially asynchronous elements\n    // geometries\n    // count how many geometries will be loaded asynchronously\n    var geoID, geoJSON;\n    for(geoID in data.geometries){\n        geoJSON = data.geometries[geoID];\n        if (geoJSON.type in this.geometryHandlerMap) {\n            counter_models += 1;\n            scope.onLoadStart();\n        }\n    }\n    // count how many hierarchies will be loaded asynchronously\n    var objID, objJSON;\n    for(objID in data.objects){\n        objJSON = data.objects[objID];\n        if (objJSON.type && objJSON.type in this.hierarchyHandlerMap) {\n            counter_models += 1;\n            scope.onLoadStart();\n        }\n    }\n    total_models = counter_models;\n    for(geoID in data.geometries){\n        geoJSON = data.geometries[geoID];\n        if (geoJSON.type === \"cube\") {\n            geometry = new THREE.CubeGeometry(geoJSON.width, geoJSON.height, geoJSON.depth, geoJSON.widthSegments, geoJSON.heightSegments, geoJSON.depthSegments);\n            result.geometries[geoID] = geometry;\n        } else if (geoJSON.type === \"plane\") {\n            geometry = new THREE.PlaneGeometry(geoJSON.width, geoJSON.height, geoJSON.widthSegments, geoJSON.heightSegments);\n            result.geometries[geoID] = geometry;\n        } else if (geoJSON.type === \"sphere\") {\n            geometry = new THREE.SphereGeometry(geoJSON.radius, geoJSON.widthSegments, geoJSON.heightSegments);\n            result.geometries[geoID] = geometry;\n        } else if (geoJSON.type === \"cylinder\") {\n            geometry = new THREE.CylinderGeometry(geoJSON.topRad, geoJSON.botRad, geoJSON.height, geoJSON.radSegs, geoJSON.heightSegs);\n            result.geometries[geoID] = geometry;\n        } else if (geoJSON.type === \"torus\") {\n            geometry = new THREE.TorusGeometry(geoJSON.radius, geoJSON.tube, geoJSON.segmentsR, geoJSON.segmentsT);\n            result.geometries[geoID] = geometry;\n        } else if (geoJSON.type === \"icosahedron\") {\n            geometry = new THREE.IcosahedronGeometry(geoJSON.radius, geoJSON.subdivisions);\n            result.geometries[geoID] = geometry;\n        } else if (geoJSON.type in this.geometryHandlerMap) {\n            var loaderParameters = {};\n            for(var parType in geoJSON)if (parType !== \"type\" && parType !== \"url\") loaderParameters[parType] = geoJSON[parType];\n            var loader = this.geometryHandlerMap[geoJSON.type][\"loaderObject\"];\n            loader.load(get_url(geoJSON.url, data.urlBaseType), create_callback_geometry(geoID), loaderParameters);\n        } else if (geoJSON.type === \"embedded\") {\n            var modelJson = data.embeds[geoJSON.id], texture_path = \"\";\n            // pass metadata along to jsonLoader so it knows the format version\n            modelJson.metadata = data.metadata;\n            if (modelJson) {\n                var jsonLoader = this.geometryHandlerMap[\"ascii\"][\"loaderObject\"];\n                jsonLoader.createModel(modelJson, create_callback_embed(geoID), texture_path);\n            }\n        }\n    }\n    // textures\n    // count how many textures will be loaded asynchronously\n    var textureID, textureJSON;\n    for(textureID in data.textures){\n        textureJSON = data.textures[textureID];\n        if (textureJSON.url instanceof Array) {\n            counter_textures += textureJSON.url.length;\n            for(var n = 0; n < textureJSON.url.length; n++)scope.onLoadStart();\n        } else {\n            counter_textures += 1;\n            scope.onLoadStart();\n        }\n    }\n    total_textures = counter_textures;\n    for(textureID in data.textures){\n        textureJSON = data.textures[textureID];\n        if (textureJSON.mapping !== undefined && THREE[textureJSON.mapping] !== undefined) textureJSON.mapping = new THREE[textureJSON.mapping]();\n        if (textureJSON.url instanceof Array) {\n            var count = textureJSON.url.length;\n            var url_array = [];\n            for(var i = 0; i < count; i++)url_array[i] = get_url(textureJSON.url[i], data.urlBaseType);\n            var isCompressed = /\\.dds$/i.test(url_array[0]);\n            if (isCompressed) texture = THREE.ImageUtils.loadCompressedTextureCube(url_array, textureJSON.mapping, generateTextureCallback(count));\n            else texture = THREE.ImageUtils.loadTextureCube(url_array, textureJSON.mapping, generateTextureCallback(count));\n        } else {\n            var isCompressed = /\\.dds$/i.test(textureJSON.url);\n            var fullUrl = get_url(textureJSON.url, data.urlBaseType);\n            var textureCallback = generateTextureCallback(1);\n            if (isCompressed) texture = THREE.ImageUtils.loadCompressedTexture(fullUrl, textureJSON.mapping, textureCallback);\n            else texture = THREE.ImageUtils.loadTexture(fullUrl, textureJSON.mapping, textureCallback);\n            if (THREE[textureJSON.minFilter] !== undefined) texture.minFilter = THREE[textureJSON.minFilter];\n            if (THREE[textureJSON.magFilter] !== undefined) texture.magFilter = THREE[textureJSON.magFilter];\n            if (textureJSON.anisotropy) texture.anisotropy = textureJSON.anisotropy;\n            if (textureJSON.repeat) {\n                texture.repeat.set(textureJSON.repeat[0], textureJSON.repeat[1]);\n                if (textureJSON.repeat[0] !== 1) texture.wrapS = THREE.RepeatWrapping;\n                if (textureJSON.repeat[1] !== 1) texture.wrapT = THREE.RepeatWrapping;\n            }\n            if (textureJSON.offset) texture.offset.set(textureJSON.offset[0], textureJSON.offset[1]);\n            // handle wrap after repeat so that default repeat can be overriden\n            if (textureJSON.wrap) {\n                var wrapMap = {\n                    \"repeat\": THREE.RepeatWrapping,\n                    \"mirror\": THREE.MirroredRepeatWrapping\n                };\n                if (wrapMap[textureJSON.wrap[0]] !== undefined) texture.wrapS = wrapMap[textureJSON.wrap[0]];\n                if (wrapMap[textureJSON.wrap[1]] !== undefined) texture.wrapT = wrapMap[textureJSON.wrap[1]];\n            }\n        }\n        result.textures[textureID] = texture;\n    }\n    // materials\n    var matID, matJSON;\n    var parID;\n    for(matID in data.materials){\n        matJSON = data.materials[matID];\n        for(parID in matJSON.parameters){\n            if (parID === \"envMap\" || parID === \"map\" || parID === \"lightMap\" || parID === \"bumpMap\") matJSON.parameters[parID] = result.textures[matJSON.parameters[parID]];\n            else if (parID === \"shading\") matJSON.parameters[parID] = matJSON.parameters[parID] === \"flat\" ? THREE.FlatShading : THREE.SmoothShading;\n            else if (parID === \"side\") {\n                if (matJSON.parameters[parID] == \"double\") matJSON.parameters[parID] = THREE.DoubleSide;\n                else if (matJSON.parameters[parID] == \"back\") matJSON.parameters[parID] = THREE.BackSide;\n                else matJSON.parameters[parID] = THREE.FrontSide;\n            } else if (parID === \"blending\") matJSON.parameters[parID] = matJSON.parameters[parID] in THREE ? THREE[matJSON.parameters[parID]] : THREE.NormalBlending;\n            else if (parID === \"combine\") matJSON.parameters[parID] = matJSON.parameters[parID] in THREE ? THREE[matJSON.parameters[parID]] : THREE.MultiplyOperation;\n            else if (parID === \"vertexColors\") {\n                if (matJSON.parameters[parID] == \"face\") matJSON.parameters[parID] = THREE.FaceColors;\n                else if (matJSON.parameters[parID]) matJSON.parameters[parID] = THREE.VertexColors;\n            } else if (parID === \"wrapRGB\") {\n                var v3 = matJSON.parameters[parID];\n                matJSON.parameters[parID] = new THREE.Vector3(v3[0], v3[1], v3[2]);\n            }\n        }\n        if (matJSON.parameters.opacity !== undefined && matJSON.parameters.opacity < 1.0) matJSON.parameters.transparent = true;\n        if (matJSON.parameters.normalMap) {\n            var shader = THREE.ShaderLib[\"normalmap\"];\n            var uniforms = THREE.UniformsUtils.clone(shader.uniforms);\n            var diffuse = matJSON.parameters.color;\n            var specular = matJSON.parameters.specular;\n            var ambient = matJSON.parameters.ambient;\n            var shininess = matJSON.parameters.shininess;\n            uniforms[\"tNormal\"].value = result.textures[matJSON.parameters.normalMap];\n            if (matJSON.parameters.normalScale) uniforms[\"uNormalScale\"].value.set(matJSON.parameters.normalScale[0], matJSON.parameters.normalScale[1]);\n            if (matJSON.parameters.map) {\n                uniforms[\"tDiffuse\"].value = matJSON.parameters.map;\n                uniforms[\"enableDiffuse\"].value = true;\n            }\n            if (matJSON.parameters.envMap) {\n                uniforms[\"tCube\"].value = matJSON.parameters.envMap;\n                uniforms[\"enableReflection\"].value = true;\n                uniforms[\"uReflectivity\"].value = matJSON.parameters.reflectivity;\n            }\n            if (matJSON.parameters.lightMap) {\n                uniforms[\"tAO\"].value = matJSON.parameters.lightMap;\n                uniforms[\"enableAO\"].value = true;\n            }\n            if (matJSON.parameters.specularMap) {\n                uniforms[\"tSpecular\"].value = result.textures[matJSON.parameters.specularMap];\n                uniforms[\"enableSpecular\"].value = true;\n            }\n            if (matJSON.parameters.displacementMap) {\n                uniforms[\"tDisplacement\"].value = result.textures[matJSON.parameters.displacementMap];\n                uniforms[\"enableDisplacement\"].value = true;\n                uniforms[\"uDisplacementBias\"].value = matJSON.parameters.displacementBias;\n                uniforms[\"uDisplacementScale\"].value = matJSON.parameters.displacementScale;\n            }\n            uniforms[\"uDiffuseColor\"].value.setHex(diffuse);\n            uniforms[\"uSpecularColor\"].value.setHex(specular);\n            uniforms[\"uAmbientColor\"].value.setHex(ambient);\n            uniforms[\"uShininess\"].value = shininess;\n            if (matJSON.parameters.opacity) uniforms[\"uOpacity\"].value = matJSON.parameters.opacity;\n            var parameters = {\n                fragmentShader: shader.fragmentShader,\n                vertexShader: shader.vertexShader,\n                uniforms: uniforms,\n                lights: true,\n                fog: true\n            };\n            material = new THREE.ShaderMaterial(parameters);\n        } else material = new THREE[matJSON.type](matJSON.parameters);\n        result.materials[matID] = material;\n    }\n    // second pass through all materials to initialize MeshFaceMaterials\n    // that could be referring to other materials out of order\n    for(matID in data.materials){\n        matJSON = data.materials[matID];\n        if (matJSON.parameters.materials) {\n            var materialArray = [];\n            for(var i = 0; i < matJSON.parameters.materials.length; i++){\n                var label = matJSON.parameters.materials[i];\n                materialArray.push(result.materials[label]);\n            }\n            result.materials[matID].materials = materialArray;\n        }\n    }\n    // objects ( synchronous init of procedural primitives )\n    handle_objects();\n    // defaults\n    if (result.cameras && data.defaults.camera) result.currentCamera = result.cameras[data.defaults.camera];\n    if (result.fogs && data.defaults.fog) result.scene.fog = result.fogs[data.defaults.fog];\n    // synchronous callback\n    scope.callbackSync(result);\n    // just in case there are no async elements\n    async_callback_gate();\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n */ THREE.TextureLoader = function() {\n    THREE.EventDispatcher.call(this);\n    this.crossOrigin = null;\n};\nTHREE.TextureLoader.prototype = {\n    constructor: THREE.TextureLoader,\n    load: function(url) {\n        var scope = this;\n        var image = new Image();\n        image.addEventListener(\"load\", function() {\n            var texture = new THREE.Texture(image);\n            texture.needsUpdate = true;\n            scope.dispatchEvent({\n                type: \"load\",\n                content: texture\n            });\n        }, false);\n        image.addEventListener(\"error\", function() {\n            scope.dispatchEvent({\n                type: \"error\",\n                message: \"Couldn't load URL [\" + url + \"]\"\n            });\n        }, false);\n        if (scope.crossOrigin) image.crossOrigin = scope.crossOrigin;\n        image.src = url;\n    }\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */ THREE.Material = function() {\n    THREE.EventDispatcher.call(this);\n    this.id = THREE.MaterialIdCount++;\n    this.name = \"\";\n    this.side = THREE.FrontSide;\n    this.opacity = 1;\n    this.transparent = false;\n    this.blending = THREE.NormalBlending;\n    this.blendSrc = THREE.SrcAlphaFactor;\n    this.blendDst = THREE.OneMinusSrcAlphaFactor;\n    this.blendEquation = THREE.AddEquation;\n    this.depthTest = true;\n    this.depthWrite = true;\n    this.polygonOffset = false;\n    this.polygonOffsetFactor = 0;\n    this.polygonOffsetUnits = 0;\n    this.alphaTest = 0;\n    this.overdraw = false; // Boolean for fixing antialiasing gaps in CanvasRenderer\n    this.visible = true;\n    this.needsUpdate = true;\n};\nTHREE.Material.prototype.setValues = function(values) {\n    if (values === undefined) return;\n    for(var key in values){\n        var newValue = values[key];\n        if (newValue === undefined) {\n            console.warn(\"THREE.Material: '\" + key + \"' parameter is undefined.\");\n            continue;\n        }\n        if (key in this) {\n            var currentValue = this[key];\n            if (currentValue instanceof THREE.Color && newValue instanceof THREE.Color) currentValue.copy(newValue);\n            else if (currentValue instanceof THREE.Color) currentValue.set(newValue);\n            else if (currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3) currentValue.copy(newValue);\n            else this[key] = newValue;\n        }\n    }\n};\nTHREE.Material.prototype.clone = function(material) {\n    if (material === undefined) material = new THREE.Material();\n    material.name = this.name;\n    material.side = this.side;\n    material.opacity = this.opacity;\n    material.transparent = this.transparent;\n    material.blending = this.blending;\n    material.blendSrc = this.blendSrc;\n    material.blendDst = this.blendDst;\n    material.blendEquation = this.blendEquation;\n    material.depthTest = this.depthTest;\n    material.depthWrite = this.depthWrite;\n    material.polygonOffset = this.polygonOffset;\n    material.polygonOffsetFactor = this.polygonOffsetFactor;\n    material.polygonOffsetUnits = this.polygonOffsetUnits;\n    material.alphaTest = this.alphaTest;\n    material.overdraw = this.overdraw;\n    material.visible = this.visible;\n    return material;\n};\nTHREE.Material.prototype.dispose = function() {\n    this.dispatchEvent({\n        type: \"dispose\"\n    });\n};\nTHREE.MaterialIdCount = 0;\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *\n *  blending: THREE.NormalBlending,\n *  depthTest: <bool>,\n *  depthWrite: <bool>,\n *\n *  linewidth: <float>,\n *  linecap: \"round\",\n *  linejoin: \"round\",\n *\n *  vertexColors: <bool>\n *\n *  fog: <bool>\n * }\n */ THREE.LineBasicMaterial = function(parameters) {\n    THREE.Material.call(this);\n    this.color = new THREE.Color(0xffffff);\n    this.linewidth = 1;\n    this.linecap = \"round\";\n    this.linejoin = \"round\";\n    this.vertexColors = false;\n    this.fog = true;\n    this.setValues(parameters);\n};\nTHREE.LineBasicMaterial.prototype = Object.create(THREE.Material.prototype);\nTHREE.LineBasicMaterial.prototype.clone = function() {\n    var material = new THREE.LineBasicMaterial();\n    THREE.Material.prototype.clone.call(this, material);\n    material.color.copy(this.color);\n    material.linewidth = this.linewidth;\n    material.linecap = this.linecap;\n    material.linejoin = this.linejoin;\n    material.vertexColors = this.vertexColors;\n    material.fog = this.fog;\n    return material;\n};\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *\n *  blending: THREE.NormalBlending,\n *  depthTest: <bool>,\n *  depthWrite: <bool>,\n *\n *  linewidth: <float>,\n *\n *  scale: <float>,\n *  dashSize: <float>,\n *  gapSize: <float>,\n *\n *  vertexColors: <bool>\n *\n *  fog: <bool>\n * }\n */ THREE.LineDashedMaterial = function(parameters) {\n    THREE.Material.call(this);\n    this.color = new THREE.Color(0xffffff);\n    this.linewidth = 1;\n    this.scale = 1;\n    this.dashSize = 3;\n    this.gapSize = 1;\n    this.vertexColors = false;\n    this.fog = true;\n    this.setValues(parameters);\n};\nTHREE.LineDashedMaterial.prototype = Object.create(THREE.Material.prototype);\nTHREE.LineDashedMaterial.prototype.clone = function() {\n    var material = new THREE.LineDashedMaterial();\n    THREE.Material.prototype.clone.call(this, material);\n    material.color.copy(this.color);\n    material.linewidth = this.linewidth;\n    material.scale = this.scale;\n    material.dashSize = this.dashSize;\n    material.gapSize = this.gapSize;\n    material.vertexColors = this.vertexColors;\n    material.fog = this.fog;\n    return material;\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *\n *  specularMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n *  combine: THREE.Multiply,\n *  reflectivity: <float>,\n *  refractionRatio: <float>,\n *\n *  shading: THREE.SmoothShading,\n *  blending: THREE.NormalBlending,\n *  depthTest: <bool>,\n *  depthWrite: <bool>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *\n *  fog: <bool>\n * }\n */ THREE.MeshBasicMaterial = function(parameters) {\n    THREE.Material.call(this);\n    this.color = new THREE.Color(0xffffff); // emissive\n    this.map = null;\n    this.lightMap = null;\n    this.specularMap = null;\n    this.envMap = null;\n    this.combine = THREE.MultiplyOperation;\n    this.reflectivity = 1;\n    this.refractionRatio = 0.98;\n    this.fog = true;\n    this.shading = THREE.SmoothShading;\n    this.wireframe = false;\n    this.wireframeLinewidth = 1;\n    this.wireframeLinecap = \"round\";\n    this.wireframeLinejoin = \"round\";\n    this.vertexColors = THREE.NoColors;\n    this.skinning = false;\n    this.morphTargets = false;\n    this.setValues(parameters);\n};\nTHREE.MeshBasicMaterial.prototype = Object.create(THREE.Material.prototype);\nTHREE.MeshBasicMaterial.prototype.clone = function() {\n    var material = new THREE.MeshBasicMaterial();\n    THREE.Material.prototype.clone.call(this, material);\n    material.color.copy(this.color);\n    material.map = this.map;\n    material.lightMap = this.lightMap;\n    material.specularMap = this.specularMap;\n    material.envMap = this.envMap;\n    material.combine = this.combine;\n    material.reflectivity = this.reflectivity;\n    material.refractionRatio = this.refractionRatio;\n    material.fog = this.fog;\n    material.shading = this.shading;\n    material.wireframe = this.wireframe;\n    material.wireframeLinewidth = this.wireframeLinewidth;\n    material.wireframeLinecap = this.wireframeLinecap;\n    material.wireframeLinejoin = this.wireframeLinejoin;\n    material.vertexColors = this.vertexColors;\n    material.skinning = this.skinning;\n    material.morphTargets = this.morphTargets;\n    return material;\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  ambient: <hex>,\n *  emissive: <hex>,\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *\n *  specularMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n *  combine: THREE.Multiply,\n *  reflectivity: <float>,\n *  refractionRatio: <float>,\n *\n *  shading: THREE.SmoothShading,\n *  blending: THREE.NormalBlending,\n *  depthTest: <bool>,\n *  depthWrite: <bool>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>,\n *\n *\tfog: <bool>\n * }\n */ THREE.MeshLambertMaterial = function(parameters) {\n    THREE.Material.call(this);\n    this.color = new THREE.Color(0xffffff); // diffuse\n    this.ambient = new THREE.Color(0xffffff);\n    this.emissive = new THREE.Color(0x000000);\n    this.wrapAround = false;\n    this.wrapRGB = new THREE.Vector3(1, 1, 1);\n    this.map = null;\n    this.lightMap = null;\n    this.specularMap = null;\n    this.envMap = null;\n    this.combine = THREE.MultiplyOperation;\n    this.reflectivity = 1;\n    this.refractionRatio = 0.98;\n    this.fog = true;\n    this.shading = THREE.SmoothShading;\n    this.wireframe = false;\n    this.wireframeLinewidth = 1;\n    this.wireframeLinecap = \"round\";\n    this.wireframeLinejoin = \"round\";\n    this.vertexColors = THREE.NoColors;\n    this.skinning = false;\n    this.morphTargets = false;\n    this.morphNormals = false;\n    this.setValues(parameters);\n};\nTHREE.MeshLambertMaterial.prototype = Object.create(THREE.Material.prototype);\nTHREE.MeshLambertMaterial.prototype.clone = function() {\n    var material = new THREE.MeshLambertMaterial();\n    THREE.Material.prototype.clone.call(this, material);\n    material.color.copy(this.color);\n    material.ambient.copy(this.ambient);\n    material.emissive.copy(this.emissive);\n    material.wrapAround = this.wrapAround;\n    material.wrapRGB.copy(this.wrapRGB);\n    material.map = this.map;\n    material.lightMap = this.lightMap;\n    material.specularMap = this.specularMap;\n    material.envMap = this.envMap;\n    material.combine = this.combine;\n    material.reflectivity = this.reflectivity;\n    material.refractionRatio = this.refractionRatio;\n    material.fog = this.fog;\n    material.shading = this.shading;\n    material.wireframe = this.wireframe;\n    material.wireframeLinewidth = this.wireframeLinewidth;\n    material.wireframeLinecap = this.wireframeLinecap;\n    material.wireframeLinejoin = this.wireframeLinejoin;\n    material.vertexColors = this.vertexColors;\n    material.skinning = this.skinning;\n    material.morphTargets = this.morphTargets;\n    material.morphNormals = this.morphNormals;\n    return material;\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  ambient: <hex>,\n *  emissive: <hex>,\n *  specular: <hex>,\n *  shininess: <float>,\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *\n *  bumpMap: new THREE.Texture( <Image> ),\n *  bumpScale: <float>,\n *\n *  normalMap: new THREE.Texture( <Image> ),\n *  normalScale: <Vector2>,\n *\n *  specularMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n *  combine: THREE.Multiply,\n *  reflectivity: <float>,\n *  refractionRatio: <float>,\n *\n *  shading: THREE.SmoothShading,\n *  blending: THREE.NormalBlending,\n *  depthTest: <bool>,\n *  depthWrite: <bool>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>,\n *\n *\tfog: <bool>\n * }\n */ THREE.MeshPhongMaterial = function(parameters) {\n    THREE.Material.call(this);\n    this.color = new THREE.Color(0xffffff); // diffuse\n    this.ambient = new THREE.Color(0xffffff);\n    this.emissive = new THREE.Color(0x000000);\n    this.specular = new THREE.Color(0x111111);\n    this.shininess = 30;\n    this.metal = false;\n    this.perPixel = true;\n    this.wrapAround = false;\n    this.wrapRGB = new THREE.Vector3(1, 1, 1);\n    this.map = null;\n    this.lightMap = null;\n    this.bumpMap = null;\n    this.bumpScale = 1;\n    this.normalMap = null;\n    this.normalScale = new THREE.Vector2(1, 1);\n    this.specularMap = null;\n    this.envMap = null;\n    this.combine = THREE.MultiplyOperation;\n    this.reflectivity = 1;\n    this.refractionRatio = 0.98;\n    this.fog = true;\n    this.shading = THREE.SmoothShading;\n    this.wireframe = false;\n    this.wireframeLinewidth = 1;\n    this.wireframeLinecap = \"round\";\n    this.wireframeLinejoin = \"round\";\n    this.vertexColors = THREE.NoColors;\n    this.skinning = false;\n    this.morphTargets = false;\n    this.morphNormals = false;\n    this.setValues(parameters);\n};\nTHREE.MeshPhongMaterial.prototype = Object.create(THREE.Material.prototype);\nTHREE.MeshPhongMaterial.prototype.clone = function() {\n    var material = new THREE.MeshPhongMaterial();\n    THREE.Material.prototype.clone.call(this, material);\n    material.color.copy(this.color);\n    material.ambient.copy(this.ambient);\n    material.emissive.copy(this.emissive);\n    material.specular.copy(this.specular);\n    material.shininess = this.shininess;\n    material.metal = this.metal;\n    material.perPixel = this.perPixel;\n    material.wrapAround = this.wrapAround;\n    material.wrapRGB.copy(this.wrapRGB);\n    material.map = this.map;\n    material.lightMap = this.lightMap;\n    material.bumpMap = this.bumpMap;\n    material.bumpScale = this.bumpScale;\n    material.normalMap = this.normalMap;\n    material.normalScale.copy(this.normalScale);\n    material.specularMap = this.specularMap;\n    material.envMap = this.envMap;\n    material.combine = this.combine;\n    material.reflectivity = this.reflectivity;\n    material.refractionRatio = this.refractionRatio;\n    material.fog = this.fog;\n    material.shading = this.shading;\n    material.wireframe = this.wireframe;\n    material.wireframeLinewidth = this.wireframeLinewidth;\n    material.wireframeLinecap = this.wireframeLinecap;\n    material.wireframeLinejoin = this.wireframeLinejoin;\n    material.vertexColors = this.vertexColors;\n    material.skinning = this.skinning;\n    material.morphTargets = this.morphTargets;\n    material.morphNormals = this.morphNormals;\n    return material;\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  opacity: <float>,\n *\n *  blending: THREE.NormalBlending,\n *  depthTest: <bool>,\n *  depthWrite: <bool>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>\n * }\n */ THREE.MeshDepthMaterial = function(parameters) {\n    THREE.Material.call(this);\n    this.wireframe = false;\n    this.wireframeLinewidth = 1;\n    this.setValues(parameters);\n};\nTHREE.MeshDepthMaterial.prototype = Object.create(THREE.Material.prototype);\nTHREE.MeshDepthMaterial.prototype.clone = function() {\n    var material = new THREE.LineBasicMaterial();\n    THREE.Material.prototype.clone.call(this, material);\n    material.wireframe = this.wireframe;\n    material.wireframeLinewidth = this.wireframeLinewidth;\n    return material;\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n *\n * parameters = {\n *  opacity: <float>,\n *\n *  shading: THREE.FlatShading,\n *  blending: THREE.NormalBlending,\n *  depthTest: <bool>,\n *  depthWrite: <bool>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>\n * }\n */ THREE.MeshNormalMaterial = function(parameters) {\n    THREE.Material.call(this, parameters);\n    this.shading = THREE.FlatShading;\n    this.wireframe = false;\n    this.wireframeLinewidth = 1;\n    this.setValues(parameters);\n};\nTHREE.MeshNormalMaterial.prototype = Object.create(THREE.Material.prototype);\nTHREE.MeshNormalMaterial.prototype.clone = function() {\n    var material = new THREE.MeshNormalMaterial();\n    THREE.Material.prototype.clone.call(this, material);\n    material.shading = this.shading;\n    material.wireframe = this.wireframe;\n    material.wireframeLinewidth = this.wireframeLinewidth;\n    return material;\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n */ THREE.MeshFaceMaterial = function(materials) {\n    this.materials = materials instanceof Array ? materials : [];\n};\nTHREE.MeshFaceMaterial.prototype.clone = function() {\n    return new THREE.MeshFaceMaterial(this.materials.slice(0));\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *  map: new THREE.Texture( <Image> ),\n *\n *  size: <float>,\n *\n *  blending: THREE.NormalBlending,\n *  depthTest: <bool>,\n *  depthWrite: <bool>,\n *\n *  vertexColors: <bool>,\n *\n *  fog: <bool>\n * }\n */ THREE.ParticleBasicMaterial = function(parameters) {\n    THREE.Material.call(this);\n    this.color = new THREE.Color(0xffffff);\n    this.map = null;\n    this.size = 1;\n    this.sizeAttenuation = true;\n    this.vertexColors = false;\n    this.fog = true;\n    this.setValues(parameters);\n};\nTHREE.ParticleBasicMaterial.prototype = Object.create(THREE.Material.prototype);\nTHREE.ParticleBasicMaterial.prototype.clone = function() {\n    var material = new THREE.ParticleBasicMaterial();\n    THREE.Material.prototype.clone.call(this, material);\n    material.color.copy(this.color);\n    material.map = this.map;\n    material.size = this.size;\n    material.sizeAttenuation = this.sizeAttenuation;\n    material.vertexColors = this.vertexColors;\n    material.fog = this.fog;\n    return material;\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n *\n * parameters = {\n *  color: <hex>,\n *  program: <function>,\n *  opacity: <float>,\n *  blending: THREE.NormalBlending\n * }\n */ THREE.ParticleCanvasMaterial = function(parameters) {\n    THREE.Material.call(this);\n    this.color = new THREE.Color(0xffffff);\n    this.program = function(context, color) {};\n    this.setValues(parameters);\n};\nTHREE.ParticleCanvasMaterial.prototype = Object.create(THREE.Material.prototype);\nTHREE.ParticleCanvasMaterial.prototype.clone = function() {\n    var material = new THREE.ParticleCanvasMaterial();\n    THREE.Material.prototype.clone.call(this, material);\n    material.color.copy(this.color);\n    material.program = this.program;\n    return material;\n};\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  fragmentShader: <string>,\n *  vertexShader: <string>,\n *\n *  uniforms: { \"parameter1\": { type: \"f\", value: 1.0 }, \"parameter2\": { type: \"i\" value2: 2 } },\n *\n *  defines: { \"label\" : \"value\" },\n *\n *  shading: THREE.SmoothShading,\n *  blending: THREE.NormalBlending,\n *  depthTest: <bool>,\n *  depthWrite: <bool>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  lights: <bool>,\n *\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>,\n *\n *\tfog: <bool>\n * }\n */ THREE.ShaderMaterial = function(parameters) {\n    THREE.Material.call(this);\n    this.fragmentShader = \"void main() {}\";\n    this.vertexShader = \"void main() {}\";\n    this.uniforms = {};\n    this.defines = {};\n    this.attributes = null;\n    this.shading = THREE.SmoothShading;\n    this.wireframe = false;\n    this.wireframeLinewidth = 1;\n    this.fog = false; // set to use scene fog\n    this.lights = false; // set to use scene lights\n    this.vertexColors = THREE.NoColors; // set to use \"color\" attribute stream\n    this.skinning = false; // set to use skinning attribute streams\n    this.morphTargets = false; // set to use morph targets\n    this.morphNormals = false; // set to use morph normals\n    this.setValues(parameters);\n};\nTHREE.ShaderMaterial.prototype = Object.create(THREE.Material.prototype);\nTHREE.ShaderMaterial.prototype.clone = function() {\n    var material = new THREE.ShaderMaterial();\n    THREE.Material.prototype.clone.call(this, material);\n    material.fragmentShader = this.fragmentShader;\n    material.vertexShader = this.vertexShader;\n    material.uniforms = THREE.UniformsUtils.clone(this.uniforms);\n    material.attributes = this.attributes;\n    material.defines = this.defines;\n    material.shading = this.shading;\n    material.wireframe = this.wireframe;\n    material.wireframeLinewidth = this.wireframeLinewidth;\n    material.fog = this.fog;\n    material.lights = this.lights;\n    material.vertexColors = this.vertexColors;\n    material.skinning = this.skinning;\n    material.morphTargets = this.morphTargets;\n    material.morphNormals = this.morphNormals;\n    return material;\n};\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *  map: new THREE.Texture( <Image> ),\n *\n *  blending: THREE.NormalBlending,\n *  depthTest: <bool>,\n *  depthWrite: <bool>,\n *\n *  useScreenCoordinates: <bool>,\n *  sizeAttenuation: <bool>,\n *  scaleByViewport: <bool>,\n *  alignment: THREE.SpriteAlignment.center,\n *\n *\tuvOffset: new THREE.Vector2(),\n *\tuvScale: new THREE.Vector2(),\n *\n *  fog: <bool>\n * }\n */ THREE.SpriteMaterial = function(parameters) {\n    THREE.Material.call(this);\n    // defaults\n    this.color = new THREE.Color(0xffffff);\n    this.map = new THREE.Texture();\n    this.useScreenCoordinates = true;\n    this.depthTest = !this.useScreenCoordinates;\n    this.sizeAttenuation = !this.useScreenCoordinates;\n    this.scaleByViewport = !this.sizeAttenuation;\n    this.alignment = THREE.SpriteAlignment.center.clone();\n    this.fog = false;\n    this.uvOffset = new THREE.Vector2(0, 0);\n    this.uvScale = new THREE.Vector2(1, 1);\n    // set parameters\n    this.setValues(parameters);\n    // override coupled defaults if not specified explicitly by parameters\n    parameters = parameters || {};\n    if (parameters.depthTest === undefined) this.depthTest = !this.useScreenCoordinates;\n    if (parameters.sizeAttenuation === undefined) this.sizeAttenuation = !this.useScreenCoordinates;\n    if (parameters.scaleByViewport === undefined) this.scaleByViewport = !this.sizeAttenuation;\n};\nTHREE.SpriteMaterial.prototype = Object.create(THREE.Material.prototype);\nTHREE.SpriteMaterial.prototype.clone = function() {\n    var material = new THREE.SpriteMaterial();\n    THREE.Material.prototype.clone.call(this, material);\n    material.color.copy(this.color);\n    material.map = this.map;\n    material.useScreenCoordinates = this.useScreenCoordinates;\n    material.sizeAttenuation = this.sizeAttenuation;\n    material.scaleByViewport = this.scaleByViewport;\n    material.alignment.copy(this.alignment);\n    material.uvOffset.copy(this.uvOffset);\n    material.uvScale.copy(this.uvScale);\n    material.fog = this.fog;\n    return material;\n};\n// Alignment enums\nTHREE.SpriteAlignment = {};\nTHREE.SpriteAlignment.topLeft = new THREE.Vector2(1, -1);\nTHREE.SpriteAlignment.topCenter = new THREE.Vector2(0, -1);\nTHREE.SpriteAlignment.topRight = new THREE.Vector2(-1, -1);\nTHREE.SpriteAlignment.centerLeft = new THREE.Vector2(1, 0);\nTHREE.SpriteAlignment.center = new THREE.Vector2(0, 0);\nTHREE.SpriteAlignment.centerRight = new THREE.Vector2(-1, 0);\nTHREE.SpriteAlignment.bottomLeft = new THREE.Vector2(1, 1);\nTHREE.SpriteAlignment.bottomCenter = new THREE.Vector2(0, 1);\nTHREE.SpriteAlignment.bottomRight = new THREE.Vector2(-1, 1);\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author szimek / https://github.com/szimek/\n */ THREE.Texture = function(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {\n    THREE.EventDispatcher.call(this);\n    this.id = THREE.TextureIdCount++;\n    this.name = \"\";\n    this.image = image;\n    this.mipmaps = [];\n    this.mapping = mapping !== undefined ? mapping : new THREE.UVMapping();\n    this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;\n    this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;\n    this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;\n    this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;\n    this.anisotropy = anisotropy !== undefined ? anisotropy : 1;\n    this.format = format !== undefined ? format : THREE.RGBAFormat;\n    this.type = type !== undefined ? type : THREE.UnsignedByteType;\n    this.offset = new THREE.Vector2(0, 0);\n    this.repeat = new THREE.Vector2(1, 1);\n    this.generateMipmaps = true;\n    this.premultiplyAlpha = false;\n    this.flipY = true;\n    this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\n    this.needsUpdate = false;\n    this.onUpdate = null;\n};\nTHREE.Texture.prototype = {\n    constructor: THREE.Texture,\n    clone: function(texture) {\n        if (texture === undefined) texture = new THREE.Texture();\n        texture.image = this.image;\n        texture.mipmaps = this.mipmaps.slice(0);\n        texture.mapping = this.mapping;\n        texture.wrapS = this.wrapS;\n        texture.wrapT = this.wrapT;\n        texture.magFilter = this.magFilter;\n        texture.minFilter = this.minFilter;\n        texture.anisotropy = this.anisotropy;\n        texture.format = this.format;\n        texture.type = this.type;\n        texture.offset.copy(this.offset);\n        texture.repeat.copy(this.repeat);\n        texture.generateMipmaps = this.generateMipmaps;\n        texture.premultiplyAlpha = this.premultiplyAlpha;\n        texture.flipY = this.flipY;\n        texture.unpackAlignment = this.unpackAlignment;\n        return texture;\n    },\n    dispose: function() {\n        this.dispatchEvent({\n            type: \"dispose\"\n        });\n    }\n};\nTHREE.TextureIdCount = 0;\n/**\n * @author alteredq / http://alteredqualia.com/\n */ THREE.CompressedTexture = function(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy) {\n    THREE.Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);\n    this.image = {\n        width: width,\n        height: height\n    };\n    this.mipmaps = mipmaps;\n    this.generateMipmaps = false; // WebGL currently can't generate mipmaps for compressed textures, they must be embedded in DDS file\n};\nTHREE.CompressedTexture.prototype = Object.create(THREE.Texture.prototype);\nTHREE.CompressedTexture.prototype.clone = function() {\n    var texture = new THREE.CompressedTexture();\n    THREE.Texture.prototype.clone.call(this, texture);\n    return texture;\n};\n/**\n * @author alteredq / http://alteredqualia.com/\n */ THREE.DataTexture = function(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy) {\n    THREE.Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);\n    this.image = {\n        data: data,\n        width: width,\n        height: height\n    };\n};\nTHREE.DataTexture.prototype = Object.create(THREE.Texture.prototype);\nTHREE.DataTexture.prototype.clone = function() {\n    var texture = new THREE.DataTexture();\n    THREE.Texture.prototype.clone.call(this, texture);\n    return texture;\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n */ THREE.Particle = function(material) {\n    THREE.Object3D.call(this);\n    this.material = material;\n};\nTHREE.Particle.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.Particle.prototype.clone = function(object) {\n    if (object === undefined) object = new THREE.Particle(this.material);\n    THREE.Object3D.prototype.clone.call(this, object);\n    return object;\n};\n/**\n * @author alteredq / http://alteredqualia.com/\n */ THREE.ParticleSystem = function(geometry, material) {\n    THREE.Object3D.call(this);\n    this.geometry = geometry;\n    this.material = material !== undefined ? material : new THREE.ParticleBasicMaterial({\n        color: Math.random() * 0xffffff\n    });\n    this.sortParticles = false;\n    if (this.geometry) // calc bound radius\n    {\n        if (this.geometry.boundingSphere === null) this.geometry.computeBoundingSphere();\n    }\n    this.frustumCulled = false;\n};\nTHREE.ParticleSystem.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.ParticleSystem.prototype.clone = function(object) {\n    if (object === undefined) object = new THREE.ParticleSystem(this.geometry, this.material);\n    object.sortParticles = this.sortParticles;\n    THREE.Object3D.prototype.clone.call(this, object);\n    return object;\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n */ THREE.Line = function(geometry, material, type) {\n    THREE.Object3D.call(this);\n    this.geometry = geometry;\n    this.material = material !== undefined ? material : new THREE.LineBasicMaterial({\n        color: Math.random() * 0xffffff\n    });\n    this.type = type !== undefined ? type : THREE.LineStrip;\n    if (this.geometry) {\n        if (!this.geometry.boundingSphere) this.geometry.computeBoundingSphere();\n    }\n};\nTHREE.LineStrip = 0;\nTHREE.LinePieces = 1;\nTHREE.Line.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.Line.prototype.clone = function(object) {\n    if (object === undefined) object = new THREE.Line(this.geometry, this.material, this.type);\n    THREE.Object3D.prototype.clone.call(this, object);\n    return object;\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author mikael emtinger / http://gomo.se/\n * @author jonobr1 / http://jonobr1.com/\n */ THREE.Mesh = function(geometry, material) {\n    THREE.Object3D.call(this);\n    this.geometry = geometry;\n    this.material = material !== undefined ? material : new THREE.MeshBasicMaterial({\n        color: Math.random() * 0xffffff,\n        wireframe: true\n    });\n    if (this.geometry !== undefined) {\n        if (this.geometry.boundingSphere === null) this.geometry.computeBoundingSphere();\n        this.updateMorphTargets();\n    }\n};\nTHREE.Mesh.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.Mesh.prototype.updateMorphTargets = function() {\n    if (this.geometry.morphTargets.length > 0) {\n        this.morphTargetBase = -1;\n        this.morphTargetForcedOrder = [];\n        this.morphTargetInfluences = [];\n        this.morphTargetDictionary = {};\n        for(var m = 0, ml = this.geometry.morphTargets.length; m < ml; m++){\n            this.morphTargetInfluences.push(0);\n            this.morphTargetDictionary[this.geometry.morphTargets[m].name] = m;\n        }\n    }\n};\nTHREE.Mesh.prototype.getMorphTargetIndexByName = function(name) {\n    if (this.morphTargetDictionary[name] !== undefined) return this.morphTargetDictionary[name];\n    console.log(\"THREE.Mesh.getMorphTargetIndexByName: morph target \" + name + \" does not exist. Returning 0.\");\n    return 0;\n};\nTHREE.Mesh.prototype.clone = function(object) {\n    if (object === undefined) object = new THREE.Mesh(this.geometry, this.material);\n    THREE.Object3D.prototype.clone.call(this, object);\n    return object;\n};\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */ THREE.Bone = function(belongsToSkin) {\n    THREE.Object3D.call(this);\n    this.skin = belongsToSkin;\n    this.skinMatrix = new THREE.Matrix4();\n};\nTHREE.Bone.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.Bone.prototype.update = function(parentSkinMatrix, forceUpdate) {\n    // update local\n    if (this.matrixAutoUpdate) forceUpdate |= this.updateMatrix();\n    // update skin matrix\n    if (forceUpdate || this.matrixWorldNeedsUpdate) {\n        if (parentSkinMatrix) this.skinMatrix.multiplyMatrices(parentSkinMatrix, this.matrix);\n        else this.skinMatrix.copy(this.matrix);\n        this.matrixWorldNeedsUpdate = false;\n        forceUpdate = true;\n    }\n    // update children\n    var child, i, l = this.children.length;\n    for(i = 0; i < l; i++)this.children[i].update(this.skinMatrix, forceUpdate);\n};\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */ THREE.SkinnedMesh = function(geometry, material, useVertexTexture) {\n    THREE.Mesh.call(this, geometry, material);\n    //\n    this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;\n    // init bones\n    this.identityMatrix = new THREE.Matrix4();\n    this.bones = [];\n    this.boneMatrices = [];\n    var b, bone, gbone, p, q, s;\n    if (this.geometry && this.geometry.bones !== undefined) {\n        for(b = 0; b < this.geometry.bones.length; b++){\n            gbone = this.geometry.bones[b];\n            p = gbone.pos;\n            q = gbone.rotq;\n            s = gbone.scl;\n            bone = this.addBone();\n            bone.name = gbone.name;\n            bone.position.set(p[0], p[1], p[2]);\n            bone.quaternion.set(q[0], q[1], q[2], q[3]);\n            bone.useQuaternion = true;\n            if (s !== undefined) bone.scale.set(s[0], s[1], s[2]);\n            else bone.scale.set(1, 1, 1);\n        }\n        for(b = 0; b < this.bones.length; b++){\n            gbone = this.geometry.bones[b];\n            bone = this.bones[b];\n            if (gbone.parent === -1) this.add(bone);\n            else this.bones[gbone.parent].add(bone);\n        }\n        //\n        var nBones = this.bones.length;\n        if (this.useVertexTexture) {\n            // layout (1 matrix = 4 pixels)\n            //\tRGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n            //  with  8x8  pixel texture max   16 bones  (8 * 8  / 4)\n            //  \t 16x16 pixel texture max   64 bones (16 * 16 / 4)\n            //  \t 32x32 pixel texture max  256 bones (32 * 32 / 4)\n            //  \t 64x64 pixel texture max 1024 bones (64 * 64 / 4)\n            var size;\n            if (nBones > 256) size = 64;\n            else if (nBones > 64) size = 32;\n            else if (nBones > 16) size = 16;\n            else size = 8;\n            this.boneTextureWidth = size;\n            this.boneTextureHeight = size;\n            this.boneMatrices = new Float32Array(this.boneTextureWidth * this.boneTextureHeight * 4); // 4 floats per RGBA pixel\n            this.boneTexture = new THREE.DataTexture(this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType);\n            this.boneTexture.minFilter = THREE.NearestFilter;\n            this.boneTexture.magFilter = THREE.NearestFilter;\n            this.boneTexture.generateMipmaps = false;\n            this.boneTexture.flipY = false;\n        } else this.boneMatrices = new Float32Array(16 * nBones);\n        this.pose();\n    }\n};\nTHREE.SkinnedMesh.prototype = Object.create(THREE.Mesh.prototype);\nTHREE.SkinnedMesh.prototype.addBone = function(bone) {\n    if (bone === undefined) bone = new THREE.Bone(this);\n    this.bones.push(bone);\n    return bone;\n};\nTHREE.SkinnedMesh.prototype.updateMatrixWorld = function(force) {\n    this.matrixAutoUpdate && this.updateMatrix();\n    // update matrixWorld\n    if (this.matrixWorldNeedsUpdate || force) {\n        if (this.parent) this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\n        else this.matrixWorld.copy(this.matrix);\n        this.matrixWorldNeedsUpdate = false;\n        force = true;\n    }\n    // update children\n    for(var i = 0, l = this.children.length; i < l; i++){\n        var child = this.children[i];\n        if (child instanceof THREE.Bone) child.update(this.identityMatrix, false);\n        else child.updateMatrixWorld(true);\n    }\n    // make a snapshot of the bones' rest position\n    if (this.boneInverses == undefined) {\n        this.boneInverses = [];\n        for(var b = 0, bl = this.bones.length; b < bl; b++){\n            var inverse = new THREE.Matrix4();\n            inverse.getInverse(this.bones[b].skinMatrix);\n            this.boneInverses.push(inverse);\n        }\n    }\n    // flatten bone matrices to array\n    for(var b = 0, bl = this.bones.length; b < bl; b++){\n        // compute the offset between the current and the original transform;\n        //TODO: we could get rid of this multiplication step if the skinMatrix\n        // was already representing the offset; however, this requires some\n        // major changes to the animation system\n        THREE.SkinnedMesh.offsetMatrix.multiplyMatrices(this.bones[b].skinMatrix, this.boneInverses[b]);\n        THREE.SkinnedMesh.offsetMatrix.flattenToArrayOffset(this.boneMatrices, b * 16);\n    }\n    if (this.useVertexTexture) this.boneTexture.needsUpdate = true;\n};\nTHREE.SkinnedMesh.prototype.pose = function() {\n    this.updateMatrixWorld(true);\n    for(var i = 0; i < this.geometry.skinIndices.length; i++){\n        // normalize weights\n        var sw = this.geometry.skinWeights[i];\n        var scale = 1.0 / sw.lengthManhattan();\n        if (scale !== Infinity) sw.multiplyScalar(scale);\n        else sw.set(1); // this will be normalized by the shader anyway\n    }\n};\nTHREE.SkinnedMesh.prototype.clone = function(object) {\n    if (object === undefined) object = new THREE.SkinnedMesh(this.geometry, this.material, this.useVertexTexture);\n    THREE.Mesh.prototype.clone.call(this, object);\n    return object;\n};\nTHREE.SkinnedMesh.offsetMatrix = new THREE.Matrix4();\n/**\n * @author alteredq / http://alteredqualia.com/\n */ THREE.MorphAnimMesh = function(geometry, material) {\n    THREE.Mesh.call(this, geometry, material);\n    // API\n    this.duration = 1000; // milliseconds\n    this.mirroredLoop = false;\n    this.time = 0;\n    // internals\n    this.lastKeyframe = 0;\n    this.currentKeyframe = 0;\n    this.direction = 1;\n    this.directionBackwards = false;\n    this.setFrameRange(0, this.geometry.morphTargets.length - 1);\n};\nTHREE.MorphAnimMesh.prototype = Object.create(THREE.Mesh.prototype);\nTHREE.MorphAnimMesh.prototype.setFrameRange = function(start, end) {\n    this.startKeyframe = start;\n    this.endKeyframe = end;\n    this.length = this.endKeyframe - this.startKeyframe + 1;\n};\nTHREE.MorphAnimMesh.prototype.setDirectionForward = function() {\n    this.direction = 1;\n    this.directionBackwards = false;\n};\nTHREE.MorphAnimMesh.prototype.setDirectionBackward = function() {\n    this.direction = -1;\n    this.directionBackwards = true;\n};\nTHREE.MorphAnimMesh.prototype.parseAnimations = function() {\n    var geometry = this.geometry;\n    if (!geometry.animations) geometry.animations = {};\n    var firstAnimation, animations = geometry.animations;\n    var pattern = /([a-z]+)(\\d+)/;\n    for(var i = 0, il = geometry.morphTargets.length; i < il; i++){\n        var morph = geometry.morphTargets[i];\n        var parts = morph.name.match(pattern);\n        if (parts && parts.length > 1) {\n            var label = parts[1];\n            var num = parts[2];\n            if (!animations[label]) animations[label] = {\n                start: Infinity,\n                end: -Infinity\n            };\n            var animation = animations[label];\n            if (i < animation.start) animation.start = i;\n            if (i > animation.end) animation.end = i;\n            if (!firstAnimation) firstAnimation = label;\n        }\n    }\n    geometry.firstAnimation = firstAnimation;\n};\nTHREE.MorphAnimMesh.prototype.setAnimationLabel = function(label, start, end) {\n    if (!this.geometry.animations) this.geometry.animations = {};\n    this.geometry.animations[label] = {\n        start: start,\n        end: end\n    };\n};\nTHREE.MorphAnimMesh.prototype.playAnimation = function(label, fps) {\n    var animation = this.geometry.animations[label];\n    if (animation) {\n        this.setFrameRange(animation.start, animation.end);\n        this.duration = 1000 * ((animation.end - animation.start) / fps);\n        this.time = 0;\n    } else console.warn(\"animation[\" + label + \"] undefined\");\n};\nTHREE.MorphAnimMesh.prototype.updateAnimation = function(delta) {\n    var frameTime = this.duration / this.length;\n    this.time += this.direction * delta;\n    if (this.mirroredLoop) {\n        if (this.time > this.duration || this.time < 0) {\n            this.direction *= -1;\n            if (this.time > this.duration) {\n                this.time = this.duration;\n                this.directionBackwards = true;\n            }\n            if (this.time < 0) {\n                this.time = 0;\n                this.directionBackwards = false;\n            }\n        }\n    } else {\n        this.time = this.time % this.duration;\n        if (this.time < 0) this.time += this.duration;\n    }\n    var keyframe = this.startKeyframe + THREE.Math.clamp(Math.floor(this.time / frameTime), 0, this.length - 1);\n    if (keyframe !== this.currentKeyframe) {\n        this.morphTargetInfluences[this.lastKeyframe] = 0;\n        this.morphTargetInfluences[this.currentKeyframe] = 1;\n        this.morphTargetInfluences[keyframe] = 0;\n        this.lastKeyframe = this.currentKeyframe;\n        this.currentKeyframe = keyframe;\n    }\n    var mix = this.time % frameTime / frameTime;\n    if (this.directionBackwards) mix = 1 - mix;\n    this.morphTargetInfluences[this.currentKeyframe] = mix;\n    this.morphTargetInfluences[this.lastKeyframe] = 1 - mix;\n};\nTHREE.MorphAnimMesh.prototype.clone = function(object) {\n    if (object === undefined) object = new THREE.MorphAnimMesh(this.geometry, this.material);\n    object.duration = this.duration;\n    object.mirroredLoop = this.mirroredLoop;\n    object.time = this.time;\n    object.lastKeyframe = this.lastKeyframe;\n    object.currentKeyframe = this.currentKeyframe;\n    object.direction = this.direction;\n    object.directionBackwards = this.directionBackwards;\n    THREE.Mesh.prototype.clone.call(this, object);\n    return object;\n};\n/**\n * @author alteredq / http://alteredqualia.com/\n */ THREE.Ribbon = function(geometry, material) {\n    THREE.Object3D.call(this);\n    this.geometry = geometry;\n    this.material = material;\n};\nTHREE.Ribbon.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.Ribbon.prototype.clone = function(object) {\n    if (object === undefined) object = new THREE.Ribbon(this.geometry, this.material);\n    THREE.Object3D.prototype.clone.call(this, object);\n    return object;\n};\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */ THREE.LOD = function() {\n    THREE.Object3D.call(this);\n    this.LODs = [];\n};\nTHREE.LOD.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.LOD.prototype.addLevel = function(object3D, visibleAtDistance) {\n    if (visibleAtDistance === undefined) visibleAtDistance = 0;\n    visibleAtDistance = Math.abs(visibleAtDistance);\n    for(var l = 0; l < this.LODs.length; l++){\n        if (visibleAtDistance < this.LODs[l].visibleAtDistance) break;\n    }\n    this.LODs.splice(l, 0, {\n        visibleAtDistance: visibleAtDistance,\n        object3D: object3D\n    });\n    this.add(object3D);\n};\nTHREE.LOD.prototype.update = function(camera) {\n    if (this.LODs.length > 1) {\n        camera.matrixWorldInverse.getInverse(camera.matrixWorld);\n        var inverse = camera.matrixWorldInverse;\n        var distance = -(inverse.elements[2] * this.matrixWorld.elements[12] + inverse.elements[6] * this.matrixWorld.elements[13] + inverse.elements[10] * this.matrixWorld.elements[14] + inverse.elements[14]);\n        this.LODs[0].object3D.visible = true;\n        for(var l = 1; l < this.LODs.length; l++){\n            if (distance >= this.LODs[l].visibleAtDistance) {\n                this.LODs[l - 1].object3D.visible = false;\n                this.LODs[l].object3D.visible = true;\n            } else break;\n        }\n        for(; l < this.LODs.length; l++)this.LODs[l].object3D.visible = false;\n    }\n};\nTHREE.LOD.prototype.clone = function() {\n// TODO\n};\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */ THREE.Sprite = function(material) {\n    THREE.Object3D.call(this);\n    this.material = material !== undefined ? material : new THREE.SpriteMaterial();\n    this.rotation3d = this.rotation;\n    this.rotation = 0;\n};\nTHREE.Sprite.prototype = Object.create(THREE.Object3D.prototype);\n/*\n * Custom update matrix\n */ THREE.Sprite.prototype.updateMatrix = function() {\n    this.matrix.setPosition(this.position);\n    this.rotation3d.set(0, 0, this.rotation);\n    this.matrix.setRotationFromEuler(this.rotation3d);\n    if (this.scale.x !== 1 || this.scale.y !== 1) this.matrix.scale(this.scale);\n    this.matrixWorldNeedsUpdate = true;\n};\nTHREE.Sprite.prototype.clone = function(object) {\n    if (object === undefined) object = new THREE.Sprite(this.material);\n    THREE.Object3D.prototype.clone.call(this, object);\n    return object;\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n */ THREE.Scene = function() {\n    THREE.Object3D.call(this);\n    this.fog = null;\n    this.overrideMaterial = null;\n    this.matrixAutoUpdate = false;\n    this.__objects = [];\n    this.__lights = [];\n    this.__objectsAdded = [];\n    this.__objectsRemoved = [];\n};\nTHREE.Scene.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.Scene.prototype.__addObject = function(object) {\n    if (object instanceof THREE.Light) {\n        if (this.__lights.indexOf(object) === -1) this.__lights.push(object);\n        if (object.target && object.target.parent === undefined) this.add(object.target);\n    } else if (!(object instanceof THREE.Camera || object instanceof THREE.Bone)) {\n        if (this.__objects.indexOf(object) === -1) {\n            this.__objects.push(object);\n            this.__objectsAdded.push(object);\n            // check if previously removed\n            var i = this.__objectsRemoved.indexOf(object);\n            if (i !== -1) this.__objectsRemoved.splice(i, 1);\n        }\n    }\n    for(var c = 0; c < object.children.length; c++)this.__addObject(object.children[c]);\n};\nTHREE.Scene.prototype.__removeObject = function(object) {\n    if (object instanceof THREE.Light) {\n        var i = this.__lights.indexOf(object);\n        if (i !== -1) this.__lights.splice(i, 1);\n    } else if (!(object instanceof THREE.Camera)) {\n        var i = this.__objects.indexOf(object);\n        if (i !== -1) {\n            this.__objects.splice(i, 1);\n            this.__objectsRemoved.push(object);\n            // check if previously added\n            var ai = this.__objectsAdded.indexOf(object);\n            if (ai !== -1) this.__objectsAdded.splice(ai, 1);\n        }\n    }\n    for(var c = 0; c < object.children.length; c++)this.__removeObject(object.children[c]);\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */ THREE.Fog = function(hex, near, far) {\n    this.name = \"\";\n    this.color = new THREE.Color(hex);\n    this.near = near !== undefined ? near : 1;\n    this.far = far !== undefined ? far : 1000;\n};\nTHREE.Fog.prototype.clone = function() {\n    return new THREE.Fog(this.color.getHex(), this.near, this.far);\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */ THREE.FogExp2 = function(hex, density) {\n    this.name = \"\";\n    this.color = new THREE.Color(hex);\n    this.density = density !== undefined ? density : 0.00025;\n};\nTHREE.FogExp2.prototype.clone = function() {\n    return new THREE.FogExp2(this.color.getHex(), this.density);\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n */ THREE.CanvasRenderer = function(parameters) {\n    console.log(\"THREE.CanvasRenderer\", THREE.REVISION);\n    var smoothstep = THREE.Math.smoothstep;\n    parameters = parameters || {};\n    var _this = this, _renderData, _elements, _lights, _projector = new THREE.Projector(), _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement(\"canvas\"), _canvasWidth, _canvasHeight, _canvasWidthHalf, _canvasHeightHalf, _context = _canvas.getContext(\"2d\"), _clearColor = new THREE.Color(0x000000), _clearOpacity = 0, _contextGlobalAlpha = 1, _contextGlobalCompositeOperation = 0, _contextStrokeStyle = null, _contextFillStyle = null, _contextLineWidth = null, _contextLineCap = null, _contextLineJoin = null, _contextDashSize = null, _contextGapSize = 0, _v1, _v2, _v3, _v4, _v5 = new THREE.RenderableVertex(), _v6 = new THREE.RenderableVertex(), _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _v4x, _v4y, _v5x, _v5y, _v6x, _v6y, _color = new THREE.Color(), _color1 = new THREE.Color(), _color2 = new THREE.Color(), _color3 = new THREE.Color(), _color4 = new THREE.Color(), _diffuseColor = new THREE.Color(), _emissiveColor = new THREE.Color(), _lightColor = new THREE.Color(), _patterns = {}, _imagedatas = {}, _near, _far, _image, _uvs, _uv1x, _uv1y, _uv2x, _uv2y, _uv3x, _uv3y, _clipBox = new THREE.Box2(), _clearBox = new THREE.Box2(), _elemBox = new THREE.Box2(), _enableLighting = false, _ambientLight = new THREE.Color(), _directionalLights = new THREE.Color(), _pointLights = new THREE.Color(), _vector3 = new THREE.Vector3(), _pixelMap, _pixelMapContext, _pixelMapImage, _pixelMapData, _gradientMap, _gradientMapContext, _gradientMapQuality = 16;\n    _pixelMap = document.createElement(\"canvas\");\n    _pixelMap.width = _pixelMap.height = 2;\n    _pixelMapContext = _pixelMap.getContext(\"2d\");\n    _pixelMapContext.fillStyle = \"rgba(0,0,0,1)\";\n    _pixelMapContext.fillRect(0, 0, 2, 2);\n    _pixelMapImage = _pixelMapContext.getImageData(0, 0, 2, 2);\n    _pixelMapData = _pixelMapImage.data;\n    _gradientMap = document.createElement(\"canvas\");\n    _gradientMap.width = _gradientMap.height = _gradientMapQuality;\n    _gradientMapContext = _gradientMap.getContext(\"2d\");\n    _gradientMapContext.translate(-_gradientMapQuality / 2, -_gradientMapQuality / 2);\n    _gradientMapContext.scale(_gradientMapQuality, _gradientMapQuality);\n    _gradientMapQuality--; // Fix UVs\n    // dash+gap fallbacks for Firefox and everything else\n    if (_context.setLineDash === undefined) {\n        if (_context.mozDash !== undefined) _context.setLineDash = function(values) {\n            _context.mozDash = values[0] !== null ? values : null;\n        };\n        else _context.setLineDash = function() {};\n    }\n    this.domElement = _canvas;\n    this.devicePixelRatio = parameters.devicePixelRatio !== undefined ? parameters.devicePixelRatio : window.devicePixelRatio !== undefined ? window.devicePixelRatio : 1;\n    this.autoClear = true;\n    this.sortObjects = true;\n    this.sortElements = true;\n    this.info = {\n        render: {\n            vertices: 0,\n            faces: 0\n        }\n    };\n    // WebGLRenderer compatibility\n    this.supportsVertexTextures = function() {};\n    this.setFaceCulling = function() {};\n    this.setSize = function(width, height) {\n        _canvasWidth = width * this.devicePixelRatio;\n        _canvasHeight = height * this.devicePixelRatio;\n        _canvasWidthHalf = Math.floor(_canvasWidth / 2);\n        _canvasHeightHalf = Math.floor(_canvasHeight / 2);\n        _canvas.width = _canvasWidth;\n        _canvas.height = _canvasHeight;\n        _canvas.style.width = width + \"px\";\n        _canvas.style.height = height + \"px\";\n        _clipBox.set(new THREE.Vector2(-_canvasWidthHalf, -_canvasHeightHalf), new THREE.Vector2(_canvasWidthHalf, _canvasHeightHalf));\n        _clearBox.set(new THREE.Vector2(-_canvasWidthHalf, -_canvasHeightHalf), new THREE.Vector2(_canvasWidthHalf, _canvasHeightHalf));\n        _contextGlobalAlpha = 1;\n        _contextGlobalCompositeOperation = 0;\n        _contextStrokeStyle = null;\n        _contextFillStyle = null;\n        _contextLineWidth = null;\n        _contextLineCap = null;\n        _contextLineJoin = null;\n    };\n    this.setClearColor = function(color, opacity) {\n        _clearColor.copy(color);\n        _clearOpacity = opacity !== undefined ? opacity : 1;\n        _clearBox.set(new THREE.Vector2(-_canvasWidthHalf, -_canvasHeightHalf), new THREE.Vector2(_canvasWidthHalf, _canvasHeightHalf));\n    };\n    this.setClearColorHex = function(hex, opacity) {\n        _clearColor.setHex(hex);\n        _clearOpacity = opacity !== undefined ? opacity : 1;\n        _clearBox.set(new THREE.Vector2(-_canvasWidthHalf, -_canvasHeightHalf), new THREE.Vector2(_canvasWidthHalf, _canvasHeightHalf));\n    };\n    this.getMaxAnisotropy = function() {\n        return 0;\n    };\n    this.clear = function() {\n        _context.setTransform(1, 0, 0, -1, _canvasWidthHalf, _canvasHeightHalf);\n        if (_clearBox.empty() === false) {\n            _clearBox.intersect(_clipBox);\n            _clearBox.expandByScalar(2);\n            if (_clearOpacity < 1) _context.clearRect(_clearBox.min.x | 0, _clearBox.min.y | 0, _clearBox.max.x - _clearBox.min.x | 0, _clearBox.max.y - _clearBox.min.y | 0);\n            if (_clearOpacity > 0) {\n                setBlending(THREE.NormalBlending);\n                setOpacity(1);\n                setFillStyle(\"rgba(\" + Math.floor(_clearColor.r * 255) + \",\" + Math.floor(_clearColor.g * 255) + \",\" + Math.floor(_clearColor.b * 255) + \",\" + _clearOpacity + \")\");\n                _context.fillRect(_clearBox.min.x | 0, _clearBox.min.y | 0, _clearBox.max.x - _clearBox.min.x | 0, _clearBox.max.y - _clearBox.min.y | 0);\n            }\n            _clearBox.makeEmpty();\n        }\n    };\n    this.render = function(scene, camera) {\n        if (camera instanceof THREE.Camera === false) {\n            console.error(\"THREE.CanvasRenderer.render: camera is not an instance of THREE.Camera.\");\n            return;\n        }\n        if (this.autoClear === true) this.clear();\n        _context.setTransform(1, 0, 0, -1, _canvasWidthHalf, _canvasHeightHalf);\n        _this.info.render.vertices = 0;\n        _this.info.render.faces = 0;\n        _renderData = _projector.projectScene(scene, camera, this.sortObjects, this.sortElements);\n        _elements = _renderData.elements;\n        _lights = _renderData.lights;\n        /* DEBUG\n\t\tsetFillStyle( 'rgba( 0, 255, 255, 0.5 )' );\n\t\t_context.fillRect( _clipBox.min.x, _clipBox.min.y, _clipBox.max.x - _clipBox.min.x, _clipBox.max.y - _clipBox.min.y );\n\t\t*/ _enableLighting = _lights.length > 0;\n        if (_enableLighting === true) calculateLights();\n        for(var e = 0, el = _elements.length; e < el; e++){\n            var element = _elements[e];\n            var material = element.material;\n            if (material === undefined || material.visible === false) continue;\n            _elemBox.makeEmpty();\n            if (element instanceof THREE.RenderableParticle) {\n                _v1 = element;\n                _v1.x *= _canvasWidthHalf;\n                _v1.y *= _canvasHeightHalf;\n                renderParticle(_v1, element, material);\n            } else if (element instanceof THREE.RenderableLine) {\n                _v1 = element.v1;\n                _v2 = element.v2;\n                _v1.positionScreen.x *= _canvasWidthHalf;\n                _v1.positionScreen.y *= _canvasHeightHalf;\n                _v2.positionScreen.x *= _canvasWidthHalf;\n                _v2.positionScreen.y *= _canvasHeightHalf;\n                _elemBox.setFromPoints([\n                    _v1.positionScreen,\n                    _v2.positionScreen\n                ]);\n                if (_clipBox.isIntersectionBox(_elemBox) === true) renderLine(_v1, _v2, element, material);\n            } else if (element instanceof THREE.RenderableFace3) {\n                _v1 = element.v1;\n                _v2 = element.v2;\n                _v3 = element.v3;\n                if (_v1.positionScreen.z < -1 || _v1.positionScreen.z > 1) continue;\n                if (_v2.positionScreen.z < -1 || _v2.positionScreen.z > 1) continue;\n                if (_v3.positionScreen.z < -1 || _v3.positionScreen.z > 1) continue;\n                _v1.positionScreen.x *= _canvasWidthHalf;\n                _v1.positionScreen.y *= _canvasHeightHalf;\n                _v2.positionScreen.x *= _canvasWidthHalf;\n                _v2.positionScreen.y *= _canvasHeightHalf;\n                _v3.positionScreen.x *= _canvasWidthHalf;\n                _v3.positionScreen.y *= _canvasHeightHalf;\n                if (material.overdraw === true) {\n                    expand(_v1.positionScreen, _v2.positionScreen);\n                    expand(_v2.positionScreen, _v3.positionScreen);\n                    expand(_v3.positionScreen, _v1.positionScreen);\n                }\n                _elemBox.setFromPoints([\n                    _v1.positionScreen,\n                    _v2.positionScreen,\n                    _v3.positionScreen\n                ]);\n                renderFace3(_v1, _v2, _v3, 0, 1, 2, element, material);\n            } else if (element instanceof THREE.RenderableFace4) {\n                _v1 = element.v1;\n                _v2 = element.v2;\n                _v3 = element.v3;\n                _v4 = element.v4;\n                if (_v1.positionScreen.z < -1 || _v1.positionScreen.z > 1) continue;\n                if (_v2.positionScreen.z < -1 || _v2.positionScreen.z > 1) continue;\n                if (_v3.positionScreen.z < -1 || _v3.positionScreen.z > 1) continue;\n                if (_v4.positionScreen.z < -1 || _v4.positionScreen.z > 1) continue;\n                _v1.positionScreen.x *= _canvasWidthHalf;\n                _v1.positionScreen.y *= _canvasHeightHalf;\n                _v2.positionScreen.x *= _canvasWidthHalf;\n                _v2.positionScreen.y *= _canvasHeightHalf;\n                _v3.positionScreen.x *= _canvasWidthHalf;\n                _v3.positionScreen.y *= _canvasHeightHalf;\n                _v4.positionScreen.x *= _canvasWidthHalf;\n                _v4.positionScreen.y *= _canvasHeightHalf;\n                _v5.positionScreen.copy(_v2.positionScreen);\n                _v6.positionScreen.copy(_v4.positionScreen);\n                if (material.overdraw === true) {\n                    expand(_v1.positionScreen, _v2.positionScreen);\n                    expand(_v2.positionScreen, _v4.positionScreen);\n                    expand(_v4.positionScreen, _v1.positionScreen);\n                    expand(_v3.positionScreen, _v5.positionScreen);\n                    expand(_v3.positionScreen, _v6.positionScreen);\n                }\n                _elemBox.setFromPoints([\n                    _v1.positionScreen,\n                    _v2.positionScreen,\n                    _v3.positionScreen,\n                    _v4.positionScreen\n                ]);\n                renderFace4(_v1, _v2, _v3, _v4, _v5, _v6, element, material, scene);\n            }\n            /* DEBUG\n\t\t\tsetLineWidth( 1 );\n\t\t\tsetStrokeStyle( 'rgba( 0, 255, 0, 0.5 )' );\n\t\t\t_context.strokeRect( _elemBox.min.x, _elemBox.min.y, _elemBox.max.x - _elemBox.min.x, _elemBox.max.y - _elemBox.min.y );\n\t\t\t*/ _clearBox.union(_elemBox);\n        }\n        /* DEBUG\n\t\tsetLineWidth( 1 );\n\t\tsetStrokeStyle( 'rgba( 255, 0, 0, 0.5 )' );\n\t\t_context.strokeRect( _clearBox.min.x, _clearBox.min.y, _clearBox.max.x - _clearBox.min.x, _clearBox.max.y - _clearBox.min.y );\n\t\t*/ _context.setTransform(1, 0, 0, 1, 0, 0);\n        //\n        function calculateLights() {\n            _ambientLight.setRGB(0, 0, 0);\n            _directionalLights.setRGB(0, 0, 0);\n            _pointLights.setRGB(0, 0, 0);\n            for(var l = 0, ll = _lights.length; l < ll; l++){\n                var light = _lights[l];\n                var lightColor = light.color;\n                if (light instanceof THREE.AmbientLight) _ambientLight.add(lightColor);\n                else if (light instanceof THREE.DirectionalLight) // for particles\n                _directionalLights.add(lightColor);\n                else if (light instanceof THREE.PointLight) // for particles\n                _pointLights.add(lightColor);\n            }\n        }\n        function calculateLight(position, normal, color) {\n            for(var l = 0, ll = _lights.length; l < ll; l++){\n                var light = _lights[l];\n                _lightColor.copy(light.color);\n                if (light instanceof THREE.DirectionalLight) {\n                    var lightPosition = _vector3.getPositionFromMatrix(light.matrixWorld).normalize();\n                    var amount = normal.dot(lightPosition);\n                    if (amount <= 0) continue;\n                    amount *= light.intensity;\n                    color.add(_lightColor.multiplyScalar(amount));\n                } else if (light instanceof THREE.PointLight) {\n                    var lightPosition = _vector3.getPositionFromMatrix(light.matrixWorld);\n                    var amount = normal.dot(_vector3.subVectors(lightPosition, position).normalize());\n                    if (amount <= 0) continue;\n                    amount *= light.distance == 0 ? 1 : 1 - Math.min(position.distanceTo(lightPosition) / light.distance, 1);\n                    if (amount == 0) continue;\n                    amount *= light.intensity;\n                    color.add(_lightColor.multiplyScalar(amount));\n                }\n            }\n        }\n        function renderParticle(v1, element, material) {\n            setOpacity(material.opacity);\n            setBlending(material.blending);\n            var width, height, scaleX, scaleY, bitmap, bitmapWidth, bitmapHeight;\n            if (material instanceof THREE.ParticleBasicMaterial) {\n                if (material.map === null) {\n                    scaleX = element.object.scale.x;\n                    scaleY = element.object.scale.y;\n                    // TODO: Be able to disable this\n                    scaleX *= element.scale.x * _canvasWidthHalf;\n                    scaleY *= element.scale.y * _canvasHeightHalf;\n                    _elemBox.min.set(v1.x - scaleX, v1.y - scaleY);\n                    _elemBox.max.set(v1.x + scaleX, v1.y + scaleY);\n                    if (_clipBox.isIntersectionBox(_elemBox) === false) return;\n                    setFillStyle(material.color.getStyle());\n                    _context.save();\n                    _context.translate(v1.x, v1.y);\n                    _context.rotate(-element.rotation);\n                    _context.scale(scaleX, scaleY);\n                    _context.fillRect(-1, -1, 2, 2);\n                    _context.restore();\n                } else {\n                    bitmap = material.map.image;\n                    bitmapWidth = bitmap.width >> 1;\n                    bitmapHeight = bitmap.height >> 1;\n                    scaleX = element.scale.x * _canvasWidthHalf;\n                    scaleY = element.scale.y * _canvasHeightHalf;\n                    width = scaleX * bitmapWidth;\n                    height = scaleY * bitmapHeight;\n                    // TODO: Rotations break this...\n                    _elemBox.min.set(v1.x - width, v1.y - height);\n                    _elemBox.max.set(v1.x + width, v1.y + height);\n                    if (_clipBox.isIntersectionBox(_elemBox) === false) return;\n                    _context.save();\n                    _context.translate(v1.x, v1.y);\n                    _context.rotate(-element.rotation);\n                    _context.scale(scaleX, -scaleY);\n                    _context.translate(-bitmapWidth, -bitmapHeight);\n                    _context.drawImage(bitmap, 0, 0);\n                    _context.restore();\n                }\n            } else if (material instanceof THREE.ParticleCanvasMaterial) {\n                width = element.scale.x * _canvasWidthHalf;\n                height = element.scale.y * _canvasHeightHalf;\n                _elemBox.min.set(v1.x - width, v1.y - height);\n                _elemBox.max.set(v1.x + width, v1.y + height);\n                if (_clipBox.isIntersectionBox(_elemBox) === false) return;\n                setStrokeStyle(material.color.getStyle());\n                setFillStyle(material.color.getStyle());\n                _context.save();\n                _context.translate(v1.x, v1.y);\n                _context.rotate(-element.rotation);\n                _context.scale(width, height);\n                material.program(_context);\n                _context.restore();\n            }\n        }\n        function renderLine(v1, v2, element, material) {\n            setOpacity(material.opacity);\n            setBlending(material.blending);\n            _context.beginPath();\n            _context.moveTo(v1.positionScreen.x, v1.positionScreen.y);\n            _context.lineTo(v2.positionScreen.x, v2.positionScreen.y);\n            if (material instanceof THREE.LineBasicMaterial) {\n                setLineWidth(material.linewidth);\n                setLineCap(material.linecap);\n                setLineJoin(material.linejoin);\n                setStrokeStyle(material.color.getStyle());\n                setDashAndGap(null, null);\n                _context.stroke();\n                _elemBox.expandByScalar(material.linewidth * 2);\n            } else if (material instanceof THREE.LineDashedMaterial) {\n                setLineWidth(material.linewidth);\n                setLineCap(material.linecap);\n                setLineJoin(material.linejoin);\n                setStrokeStyle(material.color.getStyle());\n                setDashAndGap(material.dashSize, material.gapSize);\n                _context.stroke();\n                _elemBox.expandByScalar(material.linewidth * 2);\n            }\n        }\n        function renderFace3(v1, v2, v3, uv1, uv2, uv3, element, material) {\n            _this.info.render.vertices += 3;\n            _this.info.render.faces++;\n            setOpacity(material.opacity);\n            setBlending(material.blending);\n            _v1x = v1.positionScreen.x;\n            _v1y = v1.positionScreen.y;\n            _v2x = v2.positionScreen.x;\n            _v2y = v2.positionScreen.y;\n            _v3x = v3.positionScreen.x;\n            _v3y = v3.positionScreen.y;\n            drawTriangle(_v1x, _v1y, _v2x, _v2y, _v3x, _v3y);\n            if ((material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial) && material.map === null) {\n                _diffuseColor.copy(material.color);\n                _emissiveColor.copy(material.emissive);\n                if (material.vertexColors === THREE.FaceColors) _diffuseColor.multiply(element.color);\n                if (_enableLighting === true) {\n                    if (material.wireframe === false && material.shading == THREE.SmoothShading && element.vertexNormalsLength == 3) {\n                        _color1.copy(_ambientLight);\n                        _color2.copy(_ambientLight);\n                        _color3.copy(_ambientLight);\n                        calculateLight(element.v1.positionWorld, element.vertexNormalsModel[0], _color1);\n                        calculateLight(element.v2.positionWorld, element.vertexNormalsModel[1], _color2);\n                        calculateLight(element.v3.positionWorld, element.vertexNormalsModel[2], _color3);\n                        _color1.multiply(_diffuseColor).add(_emissiveColor);\n                        _color2.multiply(_diffuseColor).add(_emissiveColor);\n                        _color3.multiply(_diffuseColor).add(_emissiveColor);\n                        _color4.addColors(_color2, _color3).multiplyScalar(0.5);\n                        _image = getGradientTexture(_color1, _color2, _color3, _color4);\n                        clipImage(_v1x, _v1y, _v2x, _v2y, _v3x, _v3y, 0, 0, 1, 0, 0, 1, _image);\n                    } else {\n                        _color.copy(_ambientLight);\n                        calculateLight(element.centroidModel, element.normalModel, _color);\n                        _color.multiply(_diffuseColor).add(_emissiveColor);\n                        material.wireframe === true ? strokePath(_color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin) : fillPath(_color);\n                    }\n                } else material.wireframe === true ? strokePath(material.color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin) : fillPath(material.color);\n            } else if (material instanceof THREE.MeshBasicMaterial || material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial) {\n                if (material.map !== null) {\n                    if (material.map.mapping instanceof THREE.UVMapping) {\n                        _uvs = element.uvs[0];\n                        patternPath(_v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _uvs[uv1].x, _uvs[uv1].y, _uvs[uv2].x, _uvs[uv2].y, _uvs[uv3].x, _uvs[uv3].y, material.map);\n                    }\n                } else if (material.envMap !== null) {\n                    if (material.envMap.mapping instanceof THREE.SphericalReflectionMapping) {\n                        _vector3.copy(element.vertexNormalsModelView[uv1]);\n                        _uv1x = 0.5 * _vector3.x + 0.5;\n                        _uv1y = 0.5 * _vector3.y + 0.5;\n                        _vector3.copy(element.vertexNormalsModelView[uv2]);\n                        _uv2x = 0.5 * _vector3.x + 0.5;\n                        _uv2y = 0.5 * _vector3.y + 0.5;\n                        _vector3.copy(element.vertexNormalsModelView[uv3]);\n                        _uv3x = 0.5 * _vector3.x + 0.5;\n                        _uv3y = 0.5 * _vector3.y + 0.5;\n                        patternPath(_v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _uv1x, _uv1y, _uv2x, _uv2y, _uv3x, _uv3y, material.envMap);\n                    } /* else if ( material.envMap.mapping == THREE.SphericalRefractionMapping ) {\n\n\n\n\t\t\t\t\t}*/ \n                } else {\n                    _color.copy(material.color);\n                    if (material.vertexColors === THREE.FaceColors) _color.multiply(element.color);\n                    material.wireframe === true ? strokePath(_color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin) : fillPath(_color);\n                }\n            } else if (material instanceof THREE.MeshDepthMaterial) {\n                _near = camera.near;\n                _far = camera.far;\n                _color1.r = _color1.g = _color1.b = 1 - smoothstep(v1.positionScreen.z * v1.positionScreen.w, _near, _far);\n                _color2.r = _color2.g = _color2.b = 1 - smoothstep(v2.positionScreen.z * v2.positionScreen.w, _near, _far);\n                _color3.r = _color3.g = _color3.b = 1 - smoothstep(v3.positionScreen.z * v3.positionScreen.w, _near, _far);\n                _color4.addColors(_color2, _color3).multiplyScalar(0.5);\n                _image = getGradientTexture(_color1, _color2, _color3, _color4);\n                clipImage(_v1x, _v1y, _v2x, _v2y, _v3x, _v3y, 0, 0, 1, 0, 0, 1, _image);\n            } else if (material instanceof THREE.MeshNormalMaterial) {\n                var normal;\n                if (material.shading == THREE.FlatShading) {\n                    normal = element.normalModelView;\n                    _color.setRGB(normal.x, normal.y, normal.z).multiplyScalar(0.5).addScalar(0.5);\n                    material.wireframe === true ? strokePath(_color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin) : fillPath(_color);\n                } else if (material.shading == THREE.SmoothShading) {\n                    normal = element.vertexNormalsModelView[uv1];\n                    _color1.setRGB(normal.x, normal.y, normal.z).multiplyScalar(0.5).addScalar(0.5);\n                    normal = element.vertexNormalsModelView[uv2];\n                    _color2.setRGB(normal.x, normal.y, normal.z).multiplyScalar(0.5).addScalar(0.5);\n                    normal = element.vertexNormalsModelView[uv3];\n                    _color3.setRGB(normal.x, normal.y, normal.z).multiplyScalar(0.5).addScalar(0.5);\n                    _color4.addColors(_color2, _color3).multiplyScalar(0.5);\n                    _image = getGradientTexture(_color1, _color2, _color3, _color4);\n                    clipImage(_v1x, _v1y, _v2x, _v2y, _v3x, _v3y, 0, 0, 1, 0, 0, 1, _image);\n                }\n            }\n        }\n        function renderFace4(v1, v2, v3, v4, v5, v6, element, material) {\n            _this.info.render.vertices += 4;\n            _this.info.render.faces++;\n            setOpacity(material.opacity);\n            setBlending(material.blending);\n            if (material.map !== undefined && material.map !== null || material.envMap !== undefined && material.envMap !== null) {\n                // Let renderFace3() handle this\n                renderFace3(v1, v2, v4, 0, 1, 3, element, material);\n                renderFace3(v5, v3, v6, 1, 2, 3, element, material);\n                return;\n            }\n            _v1x = v1.positionScreen.x;\n            _v1y = v1.positionScreen.y;\n            _v2x = v2.positionScreen.x;\n            _v2y = v2.positionScreen.y;\n            _v3x = v3.positionScreen.x;\n            _v3y = v3.positionScreen.y;\n            _v4x = v4.positionScreen.x;\n            _v4y = v4.positionScreen.y;\n            _v5x = v5.positionScreen.x;\n            _v5y = v5.positionScreen.y;\n            _v6x = v6.positionScreen.x;\n            _v6y = v6.positionScreen.y;\n            if (material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial) {\n                _diffuseColor.copy(material.color);\n                _emissiveColor.copy(material.emissive);\n                if (material.vertexColors === THREE.FaceColors) _diffuseColor.multiply(element.color);\n                if (_enableLighting === true) {\n                    if (material.wireframe === false && material.shading == THREE.SmoothShading && element.vertexNormalsLength == 4) {\n                        _color1.copy(_ambientLight);\n                        _color2.copy(_ambientLight);\n                        _color3.copy(_ambientLight);\n                        _color4.copy(_ambientLight);\n                        calculateLight(element.v1.positionWorld, element.vertexNormalsModel[0], _color1);\n                        calculateLight(element.v2.positionWorld, element.vertexNormalsModel[1], _color2);\n                        calculateLight(element.v4.positionWorld, element.vertexNormalsModel[3], _color3);\n                        calculateLight(element.v3.positionWorld, element.vertexNormalsModel[2], _color4);\n                        _color1.multiply(_diffuseColor).add(_emissiveColor);\n                        _color2.multiply(_diffuseColor).add(_emissiveColor);\n                        _color3.multiply(_diffuseColor).add(_emissiveColor);\n                        _color4.multiply(_diffuseColor).add(_emissiveColor);\n                        _image = getGradientTexture(_color1, _color2, _color3, _color4);\n                        // TODO: UVs are incorrect, v4->v3?\n                        drawTriangle(_v1x, _v1y, _v2x, _v2y, _v4x, _v4y);\n                        clipImage(_v1x, _v1y, _v2x, _v2y, _v4x, _v4y, 0, 0, 1, 0, 0, 1, _image);\n                        drawTriangle(_v5x, _v5y, _v3x, _v3y, _v6x, _v6y);\n                        clipImage(_v5x, _v5y, _v3x, _v3y, _v6x, _v6y, 1, 0, 1, 1, 0, 1, _image);\n                    } else {\n                        _color.copy(_ambientLight);\n                        calculateLight(element.centroidModel, element.normalModel, _color);\n                        _color.multiply(_diffuseColor).add(_emissiveColor);\n                        drawQuad(_v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _v4x, _v4y);\n                        material.wireframe === true ? strokePath(_color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin) : fillPath(_color);\n                    }\n                } else {\n                    _color.addColors(_diffuseColor, _emissiveColor);\n                    drawQuad(_v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _v4x, _v4y);\n                    material.wireframe === true ? strokePath(_color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin) : fillPath(_color);\n                }\n            } else if (material instanceof THREE.MeshBasicMaterial) {\n                _color.copy(material.color);\n                if (material.vertexColors === THREE.FaceColors) _color.multiply(element.color);\n                drawQuad(_v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _v4x, _v4y);\n                material.wireframe === true ? strokePath(_color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin) : fillPath(_color);\n            } else if (material instanceof THREE.MeshNormalMaterial) {\n                var normal;\n                if (material.shading == THREE.FlatShading) {\n                    normal = element.normalModelView;\n                    _color.setRGB(normal.x, normal.y, normal.z).multiplyScalar(0.5).addScalar(0.5);\n                    drawQuad(_v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _v4x, _v4y);\n                    material.wireframe === true ? strokePath(_color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin) : fillPath(_color);\n                } else if (material.shading == THREE.SmoothShading) {\n                    normal = element.vertexNormalsModelView[0];\n                    _color1.setRGB(normal.x, normal.y, normal.z).multiplyScalar(0.5).addScalar(0.5);\n                    normal = element.vertexNormalsModelView[1];\n                    _color2.setRGB(normal.x, normal.y, normal.z).multiplyScalar(0.5).addScalar(0.5);\n                    normal = element.vertexNormalsModelView[3];\n                    _color3.setRGB(normal.x, normal.y, normal.z).multiplyScalar(0.5).addScalar(0.5);\n                    normal = element.vertexNormalsModelView[2];\n                    _color4.setRGB(normal.x, normal.y, normal.z).multiplyScalar(0.5).addScalar(0.5);\n                    _image = getGradientTexture(_color1, _color2, _color3, _color4);\n                    drawTriangle(_v1x, _v1y, _v2x, _v2y, _v4x, _v4y);\n                    clipImage(_v1x, _v1y, _v2x, _v2y, _v4x, _v4y, 0, 0, 1, 0, 0, 1, _image);\n                    drawTriangle(_v5x, _v5y, _v3x, _v3y, _v6x, _v6y);\n                    clipImage(_v5x, _v5y, _v3x, _v3y, _v6x, _v6y, 1, 0, 1, 1, 0, 1, _image);\n                }\n            } else if (material instanceof THREE.MeshDepthMaterial) {\n                _near = camera.near;\n                _far = camera.far;\n                _color1.r = _color1.g = _color1.b = 1 - smoothstep(v1.positionScreen.z * v1.positionScreen.w, _near, _far);\n                _color2.r = _color2.g = _color2.b = 1 - smoothstep(v2.positionScreen.z * v2.positionScreen.w, _near, _far);\n                _color3.r = _color3.g = _color3.b = 1 - smoothstep(v4.positionScreen.z * v4.positionScreen.w, _near, _far);\n                _color4.r = _color4.g = _color4.b = 1 - smoothstep(v3.positionScreen.z * v3.positionScreen.w, _near, _far);\n                _image = getGradientTexture(_color1, _color2, _color3, _color4);\n                // TODO: UVs are incorrect, v4->v3?\n                drawTriangle(_v1x, _v1y, _v2x, _v2y, _v4x, _v4y);\n                clipImage(_v1x, _v1y, _v2x, _v2y, _v4x, _v4y, 0, 0, 1, 0, 0, 1, _image);\n                drawTriangle(_v5x, _v5y, _v3x, _v3y, _v6x, _v6y);\n                clipImage(_v5x, _v5y, _v3x, _v3y, _v6x, _v6y, 1, 0, 1, 1, 0, 1, _image);\n            }\n        }\n        //\n        function drawTriangle(x0, y0, x1, y1, x2, y2) {\n            _context.beginPath();\n            _context.moveTo(x0, y0);\n            _context.lineTo(x1, y1);\n            _context.lineTo(x2, y2);\n            _context.closePath();\n        }\n        function drawQuad(x0, y0, x1, y1, x2, y2, x3, y3) {\n            _context.beginPath();\n            _context.moveTo(x0, y0);\n            _context.lineTo(x1, y1);\n            _context.lineTo(x2, y2);\n            _context.lineTo(x3, y3);\n            _context.closePath();\n        }\n        function strokePath(color, linewidth, linecap, linejoin) {\n            setLineWidth(linewidth);\n            setLineCap(linecap);\n            setLineJoin(linejoin);\n            setStrokeStyle(color.getStyle());\n            _context.stroke();\n            _elemBox.expandByScalar(linewidth * 2);\n        }\n        function fillPath(color) {\n            setFillStyle(color.getStyle());\n            _context.fill();\n        }\n        function patternPath(x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, u2, v2, texture) {\n            if (texture instanceof THREE.DataTexture || texture.image === undefined || texture.image.width == 0) return;\n            if (texture.needsUpdate === true) {\n                var repeatX = texture.wrapS == THREE.RepeatWrapping;\n                var repeatY = texture.wrapT == THREE.RepeatWrapping;\n                _patterns[texture.id] = _context.createPattern(texture.image, repeatX === true && repeatY === true ? \"repeat\" : repeatX === true && repeatY === false ? \"repeat-x\" : repeatX === false && repeatY === true ? \"repeat-y\" : \"no-repeat\");\n                texture.needsUpdate = false;\n            }\n            _patterns[texture.id] === undefined ? setFillStyle(\"rgba(0,0,0,1)\") : setFillStyle(_patterns[texture.id]);\n            // http://extremelysatisfactorytotalitarianism.com/blog/?p=2120\n            var a, b, c, d, e, f, det, idet, offsetX = texture.offset.x / texture.repeat.x, offsetY = texture.offset.y / texture.repeat.y, width = texture.image.width * texture.repeat.x, height = texture.image.height * texture.repeat.y;\n            u0 = (u0 + offsetX) * width;\n            v0 = (1.0 - v0 + offsetY) * height;\n            u1 = (u1 + offsetX) * width;\n            v1 = (1.0 - v1 + offsetY) * height;\n            u2 = (u2 + offsetX) * width;\n            v2 = (1.0 - v2 + offsetY) * height;\n            x1 -= x0;\n            y1 -= y0;\n            x2 -= x0;\n            y2 -= y0;\n            u1 -= u0;\n            v1 -= v0;\n            u2 -= u0;\n            v2 -= v0;\n            det = u1 * v2 - u2 * v1;\n            if (det === 0) {\n                if (_imagedatas[texture.id] === undefined) {\n                    var canvas = document.createElement(\"canvas\");\n                    canvas.width = texture.image.width;\n                    canvas.height = texture.image.height;\n                    var context = canvas.getContext(\"2d\");\n                    context.drawImage(texture.image, 0, 0);\n                    _imagedatas[texture.id] = context.getImageData(0, 0, texture.image.width, texture.image.height).data;\n                }\n                var data = _imagedatas[texture.id];\n                var index = (Math.floor(u0) + Math.floor(v0) * texture.image.width) * 4;\n                _color.setRGB(data[index] / 255, data[index + 1] / 255, data[index + 2] / 255);\n                fillPath(_color);\n                return;\n            }\n            idet = 1 / det;\n            a = (v2 * x1 - v1 * x2) * idet;\n            b = (v2 * y1 - v1 * y2) * idet;\n            c = (u1 * x2 - u2 * x1) * idet;\n            d = (u1 * y2 - u2 * y1) * idet;\n            e = x0 - a * u0 - c * v0;\n            f = y0 - b * u0 - d * v0;\n            _context.save();\n            _context.transform(a, b, c, d, e, f);\n            _context.fill();\n            _context.restore();\n        }\n        function clipImage(x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, u2, v2, image) {\n            // http://extremelysatisfactorytotalitarianism.com/blog/?p=2120\n            var a, b, c, d, e, f, det, idet, width = image.width - 1, height = image.height - 1;\n            u0 *= width;\n            v0 *= height;\n            u1 *= width;\n            v1 *= height;\n            u2 *= width;\n            v2 *= height;\n            x1 -= x0;\n            y1 -= y0;\n            x2 -= x0;\n            y2 -= y0;\n            u1 -= u0;\n            v1 -= v0;\n            u2 -= u0;\n            v2 -= v0;\n            det = u1 * v2 - u2 * v1;\n            idet = 1 / det;\n            a = (v2 * x1 - v1 * x2) * idet;\n            b = (v2 * y1 - v1 * y2) * idet;\n            c = (u1 * x2 - u2 * x1) * idet;\n            d = (u1 * y2 - u2 * y1) * idet;\n            e = x0 - a * u0 - c * v0;\n            f = y0 - b * u0 - d * v0;\n            _context.save();\n            _context.transform(a, b, c, d, e, f);\n            _context.clip();\n            _context.drawImage(image, 0, 0);\n            _context.restore();\n        }\n        function getGradientTexture(color1, color2, color3, color4) {\n            // http://mrdoob.com/blog/post/710\n            _pixelMapData[0] = color1.r * 255 | 0;\n            _pixelMapData[1] = color1.g * 255 | 0;\n            _pixelMapData[2] = color1.b * 255 | 0;\n            _pixelMapData[4] = color2.r * 255 | 0;\n            _pixelMapData[5] = color2.g * 255 | 0;\n            _pixelMapData[6] = color2.b * 255 | 0;\n            _pixelMapData[8] = color3.r * 255 | 0;\n            _pixelMapData[9] = color3.g * 255 | 0;\n            _pixelMapData[10] = color3.b * 255 | 0;\n            _pixelMapData[12] = color4.r * 255 | 0;\n            _pixelMapData[13] = color4.g * 255 | 0;\n            _pixelMapData[14] = color4.b * 255 | 0;\n            _pixelMapContext.putImageData(_pixelMapImage, 0, 0);\n            _gradientMapContext.drawImage(_pixelMap, 0, 0);\n            return _gradientMap;\n        }\n        // Hide anti-alias gaps\n        function expand(v1, v2) {\n            var x = v2.x - v1.x, y = v2.y - v1.y, det = x * x + y * y, idet;\n            if (det === 0) return;\n            idet = 1 / Math.sqrt(det);\n            x *= idet;\n            y *= idet;\n            v2.x += x;\n            v2.y += y;\n            v1.x -= x;\n            v1.y -= y;\n        }\n    };\n    // Context cached methods.\n    function setOpacity(value) {\n        if (_contextGlobalAlpha !== value) {\n            _context.globalAlpha = value;\n            _contextGlobalAlpha = value;\n        }\n    }\n    function setBlending(value) {\n        if (_contextGlobalCompositeOperation !== value) {\n            if (value === THREE.NormalBlending) _context.globalCompositeOperation = \"source-over\";\n            else if (value === THREE.AdditiveBlending) _context.globalCompositeOperation = \"lighter\";\n            else if (value === THREE.SubtractiveBlending) _context.globalCompositeOperation = \"darker\";\n            _contextGlobalCompositeOperation = value;\n        }\n    }\n    function setLineWidth(value) {\n        if (_contextLineWidth !== value) {\n            _context.lineWidth = value;\n            _contextLineWidth = value;\n        }\n    }\n    function setLineCap(value) {\n        // \"butt\", \"round\", \"square\"\n        if (_contextLineCap !== value) {\n            _context.lineCap = value;\n            _contextLineCap = value;\n        }\n    }\n    function setLineJoin(value) {\n        // \"round\", \"bevel\", \"miter\"\n        if (_contextLineJoin !== value) {\n            _context.lineJoin = value;\n            _contextLineJoin = value;\n        }\n    }\n    function setStrokeStyle(value) {\n        if (_contextStrokeStyle !== value) {\n            _context.strokeStyle = value;\n            _contextStrokeStyle = value;\n        }\n    }\n    function setFillStyle(value) {\n        if (_contextFillStyle !== value) {\n            _context.fillStyle = value;\n            _contextFillStyle = value;\n        }\n    }\n    function setDashAndGap(dashSizeValue, gapSizeValue) {\n        if (_contextDashSize !== dashSizeValue || _contextGapSize !== gapSizeValue) {\n            _context.setLineDash([\n                dashSizeValue,\n                gapSizeValue\n            ]);\n            _contextDashSize = dashSizeValue;\n            _contextGapSize = gapSizeValue;\n        }\n    }\n};\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n * @author mikael emtinger / http://gomo.se/\n */ THREE.ShaderChunk = {\n    // FOG\n    fog_pars_fragment: [\n        \"#ifdef USE_FOG\",\n        \"uniform vec3 fogColor;\",\n        \"#ifdef FOG_EXP2\",\n        \"uniform float fogDensity;\",\n        \"#else\",\n        \"uniform float fogNear;\",\n        \"uniform float fogFar;\",\n        \"#endif\",\n        \"#endif\"\n    ].join(\"\\n\"),\n    fog_fragment: [\n        \"#ifdef USE_FOG\",\n        \"float depth = gl_FragCoord.z / gl_FragCoord.w;\",\n        \"#ifdef FOG_EXP2\",\n        \"const float LOG2 = 1.442695;\",\n        \"float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\",\n        \"fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\",\n        \"#else\",\n        \"float fogFactor = smoothstep( fogNear, fogFar, depth );\",\n        \"#endif\",\n        \"gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\",\n        \"#endif\"\n    ].join(\"\\n\"),\n    // ENVIRONMENT MAP\n    envmap_pars_fragment: [\n        \"#ifdef USE_ENVMAP\",\n        \"uniform float reflectivity;\",\n        \"uniform samplerCube envMap;\",\n        \"uniform float flipEnvMap;\",\n        \"uniform int combine;\",\n        \"#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\",\n        \"uniform bool useRefract;\",\n        \"uniform float refractionRatio;\",\n        \"#else\",\n        \"varying vec3 vReflect;\",\n        \"#endif\",\n        \"#endif\"\n    ].join(\"\\n\"),\n    envmap_fragment: [\n        \"#ifdef USE_ENVMAP\",\n        \"vec3 reflectVec;\",\n        \"#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\",\n        \"vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\",\n        \"if ( useRefract ) {\",\n        \"reflectVec = refract( cameraToVertex, normal, refractionRatio );\",\n        \"} else { \",\n        \"reflectVec = reflect( cameraToVertex, normal );\",\n        \"}\",\n        \"#else\",\n        \"reflectVec = vReflect;\",\n        \"#endif\",\n        \"#ifdef DOUBLE_SIDED\",\n        \"float flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\",\n        \"vec4 cubeColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\",\n        \"#else\",\n        \"vec4 cubeColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\",\n        \"#endif\",\n        \"#ifdef GAMMA_INPUT\",\n        \"cubeColor.xyz *= cubeColor.xyz;\",\n        \"#endif\",\n        \"if ( combine == 1 ) {\",\n        \"gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularStrength * reflectivity );\",\n        \"} else if ( combine == 2 ) {\",\n        \"gl_FragColor.xyz += cubeColor.xyz * specularStrength * reflectivity;\",\n        \"} else {\",\n        \"gl_FragColor.xyz = mix( gl_FragColor.xyz, gl_FragColor.xyz * cubeColor.xyz, specularStrength * reflectivity );\",\n        \"}\",\n        \"#endif\"\n    ].join(\"\\n\"),\n    envmap_pars_vertex: [\n        \"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\",\n        \"varying vec3 vReflect;\",\n        \"uniform float refractionRatio;\",\n        \"uniform bool useRefract;\",\n        \"#endif\"\n    ].join(\"\\n\"),\n    worldpos_vertex: [\n        \"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\",\n        \"#ifdef USE_SKINNING\",\n        \"vec4 worldPosition = modelMatrix * skinned;\",\n        \"#endif\",\n        \"#if defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\",\n        \"vec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\",\n        \"#endif\",\n        \"#if ! defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\",\n        \"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\",\n        \"#endif\",\n        \"#endif\"\n    ].join(\"\\n\"),\n    envmap_vertex: [\n        \"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\",\n        \"vec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;\",\n        \"worldNormal = normalize( worldNormal );\",\n        \"vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\",\n        \"if ( useRefract ) {\",\n        \"vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\",\n        \"} else {\",\n        \"vReflect = reflect( cameraToVertex, worldNormal );\",\n        \"}\",\n        \"#endif\"\n    ].join(\"\\n\"),\n    // COLOR MAP (particles)\n    map_particle_pars_fragment: [\n        \"#ifdef USE_MAP\",\n        \"uniform sampler2D map;\",\n        \"#endif\"\n    ].join(\"\\n\"),\n    map_particle_fragment: [\n        \"#ifdef USE_MAP\",\n        \"gl_FragColor = gl_FragColor * texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );\",\n        \"#endif\"\n    ].join(\"\\n\"),\n    // COLOR MAP (triangles)\n    map_pars_vertex: [\n        \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\",\n        \"varying vec2 vUv;\",\n        \"uniform vec4 offsetRepeat;\",\n        \"#endif\"\n    ].join(\"\\n\"),\n    map_pars_fragment: [\n        \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\",\n        \"varying vec2 vUv;\",\n        \"#endif\",\n        \"#ifdef USE_MAP\",\n        \"uniform sampler2D map;\",\n        \"#endif\"\n    ].join(\"\\n\"),\n    map_vertex: [\n        \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\",\n        \"vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\",\n        \"#endif\"\n    ].join(\"\\n\"),\n    map_fragment: [\n        \"#ifdef USE_MAP\",\n        \"vec4 texelColor = texture2D( map, vUv );\",\n        \"#ifdef GAMMA_INPUT\",\n        \"texelColor.xyz *= texelColor.xyz;\",\n        \"#endif\",\n        \"gl_FragColor = gl_FragColor * texelColor;\",\n        \"#endif\"\n    ].join(\"\\n\"),\n    // LIGHT MAP\n    lightmap_pars_fragment: [\n        \"#ifdef USE_LIGHTMAP\",\n        \"varying vec2 vUv2;\",\n        \"uniform sampler2D lightMap;\",\n        \"#endif\"\n    ].join(\"\\n\"),\n    lightmap_pars_vertex: [\n        \"#ifdef USE_LIGHTMAP\",\n        \"varying vec2 vUv2;\",\n        \"#endif\"\n    ].join(\"\\n\"),\n    lightmap_fragment: [\n        \"#ifdef USE_LIGHTMAP\",\n        \"gl_FragColor = gl_FragColor * texture2D( lightMap, vUv2 );\",\n        \"#endif\"\n    ].join(\"\\n\"),\n    lightmap_vertex: [\n        \"#ifdef USE_LIGHTMAP\",\n        \"vUv2 = uv2;\",\n        \"#endif\"\n    ].join(\"\\n\"),\n    // BUMP MAP\n    bumpmap_pars_fragment: [\n        \"#ifdef USE_BUMPMAP\",\n        \"uniform sampler2D bumpMap;\",\n        \"uniform float bumpScale;\",\n        // Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\n        //\thttp://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\n        // Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n        \"vec2 dHdxy_fwd() {\",\n        \"vec2 dSTdx = dFdx( vUv );\",\n        \"vec2 dSTdy = dFdy( vUv );\",\n        \"float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\",\n        \"float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\",\n        \"float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\",\n        \"return vec2( dBx, dBy );\",\n        \"}\",\n        \"vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\",\n        \"vec3 vSigmaX = dFdx( surf_pos );\",\n        \"vec3 vSigmaY = dFdy( surf_pos );\",\n        \"vec3 vN = surf_norm;\",\n        \"vec3 R1 = cross( vSigmaY, vN );\",\n        \"vec3 R2 = cross( vN, vSigmaX );\",\n        \"float fDet = dot( vSigmaX, R1 );\",\n        \"vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\",\n        \"return normalize( abs( fDet ) * surf_norm - vGrad );\",\n        \"}\",\n        \"#endif\"\n    ].join(\"\\n\"),\n    // NORMAL MAP\n    normalmap_pars_fragment: [\n        \"#ifdef USE_NORMALMAP\",\n        \"uniform sampler2D normalMap;\",\n        \"uniform vec2 normalScale;\",\n        // Per-Pixel Tangent Space Normal Mapping\n        // http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n        \"vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\",\n        \"vec3 q0 = dFdx( eye_pos.xyz );\",\n        \"vec3 q1 = dFdy( eye_pos.xyz );\",\n        \"vec2 st0 = dFdx( vUv.st );\",\n        \"vec2 st1 = dFdy( vUv.st );\",\n        \"vec3 S = normalize(  q0 * st1.t - q1 * st0.t );\",\n        \"vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\",\n        \"vec3 N = normalize( surf_norm );\",\n        \"vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\",\n        \"mapN.xy = normalScale * mapN.xy;\",\n        \"mat3 tsn = mat3( S, T, N );\",\n        \"return normalize( tsn * mapN );\",\n        \"}\",\n        \"#endif\"\n    ].join(\"\\n\"),\n    // SPECULAR MAP\n    specularmap_pars_fragment: [\n        \"#ifdef USE_SPECULARMAP\",\n        \"uniform sampler2D specularMap;\",\n        \"#endif\"\n    ].join(\"\\n\"),\n    specularmap_fragment: [\n        \"float specularStrength;\",\n        \"#ifdef USE_SPECULARMAP\",\n        \"vec4 texelSpecular = texture2D( specularMap, vUv );\",\n        \"specularStrength = texelSpecular.r;\",\n        \"#else\",\n        \"specularStrength = 1.0;\",\n        \"#endif\"\n    ].join(\"\\n\"),\n    // LIGHTS LAMBERT\n    lights_lambert_pars_vertex: [\n        \"uniform vec3 ambient;\",\n        \"uniform vec3 diffuse;\",\n        \"uniform vec3 emissive;\",\n        \"uniform vec3 ambientLightColor;\",\n        \"#if MAX_DIR_LIGHTS > 0\",\n        \"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\",\n        \"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\",\n        \"#endif\",\n        \"#if MAX_HEMI_LIGHTS > 0\",\n        \"uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\",\n        \"uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\",\n        \"uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\",\n        \"#endif\",\n        \"#if MAX_POINT_LIGHTS > 0\",\n        \"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\",\n        \"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\",\n        \"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\",\n        \"#endif\",\n        \"#if MAX_SPOT_LIGHTS > 0\",\n        \"uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\",\n        \"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\",\n        \"uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\",\n        \"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\",\n        \"uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\",\n        \"uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\",\n        \"#endif\",\n        \"#ifdef WRAP_AROUND\",\n        \"uniform vec3 wrapRGB;\",\n        \"#endif\"\n    ].join(\"\\n\"),\n    lights_lambert_vertex: [\n        \"vLightFront = vec3( 0.0 );\",\n        \"#ifdef DOUBLE_SIDED\",\n        \"vLightBack = vec3( 0.0 );\",\n        \"#endif\",\n        \"transformedNormal = normalize( transformedNormal );\",\n        \"#if MAX_DIR_LIGHTS > 0\",\n        \"for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\",\n        \"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\",\n        \"vec3 dirVector = normalize( lDirection.xyz );\",\n        \"float dotProduct = dot( transformedNormal, dirVector );\",\n        \"vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\",\n        \"#ifdef DOUBLE_SIDED\",\n        \"vec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\",\n        \"#ifdef WRAP_AROUND\",\n        \"vec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\",\n        \"#endif\",\n        \"#endif\",\n        \"#ifdef WRAP_AROUND\",\n        \"vec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\",\n        \"directionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );\",\n        \"#ifdef DOUBLE_SIDED\",\n        \"directionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );\",\n        \"#endif\",\n        \"#endif\",\n        \"vLightFront += directionalLightColor[ i ] * directionalLightWeighting;\",\n        \"#ifdef DOUBLE_SIDED\",\n        \"vLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;\",\n        \"#endif\",\n        \"}\",\n        \"#endif\",\n        \"#if MAX_POINT_LIGHTS > 0\",\n        \"for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\",\n        \"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\",\n        \"vec3 lVector = lPosition.xyz - mvPosition.xyz;\",\n        \"float lDistance = 1.0;\",\n        \"if ( pointLightDistance[ i ] > 0.0 )\",\n        \"lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\",\n        \"lVector = normalize( lVector );\",\n        \"float dotProduct = dot( transformedNormal, lVector );\",\n        \"vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );\",\n        \"#ifdef DOUBLE_SIDED\",\n        \"vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\",\n        \"#ifdef WRAP_AROUND\",\n        \"vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\",\n        \"#endif\",\n        \"#endif\",\n        \"#ifdef WRAP_AROUND\",\n        \"vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\",\n        \"pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );\",\n        \"#ifdef DOUBLE_SIDED\",\n        \"pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );\",\n        \"#endif\",\n        \"#endif\",\n        \"vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;\",\n        \"#ifdef DOUBLE_SIDED\",\n        \"vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;\",\n        \"#endif\",\n        \"}\",\n        \"#endif\",\n        \"#if MAX_SPOT_LIGHTS > 0\",\n        \"for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\",\n        \"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\",\n        \"vec3 lVector = lPosition.xyz - mvPosition.xyz;\",\n        \"float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );\",\n        \"if ( spotEffect > spotLightAngleCos[ i ] ) {\",\n        \"spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\",\n        \"float lDistance = 1.0;\",\n        \"if ( spotLightDistance[ i ] > 0.0 )\",\n        \"lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\",\n        \"lVector = normalize( lVector );\",\n        \"float dotProduct = dot( transformedNormal, lVector );\",\n        \"vec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );\",\n        \"#ifdef DOUBLE_SIDED\",\n        \"vec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\",\n        \"#ifdef WRAP_AROUND\",\n        \"vec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\",\n        \"#endif\",\n        \"#endif\",\n        \"#ifdef WRAP_AROUND\",\n        \"vec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\",\n        \"spotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );\",\n        \"#ifdef DOUBLE_SIDED\",\n        \"spotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );\",\n        \"#endif\",\n        \"#endif\",\n        \"vLightFront += spotLightColor[ i ] * spotLightWeighting * lDistance * spotEffect;\",\n        \"#ifdef DOUBLE_SIDED\",\n        \"vLightBack += spotLightColor[ i ] * spotLightWeightingBack * lDistance * spotEffect;\",\n        \"#endif\",\n        \"}\",\n        \"}\",\n        \"#endif\",\n        \"#if MAX_HEMI_LIGHTS > 0\",\n        \"for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\",\n        \"vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\",\n        \"vec3 lVector = normalize( lDirection.xyz );\",\n        \"float dotProduct = dot( transformedNormal, lVector );\",\n        \"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\",\n        \"float hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;\",\n        \"vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\",\n        \"#ifdef DOUBLE_SIDED\",\n        \"vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\",\n        \"#endif\",\n        \"}\",\n        \"#endif\",\n        \"vLightFront = vLightFront * diffuse + ambient * ambientLightColor + emissive;\",\n        \"#ifdef DOUBLE_SIDED\",\n        \"vLightBack = vLightBack * diffuse + ambient * ambientLightColor + emissive;\",\n        \"#endif\"\n    ].join(\"\\n\"),\n    // LIGHTS PHONG\n    lights_phong_pars_vertex: [\n        \"#ifndef PHONG_PER_PIXEL\",\n        \"#if MAX_POINT_LIGHTS > 0\",\n        \"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\",\n        \"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\",\n        \"varying vec4 vPointLight[ MAX_POINT_LIGHTS ];\",\n        \"#endif\",\n        \"#if MAX_SPOT_LIGHTS > 0\",\n        \"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\",\n        \"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\",\n        \"varying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];\",\n        \"#endif\",\n        \"#endif\",\n        \"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )\",\n        \"varying vec3 vWorldPosition;\",\n        \"#endif\"\n    ].join(\"\\n\"),\n    lights_phong_vertex: [\n        \"#ifndef PHONG_PER_PIXEL\",\n        \"#if MAX_POINT_LIGHTS > 0\",\n        \"for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\",\n        \"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\",\n        \"vec3 lVector = lPosition.xyz - mvPosition.xyz;\",\n        \"float lDistance = 1.0;\",\n        \"if ( pointLightDistance[ i ] > 0.0 )\",\n        \"lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\",\n        \"vPointLight[ i ] = vec4( lVector, lDistance );\",\n        \"}\",\n        \"#endif\",\n        \"#if MAX_SPOT_LIGHTS > 0\",\n        \"for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\",\n        \"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\",\n        \"vec3 lVector = lPosition.xyz - mvPosition.xyz;\",\n        \"float lDistance = 1.0;\",\n        \"if ( spotLightDistance[ i ] > 0.0 )\",\n        \"lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\",\n        \"vSpotLight[ i ] = vec4( lVector, lDistance );\",\n        \"}\",\n        \"#endif\",\n        \"#endif\",\n        \"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )\",\n        \"vWorldPosition = worldPosition.xyz;\",\n        \"#endif\"\n    ].join(\"\\n\"),\n    lights_phong_pars_fragment: [\n        \"uniform vec3 ambientLightColor;\",\n        \"#if MAX_DIR_LIGHTS > 0\",\n        \"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\",\n        \"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\",\n        \"#endif\",\n        \"#if MAX_HEMI_LIGHTS > 0\",\n        \"uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\",\n        \"uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\",\n        \"uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\",\n        \"#endif\",\n        \"#if MAX_POINT_LIGHTS > 0\",\n        \"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\",\n        \"#ifdef PHONG_PER_PIXEL\",\n        \"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\",\n        \"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\",\n        \"#else\",\n        \"varying vec4 vPointLight[ MAX_POINT_LIGHTS ];\",\n        \"#endif\",\n        \"#endif\",\n        \"#if MAX_SPOT_LIGHTS > 0\",\n        \"uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\",\n        \"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\",\n        \"uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\",\n        \"uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\",\n        \"uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\",\n        \"#ifdef PHONG_PER_PIXEL\",\n        \"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\",\n        \"#else\",\n        \"varying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];\",\n        \"#endif\",\n        \"#endif\",\n        \"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )\",\n        \"varying vec3 vWorldPosition;\",\n        \"#endif\",\n        \"#ifdef WRAP_AROUND\",\n        \"uniform vec3 wrapRGB;\",\n        \"#endif\",\n        \"varying vec3 vViewPosition;\",\n        \"varying vec3 vNormal;\"\n    ].join(\"\\n\"),\n    lights_phong_fragment: [\n        \"vec3 normal = normalize( vNormal );\",\n        \"vec3 viewPosition = normalize( vViewPosition );\",\n        \"#ifdef DOUBLE_SIDED\",\n        \"normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\",\n        \"#endif\",\n        \"#ifdef USE_NORMALMAP\",\n        \"normal = perturbNormal2Arb( -viewPosition, normal );\",\n        \"#elif defined( USE_BUMPMAP )\",\n        \"normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\",\n        \"#endif\",\n        \"#if MAX_POINT_LIGHTS > 0\",\n        \"vec3 pointDiffuse  = vec3( 0.0 );\",\n        \"vec3 pointSpecular = vec3( 0.0 );\",\n        \"for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\",\n        \"#ifdef PHONG_PER_PIXEL\",\n        \"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\",\n        \"vec3 lVector = lPosition.xyz + vViewPosition.xyz;\",\n        \"float lDistance = 1.0;\",\n        \"if ( pointLightDistance[ i ] > 0.0 )\",\n        \"lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\",\n        \"lVector = normalize( lVector );\",\n        \"#else\",\n        \"vec3 lVector = normalize( vPointLight[ i ].xyz );\",\n        \"float lDistance = vPointLight[ i ].w;\",\n        \"#endif\",\n        // diffuse\n        \"float dotProduct = dot( normal, lVector );\",\n        \"#ifdef WRAP_AROUND\",\n        \"float pointDiffuseWeightFull = max( dotProduct, 0.0 );\",\n        \"float pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\",\n        \"vec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\",\n        \"#else\",\n        \"float pointDiffuseWeight = max( dotProduct, 0.0 );\",\n        \"#endif\",\n        \"pointDiffuse  += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;\",\n        // specular\n        \"vec3 pointHalfVector = normalize( lVector + viewPosition );\",\n        \"float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\",\n        \"float pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\",\n        \"#ifdef PHYSICALLY_BASED_SHADING\",\n        // 2.0 => 2.0001 is hack to work around ANGLE bug\n        \"float specularNormalization = ( shininess + 2.0001 ) / 8.0;\",\n        \"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, pointHalfVector ), 5.0 );\",\n        \"pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;\",\n        \"#else\",\n        \"pointSpecular += specular * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance;\",\n        \"#endif\",\n        \"}\",\n        \"#endif\",\n        \"#if MAX_SPOT_LIGHTS > 0\",\n        \"vec3 spotDiffuse  = vec3( 0.0 );\",\n        \"vec3 spotSpecular = vec3( 0.0 );\",\n        \"for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\",\n        \"#ifdef PHONG_PER_PIXEL\",\n        \"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\",\n        \"vec3 lVector = lPosition.xyz + vViewPosition.xyz;\",\n        \"float lDistance = 1.0;\",\n        \"if ( spotLightDistance[ i ] > 0.0 )\",\n        \"lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\",\n        \"lVector = normalize( lVector );\",\n        \"#else\",\n        \"vec3 lVector = normalize( vSpotLight[ i ].xyz );\",\n        \"float lDistance = vSpotLight[ i ].w;\",\n        \"#endif\",\n        \"float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\",\n        \"if ( spotEffect > spotLightAngleCos[ i ] ) {\",\n        \"spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\",\n        // diffuse\n        \"float dotProduct = dot( normal, lVector );\",\n        \"#ifdef WRAP_AROUND\",\n        \"float spotDiffuseWeightFull = max( dotProduct, 0.0 );\",\n        \"float spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\",\n        \"vec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\",\n        \"#else\",\n        \"float spotDiffuseWeight = max( dotProduct, 0.0 );\",\n        \"#endif\",\n        \"spotDiffuse += diffuse * spotLightColor[ i ] * spotDiffuseWeight * lDistance * spotEffect;\",\n        // specular\n        \"vec3 spotHalfVector = normalize( lVector + viewPosition );\",\n        \"float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\",\n        \"float spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );\",\n        \"#ifdef PHYSICALLY_BASED_SHADING\",\n        // 2.0 => 2.0001 is hack to work around ANGLE bug\n        \"float specularNormalization = ( shininess + 2.0001 ) / 8.0;\",\n        \"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, spotHalfVector ), 5.0 );\",\n        \"spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;\",\n        \"#else\",\n        \"spotSpecular += specular * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * spotEffect;\",\n        \"#endif\",\n        \"}\",\n        \"}\",\n        \"#endif\",\n        \"#if MAX_DIR_LIGHTS > 0\",\n        \"vec3 dirDiffuse  = vec3( 0.0 );\",\n        \"vec3 dirSpecular = vec3( 0.0 );\",\n        \"for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\",\n        \"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\",\n        \"vec3 dirVector = normalize( lDirection.xyz );\",\n        // diffuse\n        \"float dotProduct = dot( normal, dirVector );\",\n        \"#ifdef WRAP_AROUND\",\n        \"float dirDiffuseWeightFull = max( dotProduct, 0.0 );\",\n        \"float dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\",\n        \"vec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\",\n        \"#else\",\n        \"float dirDiffuseWeight = max( dotProduct, 0.0 );\",\n        \"#endif\",\n        \"dirDiffuse  += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;\",\n        // specular\n        \"vec3 dirHalfVector = normalize( dirVector + viewPosition );\",\n        \"float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\",\n        \"float dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\",\n        \"#ifdef PHYSICALLY_BASED_SHADING\",\n        /*\n\t\t\t\t\t// fresnel term from skin shader\n\t\t\t\t\t\"const float F0 = 0.128;\",\n\n\t\t\t\t\t\"float base = 1.0 - dot( viewPosition, dirHalfVector );\",\n\t\t\t\t\t\"float exponential = pow( base, 5.0 );\",\n\n\t\t\t\t\t\"float fresnel = exponential + F0 * ( 1.0 - exponential );\",\n\t\t\t\t\t*/ /*\n\t\t\t\t\t// fresnel term from fresnel shader\n\t\t\t\t\t\"const float mFresnelBias = 0.08;\",\n\t\t\t\t\t\"const float mFresnelScale = 0.3;\",\n\t\t\t\t\t\"const float mFresnelPower = 5.0;\",\n\n\t\t\t\t\t\"float fresnel = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( -viewPosition ), normal ), mFresnelPower );\",\n\t\t\t\t\t*/ // 2.0 => 2.0001 is hack to work around ANGLE bug\n        \"float specularNormalization = ( shininess + 2.0001 ) / 8.0;\",\n        //\"dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization * fresnel;\",\n        \"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );\",\n        \"dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\",\n        \"#else\",\n        \"dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight;\",\n        \"#endif\",\n        \"}\",\n        \"#endif\",\n        \"#if MAX_HEMI_LIGHTS > 0\",\n        \"vec3 hemiDiffuse  = vec3( 0.0 );\",\n        \"vec3 hemiSpecular = vec3( 0.0 );\",\n        \"for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\",\n        \"vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\",\n        \"vec3 lVector = normalize( lDirection.xyz );\",\n        // diffuse\n        \"float dotProduct = dot( normal, lVector );\",\n        \"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\",\n        \"vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\",\n        \"hemiDiffuse += diffuse * hemiColor;\",\n        // specular (sky light)\n        \"vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\",\n        \"float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\",\n        \"float hemiSpecularWeightSky = specularStrength * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );\",\n        // specular (ground light)\n        \"vec3 lVectorGround = -lVector;\",\n        \"vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\",\n        \"float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\",\n        \"float hemiSpecularWeightGround = specularStrength * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );\",\n        \"#ifdef PHYSICALLY_BASED_SHADING\",\n        \"float dotProductGround = dot( normal, lVectorGround );\",\n        // 2.0 => 2.0001 is hack to work around ANGLE bug\n        \"float specularNormalization = ( shininess + 2.0001 ) / 8.0;\",\n        \"vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );\",\n        \"vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );\",\n        \"hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\",\n        \"#else\",\n        \"hemiSpecular += specular * hemiColor * ( hemiSpecularWeightSky + hemiSpecularWeightGround ) * hemiDiffuseWeight;\",\n        \"#endif\",\n        \"}\",\n        \"#endif\",\n        \"vec3 totalDiffuse = vec3( 0.0 );\",\n        \"vec3 totalSpecular = vec3( 0.0 );\",\n        \"#if MAX_DIR_LIGHTS > 0\",\n        \"totalDiffuse += dirDiffuse;\",\n        \"totalSpecular += dirSpecular;\",\n        \"#endif\",\n        \"#if MAX_HEMI_LIGHTS > 0\",\n        \"totalDiffuse += hemiDiffuse;\",\n        \"totalSpecular += hemiSpecular;\",\n        \"#endif\",\n        \"#if MAX_POINT_LIGHTS > 0\",\n        \"totalDiffuse += pointDiffuse;\",\n        \"totalSpecular += pointSpecular;\",\n        \"#endif\",\n        \"#if MAX_SPOT_LIGHTS > 0\",\n        \"totalDiffuse += spotDiffuse;\",\n        \"totalSpecular += spotSpecular;\",\n        \"#endif\",\n        \"#ifdef METAL\",\n        \"gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient + totalSpecular );\",\n        \"#else\",\n        \"gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\",\n        \"#endif\"\n    ].join(\"\\n\"),\n    // VERTEX COLORS\n    color_pars_fragment: [\n        \"#ifdef USE_COLOR\",\n        \"varying vec3 vColor;\",\n        \"#endif\"\n    ].join(\"\\n\"),\n    color_fragment: [\n        \"#ifdef USE_COLOR\",\n        \"gl_FragColor = gl_FragColor * vec4( vColor, opacity );\",\n        \"#endif\"\n    ].join(\"\\n\"),\n    color_pars_vertex: [\n        \"#ifdef USE_COLOR\",\n        \"varying vec3 vColor;\",\n        \"#endif\"\n    ].join(\"\\n\"),\n    color_vertex: [\n        \"#ifdef USE_COLOR\",\n        \"#ifdef GAMMA_INPUT\",\n        \"vColor = color * color;\",\n        \"#else\",\n        \"vColor = color;\",\n        \"#endif\",\n        \"#endif\"\n    ].join(\"\\n\"),\n    // SKINNING\n    skinning_pars_vertex: [\n        \"#ifdef USE_SKINNING\",\n        \"#ifdef BONE_TEXTURE\",\n        \"uniform sampler2D boneTexture;\",\n        \"mat4 getBoneMatrix( const in float i ) {\",\n        \"float j = i * 4.0;\",\n        \"float x = mod( j, N_BONE_PIXEL_X );\",\n        \"float y = floor( j / N_BONE_PIXEL_X );\",\n        \"const float dx = 1.0 / N_BONE_PIXEL_X;\",\n        \"const float dy = 1.0 / N_BONE_PIXEL_Y;\",\n        \"y = dy * ( y + 0.5 );\",\n        \"vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\",\n        \"vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\",\n        \"vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\",\n        \"vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\",\n        \"mat4 bone = mat4( v1, v2, v3, v4 );\",\n        \"return bone;\",\n        \"}\",\n        \"#else\",\n        \"uniform mat4 boneGlobalMatrices[ MAX_BONES ];\",\n        \"mat4 getBoneMatrix( const in float i ) {\",\n        \"mat4 bone = boneGlobalMatrices[ int(i) ];\",\n        \"return bone;\",\n        \"}\",\n        \"#endif\",\n        \"#endif\"\n    ].join(\"\\n\"),\n    skinbase_vertex: [\n        \"#ifdef USE_SKINNING\",\n        \"mat4 boneMatX = getBoneMatrix( skinIndex.x );\",\n        \"mat4 boneMatY = getBoneMatrix( skinIndex.y );\",\n        \"#endif\"\n    ].join(\"\\n\"),\n    skinning_vertex: [\n        \"#ifdef USE_SKINNING\",\n        \"#ifdef USE_MORPHTARGETS\",\n        \"vec4 skinVertex = vec4( morphed, 1.0 );\",\n        \"#else\",\n        \"vec4 skinVertex = vec4( position, 1.0 );\",\n        \"#endif\",\n        \"vec4 skinned  = boneMatX * skinVertex * skinWeight.x;\",\n        \"skinned \t  += boneMatY * skinVertex * skinWeight.y;\",\n        \"#endif\"\n    ].join(\"\\n\"),\n    // MORPHING\n    morphtarget_pars_vertex: [\n        \"#ifdef USE_MORPHTARGETS\",\n        \"#ifndef USE_MORPHNORMALS\",\n        \"uniform float morphTargetInfluences[ 8 ];\",\n        \"#else\",\n        \"uniform float morphTargetInfluences[ 4 ];\",\n        \"#endif\",\n        \"#endif\"\n    ].join(\"\\n\"),\n    morphtarget_vertex: [\n        \"#ifdef USE_MORPHTARGETS\",\n        \"vec3 morphed = vec3( 0.0 );\",\n        \"morphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\",\n        \"morphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\",\n        \"morphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\",\n        \"morphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\",\n        \"#ifndef USE_MORPHNORMALS\",\n        \"morphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\",\n        \"morphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\",\n        \"morphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\",\n        \"morphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\",\n        \"#endif\",\n        \"morphed += position;\",\n        \"#endif\"\n    ].join(\"\\n\"),\n    default_vertex: [\n        \"vec4 mvPosition;\",\n        \"#ifdef USE_SKINNING\",\n        \"mvPosition = modelViewMatrix * skinned;\",\n        \"#endif\",\n        \"#if !defined( USE_SKINNING ) && defined( USE_MORPHTARGETS )\",\n        \"mvPosition = modelViewMatrix * vec4( morphed, 1.0 );\",\n        \"#endif\",\n        \"#if !defined( USE_SKINNING ) && ! defined( USE_MORPHTARGETS )\",\n        \"mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\n        \"#endif\",\n        \"gl_Position = projectionMatrix * mvPosition;\"\n    ].join(\"\\n\"),\n    morphnormal_vertex: [\n        \"#ifdef USE_MORPHNORMALS\",\n        \"vec3 morphedNormal = vec3( 0.0 );\",\n        \"morphedNormal +=  ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\",\n        \"morphedNormal +=  ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\",\n        \"morphedNormal +=  ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\",\n        \"morphedNormal +=  ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\",\n        \"morphedNormal += normal;\",\n        \"#endif\"\n    ].join(\"\\n\"),\n    skinnormal_vertex: [\n        \"#ifdef USE_SKINNING\",\n        \"mat4 skinMatrix = skinWeight.x * boneMatX;\",\n        \"skinMatrix \t+= skinWeight.y * boneMatY;\",\n        \"#ifdef USE_MORPHNORMALS\",\n        \"vec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\",\n        \"#else\",\n        \"vec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\",\n        \"#endif\",\n        \"#endif\"\n    ].join(\"\\n\"),\n    defaultnormal_vertex: [\n        \"vec3 objectNormal;\",\n        \"#ifdef USE_SKINNING\",\n        \"objectNormal = skinnedNormal.xyz;\",\n        \"#endif\",\n        \"#if !defined( USE_SKINNING ) && defined( USE_MORPHNORMALS )\",\n        \"objectNormal = morphedNormal;\",\n        \"#endif\",\n        \"#if !defined( USE_SKINNING ) && ! defined( USE_MORPHNORMALS )\",\n        \"objectNormal = normal;\",\n        \"#endif\",\n        \"#ifdef FLIP_SIDED\",\n        \"objectNormal = -objectNormal;\",\n        \"#endif\",\n        \"vec3 transformedNormal = normalMatrix * objectNormal;\"\n    ].join(\"\\n\"),\n    // SHADOW MAP\n    // based on SpiderGL shadow map and Fabien Sanglard's GLSL shadow mapping examples\n    //  http://spidergl.org/example.php?id=6\n    // \thttp://fabiensanglard.net/shadowmapping\n    shadowmap_pars_fragment: [\n        \"#ifdef USE_SHADOWMAP\",\n        \"uniform sampler2D shadowMap[ MAX_SHADOWS ];\",\n        \"uniform vec2 shadowMapSize[ MAX_SHADOWS ];\",\n        \"uniform float shadowDarkness[ MAX_SHADOWS ];\",\n        \"uniform float shadowBias[ MAX_SHADOWS ];\",\n        \"varying vec4 vShadowCoord[ MAX_SHADOWS ];\",\n        \"float unpackDepth( const in vec4 rgba_depth ) {\",\n        \"const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\",\n        \"float depth = dot( rgba_depth, bit_shift );\",\n        \"return depth;\",\n        \"}\",\n        \"#endif\"\n    ].join(\"\\n\"),\n    shadowmap_fragment: [\n        \"#ifdef USE_SHADOWMAP\",\n        \"#ifdef SHADOWMAP_DEBUG\",\n        \"vec3 frustumColors[3];\",\n        \"frustumColors[0] = vec3( 1.0, 0.5, 0.0 );\",\n        \"frustumColors[1] = vec3( 0.0, 1.0, 0.8 );\",\n        \"frustumColors[2] = vec3( 0.0, 0.5, 1.0 );\",\n        \"#endif\",\n        \"#ifdef SHADOWMAP_CASCADE\",\n        \"int inFrustumCount = 0;\",\n        \"#endif\",\n        \"float fDepth;\",\n        \"vec3 shadowColor = vec3( 1.0 );\",\n        \"for( int i = 0; i < MAX_SHADOWS; i ++ ) {\",\n        \"vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\",\n        // \"if ( something && something )\" \t\t breaks ATI OpenGL shader compiler\n        // \"if ( all( something, something ) )\"  using this instead\n        \"bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\",\n        \"bool inFrustum = all( inFrustumVec );\",\n        // don't shadow pixels outside of light frustum\n        // use just first frustum (for cascades)\n        // don't shadow pixels behind far plane of light frustum\n        \"#ifdef SHADOWMAP_CASCADE\",\n        \"inFrustumCount += int( inFrustum );\",\n        \"bvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\",\n        \"#else\",\n        \"bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\",\n        \"#endif\",\n        \"bool frustumTest = all( frustumTestVec );\",\n        \"if ( frustumTest ) {\",\n        \"shadowCoord.z += shadowBias[ i ];\",\n        \"#if defined( SHADOWMAP_TYPE_PCF )\",\n        // Percentage-close filtering\n        // (9 pixel kernel)\n        // http://fabiensanglard.net/shadowmappingPCF/\n        \"float shadow = 0.0;\",\n        /*\n\t\t\t\t\t\t// nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\n\t\t\t\t\t\t// must enroll loop manually\n\n\t\t\t\t\t\t\"for ( float y = -1.25; y <= 1.25; y += 1.25 )\",\n\t\t\t\t\t\t\t\"for ( float x = -1.25; x <= 1.25; x += 1.25 ) {\",\n\n\t\t\t\t\t\t\t\t\"vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\",\n\n\t\t\t\t\t\t\t\t// doesn't seem to produce any noticeable visual difference compared to simple \"texture2D\" lookup\n\t\t\t\t\t\t\t\t//\"vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\",\n\n\t\t\t\t\t\t\t\t\"float fDepth = unpackDepth( rgbaDepth );\",\n\n\t\t\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z )\",\n\t\t\t\t\t\t\t\t\t\"shadow += 1.0;\",\n\n\t\t\t\t\t\t\"}\",\n\n\t\t\t\t\t\t\"shadow /= 9.0;\",\n\n\t\t\t\t\t\t*/ \"const float shadowDelta = 1.0 / 9.0;\",\n        \"float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\",\n        \"float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\",\n        \"float dx0 = -1.25 * xPixelOffset;\",\n        \"float dy0 = -1.25 * yPixelOffset;\",\n        \"float dx1 = 1.25 * xPixelOffset;\",\n        \"float dy1 = 1.25 * yPixelOffset;\",\n        \"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\",\n        \"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\n        \"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\",\n        \"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\n        \"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\",\n        \"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\n        \"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\",\n        \"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\n        \"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\",\n        \"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\n        \"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\",\n        \"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\n        \"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\",\n        \"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\n        \"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\",\n        \"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\n        \"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\",\n        \"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\n        \"shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\",\n        \"#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\",\n        // Percentage-close filtering\n        // (9 pixel kernel)\n        // http://fabiensanglard.net/shadowmappingPCF/\n        \"float shadow = 0.0;\",\n        \"float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\",\n        \"float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\",\n        \"float dx0 = -1.0 * xPixelOffset;\",\n        \"float dy0 = -1.0 * yPixelOffset;\",\n        \"float dx1 = 1.0 * xPixelOffset;\",\n        \"float dy1 = 1.0 * yPixelOffset;\",\n        \"mat3 shadowKernel;\",\n        \"mat3 depthKernel;\",\n        \"depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\",\n        \"if ( depthKernel[0][0] < shadowCoord.z ) shadowKernel[0][0] = 0.25;\",\n        \"else shadowKernel[0][0] = 0.0;\",\n        \"depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\",\n        \"if ( depthKernel[0][1] < shadowCoord.z ) shadowKernel[0][1] = 0.25;\",\n        \"else shadowKernel[0][1] = 0.0;\",\n        \"depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i], shadowCoord.xy + vec2( dx0, dy1 ) ) );\",\n        \"if ( depthKernel[0][2] < shadowCoord.z ) shadowKernel[0][2] = 0.25;\",\n        \"else shadowKernel[0][2] = 0.0;\",\n        \"depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\",\n        \"if ( depthKernel[1][0] < shadowCoord.z ) shadowKernel[1][0] = 0.25;\",\n        \"else shadowKernel[1][0] = 0.0;\",\n        \"depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\",\n        \"if ( depthKernel[1][1] < shadowCoord.z ) shadowKernel[1][1] = 0.25;\",\n        \"else shadowKernel[1][1] = 0.0;\",\n        \"depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\",\n        \"if ( depthKernel[1][2] < shadowCoord.z ) shadowKernel[1][2] = 0.25;\",\n        \"else shadowKernel[1][2] = 0.0;\",\n        \"depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\",\n        \"if ( depthKernel[2][0] < shadowCoord.z ) shadowKernel[2][0] = 0.25;\",\n        \"else shadowKernel[2][0] = 0.0;\",\n        \"depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\",\n        \"if ( depthKernel[2][1] < shadowCoord.z ) shadowKernel[2][1] = 0.25;\",\n        \"else shadowKernel[2][1] = 0.0;\",\n        \"depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\",\n        \"if ( depthKernel[2][2] < shadowCoord.z ) shadowKernel[2][2] = 0.25;\",\n        \"else shadowKernel[2][2] = 0.0;\",\n        \"vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\",\n        \"shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\",\n        \"shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\",\n        \"vec4 shadowValues;\",\n        \"shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\",\n        \"shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\",\n        \"shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\",\n        \"shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\",\n        \"shadow = dot( shadowValues, vec4( 1.0 ) );\",\n        \"shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\",\n        \"#else\",\n        \"vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\",\n        \"float fDepth = unpackDepth( rgbaDepth );\",\n        \"if ( fDepth < shadowCoord.z )\",\n        // spot with multiple shadows is darker\n        \"shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\",\n        // spot with multiple shadows has the same color as single shadow spot\n        //\"shadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );\",\n        \"#endif\",\n        \"}\",\n        \"#ifdef SHADOWMAP_DEBUG\",\n        \"#ifdef SHADOWMAP_CASCADE\",\n        \"if ( inFrustum && inFrustumCount == 1 ) gl_FragColor.xyz *= frustumColors[ i ];\",\n        \"#else\",\n        \"if ( inFrustum ) gl_FragColor.xyz *= frustumColors[ i ];\",\n        \"#endif\",\n        \"#endif\",\n        \"}\",\n        \"#ifdef GAMMA_OUTPUT\",\n        \"shadowColor *= shadowColor;\",\n        \"#endif\",\n        \"gl_FragColor.xyz = gl_FragColor.xyz * shadowColor;\",\n        \"#endif\"\n    ].join(\"\\n\"),\n    shadowmap_pars_vertex: [\n        \"#ifdef USE_SHADOWMAP\",\n        \"varying vec4 vShadowCoord[ MAX_SHADOWS ];\",\n        \"uniform mat4 shadowMatrix[ MAX_SHADOWS ];\",\n        \"#endif\"\n    ].join(\"\\n\"),\n    shadowmap_vertex: [\n        \"#ifdef USE_SHADOWMAP\",\n        \"for( int i = 0; i < MAX_SHADOWS; i ++ ) {\",\n        \"vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\",\n        \"}\",\n        \"#endif\"\n    ].join(\"\\n\"),\n    // ALPHATEST\n    alphatest_fragment: [\n        \"#ifdef ALPHATEST\",\n        \"if ( gl_FragColor.a < ALPHATEST ) discard;\",\n        \"#endif\"\n    ].join(\"\\n\"),\n    // LINEAR SPACE\n    linear_to_gamma_fragment: [\n        \"#ifdef GAMMA_OUTPUT\",\n        \"gl_FragColor.xyz = sqrt( gl_FragColor.xyz );\",\n        \"#endif\"\n    ].join(\"\\n\")\n};\nTHREE.UniformsUtils = {\n    merge: function(uniforms) {\n        var u, p, tmp, merged = {};\n        for(u = 0; u < uniforms.length; u++){\n            tmp = this.clone(uniforms[u]);\n            for(p in tmp)merged[p] = tmp[p];\n        }\n        return merged;\n    },\n    clone: function(uniforms_src) {\n        var u, p, parameter, parameter_src, uniforms_dst = {};\n        for(u in uniforms_src){\n            uniforms_dst[u] = {};\n            for(p in uniforms_src[u]){\n                parameter_src = uniforms_src[u][p];\n                if (parameter_src instanceof THREE.Color || parameter_src instanceof THREE.Vector2 || parameter_src instanceof THREE.Vector3 || parameter_src instanceof THREE.Vector4 || parameter_src instanceof THREE.Matrix4 || parameter_src instanceof THREE.Texture) uniforms_dst[u][p] = parameter_src.clone();\n                else if (parameter_src instanceof Array) uniforms_dst[u][p] = parameter_src.slice();\n                else uniforms_dst[u][p] = parameter_src;\n            }\n        }\n        return uniforms_dst;\n    }\n};\nTHREE.UniformsLib = {\n    common: {\n        \"diffuse\": {\n            type: \"c\",\n            value: new THREE.Color(0xeeeeee)\n        },\n        \"opacity\": {\n            type: \"f\",\n            value: 1.0\n        },\n        \"map\": {\n            type: \"t\",\n            value: null\n        },\n        \"offsetRepeat\": {\n            type: \"v4\",\n            value: new THREE.Vector4(0, 0, 1, 1)\n        },\n        \"lightMap\": {\n            type: \"t\",\n            value: null\n        },\n        \"specularMap\": {\n            type: \"t\",\n            value: null\n        },\n        \"envMap\": {\n            type: \"t\",\n            value: null\n        },\n        \"flipEnvMap\": {\n            type: \"f\",\n            value: -1\n        },\n        \"useRefract\": {\n            type: \"i\",\n            value: 0\n        },\n        \"reflectivity\": {\n            type: \"f\",\n            value: 1.0\n        },\n        \"refractionRatio\": {\n            type: \"f\",\n            value: 0.98\n        },\n        \"combine\": {\n            type: \"i\",\n            value: 0\n        },\n        \"morphTargetInfluences\": {\n            type: \"f\",\n            value: 0\n        }\n    },\n    bump: {\n        \"bumpMap\": {\n            type: \"t\",\n            value: null\n        },\n        \"bumpScale\": {\n            type: \"f\",\n            value: 1\n        }\n    },\n    normalmap: {\n        \"normalMap\": {\n            type: \"t\",\n            value: null\n        },\n        \"normalScale\": {\n            type: \"v2\",\n            value: new THREE.Vector2(1, 1)\n        }\n    },\n    fog: {\n        \"fogDensity\": {\n            type: \"f\",\n            value: 0.00025\n        },\n        \"fogNear\": {\n            type: \"f\",\n            value: 1\n        },\n        \"fogFar\": {\n            type: \"f\",\n            value: 2000\n        },\n        \"fogColor\": {\n            type: \"c\",\n            value: new THREE.Color(0xffffff)\n        }\n    },\n    lights: {\n        \"ambientLightColor\": {\n            type: \"fv\",\n            value: []\n        },\n        \"directionalLightDirection\": {\n            type: \"fv\",\n            value: []\n        },\n        \"directionalLightColor\": {\n            type: \"fv\",\n            value: []\n        },\n        \"hemisphereLightDirection\": {\n            type: \"fv\",\n            value: []\n        },\n        \"hemisphereLightSkyColor\": {\n            type: \"fv\",\n            value: []\n        },\n        \"hemisphereLightGroundColor\": {\n            type: \"fv\",\n            value: []\n        },\n        \"pointLightColor\": {\n            type: \"fv\",\n            value: []\n        },\n        \"pointLightPosition\": {\n            type: \"fv\",\n            value: []\n        },\n        \"pointLightDistance\": {\n            type: \"fv1\",\n            value: []\n        },\n        \"spotLightColor\": {\n            type: \"fv\",\n            value: []\n        },\n        \"spotLightPosition\": {\n            type: \"fv\",\n            value: []\n        },\n        \"spotLightDirection\": {\n            type: \"fv\",\n            value: []\n        },\n        \"spotLightDistance\": {\n            type: \"fv1\",\n            value: []\n        },\n        \"spotLightAngleCos\": {\n            type: \"fv1\",\n            value: []\n        },\n        \"spotLightExponent\": {\n            type: \"fv1\",\n            value: []\n        }\n    },\n    particle: {\n        \"psColor\": {\n            type: \"c\",\n            value: new THREE.Color(0xeeeeee)\n        },\n        \"opacity\": {\n            type: \"f\",\n            value: 1.0\n        },\n        \"size\": {\n            type: \"f\",\n            value: 1.0\n        },\n        \"scale\": {\n            type: \"f\",\n            value: 1.0\n        },\n        \"map\": {\n            type: \"t\",\n            value: null\n        },\n        \"fogDensity\": {\n            type: \"f\",\n            value: 0.00025\n        },\n        \"fogNear\": {\n            type: \"f\",\n            value: 1\n        },\n        \"fogFar\": {\n            type: \"f\",\n            value: 2000\n        },\n        \"fogColor\": {\n            type: \"c\",\n            value: new THREE.Color(0xffffff)\n        }\n    },\n    shadowmap: {\n        \"shadowMap\": {\n            type: \"tv\",\n            value: []\n        },\n        \"shadowMapSize\": {\n            type: \"v2v\",\n            value: []\n        },\n        \"shadowBias\": {\n            type: \"fv1\",\n            value: []\n        },\n        \"shadowDarkness\": {\n            type: \"fv1\",\n            value: []\n        },\n        \"shadowMatrix\": {\n            type: \"m4v\",\n            value: []\n        }\n    }\n};\nTHREE.ShaderLib = {\n    \"basic\": {\n        uniforms: THREE.UniformsUtils.merge([\n            THREE.UniformsLib[\"common\"],\n            THREE.UniformsLib[\"fog\"],\n            THREE.UniformsLib[\"shadowmap\"]\n        ]),\n        vertexShader: [\n            THREE.ShaderChunk[\"map_pars_vertex\"],\n            THREE.ShaderChunk[\"lightmap_pars_vertex\"],\n            THREE.ShaderChunk[\"envmap_pars_vertex\"],\n            THREE.ShaderChunk[\"color_pars_vertex\"],\n            THREE.ShaderChunk[\"morphtarget_pars_vertex\"],\n            THREE.ShaderChunk[\"skinning_pars_vertex\"],\n            THREE.ShaderChunk[\"shadowmap_pars_vertex\"],\n            \"void main() {\",\n            THREE.ShaderChunk[\"map_vertex\"],\n            THREE.ShaderChunk[\"lightmap_vertex\"],\n            THREE.ShaderChunk[\"color_vertex\"],\n            THREE.ShaderChunk[\"skinbase_vertex\"],\n            \"#ifdef USE_ENVMAP\",\n            THREE.ShaderChunk[\"morphnormal_vertex\"],\n            THREE.ShaderChunk[\"skinnormal_vertex\"],\n            THREE.ShaderChunk[\"defaultnormal_vertex\"],\n            \"#endif\",\n            THREE.ShaderChunk[\"morphtarget_vertex\"],\n            THREE.ShaderChunk[\"skinning_vertex\"],\n            THREE.ShaderChunk[\"default_vertex\"],\n            THREE.ShaderChunk[\"worldpos_vertex\"],\n            THREE.ShaderChunk[\"envmap_vertex\"],\n            THREE.ShaderChunk[\"shadowmap_vertex\"],\n            \"}\"\n        ].join(\"\\n\"),\n        fragmentShader: [\n            \"uniform vec3 diffuse;\",\n            \"uniform float opacity;\",\n            THREE.ShaderChunk[\"color_pars_fragment\"],\n            THREE.ShaderChunk[\"map_pars_fragment\"],\n            THREE.ShaderChunk[\"lightmap_pars_fragment\"],\n            THREE.ShaderChunk[\"envmap_pars_fragment\"],\n            THREE.ShaderChunk[\"fog_pars_fragment\"],\n            THREE.ShaderChunk[\"shadowmap_pars_fragment\"],\n            THREE.ShaderChunk[\"specularmap_pars_fragment\"],\n            \"void main() {\",\n            \"gl_FragColor = vec4( diffuse, opacity );\",\n            THREE.ShaderChunk[\"map_fragment\"],\n            THREE.ShaderChunk[\"alphatest_fragment\"],\n            THREE.ShaderChunk[\"specularmap_fragment\"],\n            THREE.ShaderChunk[\"lightmap_fragment\"],\n            THREE.ShaderChunk[\"color_fragment\"],\n            THREE.ShaderChunk[\"envmap_fragment\"],\n            THREE.ShaderChunk[\"shadowmap_fragment\"],\n            THREE.ShaderChunk[\"linear_to_gamma_fragment\"],\n            THREE.ShaderChunk[\"fog_fragment\"],\n            \"}\"\n        ].join(\"\\n\")\n    },\n    \"lambert\": {\n        uniforms: THREE.UniformsUtils.merge([\n            THREE.UniformsLib[\"common\"],\n            THREE.UniformsLib[\"fog\"],\n            THREE.UniformsLib[\"lights\"],\n            THREE.UniformsLib[\"shadowmap\"],\n            {\n                \"ambient\": {\n                    type: \"c\",\n                    value: new THREE.Color(0xffffff)\n                },\n                \"emissive\": {\n                    type: \"c\",\n                    value: new THREE.Color(0x000000)\n                },\n                \"wrapRGB\": {\n                    type: \"v3\",\n                    value: new THREE.Vector3(1, 1, 1)\n                }\n            }\n        ]),\n        vertexShader: [\n            \"#define LAMBERT\",\n            \"varying vec3 vLightFront;\",\n            \"#ifdef DOUBLE_SIDED\",\n            \"varying vec3 vLightBack;\",\n            \"#endif\",\n            THREE.ShaderChunk[\"map_pars_vertex\"],\n            THREE.ShaderChunk[\"lightmap_pars_vertex\"],\n            THREE.ShaderChunk[\"envmap_pars_vertex\"],\n            THREE.ShaderChunk[\"lights_lambert_pars_vertex\"],\n            THREE.ShaderChunk[\"color_pars_vertex\"],\n            THREE.ShaderChunk[\"morphtarget_pars_vertex\"],\n            THREE.ShaderChunk[\"skinning_pars_vertex\"],\n            THREE.ShaderChunk[\"shadowmap_pars_vertex\"],\n            \"void main() {\",\n            THREE.ShaderChunk[\"map_vertex\"],\n            THREE.ShaderChunk[\"lightmap_vertex\"],\n            THREE.ShaderChunk[\"color_vertex\"],\n            THREE.ShaderChunk[\"morphnormal_vertex\"],\n            THREE.ShaderChunk[\"skinbase_vertex\"],\n            THREE.ShaderChunk[\"skinnormal_vertex\"],\n            THREE.ShaderChunk[\"defaultnormal_vertex\"],\n            THREE.ShaderChunk[\"morphtarget_vertex\"],\n            THREE.ShaderChunk[\"skinning_vertex\"],\n            THREE.ShaderChunk[\"default_vertex\"],\n            THREE.ShaderChunk[\"worldpos_vertex\"],\n            THREE.ShaderChunk[\"envmap_vertex\"],\n            THREE.ShaderChunk[\"lights_lambert_vertex\"],\n            THREE.ShaderChunk[\"shadowmap_vertex\"],\n            \"}\"\n        ].join(\"\\n\"),\n        fragmentShader: [\n            \"uniform float opacity;\",\n            \"varying vec3 vLightFront;\",\n            \"#ifdef DOUBLE_SIDED\",\n            \"varying vec3 vLightBack;\",\n            \"#endif\",\n            THREE.ShaderChunk[\"color_pars_fragment\"],\n            THREE.ShaderChunk[\"map_pars_fragment\"],\n            THREE.ShaderChunk[\"lightmap_pars_fragment\"],\n            THREE.ShaderChunk[\"envmap_pars_fragment\"],\n            THREE.ShaderChunk[\"fog_pars_fragment\"],\n            THREE.ShaderChunk[\"shadowmap_pars_fragment\"],\n            THREE.ShaderChunk[\"specularmap_pars_fragment\"],\n            \"void main() {\",\n            \"gl_FragColor = vec4( vec3 ( 1.0 ), opacity );\",\n            THREE.ShaderChunk[\"map_fragment\"],\n            THREE.ShaderChunk[\"alphatest_fragment\"],\n            THREE.ShaderChunk[\"specularmap_fragment\"],\n            \"#ifdef DOUBLE_SIDED\",\n            //\"float isFront = float( gl_FrontFacing );\",\n            //\"gl_FragColor.xyz *= isFront * vLightFront + ( 1.0 - isFront ) * vLightBack;\",\n            \"if ( gl_FrontFacing )\",\n            \"gl_FragColor.xyz *= vLightFront;\",\n            \"else\",\n            \"gl_FragColor.xyz *= vLightBack;\",\n            \"#else\",\n            \"gl_FragColor.xyz *= vLightFront;\",\n            \"#endif\",\n            THREE.ShaderChunk[\"lightmap_fragment\"],\n            THREE.ShaderChunk[\"color_fragment\"],\n            THREE.ShaderChunk[\"envmap_fragment\"],\n            THREE.ShaderChunk[\"shadowmap_fragment\"],\n            THREE.ShaderChunk[\"linear_to_gamma_fragment\"],\n            THREE.ShaderChunk[\"fog_fragment\"],\n            \"}\"\n        ].join(\"\\n\")\n    },\n    \"phong\": {\n        uniforms: THREE.UniformsUtils.merge([\n            THREE.UniformsLib[\"common\"],\n            THREE.UniformsLib[\"bump\"],\n            THREE.UniformsLib[\"normalmap\"],\n            THREE.UniformsLib[\"fog\"],\n            THREE.UniformsLib[\"lights\"],\n            THREE.UniformsLib[\"shadowmap\"],\n            {\n                \"ambient\": {\n                    type: \"c\",\n                    value: new THREE.Color(0xffffff)\n                },\n                \"emissive\": {\n                    type: \"c\",\n                    value: new THREE.Color(0x000000)\n                },\n                \"specular\": {\n                    type: \"c\",\n                    value: new THREE.Color(0x111111)\n                },\n                \"shininess\": {\n                    type: \"f\",\n                    value: 30\n                },\n                \"wrapRGB\": {\n                    type: \"v3\",\n                    value: new THREE.Vector3(1, 1, 1)\n                }\n            }\n        ]),\n        vertexShader: [\n            \"#define PHONG\",\n            \"varying vec3 vViewPosition;\",\n            \"varying vec3 vNormal;\",\n            THREE.ShaderChunk[\"map_pars_vertex\"],\n            THREE.ShaderChunk[\"lightmap_pars_vertex\"],\n            THREE.ShaderChunk[\"envmap_pars_vertex\"],\n            THREE.ShaderChunk[\"lights_phong_pars_vertex\"],\n            THREE.ShaderChunk[\"color_pars_vertex\"],\n            THREE.ShaderChunk[\"morphtarget_pars_vertex\"],\n            THREE.ShaderChunk[\"skinning_pars_vertex\"],\n            THREE.ShaderChunk[\"shadowmap_pars_vertex\"],\n            \"void main() {\",\n            THREE.ShaderChunk[\"map_vertex\"],\n            THREE.ShaderChunk[\"lightmap_vertex\"],\n            THREE.ShaderChunk[\"color_vertex\"],\n            THREE.ShaderChunk[\"morphnormal_vertex\"],\n            THREE.ShaderChunk[\"skinbase_vertex\"],\n            THREE.ShaderChunk[\"skinnormal_vertex\"],\n            THREE.ShaderChunk[\"defaultnormal_vertex\"],\n            \"vNormal = normalize( transformedNormal );\",\n            THREE.ShaderChunk[\"morphtarget_vertex\"],\n            THREE.ShaderChunk[\"skinning_vertex\"],\n            THREE.ShaderChunk[\"default_vertex\"],\n            \"vViewPosition = -mvPosition.xyz;\",\n            THREE.ShaderChunk[\"worldpos_vertex\"],\n            THREE.ShaderChunk[\"envmap_vertex\"],\n            THREE.ShaderChunk[\"lights_phong_vertex\"],\n            THREE.ShaderChunk[\"shadowmap_vertex\"],\n            \"}\"\n        ].join(\"\\n\"),\n        fragmentShader: [\n            \"uniform vec3 diffuse;\",\n            \"uniform float opacity;\",\n            \"uniform vec3 ambient;\",\n            \"uniform vec3 emissive;\",\n            \"uniform vec3 specular;\",\n            \"uniform float shininess;\",\n            THREE.ShaderChunk[\"color_pars_fragment\"],\n            THREE.ShaderChunk[\"map_pars_fragment\"],\n            THREE.ShaderChunk[\"lightmap_pars_fragment\"],\n            THREE.ShaderChunk[\"envmap_pars_fragment\"],\n            THREE.ShaderChunk[\"fog_pars_fragment\"],\n            THREE.ShaderChunk[\"lights_phong_pars_fragment\"],\n            THREE.ShaderChunk[\"shadowmap_pars_fragment\"],\n            THREE.ShaderChunk[\"bumpmap_pars_fragment\"],\n            THREE.ShaderChunk[\"normalmap_pars_fragment\"],\n            THREE.ShaderChunk[\"specularmap_pars_fragment\"],\n            \"void main() {\",\n            \"gl_FragColor = vec4( vec3 ( 1.0 ), opacity );\",\n            THREE.ShaderChunk[\"map_fragment\"],\n            THREE.ShaderChunk[\"alphatest_fragment\"],\n            THREE.ShaderChunk[\"specularmap_fragment\"],\n            THREE.ShaderChunk[\"lights_phong_fragment\"],\n            THREE.ShaderChunk[\"lightmap_fragment\"],\n            THREE.ShaderChunk[\"color_fragment\"],\n            THREE.ShaderChunk[\"envmap_fragment\"],\n            THREE.ShaderChunk[\"shadowmap_fragment\"],\n            THREE.ShaderChunk[\"linear_to_gamma_fragment\"],\n            THREE.ShaderChunk[\"fog_fragment\"],\n            \"}\"\n        ].join(\"\\n\")\n    },\n    \"particle_basic\": {\n        uniforms: THREE.UniformsUtils.merge([\n            THREE.UniformsLib[\"particle\"],\n            THREE.UniformsLib[\"shadowmap\"]\n        ]),\n        vertexShader: [\n            \"uniform float size;\",\n            \"uniform float scale;\",\n            THREE.ShaderChunk[\"color_pars_vertex\"],\n            THREE.ShaderChunk[\"shadowmap_pars_vertex\"],\n            \"void main() {\",\n            THREE.ShaderChunk[\"color_vertex\"],\n            \"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\n            \"#ifdef USE_SIZEATTENUATION\",\n            \"gl_PointSize = size * ( scale / length( mvPosition.xyz ) );\",\n            \"#else\",\n            \"gl_PointSize = size;\",\n            \"#endif\",\n            \"gl_Position = projectionMatrix * mvPosition;\",\n            THREE.ShaderChunk[\"worldpos_vertex\"],\n            THREE.ShaderChunk[\"shadowmap_vertex\"],\n            \"}\"\n        ].join(\"\\n\"),\n        fragmentShader: [\n            \"uniform vec3 psColor;\",\n            \"uniform float opacity;\",\n            THREE.ShaderChunk[\"color_pars_fragment\"],\n            THREE.ShaderChunk[\"map_particle_pars_fragment\"],\n            THREE.ShaderChunk[\"fog_pars_fragment\"],\n            THREE.ShaderChunk[\"shadowmap_pars_fragment\"],\n            \"void main() {\",\n            \"gl_FragColor = vec4( psColor, opacity );\",\n            THREE.ShaderChunk[\"map_particle_fragment\"],\n            THREE.ShaderChunk[\"alphatest_fragment\"],\n            THREE.ShaderChunk[\"color_fragment\"],\n            THREE.ShaderChunk[\"shadowmap_fragment\"],\n            THREE.ShaderChunk[\"fog_fragment\"],\n            \"}\"\n        ].join(\"\\n\")\n    },\n    \"dashed\": {\n        uniforms: THREE.UniformsUtils.merge([\n            THREE.UniformsLib[\"common\"],\n            THREE.UniformsLib[\"fog\"],\n            {\n                \"scale\": {\n                    type: \"f\",\n                    value: 1\n                },\n                \"dashSize\": {\n                    type: \"f\",\n                    value: 1\n                },\n                \"totalSize\": {\n                    type: \"f\",\n                    value: 2\n                }\n            }\n        ]),\n        vertexShader: [\n            \"uniform float scale;\",\n            \"attribute float lineDistance;\",\n            \"varying float vLineDistance;\",\n            THREE.ShaderChunk[\"color_pars_vertex\"],\n            \"void main() {\",\n            THREE.ShaderChunk[\"color_vertex\"],\n            \"vLineDistance = scale * lineDistance;\",\n            \"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\n            \"gl_Position = projectionMatrix * mvPosition;\",\n            \"}\"\n        ].join(\"\\n\"),\n        fragmentShader: [\n            \"uniform vec3 diffuse;\",\n            \"uniform float opacity;\",\n            \"uniform float dashSize;\",\n            \"uniform float totalSize;\",\n            \"varying float vLineDistance;\",\n            THREE.ShaderChunk[\"color_pars_fragment\"],\n            THREE.ShaderChunk[\"fog_pars_fragment\"],\n            \"void main() {\",\n            \"if ( mod( vLineDistance, totalSize ) > dashSize ) {\",\n            \"discard;\",\n            \"}\",\n            \"gl_FragColor = vec4( diffuse, opacity );\",\n            THREE.ShaderChunk[\"color_fragment\"],\n            THREE.ShaderChunk[\"fog_fragment\"],\n            \"}\"\n        ].join(\"\\n\")\n    },\n    \"depth\": {\n        uniforms: {\n            \"mNear\": {\n                type: \"f\",\n                value: 1.0\n            },\n            \"mFar\": {\n                type: \"f\",\n                value: 2000.0\n            },\n            \"opacity\": {\n                type: \"f\",\n                value: 1.0\n            }\n        },\n        vertexShader: [\n            \"void main() {\",\n            \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n            \"}\"\n        ].join(\"\\n\"),\n        fragmentShader: [\n            \"uniform float mNear;\",\n            \"uniform float mFar;\",\n            \"uniform float opacity;\",\n            \"void main() {\",\n            \"float depth = gl_FragCoord.z / gl_FragCoord.w;\",\n            \"float color = 1.0 - smoothstep( mNear, mFar, depth );\",\n            \"gl_FragColor = vec4( vec3( color ), opacity );\",\n            \"}\"\n        ].join(\"\\n\")\n    },\n    \"normal\": {\n        uniforms: {\n            \"opacity\": {\n                type: \"f\",\n                value: 1.0\n            }\n        },\n        vertexShader: [\n            \"varying vec3 vNormal;\",\n            \"void main() {\",\n            \"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\n            \"vNormal = normalize( normalMatrix * normal );\",\n            \"gl_Position = projectionMatrix * mvPosition;\",\n            \"}\"\n        ].join(\"\\n\"),\n        fragmentShader: [\n            \"uniform float opacity;\",\n            \"varying vec3 vNormal;\",\n            \"void main() {\",\n            \"gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );\",\n            \"}\"\n        ].join(\"\\n\")\n    },\n    /* -------------------------------------------------------------------------\n\t//\tNormal map shader\n\t//\t\t- Blinn-Phong\n\t//\t\t- normal + diffuse + specular + AO + displacement + reflection + shadow maps\n\t//\t\t- point and directional lights (use with \"lights: true\" material option)\n\t ------------------------------------------------------------------------- */ \"normalmap\": {\n        uniforms: THREE.UniformsUtils.merge([\n            THREE.UniformsLib[\"fog\"],\n            THREE.UniformsLib[\"lights\"],\n            THREE.UniformsLib[\"shadowmap\"],\n            {\n                \"enableAO\": {\n                    type: \"i\",\n                    value: 0\n                },\n                \"enableDiffuse\": {\n                    type: \"i\",\n                    value: 0\n                },\n                \"enableSpecular\": {\n                    type: \"i\",\n                    value: 0\n                },\n                \"enableReflection\": {\n                    type: \"i\",\n                    value: 0\n                },\n                \"enableDisplacement\": {\n                    type: \"i\",\n                    value: 0\n                },\n                \"tDisplacement\": {\n                    type: \"t\",\n                    value: null\n                },\n                \"tDiffuse\": {\n                    type: \"t\",\n                    value: null\n                },\n                \"tCube\": {\n                    type: \"t\",\n                    value: null\n                },\n                \"tNormal\": {\n                    type: \"t\",\n                    value: null\n                },\n                \"tSpecular\": {\n                    type: \"t\",\n                    value: null\n                },\n                \"tAO\": {\n                    type: \"t\",\n                    value: null\n                },\n                \"uNormalScale\": {\n                    type: \"v2\",\n                    value: new THREE.Vector2(1, 1)\n                },\n                \"uDisplacementBias\": {\n                    type: \"f\",\n                    value: 0.0\n                },\n                \"uDisplacementScale\": {\n                    type: \"f\",\n                    value: 1.0\n                },\n                \"uDiffuseColor\": {\n                    type: \"c\",\n                    value: new THREE.Color(0xffffff)\n                },\n                \"uSpecularColor\": {\n                    type: \"c\",\n                    value: new THREE.Color(0x111111)\n                },\n                \"uAmbientColor\": {\n                    type: \"c\",\n                    value: new THREE.Color(0xffffff)\n                },\n                \"uShininess\": {\n                    type: \"f\",\n                    value: 30\n                },\n                \"uOpacity\": {\n                    type: \"f\",\n                    value: 1\n                },\n                \"useRefract\": {\n                    type: \"i\",\n                    value: 0\n                },\n                \"uRefractionRatio\": {\n                    type: \"f\",\n                    value: 0.98\n                },\n                \"uReflectivity\": {\n                    type: \"f\",\n                    value: 0.5\n                },\n                \"uOffset\": {\n                    type: \"v2\",\n                    value: new THREE.Vector2(0, 0)\n                },\n                \"uRepeat\": {\n                    type: \"v2\",\n                    value: new THREE.Vector2(1, 1)\n                },\n                \"wrapRGB\": {\n                    type: \"v3\",\n                    value: new THREE.Vector3(1, 1, 1)\n                }\n            }\n        ]),\n        fragmentShader: [\n            \"uniform vec3 uAmbientColor;\",\n            \"uniform vec3 uDiffuseColor;\",\n            \"uniform vec3 uSpecularColor;\",\n            \"uniform float uShininess;\",\n            \"uniform float uOpacity;\",\n            \"uniform bool enableDiffuse;\",\n            \"uniform bool enableSpecular;\",\n            \"uniform bool enableAO;\",\n            \"uniform bool enableReflection;\",\n            \"uniform sampler2D tDiffuse;\",\n            \"uniform sampler2D tNormal;\",\n            \"uniform sampler2D tSpecular;\",\n            \"uniform sampler2D tAO;\",\n            \"uniform samplerCube tCube;\",\n            \"uniform vec2 uNormalScale;\",\n            \"uniform bool useRefract;\",\n            \"uniform float uRefractionRatio;\",\n            \"uniform float uReflectivity;\",\n            \"varying vec3 vTangent;\",\n            \"varying vec3 vBinormal;\",\n            \"varying vec3 vNormal;\",\n            \"varying vec2 vUv;\",\n            \"uniform vec3 ambientLightColor;\",\n            \"#if MAX_DIR_LIGHTS > 0\",\n            \"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\",\n            \"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\",\n            \"#endif\",\n            \"#if MAX_HEMI_LIGHTS > 0\",\n            \"uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\",\n            \"uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\",\n            \"uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\",\n            \"#endif\",\n            \"#if MAX_POINT_LIGHTS > 0\",\n            \"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\",\n            \"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\",\n            \"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\",\n            \"#endif\",\n            \"#if MAX_SPOT_LIGHTS > 0\",\n            \"uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\",\n            \"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\",\n            \"uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\",\n            \"uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\",\n            \"uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\",\n            \"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\",\n            \"#endif\",\n            \"#ifdef WRAP_AROUND\",\n            \"uniform vec3 wrapRGB;\",\n            \"#endif\",\n            \"varying vec3 vWorldPosition;\",\n            \"varying vec3 vViewPosition;\",\n            THREE.ShaderChunk[\"shadowmap_pars_fragment\"],\n            THREE.ShaderChunk[\"fog_pars_fragment\"],\n            \"void main() {\",\n            \"gl_FragColor = vec4( vec3( 1.0 ), uOpacity );\",\n            \"vec3 specularTex = vec3( 1.0 );\",\n            \"vec3 normalTex = texture2D( tNormal, vUv ).xyz * 2.0 - 1.0;\",\n            \"normalTex.xy *= uNormalScale;\",\n            \"normalTex = normalize( normalTex );\",\n            \"if( enableDiffuse ) {\",\n            \"#ifdef GAMMA_INPUT\",\n            \"vec4 texelColor = texture2D( tDiffuse, vUv );\",\n            \"texelColor.xyz *= texelColor.xyz;\",\n            \"gl_FragColor = gl_FragColor * texelColor;\",\n            \"#else\",\n            \"gl_FragColor = gl_FragColor * texture2D( tDiffuse, vUv );\",\n            \"#endif\",\n            \"}\",\n            \"if( enableAO ) {\",\n            \"#ifdef GAMMA_INPUT\",\n            \"vec4 aoColor = texture2D( tAO, vUv );\",\n            \"aoColor.xyz *= aoColor.xyz;\",\n            \"gl_FragColor.xyz = gl_FragColor.xyz * aoColor.xyz;\",\n            \"#else\",\n            \"gl_FragColor.xyz = gl_FragColor.xyz * texture2D( tAO, vUv ).xyz;\",\n            \"#endif\",\n            \"}\",\n            \"if( enableSpecular )\",\n            \"specularTex = texture2D( tSpecular, vUv ).xyz;\",\n            \"mat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normalize( vNormal ) );\",\n            \"vec3 finalNormal = tsb * normalTex;\",\n            \"#ifdef FLIP_SIDED\",\n            \"finalNormal = -finalNormal;\",\n            \"#endif\",\n            \"vec3 normal = normalize( finalNormal );\",\n            \"vec3 viewPosition = normalize( vViewPosition );\",\n            // point lights\n            \"#if MAX_POINT_LIGHTS > 0\",\n            \"vec3 pointDiffuse = vec3( 0.0 );\",\n            \"vec3 pointSpecular = vec3( 0.0 );\",\n            \"for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\",\n            \"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\",\n            \"vec3 pointVector = lPosition.xyz + vViewPosition.xyz;\",\n            \"float pointDistance = 1.0;\",\n            \"if ( pointLightDistance[ i ] > 0.0 )\",\n            \"pointDistance = 1.0 - min( ( length( pointVector ) / pointLightDistance[ i ] ), 1.0 );\",\n            \"pointVector = normalize( pointVector );\",\n            // diffuse\n            \"#ifdef WRAP_AROUND\",\n            \"float pointDiffuseWeightFull = max( dot( normal, pointVector ), 0.0 );\",\n            \"float pointDiffuseWeightHalf = max( 0.5 * dot( normal, pointVector ) + 0.5, 0.0 );\",\n            \"vec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\",\n            \"#else\",\n            \"float pointDiffuseWeight = max( dot( normal, pointVector ), 0.0 );\",\n            \"#endif\",\n            \"pointDiffuse += pointDistance * pointLightColor[ i ] * uDiffuseColor * pointDiffuseWeight;\",\n            // specular\n            \"vec3 pointHalfVector = normalize( pointVector + viewPosition );\",\n            \"float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\",\n            \"float pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, uShininess ), 0.0 );\",\n            \"#ifdef PHYSICALLY_BASED_SHADING\",\n            // 2.0 => 2.0001 is hack to work around ANGLE bug\n            \"float specularNormalization = ( uShininess + 2.0001 ) / 8.0;\",\n            \"vec3 schlick = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( pointVector, pointHalfVector ), 5.0 );\",\n            \"pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * pointDistance * specularNormalization;\",\n            \"#else\",\n            \"pointSpecular += pointDistance * pointLightColor[ i ] * uSpecularColor * pointSpecularWeight * pointDiffuseWeight;\",\n            \"#endif\",\n            \"}\",\n            \"#endif\",\n            // spot lights\n            \"#if MAX_SPOT_LIGHTS > 0\",\n            \"vec3 spotDiffuse = vec3( 0.0 );\",\n            \"vec3 spotSpecular = vec3( 0.0 );\",\n            \"for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\",\n            \"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\",\n            \"vec3 spotVector = lPosition.xyz + vViewPosition.xyz;\",\n            \"float spotDistance = 1.0;\",\n            \"if ( spotLightDistance[ i ] > 0.0 )\",\n            \"spotDistance = 1.0 - min( ( length( spotVector ) / spotLightDistance[ i ] ), 1.0 );\",\n            \"spotVector = normalize( spotVector );\",\n            \"float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\",\n            \"if ( spotEffect > spotLightAngleCos[ i ] ) {\",\n            \"spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\",\n            // diffuse\n            \"#ifdef WRAP_AROUND\",\n            \"float spotDiffuseWeightFull = max( dot( normal, spotVector ), 0.0 );\",\n            \"float spotDiffuseWeightHalf = max( 0.5 * dot( normal, spotVector ) + 0.5, 0.0 );\",\n            \"vec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\",\n            \"#else\",\n            \"float spotDiffuseWeight = max( dot( normal, spotVector ), 0.0 );\",\n            \"#endif\",\n            \"spotDiffuse += spotDistance * spotLightColor[ i ] * uDiffuseColor * spotDiffuseWeight * spotEffect;\",\n            // specular\n            \"vec3 spotHalfVector = normalize( spotVector + viewPosition );\",\n            \"float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\",\n            \"float spotSpecularWeight = specularTex.r * max( pow( spotDotNormalHalf, uShininess ), 0.0 );\",\n            \"#ifdef PHYSICALLY_BASED_SHADING\",\n            // 2.0 => 2.0001 is hack to work around ANGLE bug\n            \"float specularNormalization = ( uShininess + 2.0001 ) / 8.0;\",\n            \"vec3 schlick = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( spotVector, spotHalfVector ), 5.0 );\",\n            \"spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * spotDistance * specularNormalization * spotEffect;\",\n            \"#else\",\n            \"spotSpecular += spotDistance * spotLightColor[ i ] * uSpecularColor * spotSpecularWeight * spotDiffuseWeight * spotEffect;\",\n            \"#endif\",\n            \"}\",\n            \"}\",\n            \"#endif\",\n            // directional lights\n            \"#if MAX_DIR_LIGHTS > 0\",\n            \"vec3 dirDiffuse = vec3( 0.0 );\",\n            \"vec3 dirSpecular = vec3( 0.0 );\",\n            \"for( int i = 0; i < MAX_DIR_LIGHTS; i++ ) {\",\n            \"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\",\n            \"vec3 dirVector = normalize( lDirection.xyz );\",\n            // diffuse\n            \"#ifdef WRAP_AROUND\",\n            \"float directionalLightWeightingFull = max( dot( normal, dirVector ), 0.0 );\",\n            \"float directionalLightWeightingHalf = max( 0.5 * dot( normal, dirVector ) + 0.5, 0.0 );\",\n            \"vec3 dirDiffuseWeight = mix( vec3( directionalLightWeightingFull ), vec3( directionalLightWeightingHalf ), wrapRGB );\",\n            \"#else\",\n            \"float dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );\",\n            \"#endif\",\n            \"dirDiffuse += directionalLightColor[ i ] * uDiffuseColor * dirDiffuseWeight;\",\n            // specular\n            \"vec3 dirHalfVector = normalize( dirVector + viewPosition );\",\n            \"float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\",\n            \"float dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, uShininess ), 0.0 );\",\n            \"#ifdef PHYSICALLY_BASED_SHADING\",\n            // 2.0 => 2.0001 is hack to work around ANGLE bug\n            \"float specularNormalization = ( uShininess + 2.0001 ) / 8.0;\",\n            \"vec3 schlick = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );\",\n            \"dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\",\n            \"#else\",\n            \"dirSpecular += directionalLightColor[ i ] * uSpecularColor * dirSpecularWeight * dirDiffuseWeight;\",\n            \"#endif\",\n            \"}\",\n            \"#endif\",\n            // hemisphere lights\n            \"#if MAX_HEMI_LIGHTS > 0\",\n            \"vec3 hemiDiffuse  = vec3( 0.0 );\",\n            \"vec3 hemiSpecular = vec3( 0.0 );\",\n            \"for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\",\n            \"vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\",\n            \"vec3 lVector = normalize( lDirection.xyz );\",\n            // diffuse\n            \"float dotProduct = dot( normal, lVector );\",\n            \"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\",\n            \"vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\",\n            \"hemiDiffuse += uDiffuseColor * hemiColor;\",\n            // specular (sky light)\n            \"vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\",\n            \"float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\",\n            \"float hemiSpecularWeightSky = specularTex.r * max( pow( hemiDotNormalHalfSky, uShininess ), 0.0 );\",\n            // specular (ground light)\n            \"vec3 lVectorGround = -lVector;\",\n            \"vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\",\n            \"float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\",\n            \"float hemiSpecularWeightGround = specularTex.r * max( pow( hemiDotNormalHalfGround, uShininess ), 0.0 );\",\n            \"#ifdef PHYSICALLY_BASED_SHADING\",\n            \"float dotProductGround = dot( normal, lVectorGround );\",\n            // 2.0 => 2.0001 is hack to work around ANGLE bug\n            \"float specularNormalization = ( uShininess + 2.0001 ) / 8.0;\",\n            \"vec3 schlickSky = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );\",\n            \"vec3 schlickGround = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );\",\n            \"hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\",\n            \"#else\",\n            \"hemiSpecular += uSpecularColor * hemiColor * ( hemiSpecularWeightSky + hemiSpecularWeightGround ) * hemiDiffuseWeight;\",\n            \"#endif\",\n            \"}\",\n            \"#endif\",\n            // all lights contribution summation\n            \"vec3 totalDiffuse = vec3( 0.0 );\",\n            \"vec3 totalSpecular = vec3( 0.0 );\",\n            \"#if MAX_DIR_LIGHTS > 0\",\n            \"totalDiffuse += dirDiffuse;\",\n            \"totalSpecular += dirSpecular;\",\n            \"#endif\",\n            \"#if MAX_HEMI_LIGHTS > 0\",\n            \"totalDiffuse += hemiDiffuse;\",\n            \"totalSpecular += hemiSpecular;\",\n            \"#endif\",\n            \"#if MAX_POINT_LIGHTS > 0\",\n            \"totalDiffuse += pointDiffuse;\",\n            \"totalSpecular += pointSpecular;\",\n            \"#endif\",\n            \"#if MAX_SPOT_LIGHTS > 0\",\n            \"totalDiffuse += spotDiffuse;\",\n            \"totalSpecular += spotSpecular;\",\n            \"#endif\",\n            \"#ifdef METAL\",\n            \"gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * uAmbientColor + totalSpecular );\",\n            \"#else\",\n            \"gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * uAmbientColor ) + totalSpecular;\",\n            \"#endif\",\n            \"if ( enableReflection ) {\",\n            \"vec3 vReflect;\",\n            \"vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\",\n            \"if ( useRefract ) {\",\n            \"vReflect = refract( cameraToVertex, normal, uRefractionRatio );\",\n            \"} else {\",\n            \"vReflect = reflect( cameraToVertex, normal );\",\n            \"}\",\n            \"vec4 cubeColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );\",\n            \"#ifdef GAMMA_INPUT\",\n            \"cubeColor.xyz *= cubeColor.xyz;\",\n            \"#endif\",\n            \"gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularTex.r * uReflectivity );\",\n            \"}\",\n            THREE.ShaderChunk[\"shadowmap_fragment\"],\n            THREE.ShaderChunk[\"linear_to_gamma_fragment\"],\n            THREE.ShaderChunk[\"fog_fragment\"],\n            \"}\"\n        ].join(\"\\n\"),\n        vertexShader: [\n            \"attribute vec4 tangent;\",\n            \"uniform vec2 uOffset;\",\n            \"uniform vec2 uRepeat;\",\n            \"uniform bool enableDisplacement;\",\n            \"#ifdef VERTEX_TEXTURES\",\n            \"uniform sampler2D tDisplacement;\",\n            \"uniform float uDisplacementScale;\",\n            \"uniform float uDisplacementBias;\",\n            \"#endif\",\n            \"varying vec3 vTangent;\",\n            \"varying vec3 vBinormal;\",\n            \"varying vec3 vNormal;\",\n            \"varying vec2 vUv;\",\n            \"varying vec3 vWorldPosition;\",\n            \"varying vec3 vViewPosition;\",\n            THREE.ShaderChunk[\"skinning_pars_vertex\"],\n            THREE.ShaderChunk[\"shadowmap_pars_vertex\"],\n            \"void main() {\",\n            THREE.ShaderChunk[\"skinbase_vertex\"],\n            THREE.ShaderChunk[\"skinnormal_vertex\"],\n            // normal, tangent and binormal vectors\n            \"#ifdef USE_SKINNING\",\n            \"vNormal = normalize( normalMatrix * skinnedNormal.xyz );\",\n            \"vec4 skinnedTangent = skinMatrix * vec4( tangent.xyz, 0.0 );\",\n            \"vTangent = normalize( normalMatrix * skinnedTangent.xyz );\",\n            \"#else\",\n            \"vNormal = normalize( normalMatrix * normal );\",\n            \"vTangent = normalize( normalMatrix * tangent.xyz );\",\n            \"#endif\",\n            \"vBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );\",\n            \"vUv = uv * uRepeat + uOffset;\",\n            // displacement mapping\n            \"vec3 displacedPosition;\",\n            \"#ifdef VERTEX_TEXTURES\",\n            \"if ( enableDisplacement ) {\",\n            \"vec3 dv = texture2D( tDisplacement, uv ).xyz;\",\n            \"float df = uDisplacementScale * dv.x + uDisplacementBias;\",\n            \"displacedPosition = position + normalize( normal ) * df;\",\n            \"} else {\",\n            \"#ifdef USE_SKINNING\",\n            \"vec4 skinVertex = vec4( position, 1.0 );\",\n            \"vec4 skinned  = boneMatX * skinVertex * skinWeight.x;\",\n            \"skinned \t  += boneMatY * skinVertex * skinWeight.y;\",\n            \"displacedPosition  = skinned.xyz;\",\n            \"#else\",\n            \"displacedPosition = position;\",\n            \"#endif\",\n            \"}\",\n            \"#else\",\n            \"#ifdef USE_SKINNING\",\n            \"vec4 skinVertex = vec4( position, 1.0 );\",\n            \"vec4 skinned  = boneMatX * skinVertex * skinWeight.x;\",\n            \"skinned \t  += boneMatY * skinVertex * skinWeight.y;\",\n            \"displacedPosition  = skinned.xyz;\",\n            \"#else\",\n            \"displacedPosition = position;\",\n            \"#endif\",\n            \"#endif\",\n            //\n            \"vec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );\",\n            \"vec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );\",\n            \"gl_Position = projectionMatrix * mvPosition;\",\n            //\n            \"vWorldPosition = worldPosition.xyz;\",\n            \"vViewPosition = -mvPosition.xyz;\",\n            // shadows\n            \"#ifdef USE_SHADOWMAP\",\n            \"for( int i = 0; i < MAX_SHADOWS; i ++ ) {\",\n            \"vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\",\n            \"}\",\n            \"#endif\",\n            \"}\"\n        ].join(\"\\n\")\n    },\n    /* -------------------------------------------------------------------------\n\t//\tCube map shader\n\t ------------------------------------------------------------------------- */ \"cube\": {\n        uniforms: {\n            \"tCube\": {\n                type: \"t\",\n                value: null\n            },\n            \"tFlip\": {\n                type: \"f\",\n                value: -1\n            }\n        },\n        vertexShader: [\n            \"varying vec3 vWorldPosition;\",\n            \"void main() {\",\n            \"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\",\n            \"vWorldPosition = worldPosition.xyz;\",\n            \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n            \"}\"\n        ].join(\"\\n\"),\n        fragmentShader: [\n            \"uniform samplerCube tCube;\",\n            \"uniform float tFlip;\",\n            \"varying vec3 vWorldPosition;\",\n            \"void main() {\",\n            \"gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\",\n            \"}\"\n        ].join(\"\\n\")\n    },\n    // Depth encoding into RGBA texture\n    // \tbased on SpiderGL shadow map example\n    // \t\thttp://spidergl.org/example.php?id=6\n    // \toriginally from\n    //\t\thttp://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD\n    // \tsee also here:\n    //\t\thttp://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\n    \"depthRGBA\": {\n        uniforms: {},\n        vertexShader: [\n            THREE.ShaderChunk[\"morphtarget_pars_vertex\"],\n            THREE.ShaderChunk[\"skinning_pars_vertex\"],\n            \"void main() {\",\n            THREE.ShaderChunk[\"skinbase_vertex\"],\n            THREE.ShaderChunk[\"morphtarget_vertex\"],\n            THREE.ShaderChunk[\"skinning_vertex\"],\n            THREE.ShaderChunk[\"default_vertex\"],\n            \"}\"\n        ].join(\"\\n\"),\n        fragmentShader: [\n            \"vec4 pack_depth( const in float depth ) {\",\n            \"const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\",\n            \"const vec4 bit_mask  = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\",\n            \"vec4 res = fract( depth * bit_shift );\",\n            \"res -= res.xxyz * bit_mask;\",\n            \"return res;\",\n            \"}\",\n            \"void main() {\",\n            \"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );\",\n            //\"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z / gl_FragCoord.w );\",\n            //\"float z = ( ( gl_FragCoord.z / gl_FragCoord.w ) - 3.0 ) / ( 4000.0 - 3.0 );\",\n            //\"gl_FragData[ 0 ] = pack_depth( z );\",\n            //\"gl_FragData[ 0 ] = vec4( z, z, z, 1.0 );\",\n            \"}\"\n        ].join(\"\\n\")\n    }\n};\n/**\n * @author supereggbert / http://www.paulbrunt.co.uk/\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author szimek / https://github.com/szimek/\n */ THREE.WebGLRenderer = function(parameters) {\n    console.log(\"THREE.WebGLRenderer\", THREE.REVISION);\n    parameters = parameters || {};\n    var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement(\"canvas\"), _precision = parameters.precision !== undefined ? parameters.precision : \"highp\", _alpha = parameters.alpha !== undefined ? parameters.alpha : true, _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true, _antialias = parameters.antialias !== undefined ? parameters.antialias : false, _stencil = parameters.stencil !== undefined ? parameters.stencil : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false, _clearColor = parameters.clearColor !== undefined ? new THREE.Color(parameters.clearColor) : new THREE.Color(0x000000), _clearAlpha = parameters.clearAlpha !== undefined ? parameters.clearAlpha : 0;\n    // public properties\n    this.domElement = _canvas;\n    this.context = null;\n    this.devicePixelRatio = parameters.devicePixelRatio !== undefined ? parameters.devicePixelRatio : window.devicePixelRatio !== undefined ? window.devicePixelRatio : 1;\n    // clearing\n    this.autoClear = true;\n    this.autoClearColor = true;\n    this.autoClearDepth = true;\n    this.autoClearStencil = true;\n    // scene graph\n    this.sortObjects = true;\n    this.autoUpdateObjects = true;\n    this.autoUpdateScene = true;\n    // physically based shading\n    this.gammaInput = false;\n    this.gammaOutput = false;\n    this.physicallyBasedShading = false;\n    // shadow map\n    this.shadowMapEnabled = false;\n    this.shadowMapAutoUpdate = true;\n    this.shadowMapType = THREE.PCFShadowMap;\n    this.shadowMapCullFace = THREE.CullFaceFront;\n    this.shadowMapDebug = false;\n    this.shadowMapCascade = false;\n    // morphs\n    this.maxMorphTargets = 8;\n    this.maxMorphNormals = 4;\n    // flags\n    this.autoScaleCubemaps = true;\n    // custom render plugins\n    this.renderPluginsPre = [];\n    this.renderPluginsPost = [];\n    // info\n    this.info = {\n        memory: {\n            programs: 0,\n            geometries: 0,\n            textures: 0\n        },\n        render: {\n            calls: 0,\n            vertices: 0,\n            faces: 0,\n            points: 0\n        }\n    };\n    // internal properties\n    var _this = this, _programs = [], _programs_counter = 0, // internal state cache\n    _currentProgram = null, _currentFramebuffer = null, _currentMaterialId = -1, _currentGeometryGroupHash = null, _currentCamera = null, _geometryGroupCounter = 0, _usedTextureUnits = 0, // GL state cache\n    _oldDoubleSided = -1, _oldFlipSided = -1, _oldBlending = -1, _oldBlendEquation = -1, _oldBlendSrc = -1, _oldBlendDst = -1, _oldDepthTest = -1, _oldDepthWrite = -1, _oldPolygonOffset = null, _oldPolygonOffsetFactor = null, _oldPolygonOffsetUnits = null, _oldLineWidth = null, _viewportX = 0, _viewportY = 0, _viewportWidth = 0, _viewportHeight = 0, _currentWidth = 0, _currentHeight = 0, _enabledAttributes = {}, // frustum\n    _frustum = new THREE.Frustum(), // camera matrices cache\n    _projScreenMatrix = new THREE.Matrix4(), _projScreenMatrixPS = new THREE.Matrix4(), _vector3 = new THREE.Vector3(), // light arrays cache\n    _direction = new THREE.Vector3(), _lightsNeedUpdate = true, _lights = {\n        ambient: [\n            0,\n            0,\n            0\n        ],\n        directional: {\n            length: 0,\n            colors: new Array(),\n            positions: new Array()\n        },\n        point: {\n            length: 0,\n            colors: new Array(),\n            positions: new Array(),\n            distances: new Array()\n        },\n        spot: {\n            length: 0,\n            colors: new Array(),\n            positions: new Array(),\n            distances: new Array(),\n            directions: new Array(),\n            anglesCos: new Array(),\n            exponents: new Array()\n        },\n        hemi: {\n            length: 0,\n            skyColors: new Array(),\n            groundColors: new Array(),\n            positions: new Array()\n        }\n    };\n    // initialize\n    var _gl;\n    var _glExtensionTextureFloat;\n    var _glExtensionStandardDerivatives;\n    var _glExtensionTextureFilterAnisotropic;\n    var _glExtensionCompressedTextureS3TC;\n    initGL();\n    setDefaultGLState();\n    this.context = _gl;\n    // GPU capabilities\n    var _maxTextures = _gl.getParameter(_gl.MAX_TEXTURE_IMAGE_UNITS);\n    var _maxVertexTextures = _gl.getParameter(_gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);\n    var _maxTextureSize = _gl.getParameter(_gl.MAX_TEXTURE_SIZE);\n    var _maxCubemapSize = _gl.getParameter(_gl.MAX_CUBE_MAP_TEXTURE_SIZE);\n    var _maxAnisotropy = _glExtensionTextureFilterAnisotropic ? _gl.getParameter(_glExtensionTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;\n    var _supportsVertexTextures = _maxVertexTextures > 0;\n    var _supportsBoneTextures = _supportsVertexTextures && _glExtensionTextureFloat;\n    var _compressedTextureFormats = _glExtensionCompressedTextureS3TC ? _gl.getParameter(_gl.COMPRESSED_TEXTURE_FORMATS) : [];\n    //\n    var _vertexShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat(_gl.VERTEX_SHADER, _gl.HIGH_FLOAT);\n    var _vertexShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat(_gl.VERTEX_SHADER, _gl.MEDIUM_FLOAT);\n    var _vertexShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat(_gl.VERTEX_SHADER, _gl.LOW_FLOAT);\n    var _fragmentShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat(_gl.FRAGMENT_SHADER, _gl.HIGH_FLOAT);\n    var _fragmentShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat(_gl.FRAGMENT_SHADER, _gl.MEDIUM_FLOAT);\n    var _fragmentShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat(_gl.FRAGMENT_SHADER, _gl.LOW_FLOAT);\n    var _vertexShaderPrecisionHighpInt = _gl.getShaderPrecisionFormat(_gl.VERTEX_SHADER, _gl.HIGH_INT);\n    var _vertexShaderPrecisionMediumpInt = _gl.getShaderPrecisionFormat(_gl.VERTEX_SHADER, _gl.MEDIUM_INT);\n    var _vertexShaderPrecisionLowpInt = _gl.getShaderPrecisionFormat(_gl.VERTEX_SHADER, _gl.LOW_INT);\n    var _fragmentShaderPrecisionHighpInt = _gl.getShaderPrecisionFormat(_gl.FRAGMENT_SHADER, _gl.HIGH_INT);\n    var _fragmentShaderPrecisionMediumpInt = _gl.getShaderPrecisionFormat(_gl.FRAGMENT_SHADER, _gl.MEDIUM_INT);\n    var _fragmentShaderPrecisionLowpInt = _gl.getShaderPrecisionFormat(_gl.FRAGMENT_SHADER, _gl.LOW_INT);\n    // clamp precision to maximum available\n    var highpAvailable = _vertexShaderPrecisionHighpFloat.precision > 0 && _fragmentShaderPrecisionHighpFloat.precision > 0;\n    var mediumpAvailable = _vertexShaderPrecisionMediumpFloat.precision > 0 && _fragmentShaderPrecisionMediumpFloat.precision > 0;\n    if (_precision === \"highp\" && !highpAvailable) {\n        if (mediumpAvailable) {\n            _precision = \"mediump\";\n            console.warn(\"WebGLRenderer: highp not supported, using mediump\");\n        } else {\n            _precision = \"lowp\";\n            console.warn(\"WebGLRenderer: highp and mediump not supported, using lowp\");\n        }\n    }\n    if (_precision === \"mediump\" && !mediumpAvailable) {\n        _precision = \"lowp\";\n        console.warn(\"WebGLRenderer: mediump not supported, using lowp\");\n    }\n    // API\n    this.getContext = function() {\n        return _gl;\n    };\n    this.supportsVertexTextures = function() {\n        return _supportsVertexTextures;\n    };\n    this.supportsFloatTextures = function() {\n        return _glExtensionTextureFloat;\n    };\n    this.supportsStandardDerivatives = function() {\n        return _glExtensionStandardDerivatives;\n    };\n    this.supportsCompressedTextureS3TC = function() {\n        return _glExtensionCompressedTextureS3TC;\n    };\n    this.getMaxAnisotropy = function() {\n        return _maxAnisotropy;\n    };\n    this.getPrecision = function() {\n        return _precision;\n    };\n    this.setSize = function(width, height) {\n        _canvas.width = width * this.devicePixelRatio;\n        _canvas.height = height * this.devicePixelRatio;\n        _canvas.style.width = width + \"px\";\n        _canvas.style.height = height + \"px\";\n        this.setViewport(0, 0, _canvas.width, _canvas.height);\n    };\n    this.setViewport = function(x, y, width, height) {\n        _viewportX = x !== undefined ? x : 0;\n        _viewportY = y !== undefined ? y : 0;\n        _viewportWidth = width !== undefined ? width : _canvas.width;\n        _viewportHeight = height !== undefined ? height : _canvas.height;\n        _gl.viewport(_viewportX, _viewportY, _viewportWidth, _viewportHeight);\n    };\n    this.setScissor = function(x, y, width, height) {\n        _gl.scissor(x, y, width, height);\n    };\n    this.enableScissorTest = function(enable) {\n        enable ? _gl.enable(_gl.SCISSOR_TEST) : _gl.disable(_gl.SCISSOR_TEST);\n    };\n    // Clearing\n    this.setClearColorHex = function(hex, alpha) {\n        _clearColor.setHex(hex);\n        _clearAlpha = alpha;\n        _gl.clearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha);\n    };\n    this.setClearColor = function(color, alpha) {\n        _clearColor.copy(color);\n        _clearAlpha = alpha;\n        _gl.clearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha);\n    };\n    this.getClearColor = function() {\n        return _clearColor;\n    };\n    this.getClearAlpha = function() {\n        return _clearAlpha;\n    };\n    this.clear = function(color, depth, stencil) {\n        var bits = 0;\n        if (color === undefined || color) bits |= _gl.COLOR_BUFFER_BIT;\n        if (depth === undefined || depth) bits |= _gl.DEPTH_BUFFER_BIT;\n        if (stencil === undefined || stencil) bits |= _gl.STENCIL_BUFFER_BIT;\n        _gl.clear(bits);\n    };\n    this.clearTarget = function(renderTarget, color, depth, stencil) {\n        this.setRenderTarget(renderTarget);\n        this.clear(color, depth, stencil);\n    };\n    // Plugins\n    this.addPostPlugin = function(plugin) {\n        plugin.init(this);\n        this.renderPluginsPost.push(plugin);\n    };\n    this.addPrePlugin = function(plugin) {\n        plugin.init(this);\n        this.renderPluginsPre.push(plugin);\n    };\n    // Rendering\n    this.updateShadowMap = function(scene, camera) {\n        _currentProgram = null;\n        _oldBlending = -1;\n        _oldDepthTest = -1;\n        _oldDepthWrite = -1;\n        _currentGeometryGroupHash = -1;\n        _currentMaterialId = -1;\n        _lightsNeedUpdate = true;\n        _oldDoubleSided = -1;\n        _oldFlipSided = -1;\n        this.shadowMapPlugin.update(scene, camera);\n    };\n    // Internal functions\n    // Buffer allocation\n    function createParticleBuffers(geometry) {\n        geometry.__webglVertexBuffer = _gl.createBuffer();\n        geometry.__webglColorBuffer = _gl.createBuffer();\n        _this.info.memory.geometries++;\n    }\n    function createLineBuffers(geometry) {\n        geometry.__webglVertexBuffer = _gl.createBuffer();\n        geometry.__webglColorBuffer = _gl.createBuffer();\n        geometry.__webglLineDistanceBuffer = _gl.createBuffer();\n        _this.info.memory.geometries++;\n    }\n    function createRibbonBuffers(geometry) {\n        geometry.__webglVertexBuffer = _gl.createBuffer();\n        geometry.__webglColorBuffer = _gl.createBuffer();\n        geometry.__webglNormalBuffer = _gl.createBuffer();\n        _this.info.memory.geometries++;\n    }\n    function createMeshBuffers(geometryGroup) {\n        geometryGroup.__webglVertexBuffer = _gl.createBuffer();\n        geometryGroup.__webglNormalBuffer = _gl.createBuffer();\n        geometryGroup.__webglTangentBuffer = _gl.createBuffer();\n        geometryGroup.__webglColorBuffer = _gl.createBuffer();\n        geometryGroup.__webglUVBuffer = _gl.createBuffer();\n        geometryGroup.__webglUV2Buffer = _gl.createBuffer();\n        geometryGroup.__webglSkinIndicesBuffer = _gl.createBuffer();\n        geometryGroup.__webglSkinWeightsBuffer = _gl.createBuffer();\n        geometryGroup.__webglFaceBuffer = _gl.createBuffer();\n        geometryGroup.__webglLineBuffer = _gl.createBuffer();\n        var m, ml;\n        if (geometryGroup.numMorphTargets) {\n            geometryGroup.__webglMorphTargetsBuffers = [];\n            for(m = 0, ml = geometryGroup.numMorphTargets; m < ml; m++)geometryGroup.__webglMorphTargetsBuffers.push(_gl.createBuffer());\n        }\n        if (geometryGroup.numMorphNormals) {\n            geometryGroup.__webglMorphNormalsBuffers = [];\n            for(m = 0, ml = geometryGroup.numMorphNormals; m < ml; m++)geometryGroup.__webglMorphNormalsBuffers.push(_gl.createBuffer());\n        }\n        _this.info.memory.geometries++;\n    }\n    // Events\n    var onGeometryDispose = function(event) {\n        var geometry = event.target;\n        geometry.removeEventListener(\"dispose\", onGeometryDispose);\n        deallocateGeometry(geometry);\n        _this.info.memory.geometries--;\n    };\n    var onTextureDispose = function(event) {\n        var texture = event.target;\n        texture.removeEventListener(\"dispose\", onTextureDispose);\n        deallocateTexture(texture);\n        _this.info.memory.textures--;\n    };\n    var onRenderTargetDispose = function(event) {\n        var renderTarget = event.target;\n        renderTarget.removeEventListener(\"dispose\", onRenderTargetDispose);\n        deallocateRenderTarget(renderTarget);\n        _this.info.memory.textures--;\n    };\n    var onMaterialDispose = function(event) {\n        var material = event.target;\n        material.removeEventListener(\"dispose\", onMaterialDispose);\n        deallocateMaterial(material);\n    };\n    // Buffer deallocation\n    var deallocateGeometry = function(geometry) {\n        geometry.__webglInit = undefined;\n        if (geometry.__webglVertexBuffer !== undefined) _gl.deleteBuffer(geometry.__webglVertexBuffer);\n        if (geometry.__webglNormalBuffer !== undefined) _gl.deleteBuffer(geometry.__webglNormalBuffer);\n        if (geometry.__webglTangentBuffer !== undefined) _gl.deleteBuffer(geometry.__webglTangentBuffer);\n        if (geometry.__webglColorBuffer !== undefined) _gl.deleteBuffer(geometry.__webglColorBuffer);\n        if (geometry.__webglUVBuffer !== undefined) _gl.deleteBuffer(geometry.__webglUVBuffer);\n        if (geometry.__webglUV2Buffer !== undefined) _gl.deleteBuffer(geometry.__webglUV2Buffer);\n        if (geometry.__webglSkinIndicesBuffer !== undefined) _gl.deleteBuffer(geometry.__webglSkinIndicesBuffer);\n        if (geometry.__webglSkinWeightsBuffer !== undefined) _gl.deleteBuffer(geometry.__webglSkinWeightsBuffer);\n        if (geometry.__webglFaceBuffer !== undefined) _gl.deleteBuffer(geometry.__webglFaceBuffer);\n        if (geometry.__webglLineBuffer !== undefined) _gl.deleteBuffer(geometry.__webglLineBuffer);\n        if (geometry.__webglLineDistanceBuffer !== undefined) _gl.deleteBuffer(geometry.__webglLineDistanceBuffer);\n        // geometry groups\n        if (geometry.geometryGroups !== undefined) for(var g in geometry.geometryGroups){\n            var geometryGroup = geometry.geometryGroups[g];\n            if (geometryGroup.numMorphTargets !== undefined) for(var m = 0, ml = geometryGroup.numMorphTargets; m < ml; m++)_gl.deleteBuffer(geometryGroup.__webglMorphTargetsBuffers[m]);\n            if (geometryGroup.numMorphNormals !== undefined) for(var m = 0, ml = geometryGroup.numMorphNormals; m < ml; m++)_gl.deleteBuffer(geometryGroup.__webglMorphNormalsBuffers[m]);\n            deleteCustomAttributesBuffers(geometryGroup);\n        }\n        deleteCustomAttributesBuffers(geometry);\n    };\n    var deallocateTexture = function(texture) {\n        if (texture.image && texture.image.__webglTextureCube) // cube texture\n        _gl.deleteTexture(texture.image.__webglTextureCube);\n        else {\n            // 2D texture\n            if (!texture.__webglInit) return;\n            texture.__webglInit = false;\n            _gl.deleteTexture(texture.__webglTexture);\n        }\n    };\n    var deallocateRenderTarget = function(renderTarget) {\n        if (!renderTarget || !renderTarget.__webglTexture) return;\n        _gl.deleteTexture(renderTarget.__webglTexture);\n        if (renderTarget instanceof THREE.WebGLRenderTargetCube) for(var i = 0; i < 6; i++){\n            _gl.deleteFramebuffer(renderTarget.__webglFramebuffer[i]);\n            _gl.deleteRenderbuffer(renderTarget.__webglRenderbuffer[i]);\n        }\n        else {\n            _gl.deleteFramebuffer(renderTarget.__webglFramebuffer);\n            _gl.deleteRenderbuffer(renderTarget.__webglRenderbuffer);\n        }\n    };\n    var deallocateMaterial = function(material) {\n        var program = material.program;\n        if (program === undefined) return;\n        material.program = undefined;\n        // only deallocate GL program if this was the last use of shared program\n        // assumed there is only single copy of any program in the _programs list\n        // (that's how it's constructed)\n        var i, il, programInfo;\n        var deleteProgram = false;\n        for(i = 0, il = _programs.length; i < il; i++){\n            programInfo = _programs[i];\n            if (programInfo.program === program) {\n                programInfo.usedTimes--;\n                if (programInfo.usedTimes === 0) deleteProgram = true;\n                break;\n            }\n        }\n        if (deleteProgram === true) {\n            // avoid using array.splice, this is costlier than creating new array from scratch\n            var newPrograms = [];\n            for(i = 0, il = _programs.length; i < il; i++){\n                programInfo = _programs[i];\n                if (programInfo.program !== program) newPrograms.push(programInfo);\n            }\n            _programs = newPrograms;\n            _gl.deleteProgram(program);\n            _this.info.memory.programs--;\n        }\n    };\n    //\n    /*\n\tfunction deleteParticleBuffers ( geometry ) {\n\n\t\t_gl.deleteBuffer( geometry.__webglVertexBuffer );\n\t\t_gl.deleteBuffer( geometry.__webglColorBuffer );\n\n\t\tdeleteCustomAttributesBuffers( geometry );\n\n\t\t_this.info.memory.geometries --;\n\n\t};\n\n\tfunction deleteLineBuffers ( geometry ) {\n\n\t\t_gl.deleteBuffer( geometry.__webglVertexBuffer );\n\t\t_gl.deleteBuffer( geometry.__webglColorBuffer );\n\t\t_gl.deleteBuffer( geometry.__webglLineDistanceBuffer );\n\n\t\tdeleteCustomAttributesBuffers( geometry );\n\n\t\t_this.info.memory.geometries --;\n\n\t};\n\n\tfunction deleteRibbonBuffers ( geometry ) {\n\n\t\t_gl.deleteBuffer( geometry.__webglVertexBuffer );\n\t\t_gl.deleteBuffer( geometry.__webglColorBuffer );\n\t\t_gl.deleteBuffer( geometry.__webglNormalBuffer );\n\n\t\tdeleteCustomAttributesBuffers( geometry );\n\n\t\t_this.info.memory.geometries --;\n\n\t};\n\n\tfunction deleteMeshBuffers ( geometryGroup ) {\n\n\t\t_gl.deleteBuffer( geometryGroup.__webglVertexBuffer );\n\t\t_gl.deleteBuffer( geometryGroup.__webglNormalBuffer );\n\t\t_gl.deleteBuffer( geometryGroup.__webglTangentBuffer );\n\t\t_gl.deleteBuffer( geometryGroup.__webglColorBuffer );\n\t\t_gl.deleteBuffer( geometryGroup.__webglUVBuffer );\n\t\t_gl.deleteBuffer( geometryGroup.__webglUV2Buffer );\n\n\t\t_gl.deleteBuffer( geometryGroup.__webglSkinIndicesBuffer );\n\t\t_gl.deleteBuffer( geometryGroup.__webglSkinWeightsBuffer );\n\n\t\t_gl.deleteBuffer( geometryGroup.__webglFaceBuffer );\n\t\t_gl.deleteBuffer( geometryGroup.__webglLineBuffer );\n\n\t\tvar m, ml;\n\n\t\tif ( geometryGroup.numMorphTargets ) {\n\n\t\t\tfor ( m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {\n\n\t\t\t\t_gl.deleteBuffer( geometryGroup.__webglMorphTargetsBuffers[ m ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( geometryGroup.numMorphNormals ) {\n\n\t\t\tfor ( m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {\n\n\t\t\t\t_gl.deleteBuffer( geometryGroup.__webglMorphNormalsBuffers[ m ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tdeleteCustomAttributesBuffers( geometryGroup );\n\n\t\t_this.info.memory.geometries --;\n\n\t};\n\t*/ function deleteCustomAttributesBuffers(geometry) {\n        if (geometry.__webglCustomAttributesList) for(var id in geometry.__webglCustomAttributesList)_gl.deleteBuffer(geometry.__webglCustomAttributesList[id].buffer);\n    }\n    // Buffer initialization\n    function initCustomAttributes(geometry, object) {\n        var nvertices = geometry.vertices.length;\n        var material = object.material;\n        if (material.attributes) {\n            if (geometry.__webglCustomAttributesList === undefined) geometry.__webglCustomAttributesList = [];\n            for(var a in material.attributes){\n                var attribute = material.attributes[a];\n                if (!attribute.__webglInitialized || attribute.createUniqueBuffers) {\n                    attribute.__webglInitialized = true;\n                    var size = 1; // \"f\" and \"i\"\n                    if (attribute.type === \"v2\") size = 2;\n                    else if (attribute.type === \"v3\") size = 3;\n                    else if (attribute.type === \"v4\") size = 4;\n                    else if (attribute.type === \"c\") size = 3;\n                    attribute.size = size;\n                    attribute.array = new Float32Array(nvertices * size);\n                    attribute.buffer = _gl.createBuffer();\n                    attribute.buffer.belongsToAttribute = a;\n                    attribute.needsUpdate = true;\n                }\n                geometry.__webglCustomAttributesList.push(attribute);\n            }\n        }\n    }\n    function initParticleBuffers(geometry, object) {\n        var nvertices = geometry.vertices.length;\n        geometry.__vertexArray = new Float32Array(nvertices * 3);\n        geometry.__colorArray = new Float32Array(nvertices * 3);\n        geometry.__sortArray = [];\n        geometry.__webglParticleCount = nvertices;\n        initCustomAttributes(geometry, object);\n    }\n    function initLineBuffers(geometry, object) {\n        var nvertices = geometry.vertices.length;\n        geometry.__vertexArray = new Float32Array(nvertices * 3);\n        geometry.__colorArray = new Float32Array(nvertices * 3);\n        geometry.__lineDistanceArray = new Float32Array(nvertices * 1);\n        geometry.__webglLineCount = nvertices;\n        initCustomAttributes(geometry, object);\n    }\n    function initRibbonBuffers(geometry, object) {\n        var nvertices = geometry.vertices.length;\n        geometry.__vertexArray = new Float32Array(nvertices * 3);\n        geometry.__colorArray = new Float32Array(nvertices * 3);\n        geometry.__normalArray = new Float32Array(nvertices * 3);\n        geometry.__webglVertexCount = nvertices;\n        initCustomAttributes(geometry, object);\n    }\n    function initMeshBuffers(geometryGroup, object) {\n        var geometry = object.geometry, faces3 = geometryGroup.faces3, faces4 = geometryGroup.faces4, nvertices = faces3.length * 3 + faces4.length * 4, ntris = faces3.length * 1 + faces4.length * 2, nlines = faces3.length * 3 + faces4.length * 4, material = getBufferMaterial(object, geometryGroup), uvType = bufferGuessUVType(material), normalType = bufferGuessNormalType(material), vertexColorType = bufferGuessVertexColorType(material);\n        //console.log( \"uvType\", uvType, \"normalType\", normalType, \"vertexColorType\", vertexColorType, object, geometryGroup, material );\n        geometryGroup.__vertexArray = new Float32Array(nvertices * 3);\n        if (normalType) geometryGroup.__normalArray = new Float32Array(nvertices * 3);\n        if (geometry.hasTangents) geometryGroup.__tangentArray = new Float32Array(nvertices * 4);\n        if (vertexColorType) geometryGroup.__colorArray = new Float32Array(nvertices * 3);\n        if (uvType) {\n            if (geometry.faceUvs.length > 0 || geometry.faceVertexUvs.length > 0) geometryGroup.__uvArray = new Float32Array(nvertices * 2);\n            if (geometry.faceUvs.length > 1 || geometry.faceVertexUvs.length > 1) geometryGroup.__uv2Array = new Float32Array(nvertices * 2);\n        }\n        if (object.geometry.skinWeights.length && object.geometry.skinIndices.length) {\n            geometryGroup.__skinIndexArray = new Float32Array(nvertices * 4);\n            geometryGroup.__skinWeightArray = new Float32Array(nvertices * 4);\n        }\n        geometryGroup.__faceArray = new Uint16Array(ntris * 3);\n        geometryGroup.__lineArray = new Uint16Array(nlines * 2);\n        var m, ml;\n        if (geometryGroup.numMorphTargets) {\n            geometryGroup.__morphTargetsArrays = [];\n            for(m = 0, ml = geometryGroup.numMorphTargets; m < ml; m++)geometryGroup.__morphTargetsArrays.push(new Float32Array(nvertices * 3));\n        }\n        if (geometryGroup.numMorphNormals) {\n            geometryGroup.__morphNormalsArrays = [];\n            for(m = 0, ml = geometryGroup.numMorphNormals; m < ml; m++)geometryGroup.__morphNormalsArrays.push(new Float32Array(nvertices * 3));\n        }\n        geometryGroup.__webglFaceCount = ntris * 3;\n        geometryGroup.__webglLineCount = nlines * 2;\n        // custom attributes\n        if (material.attributes) {\n            if (geometryGroup.__webglCustomAttributesList === undefined) geometryGroup.__webglCustomAttributesList = [];\n            for(var a in material.attributes){\n                // Do a shallow copy of the attribute object so different geometryGroup chunks use different\n                // attribute buffers which are correctly indexed in the setMeshBuffers function\n                var originalAttribute = material.attributes[a];\n                var attribute = {};\n                for(var property in originalAttribute)attribute[property] = originalAttribute[property];\n                if (!attribute.__webglInitialized || attribute.createUniqueBuffers) {\n                    attribute.__webglInitialized = true;\n                    var size = 1; // \"f\" and \"i\"\n                    if (attribute.type === \"v2\") size = 2;\n                    else if (attribute.type === \"v3\") size = 3;\n                    else if (attribute.type === \"v4\") size = 4;\n                    else if (attribute.type === \"c\") size = 3;\n                    attribute.size = size;\n                    attribute.array = new Float32Array(nvertices * size);\n                    attribute.buffer = _gl.createBuffer();\n                    attribute.buffer.belongsToAttribute = a;\n                    originalAttribute.needsUpdate = true;\n                    attribute.__original = originalAttribute;\n                }\n                geometryGroup.__webglCustomAttributesList.push(attribute);\n            }\n        }\n        geometryGroup.__inittedArrays = true;\n    }\n    function getBufferMaterial(object, geometryGroup) {\n        return object.material instanceof THREE.MeshFaceMaterial ? object.material.materials[geometryGroup.materialIndex] : object.material;\n    }\n    function materialNeedsSmoothNormals(material) {\n        return material && material.shading !== undefined && material.shading === THREE.SmoothShading;\n    }\n    function bufferGuessNormalType(material) {\n        // only MeshBasicMaterial and MeshDepthMaterial don't need normals\n        if (material instanceof THREE.MeshBasicMaterial && !material.envMap || material instanceof THREE.MeshDepthMaterial) return false;\n        if (materialNeedsSmoothNormals(material)) return THREE.SmoothShading;\n        else return THREE.FlatShading;\n    }\n    function bufferGuessVertexColorType(material) {\n        if (material.vertexColors) return material.vertexColors;\n        return false;\n    }\n    function bufferGuessUVType(material) {\n        // material must use some texture to require uvs\n        if (material.map || material.lightMap || material.bumpMap || material.normalMap || material.specularMap || material instanceof THREE.ShaderMaterial) return true;\n        return false;\n    }\n    //\n    function initDirectBuffers(geometry) {\n        var a, attribute, type;\n        for(a in geometry.attributes){\n            if (a === \"index\") type = _gl.ELEMENT_ARRAY_BUFFER;\n            else type = _gl.ARRAY_BUFFER;\n            attribute = geometry.attributes[a];\n            attribute.buffer = _gl.createBuffer();\n            _gl.bindBuffer(type, attribute.buffer);\n            _gl.bufferData(type, attribute.array, _gl.STATIC_DRAW);\n        }\n    }\n    // Buffer setting\n    function setParticleBuffers(geometry, hint, object) {\n        var v, c, vertex, offset, index, color, vertices = geometry.vertices, vl = vertices.length, colors = geometry.colors, cl = colors.length, vertexArray = geometry.__vertexArray, colorArray = geometry.__colorArray, sortArray = geometry.__sortArray, dirtyVertices = geometry.verticesNeedUpdate, dirtyElements = geometry.elementsNeedUpdate, dirtyColors = geometry.colorsNeedUpdate, customAttributes = geometry.__webglCustomAttributesList, i, il, a, ca, cal, value, customAttribute;\n        if (object.sortParticles) {\n            _projScreenMatrixPS.copy(_projScreenMatrix);\n            _projScreenMatrixPS.multiply(object.matrixWorld);\n            for(v = 0; v < vl; v++){\n                vertex = vertices[v];\n                _vector3.copy(vertex);\n                _vector3.applyProjection(_projScreenMatrixPS);\n                sortArray[v] = [\n                    _vector3.z,\n                    v\n                ];\n            }\n            sortArray.sort(numericalSort);\n            for(v = 0; v < vl; v++){\n                vertex = vertices[sortArray[v][1]];\n                offset = v * 3;\n                vertexArray[offset] = vertex.x;\n                vertexArray[offset + 1] = vertex.y;\n                vertexArray[offset + 2] = vertex.z;\n            }\n            for(c = 0; c < cl; c++){\n                offset = c * 3;\n                color = colors[sortArray[c][1]];\n                colorArray[offset] = color.r;\n                colorArray[offset + 1] = color.g;\n                colorArray[offset + 2] = color.b;\n            }\n            if (customAttributes) for(i = 0, il = customAttributes.length; i < il; i++){\n                customAttribute = customAttributes[i];\n                if (!(customAttribute.boundTo === undefined || customAttribute.boundTo === \"vertices\")) continue;\n                offset = 0;\n                cal = customAttribute.value.length;\n                if (customAttribute.size === 1) for(ca = 0; ca < cal; ca++){\n                    index = sortArray[ca][1];\n                    customAttribute.array[ca] = customAttribute.value[index];\n                }\n                else if (customAttribute.size === 2) for(ca = 0; ca < cal; ca++){\n                    index = sortArray[ca][1];\n                    value = customAttribute.value[index];\n                    customAttribute.array[offset] = value.x;\n                    customAttribute.array[offset + 1] = value.y;\n                    offset += 2;\n                }\n                else if (customAttribute.size === 3) {\n                    if (customAttribute.type === \"c\") for(ca = 0; ca < cal; ca++){\n                        index = sortArray[ca][1];\n                        value = customAttribute.value[index];\n                        customAttribute.array[offset] = value.r;\n                        customAttribute.array[offset + 1] = value.g;\n                        customAttribute.array[offset + 2] = value.b;\n                        offset += 3;\n                    }\n                    else for(ca = 0; ca < cal; ca++){\n                        index = sortArray[ca][1];\n                        value = customAttribute.value[index];\n                        customAttribute.array[offset] = value.x;\n                        customAttribute.array[offset + 1] = value.y;\n                        customAttribute.array[offset + 2] = value.z;\n                        offset += 3;\n                    }\n                } else if (customAttribute.size === 4) for(ca = 0; ca < cal; ca++){\n                    index = sortArray[ca][1];\n                    value = customAttribute.value[index];\n                    customAttribute.array[offset] = value.x;\n                    customAttribute.array[offset + 1] = value.y;\n                    customAttribute.array[offset + 2] = value.z;\n                    customAttribute.array[offset + 3] = value.w;\n                    offset += 4;\n                }\n            }\n        } else {\n            if (dirtyVertices) for(v = 0; v < vl; v++){\n                vertex = vertices[v];\n                offset = v * 3;\n                vertexArray[offset] = vertex.x;\n                vertexArray[offset + 1] = vertex.y;\n                vertexArray[offset + 2] = vertex.z;\n            }\n            if (dirtyColors) for(c = 0; c < cl; c++){\n                color = colors[c];\n                offset = c * 3;\n                colorArray[offset] = color.r;\n                colorArray[offset + 1] = color.g;\n                colorArray[offset + 2] = color.b;\n            }\n            if (customAttributes) for(i = 0, il = customAttributes.length; i < il; i++){\n                customAttribute = customAttributes[i];\n                if (customAttribute.needsUpdate && (customAttribute.boundTo === undefined || customAttribute.boundTo === \"vertices\")) {\n                    cal = customAttribute.value.length;\n                    offset = 0;\n                    if (customAttribute.size === 1) for(ca = 0; ca < cal; ca++)customAttribute.array[ca] = customAttribute.value[ca];\n                    else if (customAttribute.size === 2) for(ca = 0; ca < cal; ca++){\n                        value = customAttribute.value[ca];\n                        customAttribute.array[offset] = value.x;\n                        customAttribute.array[offset + 1] = value.y;\n                        offset += 2;\n                    }\n                    else if (customAttribute.size === 3) {\n                        if (customAttribute.type === \"c\") for(ca = 0; ca < cal; ca++){\n                            value = customAttribute.value[ca];\n                            customAttribute.array[offset] = value.r;\n                            customAttribute.array[offset + 1] = value.g;\n                            customAttribute.array[offset + 2] = value.b;\n                            offset += 3;\n                        }\n                        else for(ca = 0; ca < cal; ca++){\n                            value = customAttribute.value[ca];\n                            customAttribute.array[offset] = value.x;\n                            customAttribute.array[offset + 1] = value.y;\n                            customAttribute.array[offset + 2] = value.z;\n                            offset += 3;\n                        }\n                    } else if (customAttribute.size === 4) for(ca = 0; ca < cal; ca++){\n                        value = customAttribute.value[ca];\n                        customAttribute.array[offset] = value.x;\n                        customAttribute.array[offset + 1] = value.y;\n                        customAttribute.array[offset + 2] = value.z;\n                        customAttribute.array[offset + 3] = value.w;\n                        offset += 4;\n                    }\n                }\n            }\n        }\n        if (dirtyVertices || object.sortParticles) {\n            _gl.bindBuffer(_gl.ARRAY_BUFFER, geometry.__webglVertexBuffer);\n            _gl.bufferData(_gl.ARRAY_BUFFER, vertexArray, hint);\n        }\n        if (dirtyColors || object.sortParticles) {\n            _gl.bindBuffer(_gl.ARRAY_BUFFER, geometry.__webglColorBuffer);\n            _gl.bufferData(_gl.ARRAY_BUFFER, colorArray, hint);\n        }\n        if (customAttributes) for(i = 0, il = customAttributes.length; i < il; i++){\n            customAttribute = customAttributes[i];\n            if (customAttribute.needsUpdate || object.sortParticles) {\n                _gl.bindBuffer(_gl.ARRAY_BUFFER, customAttribute.buffer);\n                _gl.bufferData(_gl.ARRAY_BUFFER, customAttribute.array, hint);\n            }\n        }\n    }\n    function setLineBuffers(geometry, hint) {\n        var v, c, d, vertex, offset, color, vertices = geometry.vertices, colors = geometry.colors, lineDistances = geometry.lineDistances, vl = vertices.length, cl = colors.length, dl = lineDistances.length, vertexArray = geometry.__vertexArray, colorArray = geometry.__colorArray, lineDistanceArray = geometry.__lineDistanceArray, dirtyVertices = geometry.verticesNeedUpdate, dirtyColors = geometry.colorsNeedUpdate, dirtyLineDistances = geometry.lineDistancesNeedUpdate, customAttributes = geometry.__webglCustomAttributesList, i, il, a, ca, cal, value, customAttribute;\n        if (dirtyVertices) {\n            for(v = 0; v < vl; v++){\n                vertex = vertices[v];\n                offset = v * 3;\n                vertexArray[offset] = vertex.x;\n                vertexArray[offset + 1] = vertex.y;\n                vertexArray[offset + 2] = vertex.z;\n            }\n            _gl.bindBuffer(_gl.ARRAY_BUFFER, geometry.__webglVertexBuffer);\n            _gl.bufferData(_gl.ARRAY_BUFFER, vertexArray, hint);\n        }\n        if (dirtyColors) {\n            for(c = 0; c < cl; c++){\n                color = colors[c];\n                offset = c * 3;\n                colorArray[offset] = color.r;\n                colorArray[offset + 1] = color.g;\n                colorArray[offset + 2] = color.b;\n            }\n            _gl.bindBuffer(_gl.ARRAY_BUFFER, geometry.__webglColorBuffer);\n            _gl.bufferData(_gl.ARRAY_BUFFER, colorArray, hint);\n        }\n        if (dirtyLineDistances) {\n            for(d = 0; d < dl; d++)lineDistanceArray[d] = lineDistances[d];\n            _gl.bindBuffer(_gl.ARRAY_BUFFER, geometry.__webglLineDistanceBuffer);\n            _gl.bufferData(_gl.ARRAY_BUFFER, lineDistanceArray, hint);\n        }\n        if (customAttributes) for(i = 0, il = customAttributes.length; i < il; i++){\n            customAttribute = customAttributes[i];\n            if (customAttribute.needsUpdate && (customAttribute.boundTo === undefined || customAttribute.boundTo === \"vertices\")) {\n                offset = 0;\n                cal = customAttribute.value.length;\n                if (customAttribute.size === 1) for(ca = 0; ca < cal; ca++)customAttribute.array[ca] = customAttribute.value[ca];\n                else if (customAttribute.size === 2) for(ca = 0; ca < cal; ca++){\n                    value = customAttribute.value[ca];\n                    customAttribute.array[offset] = value.x;\n                    customAttribute.array[offset + 1] = value.y;\n                    offset += 2;\n                }\n                else if (customAttribute.size === 3) {\n                    if (customAttribute.type === \"c\") for(ca = 0; ca < cal; ca++){\n                        value = customAttribute.value[ca];\n                        customAttribute.array[offset] = value.r;\n                        customAttribute.array[offset + 1] = value.g;\n                        customAttribute.array[offset + 2] = value.b;\n                        offset += 3;\n                    }\n                    else for(ca = 0; ca < cal; ca++){\n                        value = customAttribute.value[ca];\n                        customAttribute.array[offset] = value.x;\n                        customAttribute.array[offset + 1] = value.y;\n                        customAttribute.array[offset + 2] = value.z;\n                        offset += 3;\n                    }\n                } else if (customAttribute.size === 4) for(ca = 0; ca < cal; ca++){\n                    value = customAttribute.value[ca];\n                    customAttribute.array[offset] = value.x;\n                    customAttribute.array[offset + 1] = value.y;\n                    customAttribute.array[offset + 2] = value.z;\n                    customAttribute.array[offset + 3] = value.w;\n                    offset += 4;\n                }\n                _gl.bindBuffer(_gl.ARRAY_BUFFER, customAttribute.buffer);\n                _gl.bufferData(_gl.ARRAY_BUFFER, customAttribute.array, hint);\n            }\n        }\n    }\n    function setRibbonBuffers(geometry, hint) {\n        var v, c, n, vertex, offset, color, normal, i, il, ca, cal, customAttribute, value, vertices = geometry.vertices, colors = geometry.colors, normals = geometry.normals, vl = vertices.length, cl = colors.length, nl = normals.length, vertexArray = geometry.__vertexArray, colorArray = geometry.__colorArray, normalArray = geometry.__normalArray, dirtyVertices = geometry.verticesNeedUpdate, dirtyColors = geometry.colorsNeedUpdate, dirtyNormals = geometry.normalsNeedUpdate, customAttributes = geometry.__webglCustomAttributesList;\n        if (dirtyVertices) {\n            for(v = 0; v < vl; v++){\n                vertex = vertices[v];\n                offset = v * 3;\n                vertexArray[offset] = vertex.x;\n                vertexArray[offset + 1] = vertex.y;\n                vertexArray[offset + 2] = vertex.z;\n            }\n            _gl.bindBuffer(_gl.ARRAY_BUFFER, geometry.__webglVertexBuffer);\n            _gl.bufferData(_gl.ARRAY_BUFFER, vertexArray, hint);\n        }\n        if (dirtyColors) {\n            for(c = 0; c < cl; c++){\n                color = colors[c];\n                offset = c * 3;\n                colorArray[offset] = color.r;\n                colorArray[offset + 1] = color.g;\n                colorArray[offset + 2] = color.b;\n            }\n            _gl.bindBuffer(_gl.ARRAY_BUFFER, geometry.__webglColorBuffer);\n            _gl.bufferData(_gl.ARRAY_BUFFER, colorArray, hint);\n        }\n        if (dirtyNormals) {\n            for(n = 0; n < nl; n++){\n                normal = normals[n];\n                offset = n * 3;\n                normalArray[offset] = normal.x;\n                normalArray[offset + 1] = normal.y;\n                normalArray[offset + 2] = normal.z;\n            }\n            _gl.bindBuffer(_gl.ARRAY_BUFFER, geometry.__webglNormalBuffer);\n            _gl.bufferData(_gl.ARRAY_BUFFER, normalArray, hint);\n        }\n        if (customAttributes) for(i = 0, il = customAttributes.length; i < il; i++){\n            customAttribute = customAttributes[i];\n            if (customAttribute.needsUpdate && (customAttribute.boundTo === undefined || customAttribute.boundTo === \"vertices\")) {\n                offset = 0;\n                cal = customAttribute.value.length;\n                if (customAttribute.size === 1) for(ca = 0; ca < cal; ca++)customAttribute.array[ca] = customAttribute.value[ca];\n                else if (customAttribute.size === 2) for(ca = 0; ca < cal; ca++){\n                    value = customAttribute.value[ca];\n                    customAttribute.array[offset] = value.x;\n                    customAttribute.array[offset + 1] = value.y;\n                    offset += 2;\n                }\n                else if (customAttribute.size === 3) {\n                    if (customAttribute.type === \"c\") for(ca = 0; ca < cal; ca++){\n                        value = customAttribute.value[ca];\n                        customAttribute.array[offset] = value.r;\n                        customAttribute.array[offset + 1] = value.g;\n                        customAttribute.array[offset + 2] = value.b;\n                        offset += 3;\n                    }\n                    else for(ca = 0; ca < cal; ca++){\n                        value = customAttribute.value[ca];\n                        customAttribute.array[offset] = value.x;\n                        customAttribute.array[offset + 1] = value.y;\n                        customAttribute.array[offset + 2] = value.z;\n                        offset += 3;\n                    }\n                } else if (customAttribute.size === 4) for(ca = 0; ca < cal; ca++){\n                    value = customAttribute.value[ca];\n                    customAttribute.array[offset] = value.x;\n                    customAttribute.array[offset + 1] = value.y;\n                    customAttribute.array[offset + 2] = value.z;\n                    customAttribute.array[offset + 3] = value.w;\n                    offset += 4;\n                }\n                _gl.bindBuffer(_gl.ARRAY_BUFFER, customAttribute.buffer);\n                _gl.bufferData(_gl.ARRAY_BUFFER, customAttribute.array, hint);\n            }\n        }\n    }\n    function setMeshBuffers(geometryGroup, object, hint, dispose, material) {\n        if (!geometryGroup.__inittedArrays) return;\n        var normalType = bufferGuessNormalType(material), vertexColorType = bufferGuessVertexColorType(material), uvType = bufferGuessUVType(material), needsSmoothNormals = normalType === THREE.SmoothShading;\n        var f, fl, fi, face, vertexNormals, faceNormal, normal, vertexColors, faceColor, vertexTangents, uv, uv2, v1, v2, v3, v4, t1, t2, t3, t4, n1, n2, n3, n4, c1, c2, c3, c4, sw1, sw2, sw3, sw4, si1, si2, si3, si4, sa1, sa2, sa3, sa4, sb1, sb2, sb3, sb4, m, ml, i, il, vn, uvi, uv2i, vk, vkl, vka, nka, chf, faceVertexNormals, a, vertexIndex = 0, offset = 0, offset_uv = 0, offset_uv2 = 0, offset_face = 0, offset_normal = 0, offset_tangent = 0, offset_line = 0, offset_color = 0, offset_skin = 0, offset_morphTarget = 0, offset_custom = 0, offset_customSrc = 0, value, vertexArray = geometryGroup.__vertexArray, uvArray = geometryGroup.__uvArray, uv2Array = geometryGroup.__uv2Array, normalArray = geometryGroup.__normalArray, tangentArray = geometryGroup.__tangentArray, colorArray = geometryGroup.__colorArray, skinIndexArray = geometryGroup.__skinIndexArray, skinWeightArray = geometryGroup.__skinWeightArray, morphTargetsArrays = geometryGroup.__morphTargetsArrays, morphNormalsArrays = geometryGroup.__morphNormalsArrays, customAttributes = geometryGroup.__webglCustomAttributesList, customAttribute, faceArray = geometryGroup.__faceArray, lineArray = geometryGroup.__lineArray, geometry = object.geometry, dirtyVertices = geometry.verticesNeedUpdate, dirtyElements = geometry.elementsNeedUpdate, dirtyUvs = geometry.uvsNeedUpdate, dirtyNormals = geometry.normalsNeedUpdate, dirtyTangents = geometry.tangentsNeedUpdate, dirtyColors = geometry.colorsNeedUpdate, dirtyMorphTargets = geometry.morphTargetsNeedUpdate, vertices = geometry.vertices, chunk_faces3 = geometryGroup.faces3, chunk_faces4 = geometryGroup.faces4, obj_faces = geometry.faces, obj_uvs = geometry.faceVertexUvs[0], obj_uvs2 = geometry.faceVertexUvs[1], obj_colors = geometry.colors, obj_skinIndices = geometry.skinIndices, obj_skinWeights = geometry.skinWeights, morphTargets = geometry.morphTargets, morphNormals = geometry.morphNormals;\n        if (dirtyVertices) {\n            for(f = 0, fl = chunk_faces3.length; f < fl; f++){\n                face = obj_faces[chunk_faces3[f]];\n                v1 = vertices[face.a];\n                v2 = vertices[face.b];\n                v3 = vertices[face.c];\n                vertexArray[offset] = v1.x;\n                vertexArray[offset + 1] = v1.y;\n                vertexArray[offset + 2] = v1.z;\n                vertexArray[offset + 3] = v2.x;\n                vertexArray[offset + 4] = v2.y;\n                vertexArray[offset + 5] = v2.z;\n                vertexArray[offset + 6] = v3.x;\n                vertexArray[offset + 7] = v3.y;\n                vertexArray[offset + 8] = v3.z;\n                offset += 9;\n            }\n            for(f = 0, fl = chunk_faces4.length; f < fl; f++){\n                face = obj_faces[chunk_faces4[f]];\n                v1 = vertices[face.a];\n                v2 = vertices[face.b];\n                v3 = vertices[face.c];\n                v4 = vertices[face.d];\n                vertexArray[offset] = v1.x;\n                vertexArray[offset + 1] = v1.y;\n                vertexArray[offset + 2] = v1.z;\n                vertexArray[offset + 3] = v2.x;\n                vertexArray[offset + 4] = v2.y;\n                vertexArray[offset + 5] = v2.z;\n                vertexArray[offset + 6] = v3.x;\n                vertexArray[offset + 7] = v3.y;\n                vertexArray[offset + 8] = v3.z;\n                vertexArray[offset + 9] = v4.x;\n                vertexArray[offset + 10] = v4.y;\n                vertexArray[offset + 11] = v4.z;\n                offset += 12;\n            }\n            _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer);\n            _gl.bufferData(_gl.ARRAY_BUFFER, vertexArray, hint);\n        }\n        if (dirtyMorphTargets) for(vk = 0, vkl = morphTargets.length; vk < vkl; vk++){\n            offset_morphTarget = 0;\n            for(f = 0, fl = chunk_faces3.length; f < fl; f++){\n                chf = chunk_faces3[f];\n                face = obj_faces[chf];\n                // morph positions\n                v1 = morphTargets[vk].vertices[face.a];\n                v2 = morphTargets[vk].vertices[face.b];\n                v3 = morphTargets[vk].vertices[face.c];\n                vka = morphTargetsArrays[vk];\n                vka[offset_morphTarget] = v1.x;\n                vka[offset_morphTarget + 1] = v1.y;\n                vka[offset_morphTarget + 2] = v1.z;\n                vka[offset_morphTarget + 3] = v2.x;\n                vka[offset_morphTarget + 4] = v2.y;\n                vka[offset_morphTarget + 5] = v2.z;\n                vka[offset_morphTarget + 6] = v3.x;\n                vka[offset_morphTarget + 7] = v3.y;\n                vka[offset_morphTarget + 8] = v3.z;\n                // morph normals\n                if (material.morphNormals) {\n                    if (needsSmoothNormals) {\n                        faceVertexNormals = morphNormals[vk].vertexNormals[chf];\n                        n1 = faceVertexNormals.a;\n                        n2 = faceVertexNormals.b;\n                        n3 = faceVertexNormals.c;\n                    } else {\n                        n1 = morphNormals[vk].faceNormals[chf];\n                        n2 = n1;\n                        n3 = n1;\n                    }\n                    nka = morphNormalsArrays[vk];\n                    nka[offset_morphTarget] = n1.x;\n                    nka[offset_morphTarget + 1] = n1.y;\n                    nka[offset_morphTarget + 2] = n1.z;\n                    nka[offset_morphTarget + 3] = n2.x;\n                    nka[offset_morphTarget + 4] = n2.y;\n                    nka[offset_morphTarget + 5] = n2.z;\n                    nka[offset_morphTarget + 6] = n3.x;\n                    nka[offset_morphTarget + 7] = n3.y;\n                    nka[offset_morphTarget + 8] = n3.z;\n                }\n                //\n                offset_morphTarget += 9;\n            }\n            for(f = 0, fl = chunk_faces4.length; f < fl; f++){\n                chf = chunk_faces4[f];\n                face = obj_faces[chf];\n                // morph positions\n                v1 = morphTargets[vk].vertices[face.a];\n                v2 = morphTargets[vk].vertices[face.b];\n                v3 = morphTargets[vk].vertices[face.c];\n                v4 = morphTargets[vk].vertices[face.d];\n                vka = morphTargetsArrays[vk];\n                vka[offset_morphTarget] = v1.x;\n                vka[offset_morphTarget + 1] = v1.y;\n                vka[offset_morphTarget + 2] = v1.z;\n                vka[offset_morphTarget + 3] = v2.x;\n                vka[offset_morphTarget + 4] = v2.y;\n                vka[offset_morphTarget + 5] = v2.z;\n                vka[offset_morphTarget + 6] = v3.x;\n                vka[offset_morphTarget + 7] = v3.y;\n                vka[offset_morphTarget + 8] = v3.z;\n                vka[offset_morphTarget + 9] = v4.x;\n                vka[offset_morphTarget + 10] = v4.y;\n                vka[offset_morphTarget + 11] = v4.z;\n                // morph normals\n                if (material.morphNormals) {\n                    if (needsSmoothNormals) {\n                        faceVertexNormals = morphNormals[vk].vertexNormals[chf];\n                        n1 = faceVertexNormals.a;\n                        n2 = faceVertexNormals.b;\n                        n3 = faceVertexNormals.c;\n                        n4 = faceVertexNormals.d;\n                    } else {\n                        n1 = morphNormals[vk].faceNormals[chf];\n                        n2 = n1;\n                        n3 = n1;\n                        n4 = n1;\n                    }\n                    nka = morphNormalsArrays[vk];\n                    nka[offset_morphTarget] = n1.x;\n                    nka[offset_morphTarget + 1] = n1.y;\n                    nka[offset_morphTarget + 2] = n1.z;\n                    nka[offset_morphTarget + 3] = n2.x;\n                    nka[offset_morphTarget + 4] = n2.y;\n                    nka[offset_morphTarget + 5] = n2.z;\n                    nka[offset_morphTarget + 6] = n3.x;\n                    nka[offset_morphTarget + 7] = n3.y;\n                    nka[offset_morphTarget + 8] = n3.z;\n                    nka[offset_morphTarget + 9] = n4.x;\n                    nka[offset_morphTarget + 10] = n4.y;\n                    nka[offset_morphTarget + 11] = n4.z;\n                }\n                //\n                offset_morphTarget += 12;\n            }\n            _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[vk]);\n            _gl.bufferData(_gl.ARRAY_BUFFER, morphTargetsArrays[vk], hint);\n            if (material.morphNormals) {\n                _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[vk]);\n                _gl.bufferData(_gl.ARRAY_BUFFER, morphNormalsArrays[vk], hint);\n            }\n        }\n        if (obj_skinWeights.length) {\n            for(f = 0, fl = chunk_faces3.length; f < fl; f++){\n                face = obj_faces[chunk_faces3[f]];\n                // weights\n                sw1 = obj_skinWeights[face.a];\n                sw2 = obj_skinWeights[face.b];\n                sw3 = obj_skinWeights[face.c];\n                skinWeightArray[offset_skin] = sw1.x;\n                skinWeightArray[offset_skin + 1] = sw1.y;\n                skinWeightArray[offset_skin + 2] = sw1.z;\n                skinWeightArray[offset_skin + 3] = sw1.w;\n                skinWeightArray[offset_skin + 4] = sw2.x;\n                skinWeightArray[offset_skin + 5] = sw2.y;\n                skinWeightArray[offset_skin + 6] = sw2.z;\n                skinWeightArray[offset_skin + 7] = sw2.w;\n                skinWeightArray[offset_skin + 8] = sw3.x;\n                skinWeightArray[offset_skin + 9] = sw3.y;\n                skinWeightArray[offset_skin + 10] = sw3.z;\n                skinWeightArray[offset_skin + 11] = sw3.w;\n                // indices\n                si1 = obj_skinIndices[face.a];\n                si2 = obj_skinIndices[face.b];\n                si3 = obj_skinIndices[face.c];\n                skinIndexArray[offset_skin] = si1.x;\n                skinIndexArray[offset_skin + 1] = si1.y;\n                skinIndexArray[offset_skin + 2] = si1.z;\n                skinIndexArray[offset_skin + 3] = si1.w;\n                skinIndexArray[offset_skin + 4] = si2.x;\n                skinIndexArray[offset_skin + 5] = si2.y;\n                skinIndexArray[offset_skin + 6] = si2.z;\n                skinIndexArray[offset_skin + 7] = si2.w;\n                skinIndexArray[offset_skin + 8] = si3.x;\n                skinIndexArray[offset_skin + 9] = si3.y;\n                skinIndexArray[offset_skin + 10] = si3.z;\n                skinIndexArray[offset_skin + 11] = si3.w;\n                offset_skin += 12;\n            }\n            for(f = 0, fl = chunk_faces4.length; f < fl; f++){\n                face = obj_faces[chunk_faces4[f]];\n                // weights\n                sw1 = obj_skinWeights[face.a];\n                sw2 = obj_skinWeights[face.b];\n                sw3 = obj_skinWeights[face.c];\n                sw4 = obj_skinWeights[face.d];\n                skinWeightArray[offset_skin] = sw1.x;\n                skinWeightArray[offset_skin + 1] = sw1.y;\n                skinWeightArray[offset_skin + 2] = sw1.z;\n                skinWeightArray[offset_skin + 3] = sw1.w;\n                skinWeightArray[offset_skin + 4] = sw2.x;\n                skinWeightArray[offset_skin + 5] = sw2.y;\n                skinWeightArray[offset_skin + 6] = sw2.z;\n                skinWeightArray[offset_skin + 7] = sw2.w;\n                skinWeightArray[offset_skin + 8] = sw3.x;\n                skinWeightArray[offset_skin + 9] = sw3.y;\n                skinWeightArray[offset_skin + 10] = sw3.z;\n                skinWeightArray[offset_skin + 11] = sw3.w;\n                skinWeightArray[offset_skin + 12] = sw4.x;\n                skinWeightArray[offset_skin + 13] = sw4.y;\n                skinWeightArray[offset_skin + 14] = sw4.z;\n                skinWeightArray[offset_skin + 15] = sw4.w;\n                // indices\n                si1 = obj_skinIndices[face.a];\n                si2 = obj_skinIndices[face.b];\n                si3 = obj_skinIndices[face.c];\n                si4 = obj_skinIndices[face.d];\n                skinIndexArray[offset_skin] = si1.x;\n                skinIndexArray[offset_skin + 1] = si1.y;\n                skinIndexArray[offset_skin + 2] = si1.z;\n                skinIndexArray[offset_skin + 3] = si1.w;\n                skinIndexArray[offset_skin + 4] = si2.x;\n                skinIndexArray[offset_skin + 5] = si2.y;\n                skinIndexArray[offset_skin + 6] = si2.z;\n                skinIndexArray[offset_skin + 7] = si2.w;\n                skinIndexArray[offset_skin + 8] = si3.x;\n                skinIndexArray[offset_skin + 9] = si3.y;\n                skinIndexArray[offset_skin + 10] = si3.z;\n                skinIndexArray[offset_skin + 11] = si3.w;\n                skinIndexArray[offset_skin + 12] = si4.x;\n                skinIndexArray[offset_skin + 13] = si4.y;\n                skinIndexArray[offset_skin + 14] = si4.z;\n                skinIndexArray[offset_skin + 15] = si4.w;\n                offset_skin += 16;\n            }\n            if (offset_skin > 0) {\n                _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer);\n                _gl.bufferData(_gl.ARRAY_BUFFER, skinIndexArray, hint);\n                _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer);\n                _gl.bufferData(_gl.ARRAY_BUFFER, skinWeightArray, hint);\n            }\n        }\n        if (dirtyColors && vertexColorType) {\n            for(f = 0, fl = chunk_faces3.length; f < fl; f++){\n                face = obj_faces[chunk_faces3[f]];\n                vertexColors = face.vertexColors;\n                faceColor = face.color;\n                if (vertexColors.length === 3 && vertexColorType === THREE.VertexColors) {\n                    c1 = vertexColors[0];\n                    c2 = vertexColors[1];\n                    c3 = vertexColors[2];\n                } else {\n                    c1 = faceColor;\n                    c2 = faceColor;\n                    c3 = faceColor;\n                }\n                colorArray[offset_color] = c1.r;\n                colorArray[offset_color + 1] = c1.g;\n                colorArray[offset_color + 2] = c1.b;\n                colorArray[offset_color + 3] = c2.r;\n                colorArray[offset_color + 4] = c2.g;\n                colorArray[offset_color + 5] = c2.b;\n                colorArray[offset_color + 6] = c3.r;\n                colorArray[offset_color + 7] = c3.g;\n                colorArray[offset_color + 8] = c3.b;\n                offset_color += 9;\n            }\n            for(f = 0, fl = chunk_faces4.length; f < fl; f++){\n                face = obj_faces[chunk_faces4[f]];\n                vertexColors = face.vertexColors;\n                faceColor = face.color;\n                if (vertexColors.length === 4 && vertexColorType === THREE.VertexColors) {\n                    c1 = vertexColors[0];\n                    c2 = vertexColors[1];\n                    c3 = vertexColors[2];\n                    c4 = vertexColors[3];\n                } else {\n                    c1 = faceColor;\n                    c2 = faceColor;\n                    c3 = faceColor;\n                    c4 = faceColor;\n                }\n                colorArray[offset_color] = c1.r;\n                colorArray[offset_color + 1] = c1.g;\n                colorArray[offset_color + 2] = c1.b;\n                colorArray[offset_color + 3] = c2.r;\n                colorArray[offset_color + 4] = c2.g;\n                colorArray[offset_color + 5] = c2.b;\n                colorArray[offset_color + 6] = c3.r;\n                colorArray[offset_color + 7] = c3.g;\n                colorArray[offset_color + 8] = c3.b;\n                colorArray[offset_color + 9] = c4.r;\n                colorArray[offset_color + 10] = c4.g;\n                colorArray[offset_color + 11] = c4.b;\n                offset_color += 12;\n            }\n            if (offset_color > 0) {\n                _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer);\n                _gl.bufferData(_gl.ARRAY_BUFFER, colorArray, hint);\n            }\n        }\n        if (dirtyTangents && geometry.hasTangents) {\n            for(f = 0, fl = chunk_faces3.length; f < fl; f++){\n                face = obj_faces[chunk_faces3[f]];\n                vertexTangents = face.vertexTangents;\n                t1 = vertexTangents[0];\n                t2 = vertexTangents[1];\n                t3 = vertexTangents[2];\n                tangentArray[offset_tangent] = t1.x;\n                tangentArray[offset_tangent + 1] = t1.y;\n                tangentArray[offset_tangent + 2] = t1.z;\n                tangentArray[offset_tangent + 3] = t1.w;\n                tangentArray[offset_tangent + 4] = t2.x;\n                tangentArray[offset_tangent + 5] = t2.y;\n                tangentArray[offset_tangent + 6] = t2.z;\n                tangentArray[offset_tangent + 7] = t2.w;\n                tangentArray[offset_tangent + 8] = t3.x;\n                tangentArray[offset_tangent + 9] = t3.y;\n                tangentArray[offset_tangent + 10] = t3.z;\n                tangentArray[offset_tangent + 11] = t3.w;\n                offset_tangent += 12;\n            }\n            for(f = 0, fl = chunk_faces4.length; f < fl; f++){\n                face = obj_faces[chunk_faces4[f]];\n                vertexTangents = face.vertexTangents;\n                t1 = vertexTangents[0];\n                t2 = vertexTangents[1];\n                t3 = vertexTangents[2];\n                t4 = vertexTangents[3];\n                tangentArray[offset_tangent] = t1.x;\n                tangentArray[offset_tangent + 1] = t1.y;\n                tangentArray[offset_tangent + 2] = t1.z;\n                tangentArray[offset_tangent + 3] = t1.w;\n                tangentArray[offset_tangent + 4] = t2.x;\n                tangentArray[offset_tangent + 5] = t2.y;\n                tangentArray[offset_tangent + 6] = t2.z;\n                tangentArray[offset_tangent + 7] = t2.w;\n                tangentArray[offset_tangent + 8] = t3.x;\n                tangentArray[offset_tangent + 9] = t3.y;\n                tangentArray[offset_tangent + 10] = t3.z;\n                tangentArray[offset_tangent + 11] = t3.w;\n                tangentArray[offset_tangent + 12] = t4.x;\n                tangentArray[offset_tangent + 13] = t4.y;\n                tangentArray[offset_tangent + 14] = t4.z;\n                tangentArray[offset_tangent + 15] = t4.w;\n                offset_tangent += 16;\n            }\n            _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer);\n            _gl.bufferData(_gl.ARRAY_BUFFER, tangentArray, hint);\n        }\n        if (dirtyNormals && normalType) {\n            for(f = 0, fl = chunk_faces3.length; f < fl; f++){\n                face = obj_faces[chunk_faces3[f]];\n                vertexNormals = face.vertexNormals;\n                faceNormal = face.normal;\n                if (vertexNormals.length === 3 && needsSmoothNormals) for(i = 0; i < 3; i++){\n                    vn = vertexNormals[i];\n                    normalArray[offset_normal] = vn.x;\n                    normalArray[offset_normal + 1] = vn.y;\n                    normalArray[offset_normal + 2] = vn.z;\n                    offset_normal += 3;\n                }\n                else for(i = 0; i < 3; i++){\n                    normalArray[offset_normal] = faceNormal.x;\n                    normalArray[offset_normal + 1] = faceNormal.y;\n                    normalArray[offset_normal + 2] = faceNormal.z;\n                    offset_normal += 3;\n                }\n            }\n            for(f = 0, fl = chunk_faces4.length; f < fl; f++){\n                face = obj_faces[chunk_faces4[f]];\n                vertexNormals = face.vertexNormals;\n                faceNormal = face.normal;\n                if (vertexNormals.length === 4 && needsSmoothNormals) for(i = 0; i < 4; i++){\n                    vn = vertexNormals[i];\n                    normalArray[offset_normal] = vn.x;\n                    normalArray[offset_normal + 1] = vn.y;\n                    normalArray[offset_normal + 2] = vn.z;\n                    offset_normal += 3;\n                }\n                else for(i = 0; i < 4; i++){\n                    normalArray[offset_normal] = faceNormal.x;\n                    normalArray[offset_normal + 1] = faceNormal.y;\n                    normalArray[offset_normal + 2] = faceNormal.z;\n                    offset_normal += 3;\n                }\n            }\n            _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer);\n            _gl.bufferData(_gl.ARRAY_BUFFER, normalArray, hint);\n        }\n        if (dirtyUvs && obj_uvs && uvType) {\n            for(f = 0, fl = chunk_faces3.length; f < fl; f++){\n                fi = chunk_faces3[f];\n                uv = obj_uvs[fi];\n                if (uv === undefined) continue;\n                for(i = 0; i < 3; i++){\n                    uvi = uv[i];\n                    uvArray[offset_uv] = uvi.x;\n                    uvArray[offset_uv + 1] = uvi.y;\n                    offset_uv += 2;\n                }\n            }\n            for(f = 0, fl = chunk_faces4.length; f < fl; f++){\n                fi = chunk_faces4[f];\n                uv = obj_uvs[fi];\n                if (uv === undefined) continue;\n                for(i = 0; i < 4; i++){\n                    uvi = uv[i];\n                    uvArray[offset_uv] = uvi.x;\n                    uvArray[offset_uv + 1] = uvi.y;\n                    offset_uv += 2;\n                }\n            }\n            if (offset_uv > 0) {\n                _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer);\n                _gl.bufferData(_gl.ARRAY_BUFFER, uvArray, hint);\n            }\n        }\n        if (dirtyUvs && obj_uvs2 && uvType) {\n            for(f = 0, fl = chunk_faces3.length; f < fl; f++){\n                fi = chunk_faces3[f];\n                uv2 = obj_uvs2[fi];\n                if (uv2 === undefined) continue;\n                for(i = 0; i < 3; i++){\n                    uv2i = uv2[i];\n                    uv2Array[offset_uv2] = uv2i.x;\n                    uv2Array[offset_uv2 + 1] = uv2i.y;\n                    offset_uv2 += 2;\n                }\n            }\n            for(f = 0, fl = chunk_faces4.length; f < fl; f++){\n                fi = chunk_faces4[f];\n                uv2 = obj_uvs2[fi];\n                if (uv2 === undefined) continue;\n                for(i = 0; i < 4; i++){\n                    uv2i = uv2[i];\n                    uv2Array[offset_uv2] = uv2i.x;\n                    uv2Array[offset_uv2 + 1] = uv2i.y;\n                    offset_uv2 += 2;\n                }\n            }\n            if (offset_uv2 > 0) {\n                _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer);\n                _gl.bufferData(_gl.ARRAY_BUFFER, uv2Array, hint);\n            }\n        }\n        if (dirtyElements) {\n            for(f = 0, fl = chunk_faces3.length; f < fl; f++){\n                faceArray[offset_face] = vertexIndex;\n                faceArray[offset_face + 1] = vertexIndex + 1;\n                faceArray[offset_face + 2] = vertexIndex + 2;\n                offset_face += 3;\n                lineArray[offset_line] = vertexIndex;\n                lineArray[offset_line + 1] = vertexIndex + 1;\n                lineArray[offset_line + 2] = vertexIndex;\n                lineArray[offset_line + 3] = vertexIndex + 2;\n                lineArray[offset_line + 4] = vertexIndex + 1;\n                lineArray[offset_line + 5] = vertexIndex + 2;\n                offset_line += 6;\n                vertexIndex += 3;\n            }\n            for(f = 0, fl = chunk_faces4.length; f < fl; f++){\n                faceArray[offset_face] = vertexIndex;\n                faceArray[offset_face + 1] = vertexIndex + 1;\n                faceArray[offset_face + 2] = vertexIndex + 3;\n                faceArray[offset_face + 3] = vertexIndex + 1;\n                faceArray[offset_face + 4] = vertexIndex + 2;\n                faceArray[offset_face + 5] = vertexIndex + 3;\n                offset_face += 6;\n                lineArray[offset_line] = vertexIndex;\n                lineArray[offset_line + 1] = vertexIndex + 1;\n                lineArray[offset_line + 2] = vertexIndex;\n                lineArray[offset_line + 3] = vertexIndex + 3;\n                lineArray[offset_line + 4] = vertexIndex + 1;\n                lineArray[offset_line + 5] = vertexIndex + 2;\n                lineArray[offset_line + 6] = vertexIndex + 2;\n                lineArray[offset_line + 7] = vertexIndex + 3;\n                offset_line += 8;\n                vertexIndex += 4;\n            }\n            _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer);\n            _gl.bufferData(_gl.ELEMENT_ARRAY_BUFFER, faceArray, hint);\n            _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer);\n            _gl.bufferData(_gl.ELEMENT_ARRAY_BUFFER, lineArray, hint);\n        }\n        if (customAttributes) for(i = 0, il = customAttributes.length; i < il; i++){\n            customAttribute = customAttributes[i];\n            if (!customAttribute.__original.needsUpdate) continue;\n            offset_custom = 0;\n            offset_customSrc = 0;\n            if (customAttribute.size === 1) {\n                if (customAttribute.boundTo === undefined || customAttribute.boundTo === \"vertices\") {\n                    for(f = 0, fl = chunk_faces3.length; f < fl; f++){\n                        face = obj_faces[chunk_faces3[f]];\n                        customAttribute.array[offset_custom] = customAttribute.value[face.a];\n                        customAttribute.array[offset_custom + 1] = customAttribute.value[face.b];\n                        customAttribute.array[offset_custom + 2] = customAttribute.value[face.c];\n                        offset_custom += 3;\n                    }\n                    for(f = 0, fl = chunk_faces4.length; f < fl; f++){\n                        face = obj_faces[chunk_faces4[f]];\n                        customAttribute.array[offset_custom] = customAttribute.value[face.a];\n                        customAttribute.array[offset_custom + 1] = customAttribute.value[face.b];\n                        customAttribute.array[offset_custom + 2] = customAttribute.value[face.c];\n                        customAttribute.array[offset_custom + 3] = customAttribute.value[face.d];\n                        offset_custom += 4;\n                    }\n                } else if (customAttribute.boundTo === \"faces\") {\n                    for(f = 0, fl = chunk_faces3.length; f < fl; f++){\n                        value = customAttribute.value[chunk_faces3[f]];\n                        customAttribute.array[offset_custom] = value;\n                        customAttribute.array[offset_custom + 1] = value;\n                        customAttribute.array[offset_custom + 2] = value;\n                        offset_custom += 3;\n                    }\n                    for(f = 0, fl = chunk_faces4.length; f < fl; f++){\n                        value = customAttribute.value[chunk_faces4[f]];\n                        customAttribute.array[offset_custom] = value;\n                        customAttribute.array[offset_custom + 1] = value;\n                        customAttribute.array[offset_custom + 2] = value;\n                        customAttribute.array[offset_custom + 3] = value;\n                        offset_custom += 4;\n                    }\n                }\n            } else if (customAttribute.size === 2) {\n                if (customAttribute.boundTo === undefined || customAttribute.boundTo === \"vertices\") {\n                    for(f = 0, fl = chunk_faces3.length; f < fl; f++){\n                        face = obj_faces[chunk_faces3[f]];\n                        v1 = customAttribute.value[face.a];\n                        v2 = customAttribute.value[face.b];\n                        v3 = customAttribute.value[face.c];\n                        customAttribute.array[offset_custom] = v1.x;\n                        customAttribute.array[offset_custom + 1] = v1.y;\n                        customAttribute.array[offset_custom + 2] = v2.x;\n                        customAttribute.array[offset_custom + 3] = v2.y;\n                        customAttribute.array[offset_custom + 4] = v3.x;\n                        customAttribute.array[offset_custom + 5] = v3.y;\n                        offset_custom += 6;\n                    }\n                    for(f = 0, fl = chunk_faces4.length; f < fl; f++){\n                        face = obj_faces[chunk_faces4[f]];\n                        v1 = customAttribute.value[face.a];\n                        v2 = customAttribute.value[face.b];\n                        v3 = customAttribute.value[face.c];\n                        v4 = customAttribute.value[face.d];\n                        customAttribute.array[offset_custom] = v1.x;\n                        customAttribute.array[offset_custom + 1] = v1.y;\n                        customAttribute.array[offset_custom + 2] = v2.x;\n                        customAttribute.array[offset_custom + 3] = v2.y;\n                        customAttribute.array[offset_custom + 4] = v3.x;\n                        customAttribute.array[offset_custom + 5] = v3.y;\n                        customAttribute.array[offset_custom + 6] = v4.x;\n                        customAttribute.array[offset_custom + 7] = v4.y;\n                        offset_custom += 8;\n                    }\n                } else if (customAttribute.boundTo === \"faces\") {\n                    for(f = 0, fl = chunk_faces3.length; f < fl; f++){\n                        value = customAttribute.value[chunk_faces3[f]];\n                        v1 = value;\n                        v2 = value;\n                        v3 = value;\n                        customAttribute.array[offset_custom] = v1.x;\n                        customAttribute.array[offset_custom + 1] = v1.y;\n                        customAttribute.array[offset_custom + 2] = v2.x;\n                        customAttribute.array[offset_custom + 3] = v2.y;\n                        customAttribute.array[offset_custom + 4] = v3.x;\n                        customAttribute.array[offset_custom + 5] = v3.y;\n                        offset_custom += 6;\n                    }\n                    for(f = 0, fl = chunk_faces4.length; f < fl; f++){\n                        value = customAttribute.value[chunk_faces4[f]];\n                        v1 = value;\n                        v2 = value;\n                        v3 = value;\n                        v4 = value;\n                        customAttribute.array[offset_custom] = v1.x;\n                        customAttribute.array[offset_custom + 1] = v1.y;\n                        customAttribute.array[offset_custom + 2] = v2.x;\n                        customAttribute.array[offset_custom + 3] = v2.y;\n                        customAttribute.array[offset_custom + 4] = v3.x;\n                        customAttribute.array[offset_custom + 5] = v3.y;\n                        customAttribute.array[offset_custom + 6] = v4.x;\n                        customAttribute.array[offset_custom + 7] = v4.y;\n                        offset_custom += 8;\n                    }\n                }\n            } else if (customAttribute.size === 3) {\n                var pp;\n                if (customAttribute.type === \"c\") pp = [\n                    \"r\",\n                    \"g\",\n                    \"b\"\n                ];\n                else pp = [\n                    \"x\",\n                    \"y\",\n                    \"z\"\n                ];\n                if (customAttribute.boundTo === undefined || customAttribute.boundTo === \"vertices\") {\n                    for(f = 0, fl = chunk_faces3.length; f < fl; f++){\n                        face = obj_faces[chunk_faces3[f]];\n                        v1 = customAttribute.value[face.a];\n                        v2 = customAttribute.value[face.b];\n                        v3 = customAttribute.value[face.c];\n                        customAttribute.array[offset_custom] = v1[pp[0]];\n                        customAttribute.array[offset_custom + 1] = v1[pp[1]];\n                        customAttribute.array[offset_custom + 2] = v1[pp[2]];\n                        customAttribute.array[offset_custom + 3] = v2[pp[0]];\n                        customAttribute.array[offset_custom + 4] = v2[pp[1]];\n                        customAttribute.array[offset_custom + 5] = v2[pp[2]];\n                        customAttribute.array[offset_custom + 6] = v3[pp[0]];\n                        customAttribute.array[offset_custom + 7] = v3[pp[1]];\n                        customAttribute.array[offset_custom + 8] = v3[pp[2]];\n                        offset_custom += 9;\n                    }\n                    for(f = 0, fl = chunk_faces4.length; f < fl; f++){\n                        face = obj_faces[chunk_faces4[f]];\n                        v1 = customAttribute.value[face.a];\n                        v2 = customAttribute.value[face.b];\n                        v3 = customAttribute.value[face.c];\n                        v4 = customAttribute.value[face.d];\n                        customAttribute.array[offset_custom] = v1[pp[0]];\n                        customAttribute.array[offset_custom + 1] = v1[pp[1]];\n                        customAttribute.array[offset_custom + 2] = v1[pp[2]];\n                        customAttribute.array[offset_custom + 3] = v2[pp[0]];\n                        customAttribute.array[offset_custom + 4] = v2[pp[1]];\n                        customAttribute.array[offset_custom + 5] = v2[pp[2]];\n                        customAttribute.array[offset_custom + 6] = v3[pp[0]];\n                        customAttribute.array[offset_custom + 7] = v3[pp[1]];\n                        customAttribute.array[offset_custom + 8] = v3[pp[2]];\n                        customAttribute.array[offset_custom + 9] = v4[pp[0]];\n                        customAttribute.array[offset_custom + 10] = v4[pp[1]];\n                        customAttribute.array[offset_custom + 11] = v4[pp[2]];\n                        offset_custom += 12;\n                    }\n                } else if (customAttribute.boundTo === \"faces\") {\n                    for(f = 0, fl = chunk_faces3.length; f < fl; f++){\n                        value = customAttribute.value[chunk_faces3[f]];\n                        v1 = value;\n                        v2 = value;\n                        v3 = value;\n                        customAttribute.array[offset_custom] = v1[pp[0]];\n                        customAttribute.array[offset_custom + 1] = v1[pp[1]];\n                        customAttribute.array[offset_custom + 2] = v1[pp[2]];\n                        customAttribute.array[offset_custom + 3] = v2[pp[0]];\n                        customAttribute.array[offset_custom + 4] = v2[pp[1]];\n                        customAttribute.array[offset_custom + 5] = v2[pp[2]];\n                        customAttribute.array[offset_custom + 6] = v3[pp[0]];\n                        customAttribute.array[offset_custom + 7] = v3[pp[1]];\n                        customAttribute.array[offset_custom + 8] = v3[pp[2]];\n                        offset_custom += 9;\n                    }\n                    for(f = 0, fl = chunk_faces4.length; f < fl; f++){\n                        value = customAttribute.value[chunk_faces4[f]];\n                        v1 = value;\n                        v2 = value;\n                        v3 = value;\n                        v4 = value;\n                        customAttribute.array[offset_custom] = v1[pp[0]];\n                        customAttribute.array[offset_custom + 1] = v1[pp[1]];\n                        customAttribute.array[offset_custom + 2] = v1[pp[2]];\n                        customAttribute.array[offset_custom + 3] = v2[pp[0]];\n                        customAttribute.array[offset_custom + 4] = v2[pp[1]];\n                        customAttribute.array[offset_custom + 5] = v2[pp[2]];\n                        customAttribute.array[offset_custom + 6] = v3[pp[0]];\n                        customAttribute.array[offset_custom + 7] = v3[pp[1]];\n                        customAttribute.array[offset_custom + 8] = v3[pp[2]];\n                        customAttribute.array[offset_custom + 9] = v4[pp[0]];\n                        customAttribute.array[offset_custom + 10] = v4[pp[1]];\n                        customAttribute.array[offset_custom + 11] = v4[pp[2]];\n                        offset_custom += 12;\n                    }\n                } else if (customAttribute.boundTo === \"faceVertices\") {\n                    for(f = 0, fl = chunk_faces3.length; f < fl; f++){\n                        value = customAttribute.value[chunk_faces3[f]];\n                        v1 = value[0];\n                        v2 = value[1];\n                        v3 = value[2];\n                        customAttribute.array[offset_custom] = v1[pp[0]];\n                        customAttribute.array[offset_custom + 1] = v1[pp[1]];\n                        customAttribute.array[offset_custom + 2] = v1[pp[2]];\n                        customAttribute.array[offset_custom + 3] = v2[pp[0]];\n                        customAttribute.array[offset_custom + 4] = v2[pp[1]];\n                        customAttribute.array[offset_custom + 5] = v2[pp[2]];\n                        customAttribute.array[offset_custom + 6] = v3[pp[0]];\n                        customAttribute.array[offset_custom + 7] = v3[pp[1]];\n                        customAttribute.array[offset_custom + 8] = v3[pp[2]];\n                        offset_custom += 9;\n                    }\n                    for(f = 0, fl = chunk_faces4.length; f < fl; f++){\n                        value = customAttribute.value[chunk_faces4[f]];\n                        v1 = value[0];\n                        v2 = value[1];\n                        v3 = value[2];\n                        v4 = value[3];\n                        customAttribute.array[offset_custom] = v1[pp[0]];\n                        customAttribute.array[offset_custom + 1] = v1[pp[1]];\n                        customAttribute.array[offset_custom + 2] = v1[pp[2]];\n                        customAttribute.array[offset_custom + 3] = v2[pp[0]];\n                        customAttribute.array[offset_custom + 4] = v2[pp[1]];\n                        customAttribute.array[offset_custom + 5] = v2[pp[2]];\n                        customAttribute.array[offset_custom + 6] = v3[pp[0]];\n                        customAttribute.array[offset_custom + 7] = v3[pp[1]];\n                        customAttribute.array[offset_custom + 8] = v3[pp[2]];\n                        customAttribute.array[offset_custom + 9] = v4[pp[0]];\n                        customAttribute.array[offset_custom + 10] = v4[pp[1]];\n                        customAttribute.array[offset_custom + 11] = v4[pp[2]];\n                        offset_custom += 12;\n                    }\n                }\n            } else if (customAttribute.size === 4) {\n                if (customAttribute.boundTo === undefined || customAttribute.boundTo === \"vertices\") {\n                    for(f = 0, fl = chunk_faces3.length; f < fl; f++){\n                        face = obj_faces[chunk_faces3[f]];\n                        v1 = customAttribute.value[face.a];\n                        v2 = customAttribute.value[face.b];\n                        v3 = customAttribute.value[face.c];\n                        customAttribute.array[offset_custom] = v1.x;\n                        customAttribute.array[offset_custom + 1] = v1.y;\n                        customAttribute.array[offset_custom + 2] = v1.z;\n                        customAttribute.array[offset_custom + 3] = v1.w;\n                        customAttribute.array[offset_custom + 4] = v2.x;\n                        customAttribute.array[offset_custom + 5] = v2.y;\n                        customAttribute.array[offset_custom + 6] = v2.z;\n                        customAttribute.array[offset_custom + 7] = v2.w;\n                        customAttribute.array[offset_custom + 8] = v3.x;\n                        customAttribute.array[offset_custom + 9] = v3.y;\n                        customAttribute.array[offset_custom + 10] = v3.z;\n                        customAttribute.array[offset_custom + 11] = v3.w;\n                        offset_custom += 12;\n                    }\n                    for(f = 0, fl = chunk_faces4.length; f < fl; f++){\n                        face = obj_faces[chunk_faces4[f]];\n                        v1 = customAttribute.value[face.a];\n                        v2 = customAttribute.value[face.b];\n                        v3 = customAttribute.value[face.c];\n                        v4 = customAttribute.value[face.d];\n                        customAttribute.array[offset_custom] = v1.x;\n                        customAttribute.array[offset_custom + 1] = v1.y;\n                        customAttribute.array[offset_custom + 2] = v1.z;\n                        customAttribute.array[offset_custom + 3] = v1.w;\n                        customAttribute.array[offset_custom + 4] = v2.x;\n                        customAttribute.array[offset_custom + 5] = v2.y;\n                        customAttribute.array[offset_custom + 6] = v2.z;\n                        customAttribute.array[offset_custom + 7] = v2.w;\n                        customAttribute.array[offset_custom + 8] = v3.x;\n                        customAttribute.array[offset_custom + 9] = v3.y;\n                        customAttribute.array[offset_custom + 10] = v3.z;\n                        customAttribute.array[offset_custom + 11] = v3.w;\n                        customAttribute.array[offset_custom + 12] = v4.x;\n                        customAttribute.array[offset_custom + 13] = v4.y;\n                        customAttribute.array[offset_custom + 14] = v4.z;\n                        customAttribute.array[offset_custom + 15] = v4.w;\n                        offset_custom += 16;\n                    }\n                } else if (customAttribute.boundTo === \"faces\") {\n                    for(f = 0, fl = chunk_faces3.length; f < fl; f++){\n                        value = customAttribute.value[chunk_faces3[f]];\n                        v1 = value;\n                        v2 = value;\n                        v3 = value;\n                        customAttribute.array[offset_custom] = v1.x;\n                        customAttribute.array[offset_custom + 1] = v1.y;\n                        customAttribute.array[offset_custom + 2] = v1.z;\n                        customAttribute.array[offset_custom + 3] = v1.w;\n                        customAttribute.array[offset_custom + 4] = v2.x;\n                        customAttribute.array[offset_custom + 5] = v2.y;\n                        customAttribute.array[offset_custom + 6] = v2.z;\n                        customAttribute.array[offset_custom + 7] = v2.w;\n                        customAttribute.array[offset_custom + 8] = v3.x;\n                        customAttribute.array[offset_custom + 9] = v3.y;\n                        customAttribute.array[offset_custom + 10] = v3.z;\n                        customAttribute.array[offset_custom + 11] = v3.w;\n                        offset_custom += 12;\n                    }\n                    for(f = 0, fl = chunk_faces4.length; f < fl; f++){\n                        value = customAttribute.value[chunk_faces4[f]];\n                        v1 = value;\n                        v2 = value;\n                        v3 = value;\n                        v4 = value;\n                        customAttribute.array[offset_custom] = v1.x;\n                        customAttribute.array[offset_custom + 1] = v1.y;\n                        customAttribute.array[offset_custom + 2] = v1.z;\n                        customAttribute.array[offset_custom + 3] = v1.w;\n                        customAttribute.array[offset_custom + 4] = v2.x;\n                        customAttribute.array[offset_custom + 5] = v2.y;\n                        customAttribute.array[offset_custom + 6] = v2.z;\n                        customAttribute.array[offset_custom + 7] = v2.w;\n                        customAttribute.array[offset_custom + 8] = v3.x;\n                        customAttribute.array[offset_custom + 9] = v3.y;\n                        customAttribute.array[offset_custom + 10] = v3.z;\n                        customAttribute.array[offset_custom + 11] = v3.w;\n                        customAttribute.array[offset_custom + 12] = v4.x;\n                        customAttribute.array[offset_custom + 13] = v4.y;\n                        customAttribute.array[offset_custom + 14] = v4.z;\n                        customAttribute.array[offset_custom + 15] = v4.w;\n                        offset_custom += 16;\n                    }\n                } else if (customAttribute.boundTo === \"faceVertices\") {\n                    for(f = 0, fl = chunk_faces3.length; f < fl; f++){\n                        value = customAttribute.value[chunk_faces3[f]];\n                        v1 = value[0];\n                        v2 = value[1];\n                        v3 = value[2];\n                        customAttribute.array[offset_custom] = v1.x;\n                        customAttribute.array[offset_custom + 1] = v1.y;\n                        customAttribute.array[offset_custom + 2] = v1.z;\n                        customAttribute.array[offset_custom + 3] = v1.w;\n                        customAttribute.array[offset_custom + 4] = v2.x;\n                        customAttribute.array[offset_custom + 5] = v2.y;\n                        customAttribute.array[offset_custom + 6] = v2.z;\n                        customAttribute.array[offset_custom + 7] = v2.w;\n                        customAttribute.array[offset_custom + 8] = v3.x;\n                        customAttribute.array[offset_custom + 9] = v3.y;\n                        customAttribute.array[offset_custom + 10] = v3.z;\n                        customAttribute.array[offset_custom + 11] = v3.w;\n                        offset_custom += 12;\n                    }\n                    for(f = 0, fl = chunk_faces4.length; f < fl; f++){\n                        value = customAttribute.value[chunk_faces4[f]];\n                        v1 = value[0];\n                        v2 = value[1];\n                        v3 = value[2];\n                        v4 = value[3];\n                        customAttribute.array[offset_custom] = v1.x;\n                        customAttribute.array[offset_custom + 1] = v1.y;\n                        customAttribute.array[offset_custom + 2] = v1.z;\n                        customAttribute.array[offset_custom + 3] = v1.w;\n                        customAttribute.array[offset_custom + 4] = v2.x;\n                        customAttribute.array[offset_custom + 5] = v2.y;\n                        customAttribute.array[offset_custom + 6] = v2.z;\n                        customAttribute.array[offset_custom + 7] = v2.w;\n                        customAttribute.array[offset_custom + 8] = v3.x;\n                        customAttribute.array[offset_custom + 9] = v3.y;\n                        customAttribute.array[offset_custom + 10] = v3.z;\n                        customAttribute.array[offset_custom + 11] = v3.w;\n                        customAttribute.array[offset_custom + 12] = v4.x;\n                        customAttribute.array[offset_custom + 13] = v4.y;\n                        customAttribute.array[offset_custom + 14] = v4.z;\n                        customAttribute.array[offset_custom + 15] = v4.w;\n                        offset_custom += 16;\n                    }\n                }\n            }\n            _gl.bindBuffer(_gl.ARRAY_BUFFER, customAttribute.buffer);\n            _gl.bufferData(_gl.ARRAY_BUFFER, customAttribute.array, hint);\n        }\n        if (dispose) {\n            delete geometryGroup.__inittedArrays;\n            delete geometryGroup.__colorArray;\n            delete geometryGroup.__normalArray;\n            delete geometryGroup.__tangentArray;\n            delete geometryGroup.__uvArray;\n            delete geometryGroup.__uv2Array;\n            delete geometryGroup.__faceArray;\n            delete geometryGroup.__vertexArray;\n            delete geometryGroup.__lineArray;\n            delete geometryGroup.__skinIndexArray;\n            delete geometryGroup.__skinWeightArray;\n        }\n    }\n    function setDirectBuffers(geometry, hint, dispose) {\n        var attributes = geometry.attributes;\n        var index = attributes[\"index\"];\n        var position = attributes[\"position\"];\n        var normal = attributes[\"normal\"];\n        var uv = attributes[\"uv\"];\n        var color = attributes[\"color\"];\n        var tangent = attributes[\"tangent\"];\n        if (geometry.elementsNeedUpdate && index !== undefined) {\n            _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, index.buffer);\n            _gl.bufferData(_gl.ELEMENT_ARRAY_BUFFER, index.array, hint);\n        }\n        if (geometry.verticesNeedUpdate && position !== undefined) {\n            _gl.bindBuffer(_gl.ARRAY_BUFFER, position.buffer);\n            _gl.bufferData(_gl.ARRAY_BUFFER, position.array, hint);\n        }\n        if (geometry.normalsNeedUpdate && normal !== undefined) {\n            _gl.bindBuffer(_gl.ARRAY_BUFFER, normal.buffer);\n            _gl.bufferData(_gl.ARRAY_BUFFER, normal.array, hint);\n        }\n        if (geometry.uvsNeedUpdate && uv !== undefined) {\n            _gl.bindBuffer(_gl.ARRAY_BUFFER, uv.buffer);\n            _gl.bufferData(_gl.ARRAY_BUFFER, uv.array, hint);\n        }\n        if (geometry.colorsNeedUpdate && color !== undefined) {\n            _gl.bindBuffer(_gl.ARRAY_BUFFER, color.buffer);\n            _gl.bufferData(_gl.ARRAY_BUFFER, color.array, hint);\n        }\n        if (geometry.tangentsNeedUpdate && tangent !== undefined) {\n            _gl.bindBuffer(_gl.ARRAY_BUFFER, tangent.buffer);\n            _gl.bufferData(_gl.ARRAY_BUFFER, tangent.array, hint);\n        }\n        if (dispose) for(var i in geometry.attributes)delete geometry.attributes[i].array;\n    }\n    // Buffer rendering\n    this.renderBufferImmediate = function(object, program, material) {\n        if (object.hasPositions && !object.__webglVertexBuffer) object.__webglVertexBuffer = _gl.createBuffer();\n        if (object.hasNormals && !object.__webglNormalBuffer) object.__webglNormalBuffer = _gl.createBuffer();\n        if (object.hasUvs && !object.__webglUvBuffer) object.__webglUvBuffer = _gl.createBuffer();\n        if (object.hasColors && !object.__webglColorBuffer) object.__webglColorBuffer = _gl.createBuffer();\n        if (object.hasPositions) {\n            _gl.bindBuffer(_gl.ARRAY_BUFFER, object.__webglVertexBuffer);\n            _gl.bufferData(_gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW);\n            _gl.enableVertexAttribArray(program.attributes.position);\n            _gl.vertexAttribPointer(program.attributes.position, 3, _gl.FLOAT, false, 0, 0);\n        }\n        if (object.hasNormals) {\n            _gl.bindBuffer(_gl.ARRAY_BUFFER, object.__webglNormalBuffer);\n            if (material.shading === THREE.FlatShading) {\n                var nx, ny, nz, nax, nbx, ncx, nay, nby, ncy, naz, nbz, ncz, normalArray, i, il = object.count * 3;\n                for(i = 0; i < il; i += 9){\n                    normalArray = object.normalArray;\n                    nax = normalArray[i];\n                    nay = normalArray[i + 1];\n                    naz = normalArray[i + 2];\n                    nbx = normalArray[i + 3];\n                    nby = normalArray[i + 4];\n                    nbz = normalArray[i + 5];\n                    ncx = normalArray[i + 6];\n                    ncy = normalArray[i + 7];\n                    ncz = normalArray[i + 8];\n                    nx = (nax + nbx + ncx) / 3;\n                    ny = (nay + nby + ncy) / 3;\n                    nz = (naz + nbz + ncz) / 3;\n                    normalArray[i] = nx;\n                    normalArray[i + 1] = ny;\n                    normalArray[i + 2] = nz;\n                    normalArray[i + 3] = nx;\n                    normalArray[i + 4] = ny;\n                    normalArray[i + 5] = nz;\n                    normalArray[i + 6] = nx;\n                    normalArray[i + 7] = ny;\n                    normalArray[i + 8] = nz;\n                }\n            }\n            _gl.bufferData(_gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW);\n            _gl.enableVertexAttribArray(program.attributes.normal);\n            _gl.vertexAttribPointer(program.attributes.normal, 3, _gl.FLOAT, false, 0, 0);\n        }\n        if (object.hasUvs && material.map) {\n            _gl.bindBuffer(_gl.ARRAY_BUFFER, object.__webglUvBuffer);\n            _gl.bufferData(_gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW);\n            _gl.enableVertexAttribArray(program.attributes.uv);\n            _gl.vertexAttribPointer(program.attributes.uv, 2, _gl.FLOAT, false, 0, 0);\n        }\n        if (object.hasColors && material.vertexColors !== THREE.NoColors) {\n            _gl.bindBuffer(_gl.ARRAY_BUFFER, object.__webglColorBuffer);\n            _gl.bufferData(_gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW);\n            _gl.enableVertexAttribArray(program.attributes.color);\n            _gl.vertexAttribPointer(program.attributes.color, 3, _gl.FLOAT, false, 0, 0);\n        }\n        _gl.drawArrays(_gl.TRIANGLES, 0, object.count);\n        object.count = 0;\n    };\n    this.renderBufferDirect = function(camera, lights, fog, material, geometry, object) {\n        if (material.visible === false) return;\n        var program, attributes, linewidth, primitives, a, attribute;\n        program = setProgram(camera, lights, fog, material, object);\n        attributes = program.attributes;\n        var updateBuffers = false, wireframeBit = material.wireframe ? 1 : 0, geometryHash = geometry.id * 0xffffff + program.id * 2 + wireframeBit;\n        if (geometryHash !== _currentGeometryGroupHash) {\n            _currentGeometryGroupHash = geometryHash;\n            updateBuffers = true;\n        }\n        if (updateBuffers) disableAttributes();\n        // render mesh\n        if (object instanceof THREE.Mesh) {\n            var index = geometry.attributes[\"index\"];\n            // indexed triangles\n            if (index) {\n                var offsets = geometry.offsets;\n                // if there is more than 1 chunk\n                // must set attribute pointers to use new offsets for each chunk\n                // even if geometry and materials didn't change\n                if (offsets.length > 1) updateBuffers = true;\n                for(var i = 0, il = offsets.length; i < il; i++){\n                    var startIndex = offsets[i].index;\n                    if (updateBuffers) {\n                        // vertices\n                        var position = geometry.attributes[\"position\"];\n                        var positionSize = position.itemSize;\n                        _gl.bindBuffer(_gl.ARRAY_BUFFER, position.buffer);\n                        enableAttribute(attributes.position);\n                        _gl.vertexAttribPointer(attributes.position, positionSize, _gl.FLOAT, false, 0, startIndex * positionSize * 4); // 4 bytes per Float32\n                        // normals\n                        var normal = geometry.attributes[\"normal\"];\n                        if (attributes.normal >= 0 && normal) {\n                            var normalSize = normal.itemSize;\n                            _gl.bindBuffer(_gl.ARRAY_BUFFER, normal.buffer);\n                            enableAttribute(attributes.normal);\n                            _gl.vertexAttribPointer(attributes.normal, normalSize, _gl.FLOAT, false, 0, startIndex * normalSize * 4);\n                        }\n                        // uvs\n                        var uv = geometry.attributes[\"uv\"];\n                        if (attributes.uv >= 0 && uv) {\n                            var uvSize = uv.itemSize;\n                            _gl.bindBuffer(_gl.ARRAY_BUFFER, uv.buffer);\n                            enableAttribute(attributes.uv);\n                            _gl.vertexAttribPointer(attributes.uv, uvSize, _gl.FLOAT, false, 0, startIndex * uvSize * 4);\n                        }\n                        // colors\n                        var color = geometry.attributes[\"color\"];\n                        if (attributes.color >= 0 && color) {\n                            var colorSize = color.itemSize;\n                            _gl.bindBuffer(_gl.ARRAY_BUFFER, color.buffer);\n                            enableAttribute(attributes.color);\n                            _gl.vertexAttribPointer(attributes.color, colorSize, _gl.FLOAT, false, 0, startIndex * colorSize * 4);\n                        }\n                        // tangents\n                        var tangent = geometry.attributes[\"tangent\"];\n                        if (attributes.tangent >= 0 && tangent) {\n                            var tangentSize = tangent.itemSize;\n                            _gl.bindBuffer(_gl.ARRAY_BUFFER, tangent.buffer);\n                            enableAttribute(attributes.tangent);\n                            _gl.vertexAttribPointer(attributes.tangent, tangentSize, _gl.FLOAT, false, 0, startIndex * tangentSize * 4);\n                        }\n                        // indices\n                        _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, index.buffer);\n                    }\n                    // render indexed triangles\n                    _gl.drawElements(_gl.TRIANGLES, offsets[i].count, _gl.UNSIGNED_SHORT, offsets[i].start * 2); // 2 bytes per Uint16\n                    _this.info.render.calls++;\n                    _this.info.render.vertices += offsets[i].count; // not really true, here vertices can be shared\n                    _this.info.render.faces += offsets[i].count / 3;\n                }\n            // non-indexed triangles\n            } else {\n                if (updateBuffers) {\n                    // vertices\n                    var position = geometry.attributes[\"position\"];\n                    var positionSize = position.itemSize;\n                    _gl.bindBuffer(_gl.ARRAY_BUFFER, position.buffer);\n                    enableAttribute(attributes.position);\n                    _gl.vertexAttribPointer(attributes.position, positionSize, _gl.FLOAT, false, 0, 0);\n                    // normals\n                    var normal = geometry.attributes[\"normal\"];\n                    if (attributes.normal >= 0 && normal) {\n                        var normalSize = normal.itemSize;\n                        _gl.bindBuffer(_gl.ARRAY_BUFFER, normal.buffer);\n                        enableAttribute(attributes.normal);\n                        _gl.vertexAttribPointer(attributes.normal, normalSize, _gl.FLOAT, false, 0, 0);\n                    }\n                    // uvs\n                    var uv = geometry.attributes[\"uv\"];\n                    if (attributes.uv >= 0 && uv) {\n                        var uvSize = uv.itemSize;\n                        _gl.bindBuffer(_gl.ARRAY_BUFFER, uv.buffer);\n                        enableAttribute(attributes.uv);\n                        _gl.vertexAttribPointer(attributes.uv, uvSize, _gl.FLOAT, false, 0, 0);\n                    }\n                    // colors\n                    var color = geometry.attributes[\"color\"];\n                    if (attributes.color >= 0 && color) {\n                        var colorSize = color.itemSize;\n                        _gl.bindBuffer(_gl.ARRAY_BUFFER, color.buffer);\n                        enableAttribute(attributes.color);\n                        _gl.vertexAttribPointer(attributes.color, colorSize, _gl.FLOAT, false, 0, 0);\n                    }\n                    // tangents\n                    var tangent = geometry.attributes[\"tangent\"];\n                    if (attributes.tangent >= 0 && tangent) {\n                        var tangentSize = tangent.itemSize;\n                        _gl.bindBuffer(_gl.ARRAY_BUFFER, tangent.buffer);\n                        enableAttribute(attributes.tangent);\n                        _gl.vertexAttribPointer(attributes.tangent, tangentSize, _gl.FLOAT, false, 0, 0);\n                    }\n                }\n                // render non-indexed triangles\n                _gl.drawArrays(_gl.TRIANGLES, 0, position.numItems / 3);\n                _this.info.render.calls++;\n                _this.info.render.vertices += position.numItems / 3;\n                _this.info.render.faces += position.numItems / 3 / 3;\n            }\n        // render particles\n        } else if (object instanceof THREE.ParticleSystem) {\n            if (updateBuffers) {\n                // vertices\n                var position = geometry.attributes[\"position\"];\n                var positionSize = position.itemSize;\n                _gl.bindBuffer(_gl.ARRAY_BUFFER, position.buffer);\n                enableAttribute(attributes.position);\n                _gl.vertexAttribPointer(attributes.position, positionSize, _gl.FLOAT, false, 0, 0);\n                // colors\n                var color = geometry.attributes[\"color\"];\n                if (attributes.color >= 0 && color) {\n                    var colorSize = color.itemSize;\n                    _gl.bindBuffer(_gl.ARRAY_BUFFER, color.buffer);\n                    enableAttribute(attributes.color);\n                    _gl.vertexAttribPointer(attributes.color, colorSize, _gl.FLOAT, false, 0, 0);\n                }\n                // render particles\n                _gl.drawArrays(_gl.POINTS, 0, position.numItems / 3);\n                _this.info.render.calls++;\n                _this.info.render.points += position.numItems / 3;\n            }\n        } else if (object instanceof THREE.Line) {\n            if (updateBuffers) {\n                // vertices\n                var position = geometry.attributes[\"position\"];\n                var positionSize = position.itemSize;\n                _gl.bindBuffer(_gl.ARRAY_BUFFER, position.buffer);\n                enableAttribute(attributes.position);\n                _gl.vertexAttribPointer(attributes.position, positionSize, _gl.FLOAT, false, 0, 0);\n                // colors\n                var color = geometry.attributes[\"color\"];\n                if (attributes.color >= 0 && color) {\n                    var colorSize = color.itemSize;\n                    _gl.bindBuffer(_gl.ARRAY_BUFFER, color.buffer);\n                    enableAttribute(attributes.color);\n                    _gl.vertexAttribPointer(attributes.color, colorSize, _gl.FLOAT, false, 0, 0);\n                }\n                // render lines\n                setLineWidth(material.linewidth);\n                _gl.drawArrays(_gl.LINE_STRIP, 0, position.numItems / 3);\n                _this.info.render.calls++;\n                _this.info.render.points += position.numItems;\n            }\n        }\n    };\n    this.renderBuffer = function(camera, lights, fog, material, geometryGroup, object) {\n        if (material.visible === false) return;\n        var program, attributes, linewidth, primitives, a, attribute, i, il;\n        program = setProgram(camera, lights, fog, material, object);\n        attributes = program.attributes;\n        var updateBuffers = false, wireframeBit = material.wireframe ? 1 : 0, geometryGroupHash = geometryGroup.id * 0xffffff + program.id * 2 + wireframeBit;\n        if (geometryGroupHash !== _currentGeometryGroupHash) {\n            _currentGeometryGroupHash = geometryGroupHash;\n            updateBuffers = true;\n        }\n        if (updateBuffers) disableAttributes();\n        // vertices\n        if (!material.morphTargets && attributes.position >= 0) {\n            if (updateBuffers) {\n                _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer);\n                enableAttribute(attributes.position);\n                _gl.vertexAttribPointer(attributes.position, 3, _gl.FLOAT, false, 0, 0);\n            }\n        } else if (object.morphTargetBase) setupMorphTargets(material, geometryGroup, object);\n        if (updateBuffers) {\n            // custom attributes\n            // Use the per-geometryGroup custom attribute arrays which are setup in initMeshBuffers\n            if (geometryGroup.__webglCustomAttributesList) for(i = 0, il = geometryGroup.__webglCustomAttributesList.length; i < il; i++){\n                attribute = geometryGroup.__webglCustomAttributesList[i];\n                if (attributes[attribute.buffer.belongsToAttribute] >= 0) {\n                    _gl.bindBuffer(_gl.ARRAY_BUFFER, attribute.buffer);\n                    enableAttribute(attributes[attribute.buffer.belongsToAttribute]);\n                    _gl.vertexAttribPointer(attributes[attribute.buffer.belongsToAttribute], attribute.size, _gl.FLOAT, false, 0, 0);\n                }\n            }\n            // colors\n            if (attributes.color >= 0) {\n                _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer);\n                enableAttribute(attributes.color);\n                _gl.vertexAttribPointer(attributes.color, 3, _gl.FLOAT, false, 0, 0);\n            }\n            // normals\n            if (attributes.normal >= 0) {\n                _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer);\n                enableAttribute(attributes.normal);\n                _gl.vertexAttribPointer(attributes.normal, 3, _gl.FLOAT, false, 0, 0);\n            }\n            // tangents\n            if (attributes.tangent >= 0) {\n                _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer);\n                enableAttribute(attributes.tangent);\n                _gl.vertexAttribPointer(attributes.tangent, 4, _gl.FLOAT, false, 0, 0);\n            }\n            // uvs\n            if (attributes.uv >= 0) {\n                _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer);\n                enableAttribute(attributes.uv);\n                _gl.vertexAttribPointer(attributes.uv, 2, _gl.FLOAT, false, 0, 0);\n            }\n            if (attributes.uv2 >= 0) {\n                _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer);\n                enableAttribute(attributes.uv2);\n                _gl.vertexAttribPointer(attributes.uv2, 2, _gl.FLOAT, false, 0, 0);\n            }\n            if (material.skinning && attributes.skinIndex >= 0 && attributes.skinWeight >= 0) {\n                _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer);\n                enableAttribute(attributes.skinIndex);\n                _gl.vertexAttribPointer(attributes.skinIndex, 4, _gl.FLOAT, false, 0, 0);\n                _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer);\n                enableAttribute(attributes.skinWeight);\n                _gl.vertexAttribPointer(attributes.skinWeight, 4, _gl.FLOAT, false, 0, 0);\n            }\n            // line distances\n            if (attributes.lineDistance >= 0) {\n                _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglLineDistanceBuffer);\n                enableAttribute(attributes.lineDistance);\n                _gl.vertexAttribPointer(attributes.lineDistance, 1, _gl.FLOAT, false, 0, 0);\n            }\n        }\n        // render mesh\n        if (object instanceof THREE.Mesh) {\n            // wireframe\n            if (material.wireframe) {\n                setLineWidth(material.wireframeLinewidth);\n                if (updateBuffers) _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer);\n                _gl.drawElements(_gl.LINES, geometryGroup.__webglLineCount, _gl.UNSIGNED_SHORT, 0);\n            // triangles\n            } else {\n                if (updateBuffers) _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer);\n                _gl.drawElements(_gl.TRIANGLES, geometryGroup.__webglFaceCount, _gl.UNSIGNED_SHORT, 0);\n            }\n            _this.info.render.calls++;\n            _this.info.render.vertices += geometryGroup.__webglFaceCount;\n            _this.info.render.faces += geometryGroup.__webglFaceCount / 3;\n        // render lines\n        } else if (object instanceof THREE.Line) {\n            primitives = object.type === THREE.LineStrip ? _gl.LINE_STRIP : _gl.LINES;\n            setLineWidth(material.linewidth);\n            _gl.drawArrays(primitives, 0, geometryGroup.__webglLineCount);\n            _this.info.render.calls++;\n        // render particles\n        } else if (object instanceof THREE.ParticleSystem) {\n            _gl.drawArrays(_gl.POINTS, 0, geometryGroup.__webglParticleCount);\n            _this.info.render.calls++;\n            _this.info.render.points += geometryGroup.__webglParticleCount;\n        // render ribbon\n        } else if (object instanceof THREE.Ribbon) {\n            _gl.drawArrays(_gl.TRIANGLE_STRIP, 0, geometryGroup.__webglVertexCount);\n            _this.info.render.calls++;\n        }\n    };\n    function enableAttribute(attribute) {\n        if (!_enabledAttributes[attribute]) {\n            _gl.enableVertexAttribArray(attribute);\n            _enabledAttributes[attribute] = true;\n        }\n    }\n    function disableAttributes() {\n        for(var attribute in _enabledAttributes)if (_enabledAttributes[attribute]) {\n            _gl.disableVertexAttribArray(attribute);\n            _enabledAttributes[attribute] = false;\n        }\n    }\n    function setupMorphTargets(material, geometryGroup, object) {\n        // set base\n        var attributes = material.program.attributes;\n        if (object.morphTargetBase !== -1 && attributes.position >= 0) {\n            _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[object.morphTargetBase]);\n            enableAttribute(attributes.position);\n            _gl.vertexAttribPointer(attributes.position, 3, _gl.FLOAT, false, 0, 0);\n        } else if (attributes.position >= 0) {\n            _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer);\n            enableAttribute(attributes.position);\n            _gl.vertexAttribPointer(attributes.position, 3, _gl.FLOAT, false, 0, 0);\n        }\n        if (object.morphTargetForcedOrder.length) {\n            // set forced order\n            var m = 0;\n            var order = object.morphTargetForcedOrder;\n            var influences = object.morphTargetInfluences;\n            while(m < material.numSupportedMorphTargets && m < order.length){\n                if (attributes[\"morphTarget\" + m] >= 0) {\n                    _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[order[m]]);\n                    enableAttribute(attributes[\"morphTarget\" + m]);\n                    _gl.vertexAttribPointer(attributes[\"morphTarget\" + m], 3, _gl.FLOAT, false, 0, 0);\n                }\n                if (attributes[\"morphNormal\" + m] >= 0 && material.morphNormals) {\n                    _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[order[m]]);\n                    enableAttribute(attributes[\"morphNormal\" + m]);\n                    _gl.vertexAttribPointer(attributes[\"morphNormal\" + m], 3, _gl.FLOAT, false, 0, 0);\n                }\n                object.__webglMorphTargetInfluences[m] = influences[order[m]];\n                m++;\n            }\n        } else {\n            // find the most influencing\n            var influence, activeInfluenceIndices = [];\n            var influences = object.morphTargetInfluences;\n            var i, il = influences.length;\n            for(i = 0; i < il; i++){\n                influence = influences[i];\n                if (influence > 0) activeInfluenceIndices.push([\n                    influence,\n                    i\n                ]);\n            }\n            if (activeInfluenceIndices.length > material.numSupportedMorphTargets) {\n                activeInfluenceIndices.sort(numericalSort);\n                activeInfluenceIndices.length = material.numSupportedMorphTargets;\n            } else if (activeInfluenceIndices.length > material.numSupportedMorphNormals) activeInfluenceIndices.sort(numericalSort);\n            else if (activeInfluenceIndices.length === 0) activeInfluenceIndices.push([\n                0,\n                0\n            ]);\n            var influenceIndex, m = 0;\n            while(m < material.numSupportedMorphTargets){\n                if (activeInfluenceIndices[m]) {\n                    influenceIndex = activeInfluenceIndices[m][1];\n                    if (attributes[\"morphTarget\" + m] >= 0) {\n                        _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[influenceIndex]);\n                        enableAttribute(attributes[\"morphTarget\" + m]);\n                        _gl.vertexAttribPointer(attributes[\"morphTarget\" + m], 3, _gl.FLOAT, false, 0, 0);\n                    }\n                    if (attributes[\"morphNormal\" + m] >= 0 && material.morphNormals) {\n                        _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[influenceIndex]);\n                        enableAttribute(attributes[\"morphNormal\" + m]);\n                        _gl.vertexAttribPointer(attributes[\"morphNormal\" + m], 3, _gl.FLOAT, false, 0, 0);\n                    }\n                    object.__webglMorphTargetInfluences[m] = influences[influenceIndex];\n                } else /*\n\t\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphTarget\" + m ], 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t\t\tif ( material.morphNormals ) {\n\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphNormal\" + m ], 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t\t\t}\n\t\t\t\t\t*/ object.__webglMorphTargetInfluences[m] = 0;\n                m++;\n            }\n        }\n        // load updated influences uniform\n        if (material.program.uniforms.morphTargetInfluences !== null) _gl.uniform1fv(material.program.uniforms.morphTargetInfluences, object.__webglMorphTargetInfluences);\n    }\n    // Sorting\n    function painterSortStable(a, b) {\n        if (a.z !== b.z) return b.z - a.z;\n        else return b.id - a.id;\n    }\n    function numericalSort(a, b) {\n        return b[0] - a[0];\n    }\n    // Rendering\n    this.render = function(scene, camera, renderTarget, forceClear) {\n        if (camera instanceof THREE.Camera === false) {\n            console.error(\"THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.\");\n            return;\n        }\n        var i, il, webglObject, object, renderList, lights = scene.__lights, fog = scene.fog;\n        // reset caching for this frame\n        _currentMaterialId = -1;\n        _lightsNeedUpdate = true;\n        // update scene graph\n        if (this.autoUpdateScene) scene.updateMatrixWorld();\n        // update camera matrices and frustum\n        if (camera.parent === undefined) camera.updateMatrixWorld();\n        camera.matrixWorldInverse.getInverse(camera.matrixWorld);\n        _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);\n        _frustum.setFromMatrix(_projScreenMatrix);\n        // update WebGL objects\n        if (this.autoUpdateObjects) this.initWebGLObjects(scene);\n        // custom render plugins (pre pass)\n        renderPlugins(this.renderPluginsPre, scene, camera);\n        //\n        _this.info.render.calls = 0;\n        _this.info.render.vertices = 0;\n        _this.info.render.faces = 0;\n        _this.info.render.points = 0;\n        this.setRenderTarget(renderTarget);\n        if (this.autoClear || forceClear) this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil);\n        // set matrices for regular objects (frustum culled)\n        renderList = scene.__webglObjects;\n        for(i = 0, il = renderList.length; i < il; i++){\n            webglObject = renderList[i];\n            object = webglObject.object;\n            webglObject.render = false;\n            if (object.visible) {\n                if (!(object instanceof THREE.Mesh || object instanceof THREE.ParticleSystem) || !object.frustumCulled || _frustum.intersectsObject(object)) {\n                    setupMatrices(object, camera);\n                    unrollBufferMaterial(webglObject);\n                    webglObject.render = true;\n                    if (this.sortObjects === true) {\n                        if (object.renderDepth !== null) webglObject.z = object.renderDepth;\n                        else {\n                            _vector3.getPositionFromMatrix(object.matrixWorld);\n                            _vector3.applyProjection(_projScreenMatrix);\n                            webglObject.z = _vector3.z;\n                        }\n                        webglObject.id = object.id;\n                    }\n                }\n            }\n        }\n        if (this.sortObjects) renderList.sort(painterSortStable);\n        // set matrices for immediate objects\n        renderList = scene.__webglObjectsImmediate;\n        for(i = 0, il = renderList.length; i < il; i++){\n            webglObject = renderList[i];\n            object = webglObject.object;\n            if (object.visible) {\n                setupMatrices(object, camera);\n                unrollImmediateBufferMaterial(webglObject);\n            }\n        }\n        if (scene.overrideMaterial) {\n            var material = scene.overrideMaterial;\n            this.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst);\n            this.setDepthTest(material.depthTest);\n            this.setDepthWrite(material.depthWrite);\n            setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);\n            renderObjects(scene.__webglObjects, false, \"\", camera, lights, fog, true, material);\n            renderObjectsImmediate(scene.__webglObjectsImmediate, \"\", camera, lights, fog, false, material);\n        } else {\n            var material = null;\n            // opaque pass (front-to-back order)\n            this.setBlending(THREE.NoBlending);\n            renderObjects(scene.__webglObjects, true, \"opaque\", camera, lights, fog, false, material);\n            renderObjectsImmediate(scene.__webglObjectsImmediate, \"opaque\", camera, lights, fog, false, material);\n            // transparent pass (back-to-front order)\n            renderObjects(scene.__webglObjects, false, \"transparent\", camera, lights, fog, true, material);\n            renderObjectsImmediate(scene.__webglObjectsImmediate, \"transparent\", camera, lights, fog, true, material);\n        }\n        // custom render plugins (post pass)\n        renderPlugins(this.renderPluginsPost, scene, camera);\n        // Generate mipmap if we're using any kind of mipmap filtering\n        if (renderTarget && renderTarget.generateMipmaps && renderTarget.minFilter !== THREE.NearestFilter && renderTarget.minFilter !== THREE.LinearFilter) updateRenderTargetMipmap(renderTarget);\n        // Ensure depth buffer writing is enabled so it can be cleared on next render\n        this.setDepthTest(true);\n        this.setDepthWrite(true);\n    // _gl.finish();\n    };\n    function renderPlugins(plugins, scene, camera) {\n        if (!plugins.length) return;\n        for(var i = 0, il = plugins.length; i < il; i++){\n            // reset state for plugin (to start from clean slate)\n            _currentProgram = null;\n            _currentCamera = null;\n            _oldBlending = -1;\n            _oldDepthTest = -1;\n            _oldDepthWrite = -1;\n            _oldDoubleSided = -1;\n            _oldFlipSided = -1;\n            _currentGeometryGroupHash = -1;\n            _currentMaterialId = -1;\n            _lightsNeedUpdate = true;\n            plugins[i].render(scene, camera, _currentWidth, _currentHeight);\n            // reset state after plugin (anything could have changed)\n            _currentProgram = null;\n            _currentCamera = null;\n            _oldBlending = -1;\n            _oldDepthTest = -1;\n            _oldDepthWrite = -1;\n            _oldDoubleSided = -1;\n            _oldFlipSided = -1;\n            _currentGeometryGroupHash = -1;\n            _currentMaterialId = -1;\n            _lightsNeedUpdate = true;\n        }\n    }\n    function renderObjects(renderList, reverse, materialType, camera, lights, fog, useBlending, overrideMaterial) {\n        var webglObject, object, buffer, material, start, end, delta;\n        if (reverse) {\n            start = renderList.length - 1;\n            end = -1;\n            delta = -1;\n        } else {\n            start = 0;\n            end = renderList.length;\n            delta = 1;\n        }\n        for(var i = start; i !== end; i += delta){\n            webglObject = renderList[i];\n            if (webglObject.render) {\n                object = webglObject.object;\n                buffer = webglObject.buffer;\n                if (overrideMaterial) material = overrideMaterial;\n                else {\n                    material = webglObject[materialType];\n                    if (!material) continue;\n                    if (useBlending) _this.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst);\n                    _this.setDepthTest(material.depthTest);\n                    _this.setDepthWrite(material.depthWrite);\n                    setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);\n                }\n                _this.setMaterialFaces(material);\n                if (buffer instanceof THREE.BufferGeometry) _this.renderBufferDirect(camera, lights, fog, material, buffer, object);\n                else _this.renderBuffer(camera, lights, fog, material, buffer, object);\n            }\n        }\n    }\n    function renderObjectsImmediate(renderList, materialType, camera, lights, fog, useBlending, overrideMaterial) {\n        var webglObject, object, material, program;\n        for(var i = 0, il = renderList.length; i < il; i++){\n            webglObject = renderList[i];\n            object = webglObject.object;\n            if (object.visible) {\n                if (overrideMaterial) material = overrideMaterial;\n                else {\n                    material = webglObject[materialType];\n                    if (!material) continue;\n                    if (useBlending) _this.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst);\n                    _this.setDepthTest(material.depthTest);\n                    _this.setDepthWrite(material.depthWrite);\n                    setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);\n                }\n                _this.renderImmediateObject(camera, lights, fog, material, object);\n            }\n        }\n    }\n    this.renderImmediateObject = function(camera, lights, fog, material, object) {\n        var program = setProgram(camera, lights, fog, material, object);\n        _currentGeometryGroupHash = -1;\n        _this.setMaterialFaces(material);\n        if (object.immediateRenderCallback) object.immediateRenderCallback(program, _gl, _frustum);\n        else object.render(function(object) {\n            _this.renderBufferImmediate(object, program, material);\n        });\n    };\n    function unrollImmediateBufferMaterial(globject) {\n        var object = globject.object, material = object.material;\n        if (material.transparent) {\n            globject.transparent = material;\n            globject.opaque = null;\n        } else {\n            globject.opaque = material;\n            globject.transparent = null;\n        }\n    }\n    function unrollBufferMaterial(globject) {\n        var object = globject.object, buffer = globject.buffer, material, materialIndex, meshMaterial;\n        meshMaterial = object.material;\n        if (meshMaterial instanceof THREE.MeshFaceMaterial) {\n            materialIndex = buffer.materialIndex;\n            material = meshMaterial.materials[materialIndex];\n            if (material.transparent) {\n                globject.transparent = material;\n                globject.opaque = null;\n            } else {\n                globject.opaque = material;\n                globject.transparent = null;\n            }\n        } else {\n            material = meshMaterial;\n            if (material) {\n                if (material.transparent) {\n                    globject.transparent = material;\n                    globject.opaque = null;\n                } else {\n                    globject.opaque = material;\n                    globject.transparent = null;\n                }\n            }\n        }\n    }\n    // Geometry splitting\n    function sortFacesByMaterial(geometry, material) {\n        var f, fl, face, materialIndex, vertices, groupHash, hash_map = {};\n        var numMorphTargets = geometry.morphTargets.length;\n        var numMorphNormals = geometry.morphNormals.length;\n        var usesFaceMaterial = material instanceof THREE.MeshFaceMaterial;\n        geometry.geometryGroups = {};\n        for(f = 0, fl = geometry.faces.length; f < fl; f++){\n            face = geometry.faces[f];\n            materialIndex = usesFaceMaterial ? face.materialIndex : 0;\n            if (hash_map[materialIndex] === undefined) hash_map[materialIndex] = {\n                \"hash\": materialIndex,\n                \"counter\": 0\n            };\n            groupHash = hash_map[materialIndex].hash + \"_\" + hash_map[materialIndex].counter;\n            if (geometry.geometryGroups[groupHash] === undefined) geometry.geometryGroups[groupHash] = {\n                \"faces3\": [],\n                \"faces4\": [],\n                \"materialIndex\": materialIndex,\n                \"vertices\": 0,\n                \"numMorphTargets\": numMorphTargets,\n                \"numMorphNormals\": numMorphNormals\n            };\n            vertices = face instanceof THREE.Face3 ? 3 : 4;\n            if (geometry.geometryGroups[groupHash].vertices + vertices > 65535) {\n                hash_map[materialIndex].counter += 1;\n                groupHash = hash_map[materialIndex].hash + \"_\" + hash_map[materialIndex].counter;\n                if (geometry.geometryGroups[groupHash] === undefined) geometry.geometryGroups[groupHash] = {\n                    \"faces3\": [],\n                    \"faces4\": [],\n                    \"materialIndex\": materialIndex,\n                    \"vertices\": 0,\n                    \"numMorphTargets\": numMorphTargets,\n                    \"numMorphNormals\": numMorphNormals\n                };\n            }\n            if (face instanceof THREE.Face3) geometry.geometryGroups[groupHash].faces3.push(f);\n            else geometry.geometryGroups[groupHash].faces4.push(f);\n            geometry.geometryGroups[groupHash].vertices += vertices;\n        }\n        geometry.geometryGroupsList = [];\n        for(var g in geometry.geometryGroups){\n            geometry.geometryGroups[g].id = _geometryGroupCounter++;\n            geometry.geometryGroupsList.push(geometry.geometryGroups[g]);\n        }\n    }\n    // Objects refresh\n    this.initWebGLObjects = function(scene) {\n        if (!scene.__webglObjects) {\n            scene.__webglObjects = [];\n            scene.__webglObjectsImmediate = [];\n            scene.__webglSprites = [];\n            scene.__webglFlares = [];\n        }\n        while(scene.__objectsAdded.length){\n            addObject(scene.__objectsAdded[0], scene);\n            scene.__objectsAdded.splice(0, 1);\n        }\n        while(scene.__objectsRemoved.length){\n            removeObject(scene.__objectsRemoved[0], scene);\n            scene.__objectsRemoved.splice(0, 1);\n        }\n        // update must be called after objects adding / removal\n        for(var o = 0, ol = scene.__webglObjects.length; o < ol; o++)updateObject(scene.__webglObjects[o].object);\n    };\n    // Objects adding\n    function addObject(object, scene) {\n        var g, geometry, material, geometryGroup;\n        if (!object.__webglInit) {\n            object.__webglInit = true;\n            object._modelViewMatrix = new THREE.Matrix4();\n            object._normalMatrix = new THREE.Matrix3();\n            if (object.geometry !== undefined && object.geometry.__webglInit === undefined) {\n                object.geometry.__webglInit = true;\n                object.geometry.addEventListener(\"dispose\", onGeometryDispose);\n            }\n            if (object instanceof THREE.Mesh) {\n                geometry = object.geometry;\n                material = object.material;\n                if (geometry instanceof THREE.Geometry) {\n                    if (geometry.geometryGroups === undefined) sortFacesByMaterial(geometry, material);\n                    // create separate VBOs per geometry chunk\n                    for(g in geometry.geometryGroups){\n                        geometryGroup = geometry.geometryGroups[g];\n                        // initialise VBO on the first access\n                        if (!geometryGroup.__webglVertexBuffer) {\n                            createMeshBuffers(geometryGroup);\n                            initMeshBuffers(geometryGroup, object);\n                            geometry.verticesNeedUpdate = true;\n                            geometry.morphTargetsNeedUpdate = true;\n                            geometry.elementsNeedUpdate = true;\n                            geometry.uvsNeedUpdate = true;\n                            geometry.normalsNeedUpdate = true;\n                            geometry.tangentsNeedUpdate = true;\n                            geometry.colorsNeedUpdate = true;\n                        }\n                    }\n                } else if (geometry instanceof THREE.BufferGeometry) initDirectBuffers(geometry);\n            } else if (object instanceof THREE.Ribbon) {\n                geometry = object.geometry;\n                if (!geometry.__webglVertexBuffer) {\n                    createRibbonBuffers(geometry);\n                    initRibbonBuffers(geometry, object);\n                    geometry.verticesNeedUpdate = true;\n                    geometry.colorsNeedUpdate = true;\n                    geometry.normalsNeedUpdate = true;\n                }\n            } else if (object instanceof THREE.Line) {\n                geometry = object.geometry;\n                if (!geometry.__webglVertexBuffer) {\n                    if (geometry instanceof THREE.Geometry) {\n                        createLineBuffers(geometry);\n                        initLineBuffers(geometry, object);\n                        geometry.verticesNeedUpdate = true;\n                        geometry.colorsNeedUpdate = true;\n                        geometry.lineDistancesNeedUpdate = true;\n                    } else if (geometry instanceof THREE.BufferGeometry) initDirectBuffers(geometry);\n                }\n            } else if (object instanceof THREE.ParticleSystem) {\n                geometry = object.geometry;\n                if (!geometry.__webglVertexBuffer) {\n                    if (geometry instanceof THREE.Geometry) {\n                        createParticleBuffers(geometry);\n                        initParticleBuffers(geometry, object);\n                        geometry.verticesNeedUpdate = true;\n                        geometry.colorsNeedUpdate = true;\n                    } else if (geometry instanceof THREE.BufferGeometry) initDirectBuffers(geometry);\n                }\n            }\n        }\n        if (!object.__webglActive) {\n            if (object instanceof THREE.Mesh) {\n                geometry = object.geometry;\n                if (geometry instanceof THREE.BufferGeometry) addBuffer(scene.__webglObjects, geometry, object);\n                else if (geometry instanceof THREE.Geometry) for(g in geometry.geometryGroups){\n                    geometryGroup = geometry.geometryGroups[g];\n                    addBuffer(scene.__webglObjects, geometryGroup, object);\n                }\n            } else if (object instanceof THREE.Ribbon || object instanceof THREE.Line || object instanceof THREE.ParticleSystem) {\n                geometry = object.geometry;\n                addBuffer(scene.__webglObjects, geometry, object);\n            } else if (object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback) addBufferImmediate(scene.__webglObjectsImmediate, object);\n            else if (object instanceof THREE.Sprite) scene.__webglSprites.push(object);\n            else if (object instanceof THREE.LensFlare) scene.__webglFlares.push(object);\n            object.__webglActive = true;\n        }\n    }\n    function addBuffer(objlist, buffer, object) {\n        objlist.push({\n            buffer: buffer,\n            object: object,\n            opaque: null,\n            transparent: null\n        });\n    }\n    function addBufferImmediate(objlist, object) {\n        objlist.push({\n            object: object,\n            opaque: null,\n            transparent: null\n        });\n    }\n    // Objects updates\n    function updateObject(object) {\n        var geometry = object.geometry, geometryGroup, customAttributesDirty, material;\n        if (object instanceof THREE.Mesh) {\n            if (geometry instanceof THREE.BufferGeometry) {\n                if (geometry.verticesNeedUpdate || geometry.elementsNeedUpdate || geometry.uvsNeedUpdate || geometry.normalsNeedUpdate || geometry.colorsNeedUpdate || geometry.tangentsNeedUpdate) setDirectBuffers(geometry, _gl.DYNAMIC_DRAW, !geometry.dynamic);\n                geometry.verticesNeedUpdate = false;\n                geometry.elementsNeedUpdate = false;\n                geometry.uvsNeedUpdate = false;\n                geometry.normalsNeedUpdate = false;\n                geometry.colorsNeedUpdate = false;\n                geometry.tangentsNeedUpdate = false;\n            } else {\n                // check all geometry groups\n                for(var i = 0, il = geometry.geometryGroupsList.length; i < il; i++){\n                    geometryGroup = geometry.geometryGroupsList[i];\n                    material = getBufferMaterial(object, geometryGroup);\n                    if (geometry.buffersNeedUpdate) initMeshBuffers(geometryGroup, object);\n                    customAttributesDirty = material.attributes && areCustomAttributesDirty(material);\n                    if (geometry.verticesNeedUpdate || geometry.morphTargetsNeedUpdate || geometry.elementsNeedUpdate || geometry.uvsNeedUpdate || geometry.normalsNeedUpdate || geometry.colorsNeedUpdate || geometry.tangentsNeedUpdate || customAttributesDirty) setMeshBuffers(geometryGroup, object, _gl.DYNAMIC_DRAW, !geometry.dynamic, material);\n                }\n                geometry.verticesNeedUpdate = false;\n                geometry.morphTargetsNeedUpdate = false;\n                geometry.elementsNeedUpdate = false;\n                geometry.uvsNeedUpdate = false;\n                geometry.normalsNeedUpdate = false;\n                geometry.colorsNeedUpdate = false;\n                geometry.tangentsNeedUpdate = false;\n                geometry.buffersNeedUpdate = false;\n                material.attributes && clearCustomAttributes(material);\n            }\n        } else if (object instanceof THREE.Ribbon) {\n            material = getBufferMaterial(object, geometry);\n            customAttributesDirty = material.attributes && areCustomAttributesDirty(material);\n            if (geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || geometry.normalsNeedUpdate || customAttributesDirty) setRibbonBuffers(geometry, _gl.DYNAMIC_DRAW);\n            geometry.verticesNeedUpdate = false;\n            geometry.colorsNeedUpdate = false;\n            geometry.normalsNeedUpdate = false;\n            material.attributes && clearCustomAttributes(material);\n        } else if (object instanceof THREE.Line) {\n            if (geometry instanceof THREE.BufferGeometry) {\n                if (geometry.verticesNeedUpdate || geometry.colorsNeedUpdate) setDirectBuffers(geometry, _gl.DYNAMIC_DRAW, !geometry.dynamic);\n                geometry.verticesNeedUpdate = false;\n                geometry.colorsNeedUpdate = false;\n            } else {\n                material = getBufferMaterial(object, geometry);\n                customAttributesDirty = material.attributes && areCustomAttributesDirty(material);\n                if (geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || geometry.lineDistancesNeedUpdate || customAttributesDirty) setLineBuffers(geometry, _gl.DYNAMIC_DRAW);\n                geometry.verticesNeedUpdate = false;\n                geometry.colorsNeedUpdate = false;\n                geometry.lineDistancesNeedUpdate = false;\n                material.attributes && clearCustomAttributes(material);\n            }\n        } else if (object instanceof THREE.ParticleSystem) {\n            if (geometry instanceof THREE.BufferGeometry) {\n                if (geometry.verticesNeedUpdate || geometry.colorsNeedUpdate) setDirectBuffers(geometry, _gl.DYNAMIC_DRAW, !geometry.dynamic);\n                geometry.verticesNeedUpdate = false;\n                geometry.colorsNeedUpdate = false;\n            } else {\n                material = getBufferMaterial(object, geometry);\n                customAttributesDirty = material.attributes && areCustomAttributesDirty(material);\n                if (geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || object.sortParticles || customAttributesDirty) setParticleBuffers(geometry, _gl.DYNAMIC_DRAW, object);\n                geometry.verticesNeedUpdate = false;\n                geometry.colorsNeedUpdate = false;\n                material.attributes && clearCustomAttributes(material);\n            }\n        }\n    }\n    // Objects updates - custom attributes check\n    function areCustomAttributesDirty(material) {\n        for(var a in material.attributes){\n            if (material.attributes[a].needsUpdate) return true;\n        }\n        return false;\n    }\n    function clearCustomAttributes(material) {\n        for(var a in material.attributes)material.attributes[a].needsUpdate = false;\n    }\n    // Objects removal\n    function removeObject(object, scene) {\n        if (object instanceof THREE.Mesh || object instanceof THREE.ParticleSystem || object instanceof THREE.Ribbon || object instanceof THREE.Line) removeInstances(scene.__webglObjects, object);\n        else if (object instanceof THREE.Sprite) removeInstancesDirect(scene.__webglSprites, object);\n        else if (object instanceof THREE.LensFlare) removeInstancesDirect(scene.__webglFlares, object);\n        else if (object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback) removeInstances(scene.__webglObjectsImmediate, object);\n        object.__webglActive = false;\n    }\n    function removeInstances(objlist, object) {\n        for(var o = objlist.length - 1; o >= 0; o--)if (objlist[o].object === object) objlist.splice(o, 1);\n    }\n    function removeInstancesDirect(objlist, object) {\n        for(var o = objlist.length - 1; o >= 0; o--)if (objlist[o] === object) objlist.splice(o, 1);\n    }\n    // Materials\n    this.initMaterial = function(material, lights, fog, object) {\n        material.addEventListener(\"dispose\", onMaterialDispose);\n        var u, a, identifiers, i, parameters, maxLightCount, maxBones, maxShadows, shaderID;\n        if (material instanceof THREE.MeshDepthMaterial) shaderID = \"depth\";\n        else if (material instanceof THREE.MeshNormalMaterial) shaderID = \"normal\";\n        else if (material instanceof THREE.MeshBasicMaterial) shaderID = \"basic\";\n        else if (material instanceof THREE.MeshLambertMaterial) shaderID = \"lambert\";\n        else if (material instanceof THREE.MeshPhongMaterial) shaderID = \"phong\";\n        else if (material instanceof THREE.LineBasicMaterial) shaderID = \"basic\";\n        else if (material instanceof THREE.LineDashedMaterial) shaderID = \"dashed\";\n        else if (material instanceof THREE.ParticleBasicMaterial) shaderID = \"particle_basic\";\n        if (shaderID) setMaterialShaders(material, THREE.ShaderLib[shaderID]);\n        // heuristics to create shader parameters according to lights in the scene\n        // (not to blow over maxLights budget)\n        maxLightCount = allocateLights(lights);\n        maxShadows = allocateShadows(lights);\n        maxBones = allocateBones(object);\n        parameters = {\n            map: !!material.map,\n            envMap: !!material.envMap,\n            lightMap: !!material.lightMap,\n            bumpMap: !!material.bumpMap,\n            normalMap: !!material.normalMap,\n            specularMap: !!material.specularMap,\n            vertexColors: material.vertexColors,\n            fog: fog,\n            useFog: material.fog,\n            fogExp: fog instanceof THREE.FogExp2,\n            sizeAttenuation: material.sizeAttenuation,\n            skinning: material.skinning,\n            maxBones: maxBones,\n            useVertexTexture: _supportsBoneTextures && object && object.useVertexTexture,\n            boneTextureWidth: object && object.boneTextureWidth,\n            boneTextureHeight: object && object.boneTextureHeight,\n            morphTargets: material.morphTargets,\n            morphNormals: material.morphNormals,\n            maxMorphTargets: this.maxMorphTargets,\n            maxMorphNormals: this.maxMorphNormals,\n            maxDirLights: maxLightCount.directional,\n            maxPointLights: maxLightCount.point,\n            maxSpotLights: maxLightCount.spot,\n            maxHemiLights: maxLightCount.hemi,\n            maxShadows: maxShadows,\n            shadowMapEnabled: this.shadowMapEnabled && object.receiveShadow,\n            shadowMapType: this.shadowMapType,\n            shadowMapDebug: this.shadowMapDebug,\n            shadowMapCascade: this.shadowMapCascade,\n            alphaTest: material.alphaTest,\n            metal: material.metal,\n            perPixel: material.perPixel,\n            wrapAround: material.wrapAround,\n            doubleSided: material.side === THREE.DoubleSide,\n            flipSided: material.side === THREE.BackSide\n        };\n        material.program = buildProgram(shaderID, material.fragmentShader, material.vertexShader, material.uniforms, material.attributes, material.defines, parameters);\n        var attributes = material.program.attributes;\n        if (material.morphTargets) {\n            material.numSupportedMorphTargets = 0;\n            var id, base = \"morphTarget\";\n            for(i = 0; i < this.maxMorphTargets; i++){\n                id = base + i;\n                if (attributes[id] >= 0) material.numSupportedMorphTargets++;\n            }\n        }\n        if (material.morphNormals) {\n            material.numSupportedMorphNormals = 0;\n            var id, base = \"morphNormal\";\n            for(i = 0; i < this.maxMorphNormals; i++){\n                id = base + i;\n                if (attributes[id] >= 0) material.numSupportedMorphNormals++;\n            }\n        }\n        material.uniformsList = [];\n        for(u in material.uniforms)material.uniformsList.push([\n            material.uniforms[u],\n            u\n        ]);\n    };\n    function setMaterialShaders(material, shaders) {\n        material.uniforms = THREE.UniformsUtils.clone(shaders.uniforms);\n        material.vertexShader = shaders.vertexShader;\n        material.fragmentShader = shaders.fragmentShader;\n    }\n    function setProgram(camera, lights, fog, material, object) {\n        _usedTextureUnits = 0;\n        if (material.needsUpdate) {\n            if (material.program) deallocateMaterial(material);\n            _this.initMaterial(material, lights, fog, object);\n            material.needsUpdate = false;\n        }\n        if (material.morphTargets) {\n            if (!object.__webglMorphTargetInfluences) object.__webglMorphTargetInfluences = new Float32Array(_this.maxMorphTargets);\n        }\n        var refreshMaterial = false;\n        var program = material.program, p_uniforms = program.uniforms, m_uniforms = material.uniforms;\n        if (program !== _currentProgram) {\n            _gl.useProgram(program);\n            _currentProgram = program;\n            refreshMaterial = true;\n        }\n        if (material.id !== _currentMaterialId) {\n            _currentMaterialId = material.id;\n            refreshMaterial = true;\n        }\n        if (refreshMaterial || camera !== _currentCamera) {\n            _gl.uniformMatrix4fv(p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements);\n            if (camera !== _currentCamera) _currentCamera = camera;\n        }\n        // skinning uniforms must be set even if material didn't change\n        // auto-setting of texture unit for bone texture must go before other textures\n        // not sure why, but otherwise weird things happen\n        if (material.skinning) {\n            if (_supportsBoneTextures && object.useVertexTexture) {\n                if (p_uniforms.boneTexture !== null) {\n                    var textureUnit = getTextureUnit();\n                    _gl.uniform1i(p_uniforms.boneTexture, textureUnit);\n                    _this.setTexture(object.boneTexture, textureUnit);\n                }\n            } else if (p_uniforms.boneGlobalMatrices !== null) _gl.uniformMatrix4fv(p_uniforms.boneGlobalMatrices, false, object.boneMatrices);\n        }\n        if (refreshMaterial) {\n            // refresh uniforms common to several materials\n            if (fog && material.fog) refreshUniformsFog(m_uniforms, fog);\n            if (material instanceof THREE.MeshPhongMaterial || material instanceof THREE.MeshLambertMaterial || material.lights) {\n                if (_lightsNeedUpdate) {\n                    setupLights(program, lights);\n                    _lightsNeedUpdate = false;\n                }\n                refreshUniformsLights(m_uniforms, _lights);\n            }\n            if (material instanceof THREE.MeshBasicMaterial || material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial) refreshUniformsCommon(m_uniforms, material);\n            // refresh single material specific uniforms\n            if (material instanceof THREE.LineBasicMaterial) refreshUniformsLine(m_uniforms, material);\n            else if (material instanceof THREE.LineDashedMaterial) {\n                refreshUniformsLine(m_uniforms, material);\n                refreshUniformsDash(m_uniforms, material);\n            } else if (material instanceof THREE.ParticleBasicMaterial) refreshUniformsParticle(m_uniforms, material);\n            else if (material instanceof THREE.MeshPhongMaterial) refreshUniformsPhong(m_uniforms, material);\n            else if (material instanceof THREE.MeshLambertMaterial) refreshUniformsLambert(m_uniforms, material);\n            else if (material instanceof THREE.MeshDepthMaterial) {\n                m_uniforms.mNear.value = camera.near;\n                m_uniforms.mFar.value = camera.far;\n                m_uniforms.opacity.value = material.opacity;\n            } else if (material instanceof THREE.MeshNormalMaterial) m_uniforms.opacity.value = material.opacity;\n            if (object.receiveShadow && !material._shadowPass) refreshUniformsShadow(m_uniforms, lights);\n            // load common uniforms\n            loadUniformsGeneric(program, material.uniformsList);\n            // load material specific uniforms\n            // (shader material also gets them for the sake of genericity)\n            if (material instanceof THREE.ShaderMaterial || material instanceof THREE.MeshPhongMaterial || material.envMap) {\n                if (p_uniforms.cameraPosition !== null) {\n                    _vector3.getPositionFromMatrix(camera.matrixWorld);\n                    _gl.uniform3f(p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z);\n                }\n            }\n            if (material instanceof THREE.MeshPhongMaterial || material instanceof THREE.MeshLambertMaterial || material instanceof THREE.ShaderMaterial || material.skinning) {\n                if (p_uniforms.viewMatrix !== null) _gl.uniformMatrix4fv(p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements);\n            }\n        }\n        loadUniformsMatrices(p_uniforms, object);\n        if (p_uniforms.modelMatrix !== null) _gl.uniformMatrix4fv(p_uniforms.modelMatrix, false, object.matrixWorld.elements);\n        return program;\n    }\n    // Uniforms (refresh uniforms objects)\n    function refreshUniformsCommon(uniforms, material) {\n        uniforms.opacity.value = material.opacity;\n        if (_this.gammaInput) uniforms.diffuse.value.copyGammaToLinear(material.color);\n        else uniforms.diffuse.value = material.color;\n        uniforms.map.value = material.map;\n        uniforms.lightMap.value = material.lightMap;\n        uniforms.specularMap.value = material.specularMap;\n        if (material.bumpMap) {\n            uniforms.bumpMap.value = material.bumpMap;\n            uniforms.bumpScale.value = material.bumpScale;\n        }\n        if (material.normalMap) {\n            uniforms.normalMap.value = material.normalMap;\n            uniforms.normalScale.value.copy(material.normalScale);\n        }\n        // uv repeat and offset setting priorities\n        //\t1. color map\n        //\t2. specular map\n        //\t3. normal map\n        //\t4. bump map\n        var uvScaleMap;\n        if (material.map) uvScaleMap = material.map;\n        else if (material.specularMap) uvScaleMap = material.specularMap;\n        else if (material.normalMap) uvScaleMap = material.normalMap;\n        else if (material.bumpMap) uvScaleMap = material.bumpMap;\n        if (uvScaleMap !== undefined) {\n            var offset = uvScaleMap.offset;\n            var repeat = uvScaleMap.repeat;\n            uniforms.offsetRepeat.value.set(offset.x, offset.y, repeat.x, repeat.y);\n        }\n        uniforms.envMap.value = material.envMap;\n        uniforms.flipEnvMap.value = material.envMap instanceof THREE.WebGLRenderTargetCube ? 1 : -1;\n        if (_this.gammaInput) //uniforms.reflectivity.value = material.reflectivity * material.reflectivity;\n        uniforms.reflectivity.value = material.reflectivity;\n        else uniforms.reflectivity.value = material.reflectivity;\n        uniforms.refractionRatio.value = material.refractionRatio;\n        uniforms.combine.value = material.combine;\n        uniforms.useRefract.value = material.envMap && material.envMap.mapping instanceof THREE.CubeRefractionMapping;\n    }\n    function refreshUniformsLine(uniforms, material) {\n        uniforms.diffuse.value = material.color;\n        uniforms.opacity.value = material.opacity;\n    }\n    function refreshUniformsDash(uniforms, material) {\n        uniforms.dashSize.value = material.dashSize;\n        uniforms.totalSize.value = material.dashSize + material.gapSize;\n        uniforms.scale.value = material.scale;\n    }\n    function refreshUniformsParticle(uniforms, material) {\n        uniforms.psColor.value = material.color;\n        uniforms.opacity.value = material.opacity;\n        uniforms.size.value = material.size;\n        uniforms.scale.value = _canvas.height / 2.0; // TODO: Cache this.\n        uniforms.map.value = material.map;\n    }\n    function refreshUniformsFog(uniforms, fog) {\n        uniforms.fogColor.value = fog.color;\n        if (fog instanceof THREE.Fog) {\n            uniforms.fogNear.value = fog.near;\n            uniforms.fogFar.value = fog.far;\n        } else if (fog instanceof THREE.FogExp2) uniforms.fogDensity.value = fog.density;\n    }\n    function refreshUniformsPhong(uniforms, material) {\n        uniforms.shininess.value = material.shininess;\n        if (_this.gammaInput) {\n            uniforms.ambient.value.copyGammaToLinear(material.ambient);\n            uniforms.emissive.value.copyGammaToLinear(material.emissive);\n            uniforms.specular.value.copyGammaToLinear(material.specular);\n        } else {\n            uniforms.ambient.value = material.ambient;\n            uniforms.emissive.value = material.emissive;\n            uniforms.specular.value = material.specular;\n        }\n        if (material.wrapAround) uniforms.wrapRGB.value.copy(material.wrapRGB);\n    }\n    function refreshUniformsLambert(uniforms, material) {\n        if (_this.gammaInput) {\n            uniforms.ambient.value.copyGammaToLinear(material.ambient);\n            uniforms.emissive.value.copyGammaToLinear(material.emissive);\n        } else {\n            uniforms.ambient.value = material.ambient;\n            uniforms.emissive.value = material.emissive;\n        }\n        if (material.wrapAround) uniforms.wrapRGB.value.copy(material.wrapRGB);\n    }\n    function refreshUniformsLights(uniforms, lights) {\n        uniforms.ambientLightColor.value = lights.ambient;\n        uniforms.directionalLightColor.value = lights.directional.colors;\n        uniforms.directionalLightDirection.value = lights.directional.positions;\n        uniforms.pointLightColor.value = lights.point.colors;\n        uniforms.pointLightPosition.value = lights.point.positions;\n        uniforms.pointLightDistance.value = lights.point.distances;\n        uniforms.spotLightColor.value = lights.spot.colors;\n        uniforms.spotLightPosition.value = lights.spot.positions;\n        uniforms.spotLightDistance.value = lights.spot.distances;\n        uniforms.spotLightDirection.value = lights.spot.directions;\n        uniforms.spotLightAngleCos.value = lights.spot.anglesCos;\n        uniforms.spotLightExponent.value = lights.spot.exponents;\n        uniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;\n        uniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;\n        uniforms.hemisphereLightDirection.value = lights.hemi.positions;\n    }\n    function refreshUniformsShadow(uniforms, lights) {\n        if (uniforms.shadowMatrix) {\n            var j = 0;\n            for(var i = 0, il = lights.length; i < il; i++){\n                var light = lights[i];\n                if (!light.castShadow) continue;\n                if (light instanceof THREE.SpotLight || light instanceof THREE.DirectionalLight && !light.shadowCascade) {\n                    uniforms.shadowMap.value[j] = light.shadowMap;\n                    uniforms.shadowMapSize.value[j] = light.shadowMapSize;\n                    uniforms.shadowMatrix.value[j] = light.shadowMatrix;\n                    uniforms.shadowDarkness.value[j] = light.shadowDarkness;\n                    uniforms.shadowBias.value[j] = light.shadowBias;\n                    j++;\n                }\n            }\n        }\n    }\n    // Uniforms (load to GPU)\n    function loadUniformsMatrices(uniforms, object) {\n        _gl.uniformMatrix4fv(uniforms.modelViewMatrix, false, object._modelViewMatrix.elements);\n        if (uniforms.normalMatrix) _gl.uniformMatrix3fv(uniforms.normalMatrix, false, object._normalMatrix.elements);\n    }\n    function getTextureUnit() {\n        var textureUnit = _usedTextureUnits;\n        if (textureUnit >= _maxTextures) console.warn(\"WebGLRenderer: trying to use \" + textureUnit + \" texture units while this GPU supports only \" + _maxTextures);\n        _usedTextureUnits += 1;\n        return textureUnit;\n    }\n    function loadUniformsGeneric(program, uniforms) {\n        var uniform, value, type, location, texture, textureUnit, i, il, j, jl, offset;\n        for(j = 0, jl = uniforms.length; j < jl; j++){\n            location = program.uniforms[uniforms[j][1]];\n            if (!location) continue;\n            uniform = uniforms[j][0];\n            type = uniform.type;\n            value = uniform.value;\n            if (type === \"i\") _gl.uniform1i(location, value);\n            else if (type === \"f\") _gl.uniform1f(location, value);\n            else if (type === \"v2\") _gl.uniform2f(location, value.x, value.y);\n            else if (type === \"v3\") _gl.uniform3f(location, value.x, value.y, value.z);\n            else if (type === \"v4\") _gl.uniform4f(location, value.x, value.y, value.z, value.w);\n            else if (type === \"c\") _gl.uniform3f(location, value.r, value.g, value.b);\n            else if (type === \"iv1\") _gl.uniform1iv(location, value);\n            else if (type === \"iv\") _gl.uniform3iv(location, value);\n            else if (type === \"fv1\") _gl.uniform1fv(location, value);\n            else if (type === \"fv\") _gl.uniform3fv(location, value);\n            else if (type === \"v2v\") {\n                if (uniform._array === undefined) uniform._array = new Float32Array(2 * value.length);\n                for(i = 0, il = value.length; i < il; i++){\n                    offset = i * 2;\n                    uniform._array[offset] = value[i].x;\n                    uniform._array[offset + 1] = value[i].y;\n                }\n                _gl.uniform2fv(location, uniform._array);\n            } else if (type === \"v3v\") {\n                if (uniform._array === undefined) uniform._array = new Float32Array(3 * value.length);\n                for(i = 0, il = value.length; i < il; i++){\n                    offset = i * 3;\n                    uniform._array[offset] = value[i].x;\n                    uniform._array[offset + 1] = value[i].y;\n                    uniform._array[offset + 2] = value[i].z;\n                }\n                _gl.uniform3fv(location, uniform._array);\n            } else if (type === \"v4v\") {\n                if (uniform._array === undefined) uniform._array = new Float32Array(4 * value.length);\n                for(i = 0, il = value.length; i < il; i++){\n                    offset = i * 4;\n                    uniform._array[offset] = value[i].x;\n                    uniform._array[offset + 1] = value[i].y;\n                    uniform._array[offset + 2] = value[i].z;\n                    uniform._array[offset + 3] = value[i].w;\n                }\n                _gl.uniform4fv(location, uniform._array);\n            } else if (type === \"m4\") {\n                if (uniform._array === undefined) uniform._array = new Float32Array(16);\n                value.flattenToArray(uniform._array);\n                _gl.uniformMatrix4fv(location, false, uniform._array);\n            } else if (type === \"m4v\") {\n                if (uniform._array === undefined) uniform._array = new Float32Array(16 * value.length);\n                for(i = 0, il = value.length; i < il; i++)value[i].flattenToArrayOffset(uniform._array, i * 16);\n                _gl.uniformMatrix4fv(location, false, uniform._array);\n            } else if (type === \"t\") {\n                texture = value;\n                textureUnit = getTextureUnit();\n                _gl.uniform1i(location, textureUnit);\n                if (!texture) continue;\n                if (texture.image instanceof Array && texture.image.length === 6) setCubeTexture(texture, textureUnit);\n                else if (texture instanceof THREE.WebGLRenderTargetCube) setCubeTextureDynamic(texture, textureUnit);\n                else _this.setTexture(texture, textureUnit);\n            } else if (type === \"tv\") {\n                if (uniform._array === undefined) uniform._array = [];\n                for(i = 0, il = uniform.value.length; i < il; i++)uniform._array[i] = getTextureUnit();\n                _gl.uniform1iv(location, uniform._array);\n                for(i = 0, il = uniform.value.length; i < il; i++){\n                    texture = uniform.value[i];\n                    textureUnit = uniform._array[i];\n                    if (!texture) continue;\n                    _this.setTexture(texture, textureUnit);\n                }\n            }\n        }\n    }\n    function setupMatrices(object, camera) {\n        object._modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);\n        object._normalMatrix.getInverse(object._modelViewMatrix);\n        object._normalMatrix.transpose();\n    }\n    //\n    function setColorGamma(array, offset, color, intensitySq) {\n        array[offset] = color.r * color.r * intensitySq;\n        array[offset + 1] = color.g * color.g * intensitySq;\n        array[offset + 2] = color.b * color.b * intensitySq;\n    }\n    function setColorLinear(array, offset, color, intensity) {\n        array[offset] = color.r * intensity;\n        array[offset + 1] = color.g * intensity;\n        array[offset + 2] = color.b * intensity;\n    }\n    function setupLights(program, lights) {\n        var l, ll, light, n, r = 0, g = 0, b = 0, color, skyColor, groundColor, intensity, intensitySq, position, distance, zlights = _lights, dirColors = zlights.directional.colors, dirPositions = zlights.directional.positions, pointColors = zlights.point.colors, pointPositions = zlights.point.positions, pointDistances = zlights.point.distances, spotColors = zlights.spot.colors, spotPositions = zlights.spot.positions, spotDistances = zlights.spot.distances, spotDirections = zlights.spot.directions, spotAnglesCos = zlights.spot.anglesCos, spotExponents = zlights.spot.exponents, hemiSkyColors = zlights.hemi.skyColors, hemiGroundColors = zlights.hemi.groundColors, hemiPositions = zlights.hemi.positions, dirLength = 0, pointLength = 0, spotLength = 0, hemiLength = 0, dirCount = 0, pointCount = 0, spotCount = 0, hemiCount = 0, dirOffset = 0, pointOffset = 0, spotOffset = 0, hemiOffset = 0;\n        for(l = 0, ll = lights.length; l < ll; l++){\n            light = lights[l];\n            if (light.onlyShadow) continue;\n            color = light.color;\n            intensity = light.intensity;\n            distance = light.distance;\n            if (light instanceof THREE.AmbientLight) {\n                if (!light.visible) continue;\n                if (_this.gammaInput) {\n                    r += color.r * color.r;\n                    g += color.g * color.g;\n                    b += color.b * color.b;\n                } else {\n                    r += color.r;\n                    g += color.g;\n                    b += color.b;\n                }\n            } else if (light instanceof THREE.DirectionalLight) {\n                dirCount += 1;\n                if (!light.visible) continue;\n                _direction.getPositionFromMatrix(light.matrixWorld);\n                _vector3.getPositionFromMatrix(light.target.matrixWorld);\n                _direction.sub(_vector3);\n                _direction.normalize();\n                // skip lights with undefined direction\n                // these create troubles in OpenGL (making pixel black)\n                if (_direction.x === 0 && _direction.y === 0 && _direction.z === 0) continue;\n                dirOffset = dirLength * 3;\n                dirPositions[dirOffset] = _direction.x;\n                dirPositions[dirOffset + 1] = _direction.y;\n                dirPositions[dirOffset + 2] = _direction.z;\n                if (_this.gammaInput) setColorGamma(dirColors, dirOffset, color, intensity * intensity);\n                else setColorLinear(dirColors, dirOffset, color, intensity);\n                dirLength += 1;\n            } else if (light instanceof THREE.PointLight) {\n                pointCount += 1;\n                if (!light.visible) continue;\n                pointOffset = pointLength * 3;\n                if (_this.gammaInput) setColorGamma(pointColors, pointOffset, color, intensity * intensity);\n                else setColorLinear(pointColors, pointOffset, color, intensity);\n                _vector3.getPositionFromMatrix(light.matrixWorld);\n                pointPositions[pointOffset] = _vector3.x;\n                pointPositions[pointOffset + 1] = _vector3.y;\n                pointPositions[pointOffset + 2] = _vector3.z;\n                pointDistances[pointLength] = distance;\n                pointLength += 1;\n            } else if (light instanceof THREE.SpotLight) {\n                spotCount += 1;\n                if (!light.visible) continue;\n                spotOffset = spotLength * 3;\n                if (_this.gammaInput) setColorGamma(spotColors, spotOffset, color, intensity * intensity);\n                else setColorLinear(spotColors, spotOffset, color, intensity);\n                _vector3.getPositionFromMatrix(light.matrixWorld);\n                spotPositions[spotOffset] = _vector3.x;\n                spotPositions[spotOffset + 1] = _vector3.y;\n                spotPositions[spotOffset + 2] = _vector3.z;\n                spotDistances[spotLength] = distance;\n                _direction.copy(_vector3);\n                _vector3.getPositionFromMatrix(light.target.matrixWorld);\n                _direction.sub(_vector3);\n                _direction.normalize();\n                spotDirections[spotOffset] = _direction.x;\n                spotDirections[spotOffset + 1] = _direction.y;\n                spotDirections[spotOffset + 2] = _direction.z;\n                spotAnglesCos[spotLength] = Math.cos(light.angle);\n                spotExponents[spotLength] = light.exponent;\n                spotLength += 1;\n            } else if (light instanceof THREE.HemisphereLight) {\n                hemiCount += 1;\n                if (!light.visible) continue;\n                _direction.getPositionFromMatrix(light.matrixWorld);\n                _direction.normalize();\n                // skip lights with undefined direction\n                // these create troubles in OpenGL (making pixel black)\n                if (_direction.x === 0 && _direction.y === 0 && _direction.z === 0) continue;\n                hemiOffset = hemiLength * 3;\n                hemiPositions[hemiOffset] = _direction.x;\n                hemiPositions[hemiOffset + 1] = _direction.y;\n                hemiPositions[hemiOffset + 2] = _direction.z;\n                skyColor = light.color;\n                groundColor = light.groundColor;\n                if (_this.gammaInput) {\n                    intensitySq = intensity * intensity;\n                    setColorGamma(hemiSkyColors, hemiOffset, skyColor, intensitySq);\n                    setColorGamma(hemiGroundColors, hemiOffset, groundColor, intensitySq);\n                } else {\n                    setColorLinear(hemiSkyColors, hemiOffset, skyColor, intensity);\n                    setColorLinear(hemiGroundColors, hemiOffset, groundColor, intensity);\n                }\n                hemiLength += 1;\n            }\n        }\n        // null eventual remains from removed lights\n        // (this is to avoid if in shader)\n        for(l = dirLength * 3, ll = Math.max(dirColors.length, dirCount * 3); l < ll; l++)dirColors[l] = 0.0;\n        for(l = pointLength * 3, ll = Math.max(pointColors.length, pointCount * 3); l < ll; l++)pointColors[l] = 0.0;\n        for(l = spotLength * 3, ll = Math.max(spotColors.length, spotCount * 3); l < ll; l++)spotColors[l] = 0.0;\n        for(l = hemiLength * 3, ll = Math.max(hemiSkyColors.length, hemiCount * 3); l < ll; l++)hemiSkyColors[l] = 0.0;\n        for(l = hemiLength * 3, ll = Math.max(hemiGroundColors.length, hemiCount * 3); l < ll; l++)hemiGroundColors[l] = 0.0;\n        zlights.directional.length = dirLength;\n        zlights.point.length = pointLength;\n        zlights.spot.length = spotLength;\n        zlights.hemi.length = hemiLength;\n        zlights.ambient[0] = r;\n        zlights.ambient[1] = g;\n        zlights.ambient[2] = b;\n    }\n    // GL state setting\n    this.setFaceCulling = function(cullFace, frontFaceDirection) {\n        if (cullFace === THREE.CullFaceNone) _gl.disable(_gl.CULL_FACE);\n        else {\n            if (frontFaceDirection === THREE.FrontFaceDirectionCW) _gl.frontFace(_gl.CW);\n            else _gl.frontFace(_gl.CCW);\n            if (cullFace === THREE.CullFaceBack) _gl.cullFace(_gl.BACK);\n            else if (cullFace === THREE.CullFaceFront) _gl.cullFace(_gl.FRONT);\n            else _gl.cullFace(_gl.FRONT_AND_BACK);\n            _gl.enable(_gl.CULL_FACE);\n        }\n    };\n    this.setMaterialFaces = function(material) {\n        var doubleSided = material.side === THREE.DoubleSide;\n        var flipSided = material.side === THREE.BackSide;\n        if (_oldDoubleSided !== doubleSided) {\n            if (doubleSided) _gl.disable(_gl.CULL_FACE);\n            else _gl.enable(_gl.CULL_FACE);\n            _oldDoubleSided = doubleSided;\n        }\n        if (_oldFlipSided !== flipSided) {\n            if (flipSided) _gl.frontFace(_gl.CW);\n            else _gl.frontFace(_gl.CCW);\n            _oldFlipSided = flipSided;\n        }\n    };\n    this.setDepthTest = function(depthTest) {\n        if (_oldDepthTest !== depthTest) {\n            if (depthTest) _gl.enable(_gl.DEPTH_TEST);\n            else _gl.disable(_gl.DEPTH_TEST);\n            _oldDepthTest = depthTest;\n        }\n    };\n    this.setDepthWrite = function(depthWrite) {\n        if (_oldDepthWrite !== depthWrite) {\n            _gl.depthMask(depthWrite);\n            _oldDepthWrite = depthWrite;\n        }\n    };\n    function setLineWidth(width) {\n        if (width !== _oldLineWidth) {\n            _gl.lineWidth(width);\n            _oldLineWidth = width;\n        }\n    }\n    function setPolygonOffset(polygonoffset, factor, units) {\n        if (_oldPolygonOffset !== polygonoffset) {\n            if (polygonoffset) _gl.enable(_gl.POLYGON_OFFSET_FILL);\n            else _gl.disable(_gl.POLYGON_OFFSET_FILL);\n            _oldPolygonOffset = polygonoffset;\n        }\n        if (polygonoffset && (_oldPolygonOffsetFactor !== factor || _oldPolygonOffsetUnits !== units)) {\n            _gl.polygonOffset(factor, units);\n            _oldPolygonOffsetFactor = factor;\n            _oldPolygonOffsetUnits = units;\n        }\n    }\n    this.setBlending = function(blending, blendEquation, blendSrc, blendDst) {\n        if (blending !== _oldBlending) {\n            if (blending === THREE.NoBlending) _gl.disable(_gl.BLEND);\n            else if (blending === THREE.AdditiveBlending) {\n                _gl.enable(_gl.BLEND);\n                _gl.blendEquation(_gl.FUNC_ADD);\n                _gl.blendFunc(_gl.SRC_ALPHA, _gl.ONE);\n            } else if (blending === THREE.SubtractiveBlending) {\n                // TODO: Find blendFuncSeparate() combination\n                _gl.enable(_gl.BLEND);\n                _gl.blendEquation(_gl.FUNC_ADD);\n                _gl.blendFunc(_gl.ZERO, _gl.ONE_MINUS_SRC_COLOR);\n            } else if (blending === THREE.MultiplyBlending) {\n                // TODO: Find blendFuncSeparate() combination\n                _gl.enable(_gl.BLEND);\n                _gl.blendEquation(_gl.FUNC_ADD);\n                _gl.blendFunc(_gl.ZERO, _gl.SRC_COLOR);\n            } else if (blending === THREE.CustomBlending) _gl.enable(_gl.BLEND);\n            else {\n                _gl.enable(_gl.BLEND);\n                _gl.blendEquationSeparate(_gl.FUNC_ADD, _gl.FUNC_ADD);\n                _gl.blendFuncSeparate(_gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA, _gl.ONE, _gl.ONE_MINUS_SRC_ALPHA);\n            }\n            _oldBlending = blending;\n        }\n        if (blending === THREE.CustomBlending) {\n            if (blendEquation !== _oldBlendEquation) {\n                _gl.blendEquation(paramThreeToGL(blendEquation));\n                _oldBlendEquation = blendEquation;\n            }\n            if (blendSrc !== _oldBlendSrc || blendDst !== _oldBlendDst) {\n                _gl.blendFunc(paramThreeToGL(blendSrc), paramThreeToGL(blendDst));\n                _oldBlendSrc = blendSrc;\n                _oldBlendDst = blendDst;\n            }\n        } else {\n            _oldBlendEquation = null;\n            _oldBlendSrc = null;\n            _oldBlendDst = null;\n        }\n    };\n    // Defines\n    function generateDefines(defines) {\n        var value, chunk, chunks = [];\n        for(var d in defines){\n            value = defines[d];\n            if (value === false) continue;\n            chunk = \"#define \" + d + \" \" + value;\n            chunks.push(chunk);\n        }\n        return chunks.join(\"\\n\");\n    }\n    // Shaders\n    function buildProgram(shaderID, fragmentShader, vertexShader, uniforms, attributes, defines, parameters) {\n        var p, pl, d, program, code;\n        var chunks = [];\n        // Generate code\n        if (shaderID) chunks.push(shaderID);\n        else {\n            chunks.push(fragmentShader);\n            chunks.push(vertexShader);\n        }\n        for(d in defines){\n            chunks.push(d);\n            chunks.push(defines[d]);\n        }\n        for(p in parameters){\n            chunks.push(p);\n            chunks.push(parameters[p]);\n        }\n        code = chunks.join();\n        // Check if code has been already compiled\n        for(p = 0, pl = _programs.length; p < pl; p++){\n            var programInfo = _programs[p];\n            if (programInfo.code === code) {\n                //console.log( \"Code already compiled.\" /*: \\n\\n\" + code*/ );\n                programInfo.usedTimes++;\n                return programInfo.program;\n            }\n        }\n        var shadowMapTypeDefine = \"SHADOWMAP_TYPE_BASIC\";\n        if (parameters.shadowMapType === THREE.PCFShadowMap) shadowMapTypeDefine = \"SHADOWMAP_TYPE_PCF\";\n        else if (parameters.shadowMapType === THREE.PCFSoftShadowMap) shadowMapTypeDefine = \"SHADOWMAP_TYPE_PCF_SOFT\";\n        //console.log( \"building new program \" );\n        //\n        var customDefines = generateDefines(defines);\n        //\n        program = _gl.createProgram();\n        var prefix_vertex = [\n            \"precision \" + _precision + \" float;\",\n            customDefines,\n            _supportsVertexTextures ? \"#define VERTEX_TEXTURES\" : \"\",\n            _this.gammaInput ? \"#define GAMMA_INPUT\" : \"\",\n            _this.gammaOutput ? \"#define GAMMA_OUTPUT\" : \"\",\n            _this.physicallyBasedShading ? \"#define PHYSICALLY_BASED_SHADING\" : \"\",\n            \"#define MAX_DIR_LIGHTS \" + parameters.maxDirLights,\n            \"#define MAX_POINT_LIGHTS \" + parameters.maxPointLights,\n            \"#define MAX_SPOT_LIGHTS \" + parameters.maxSpotLights,\n            \"#define MAX_HEMI_LIGHTS \" + parameters.maxHemiLights,\n            \"#define MAX_SHADOWS \" + parameters.maxShadows,\n            \"#define MAX_BONES \" + parameters.maxBones,\n            parameters.map ? \"#define USE_MAP\" : \"\",\n            parameters.envMap ? \"#define USE_ENVMAP\" : \"\",\n            parameters.lightMap ? \"#define USE_LIGHTMAP\" : \"\",\n            parameters.bumpMap ? \"#define USE_BUMPMAP\" : \"\",\n            parameters.normalMap ? \"#define USE_NORMALMAP\" : \"\",\n            parameters.specularMap ? \"#define USE_SPECULARMAP\" : \"\",\n            parameters.vertexColors ? \"#define USE_COLOR\" : \"\",\n            parameters.skinning ? \"#define USE_SKINNING\" : \"\",\n            parameters.useVertexTexture ? \"#define BONE_TEXTURE\" : \"\",\n            parameters.boneTextureWidth ? \"#define N_BONE_PIXEL_X \" + parameters.boneTextureWidth.toFixed(1) : \"\",\n            parameters.boneTextureHeight ? \"#define N_BONE_PIXEL_Y \" + parameters.boneTextureHeight.toFixed(1) : \"\",\n            parameters.morphTargets ? \"#define USE_MORPHTARGETS\" : \"\",\n            parameters.morphNormals ? \"#define USE_MORPHNORMALS\" : \"\",\n            parameters.perPixel ? \"#define PHONG_PER_PIXEL\" : \"\",\n            parameters.wrapAround ? \"#define WRAP_AROUND\" : \"\",\n            parameters.doubleSided ? \"#define DOUBLE_SIDED\" : \"\",\n            parameters.flipSided ? \"#define FLIP_SIDED\" : \"\",\n            parameters.shadowMapEnabled ? \"#define USE_SHADOWMAP\" : \"\",\n            parameters.shadowMapEnabled ? \"#define \" + shadowMapTypeDefine : \"\",\n            parameters.shadowMapDebug ? \"#define SHADOWMAP_DEBUG\" : \"\",\n            parameters.shadowMapCascade ? \"#define SHADOWMAP_CASCADE\" : \"\",\n            parameters.sizeAttenuation ? \"#define USE_SIZEATTENUATION\" : \"\",\n            \"uniform mat4 modelMatrix;\",\n            \"uniform mat4 modelViewMatrix;\",\n            \"uniform mat4 projectionMatrix;\",\n            \"uniform mat4 viewMatrix;\",\n            \"uniform mat3 normalMatrix;\",\n            \"uniform vec3 cameraPosition;\",\n            \"attribute vec3 position;\",\n            \"attribute vec3 normal;\",\n            \"attribute vec2 uv;\",\n            \"attribute vec2 uv2;\",\n            \"#ifdef USE_COLOR\",\n            \"attribute vec3 color;\",\n            \"#endif\",\n            \"#ifdef USE_MORPHTARGETS\",\n            \"attribute vec3 morphTarget0;\",\n            \"attribute vec3 morphTarget1;\",\n            \"attribute vec3 morphTarget2;\",\n            \"attribute vec3 morphTarget3;\",\n            \"#ifdef USE_MORPHNORMALS\",\n            \"attribute vec3 morphNormal0;\",\n            \"attribute vec3 morphNormal1;\",\n            \"attribute vec3 morphNormal2;\",\n            \"attribute vec3 morphNormal3;\",\n            \"#else\",\n            \"attribute vec3 morphTarget4;\",\n            \"attribute vec3 morphTarget5;\",\n            \"attribute vec3 morphTarget6;\",\n            \"attribute vec3 morphTarget7;\",\n            \"#endif\",\n            \"#endif\",\n            \"#ifdef USE_SKINNING\",\n            \"attribute vec4 skinIndex;\",\n            \"attribute vec4 skinWeight;\",\n            \"#endif\",\n            \"\"\n        ].join(\"\\n\");\n        var prefix_fragment = [\n            \"precision \" + _precision + \" float;\",\n            parameters.bumpMap || parameters.normalMap ? \"#extension GL_OES_standard_derivatives : enable\" : \"\",\n            customDefines,\n            \"#define MAX_DIR_LIGHTS \" + parameters.maxDirLights,\n            \"#define MAX_POINT_LIGHTS \" + parameters.maxPointLights,\n            \"#define MAX_SPOT_LIGHTS \" + parameters.maxSpotLights,\n            \"#define MAX_HEMI_LIGHTS \" + parameters.maxHemiLights,\n            \"#define MAX_SHADOWS \" + parameters.maxShadows,\n            parameters.alphaTest ? \"#define ALPHATEST \" + parameters.alphaTest : \"\",\n            _this.gammaInput ? \"#define GAMMA_INPUT\" : \"\",\n            _this.gammaOutput ? \"#define GAMMA_OUTPUT\" : \"\",\n            _this.physicallyBasedShading ? \"#define PHYSICALLY_BASED_SHADING\" : \"\",\n            parameters.useFog && parameters.fog ? \"#define USE_FOG\" : \"\",\n            parameters.useFog && parameters.fogExp ? \"#define FOG_EXP2\" : \"\",\n            parameters.map ? \"#define USE_MAP\" : \"\",\n            parameters.envMap ? \"#define USE_ENVMAP\" : \"\",\n            parameters.lightMap ? \"#define USE_LIGHTMAP\" : \"\",\n            parameters.bumpMap ? \"#define USE_BUMPMAP\" : \"\",\n            parameters.normalMap ? \"#define USE_NORMALMAP\" : \"\",\n            parameters.specularMap ? \"#define USE_SPECULARMAP\" : \"\",\n            parameters.vertexColors ? \"#define USE_COLOR\" : \"\",\n            parameters.metal ? \"#define METAL\" : \"\",\n            parameters.perPixel ? \"#define PHONG_PER_PIXEL\" : \"\",\n            parameters.wrapAround ? \"#define WRAP_AROUND\" : \"\",\n            parameters.doubleSided ? \"#define DOUBLE_SIDED\" : \"\",\n            parameters.flipSided ? \"#define FLIP_SIDED\" : \"\",\n            parameters.shadowMapEnabled ? \"#define USE_SHADOWMAP\" : \"\",\n            parameters.shadowMapEnabled ? \"#define \" + shadowMapTypeDefine : \"\",\n            parameters.shadowMapDebug ? \"#define SHADOWMAP_DEBUG\" : \"\",\n            parameters.shadowMapCascade ? \"#define SHADOWMAP_CASCADE\" : \"\",\n            \"uniform mat4 viewMatrix;\",\n            \"uniform vec3 cameraPosition;\",\n            \"\"\n        ].join(\"\\n\");\n        var glFragmentShader = getShader(\"fragment\", prefix_fragment + fragmentShader);\n        var glVertexShader = getShader(\"vertex\", prefix_vertex + vertexShader);\n        _gl.attachShader(program, glVertexShader);\n        _gl.attachShader(program, glFragmentShader);\n        _gl.linkProgram(program);\n        if (!_gl.getProgramParameter(program, _gl.LINK_STATUS)) console.error(\"Could not initialise shader\\nVALIDATE_STATUS: \" + _gl.getProgramParameter(program, _gl.VALIDATE_STATUS) + \", gl error [\" + _gl.getError() + \"]\");\n        // clean up\n        _gl.deleteShader(glFragmentShader);\n        _gl.deleteShader(glVertexShader);\n        //console.log( prefix_fragment + fragmentShader );\n        //console.log( prefix_vertex + vertexShader );\n        program.uniforms = {};\n        program.attributes = {};\n        var identifiers, u, a, i;\n        // cache uniform locations\n        identifiers = [\n            \"viewMatrix\",\n            \"modelViewMatrix\",\n            \"projectionMatrix\",\n            \"normalMatrix\",\n            \"modelMatrix\",\n            \"cameraPosition\",\n            \"morphTargetInfluences\"\n        ];\n        if (parameters.useVertexTexture) identifiers.push(\"boneTexture\");\n        else identifiers.push(\"boneGlobalMatrices\");\n        for(u in uniforms)identifiers.push(u);\n        cacheUniformLocations(program, identifiers);\n        // cache attributes locations\n        identifiers = [\n            \"position\",\n            \"normal\",\n            \"uv\",\n            \"uv2\",\n            \"tangent\",\n            \"color\",\n            \"skinIndex\",\n            \"skinWeight\",\n            \"lineDistance\"\n        ];\n        for(i = 0; i < parameters.maxMorphTargets; i++)identifiers.push(\"morphTarget\" + i);\n        for(i = 0; i < parameters.maxMorphNormals; i++)identifiers.push(\"morphNormal\" + i);\n        for(a in attributes)identifiers.push(a);\n        cacheAttributeLocations(program, identifiers);\n        program.id = _programs_counter++;\n        _programs.push({\n            program: program,\n            code: code,\n            usedTimes: 1\n        });\n        _this.info.memory.programs = _programs.length;\n        return program;\n    }\n    // Shader parameters cache\n    function cacheUniformLocations(program, identifiers) {\n        var i, l, id;\n        for(i = 0, l = identifiers.length; i < l; i++){\n            id = identifiers[i];\n            program.uniforms[id] = _gl.getUniformLocation(program, id);\n        }\n    }\n    function cacheAttributeLocations(program, identifiers) {\n        var i, l, id;\n        for(i = 0, l = identifiers.length; i < l; i++){\n            id = identifiers[i];\n            program.attributes[id] = _gl.getAttribLocation(program, id);\n        }\n    }\n    function addLineNumbers(string) {\n        var chunks = string.split(\"\\n\");\n        for(var i = 0, il = chunks.length; i < il; i++)// Chrome reports shader errors on lines\n        // starting counting from 1\n        chunks[i] = i + 1 + \": \" + chunks[i];\n        return chunks.join(\"\\n\");\n    }\n    function getShader(type, string) {\n        var shader;\n        if (type === \"fragment\") shader = _gl.createShader(_gl.FRAGMENT_SHADER);\n        else if (type === \"vertex\") shader = _gl.createShader(_gl.VERTEX_SHADER);\n        _gl.shaderSource(shader, string);\n        _gl.compileShader(shader);\n        if (!_gl.getShaderParameter(shader, _gl.COMPILE_STATUS)) {\n            console.error(_gl.getShaderInfoLog(shader));\n            console.error(addLineNumbers(string));\n            return null;\n        }\n        return shader;\n    }\n    // Textures\n    function isPowerOfTwo(value) {\n        return (value & value - 1) === 0;\n    }\n    function setTextureParameters(textureType, texture, isImagePowerOfTwo) {\n        if (isImagePowerOfTwo) {\n            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL(texture.wrapS));\n            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL(texture.wrapT));\n            _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL(texture.magFilter));\n            _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL(texture.minFilter));\n        } else {\n            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);\n            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);\n            _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter));\n            _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter));\n        }\n        if (_glExtensionTextureFilterAnisotropic && texture.type !== THREE.FloatType) {\n            if (texture.anisotropy > 1 || texture.__oldAnisotropy) {\n                _gl.texParameterf(textureType, _glExtensionTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, _maxAnisotropy));\n                texture.__oldAnisotropy = texture.anisotropy;\n            }\n        }\n    }\n    this.setTexture = function(texture, slot) {\n        if (texture.needsUpdate) {\n            if (!texture.__webglInit) {\n                texture.__webglInit = true;\n                texture.addEventListener(\"dispose\", onTextureDispose);\n                texture.__webglTexture = _gl.createTexture();\n                _this.info.memory.textures++;\n            }\n            _gl.activeTexture(_gl.TEXTURE0 + slot);\n            _gl.bindTexture(_gl.TEXTURE_2D, texture.__webglTexture);\n            _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);\n            _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);\n            _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);\n            var image = texture.image, isImagePowerOfTwo = isPowerOfTwo(image.width) && isPowerOfTwo(image.height), glFormat = paramThreeToGL(texture.format), glType = paramThreeToGL(texture.type);\n            setTextureParameters(_gl.TEXTURE_2D, texture, isImagePowerOfTwo);\n            var mipmap, mipmaps = texture.mipmaps;\n            if (texture instanceof THREE.DataTexture) {\n                // use manually created mipmaps if available\n                // if there are no manual mipmaps\n                // set 0 level mipmap and then use GL to generate other mipmap levels\n                if (mipmaps.length > 0 && isImagePowerOfTwo) {\n                    for(var i = 0, il = mipmaps.length; i < il; i++){\n                        mipmap = mipmaps[i];\n                        _gl.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);\n                    }\n                    texture.generateMipmaps = false;\n                } else _gl.texImage2D(_gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data);\n            } else if (texture instanceof THREE.CompressedTexture) // compressed textures can only use manually created mipmaps\n            // WebGL can't generate mipmaps for DDS textures\n            for(var i = 0, il = mipmaps.length; i < il; i++){\n                mipmap = mipmaps[i];\n                _gl.compressedTexImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data);\n            }\n            else // use manually created mipmaps if available\n            // if there are no manual mipmaps\n            // set 0 level mipmap and then use GL to generate other mipmap levels\n            if (mipmaps.length > 0 && isImagePowerOfTwo) {\n                for(var i = 0, il = mipmaps.length; i < il; i++){\n                    mipmap = mipmaps[i];\n                    _gl.texImage2D(_gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap);\n                }\n                texture.generateMipmaps = false;\n            } else _gl.texImage2D(_gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image);\n            if (texture.generateMipmaps && isImagePowerOfTwo) _gl.generateMipmap(_gl.TEXTURE_2D);\n            texture.needsUpdate = false;\n            if (texture.onUpdate) texture.onUpdate();\n        } else {\n            _gl.activeTexture(_gl.TEXTURE0 + slot);\n            _gl.bindTexture(_gl.TEXTURE_2D, texture.__webglTexture);\n        }\n    };\n    function clampToMaxSize(image, maxSize) {\n        if (image.width <= maxSize && image.height <= maxSize) return image;\n        // Warning: Scaling through the canvas will only work with images that use\n        // premultiplied alpha.\n        var maxDimension = Math.max(image.width, image.height);\n        var newWidth = Math.floor(image.width * maxSize / maxDimension);\n        var newHeight = Math.floor(image.height * maxSize / maxDimension);\n        var canvas = document.createElement(\"canvas\");\n        canvas.width = newWidth;\n        canvas.height = newHeight;\n        var ctx = canvas.getContext(\"2d\");\n        ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, newWidth, newHeight);\n        return canvas;\n    }\n    function setCubeTexture(texture, slot) {\n        if (texture.image.length === 6) {\n            if (texture.needsUpdate) {\n                if (!texture.image.__webglTextureCube) {\n                    texture.image.__webglTextureCube = _gl.createTexture();\n                    _this.info.memory.textures++;\n                }\n                _gl.activeTexture(_gl.TEXTURE0 + slot);\n                _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube);\n                _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);\n                var isCompressed = texture instanceof THREE.CompressedTexture;\n                var cubeImage = [];\n                for(var i = 0; i < 6; i++)if (_this.autoScaleCubemaps && !isCompressed) cubeImage[i] = clampToMaxSize(texture.image[i], _maxCubemapSize);\n                else cubeImage[i] = texture.image[i];\n                var image = cubeImage[0], isImagePowerOfTwo = isPowerOfTwo(image.width) && isPowerOfTwo(image.height), glFormat = paramThreeToGL(texture.format), glType = paramThreeToGL(texture.type);\n                setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo);\n                for(var i = 0; i < 6; i++)if (isCompressed) {\n                    var mipmap, mipmaps = cubeImage[i].mipmaps;\n                    for(var j = 0, jl = mipmaps.length; j < jl; j++){\n                        mipmap = mipmaps[j];\n                        _gl.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data);\n                    }\n                } else _gl.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[i]);\n                if (texture.generateMipmaps && isImagePowerOfTwo) _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);\n                texture.needsUpdate = false;\n                if (texture.onUpdate) texture.onUpdate();\n            } else {\n                _gl.activeTexture(_gl.TEXTURE0 + slot);\n                _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube);\n            }\n        }\n    }\n    function setCubeTextureDynamic(texture, slot) {\n        _gl.activeTexture(_gl.TEXTURE0 + slot);\n        _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, texture.__webglTexture);\n    }\n    // Render targets\n    function setupFrameBuffer(framebuffer, renderTarget, textureTarget) {\n        _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);\n        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureTarget, renderTarget.__webglTexture, 0);\n    }\n    function setupRenderBuffer(renderbuffer, renderTarget) {\n        _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);\n        if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {\n            _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height);\n            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);\n        /* For some reason this is not working. Defaulting to RGBA4.\n\t\t} else if( ! renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\n\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.STENCIL_INDEX8, renderTarget.width, renderTarget.height );\n\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\t\t*/ } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {\n            _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height);\n            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);\n        } else _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height);\n    }\n    this.setRenderTarget = function(renderTarget) {\n        var isCube = renderTarget instanceof THREE.WebGLRenderTargetCube;\n        if (renderTarget && !renderTarget.__webglFramebuffer) {\n            if (renderTarget.depthBuffer === undefined) renderTarget.depthBuffer = true;\n            if (renderTarget.stencilBuffer === undefined) renderTarget.stencilBuffer = true;\n            renderTarget.addEventListener(\"dispose\", onRenderTargetDispose);\n            renderTarget.__webglTexture = _gl.createTexture();\n            _this.info.memory.textures++;\n            // Setup texture, create render and frame buffers\n            var isTargetPowerOfTwo = isPowerOfTwo(renderTarget.width) && isPowerOfTwo(renderTarget.height), glFormat = paramThreeToGL(renderTarget.format), glType = paramThreeToGL(renderTarget.type);\n            if (isCube) {\n                renderTarget.__webglFramebuffer = [];\n                renderTarget.__webglRenderbuffer = [];\n                _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture);\n                setTextureParameters(_gl.TEXTURE_CUBE_MAP, renderTarget, isTargetPowerOfTwo);\n                for(var i = 0; i < 6; i++){\n                    renderTarget.__webglFramebuffer[i] = _gl.createFramebuffer();\n                    renderTarget.__webglRenderbuffer[i] = _gl.createRenderbuffer();\n                    _gl.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);\n                    setupFrameBuffer(renderTarget.__webglFramebuffer[i], renderTarget, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i);\n                    setupRenderBuffer(renderTarget.__webglRenderbuffer[i], renderTarget);\n                }\n                if (isTargetPowerOfTwo) _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);\n            } else {\n                renderTarget.__webglFramebuffer = _gl.createFramebuffer();\n                if (renderTarget.shareDepthFrom) renderTarget.__webglRenderbuffer = renderTarget.shareDepthFrom.__webglRenderbuffer;\n                else renderTarget.__webglRenderbuffer = _gl.createRenderbuffer();\n                _gl.bindTexture(_gl.TEXTURE_2D, renderTarget.__webglTexture);\n                setTextureParameters(_gl.TEXTURE_2D, renderTarget, isTargetPowerOfTwo);\n                _gl.texImage2D(_gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);\n                setupFrameBuffer(renderTarget.__webglFramebuffer, renderTarget, _gl.TEXTURE_2D);\n                if (renderTarget.shareDepthFrom) {\n                    if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer);\n                    else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer);\n                } else setupRenderBuffer(renderTarget.__webglRenderbuffer, renderTarget);\n                if (isTargetPowerOfTwo) _gl.generateMipmap(_gl.TEXTURE_2D);\n            }\n            // Release everything\n            if (isCube) _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, null);\n            else _gl.bindTexture(_gl.TEXTURE_2D, null);\n            _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);\n            _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);\n        }\n        var framebuffer, width, height, vx, vy;\n        if (renderTarget) {\n            if (isCube) framebuffer = renderTarget.__webglFramebuffer[renderTarget.activeCubeFace];\n            else framebuffer = renderTarget.__webglFramebuffer;\n            width = renderTarget.width;\n            height = renderTarget.height;\n            vx = 0;\n            vy = 0;\n        } else {\n            framebuffer = null;\n            width = _viewportWidth;\n            height = _viewportHeight;\n            vx = _viewportX;\n            vy = _viewportY;\n        }\n        if (framebuffer !== _currentFramebuffer) {\n            _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);\n            _gl.viewport(vx, vy, width, height);\n            _currentFramebuffer = framebuffer;\n        }\n        _currentWidth = width;\n        _currentHeight = height;\n    };\n    function updateRenderTargetMipmap(renderTarget) {\n        if (renderTarget instanceof THREE.WebGLRenderTargetCube) {\n            _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture);\n            _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);\n            _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, null);\n        } else {\n            _gl.bindTexture(_gl.TEXTURE_2D, renderTarget.__webglTexture);\n            _gl.generateMipmap(_gl.TEXTURE_2D);\n            _gl.bindTexture(_gl.TEXTURE_2D, null);\n        }\n    }\n    // Fallback filters for non-power-of-2 textures\n    function filterFallback(f) {\n        if (f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter) return _gl.NEAREST;\n        return _gl.LINEAR;\n    }\n    // Map three.js constants to WebGL constants\n    function paramThreeToGL(p) {\n        if (p === THREE.RepeatWrapping) return _gl.REPEAT;\n        if (p === THREE.ClampToEdgeWrapping) return _gl.CLAMP_TO_EDGE;\n        if (p === THREE.MirroredRepeatWrapping) return _gl.MIRRORED_REPEAT;\n        if (p === THREE.NearestFilter) return _gl.NEAREST;\n        if (p === THREE.NearestMipMapNearestFilter) return _gl.NEAREST_MIPMAP_NEAREST;\n        if (p === THREE.NearestMipMapLinearFilter) return _gl.NEAREST_MIPMAP_LINEAR;\n        if (p === THREE.LinearFilter) return _gl.LINEAR;\n        if (p === THREE.LinearMipMapNearestFilter) return _gl.LINEAR_MIPMAP_NEAREST;\n        if (p === THREE.LinearMipMapLinearFilter) return _gl.LINEAR_MIPMAP_LINEAR;\n        if (p === THREE.UnsignedByteType) return _gl.UNSIGNED_BYTE;\n        if (p === THREE.UnsignedShort4444Type) return _gl.UNSIGNED_SHORT_4_4_4_4;\n        if (p === THREE.UnsignedShort5551Type) return _gl.UNSIGNED_SHORT_5_5_5_1;\n        if (p === THREE.UnsignedShort565Type) return _gl.UNSIGNED_SHORT_5_6_5;\n        if (p === THREE.ByteType) return _gl.BYTE;\n        if (p === THREE.ShortType) return _gl.SHORT;\n        if (p === THREE.UnsignedShortType) return _gl.UNSIGNED_SHORT;\n        if (p === THREE.IntType) return _gl.INT;\n        if (p === THREE.UnsignedIntType) return _gl.UNSIGNED_INT;\n        if (p === THREE.FloatType) return _gl.FLOAT;\n        if (p === THREE.AlphaFormat) return _gl.ALPHA;\n        if (p === THREE.RGBFormat) return _gl.RGB;\n        if (p === THREE.RGBAFormat) return _gl.RGBA;\n        if (p === THREE.LuminanceFormat) return _gl.LUMINANCE;\n        if (p === THREE.LuminanceAlphaFormat) return _gl.LUMINANCE_ALPHA;\n        if (p === THREE.AddEquation) return _gl.FUNC_ADD;\n        if (p === THREE.SubtractEquation) return _gl.FUNC_SUBTRACT;\n        if (p === THREE.ReverseSubtractEquation) return _gl.FUNC_REVERSE_SUBTRACT;\n        if (p === THREE.ZeroFactor) return _gl.ZERO;\n        if (p === THREE.OneFactor) return _gl.ONE;\n        if (p === THREE.SrcColorFactor) return _gl.SRC_COLOR;\n        if (p === THREE.OneMinusSrcColorFactor) return _gl.ONE_MINUS_SRC_COLOR;\n        if (p === THREE.SrcAlphaFactor) return _gl.SRC_ALPHA;\n        if (p === THREE.OneMinusSrcAlphaFactor) return _gl.ONE_MINUS_SRC_ALPHA;\n        if (p === THREE.DstAlphaFactor) return _gl.DST_ALPHA;\n        if (p === THREE.OneMinusDstAlphaFactor) return _gl.ONE_MINUS_DST_ALPHA;\n        if (p === THREE.DstColorFactor) return _gl.DST_COLOR;\n        if (p === THREE.OneMinusDstColorFactor) return _gl.ONE_MINUS_DST_COLOR;\n        if (p === THREE.SrcAlphaSaturateFactor) return _gl.SRC_ALPHA_SATURATE;\n        if (_glExtensionCompressedTextureS3TC !== undefined) {\n            if (p === THREE.RGB_S3TC_DXT1_Format) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGB_S3TC_DXT1_EXT;\n            if (p === THREE.RGBA_S3TC_DXT1_Format) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n            if (p === THREE.RGBA_S3TC_DXT3_Format) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n            if (p === THREE.RGBA_S3TC_DXT5_Format) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n        }\n        return 0;\n    }\n    // Allocations\n    function allocateBones(object) {\n        if (_supportsBoneTextures && object && object.useVertexTexture) return 1024;\n        else {\n            // default for when object is not specified\n            // ( for example when prebuilding shader\n            //   to be used with multiple objects )\n            //\n            // \t- leave some extra space for other uniforms\n            //  - limit here is ANGLE's 254 max uniform vectors\n            //    (up to 54 should be safe)\n            var nVertexUniforms = _gl.getParameter(_gl.MAX_VERTEX_UNIFORM_VECTORS);\n            var nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);\n            var maxBones = nVertexMatrices;\n            if (object !== undefined && object instanceof THREE.SkinnedMesh) {\n                maxBones = Math.min(object.bones.length, maxBones);\n                if (maxBones < object.bones.length) console.warn(\"WebGLRenderer: too many bones - \" + object.bones.length + \", this GPU supports just \" + maxBones + \" (try OpenGL instead of ANGLE)\");\n            }\n            return maxBones;\n        }\n    }\n    function allocateLights(lights) {\n        var l, ll, light, dirLights, pointLights, spotLights, hemiLights;\n        dirLights = pointLights = spotLights = hemiLights = 0;\n        for(l = 0, ll = lights.length; l < ll; l++){\n            light = lights[l];\n            if (light.onlyShadow) continue;\n            if (light instanceof THREE.DirectionalLight) dirLights++;\n            if (light instanceof THREE.PointLight) pointLights++;\n            if (light instanceof THREE.SpotLight) spotLights++;\n            if (light instanceof THREE.HemisphereLight) hemiLights++;\n        }\n        return {\n            \"directional\": dirLights,\n            \"point\": pointLights,\n            \"spot\": spotLights,\n            \"hemi\": hemiLights\n        };\n    }\n    function allocateShadows(lights) {\n        var l, ll, light, maxShadows = 0;\n        for(l = 0, ll = lights.length; l < ll; l++){\n            light = lights[l];\n            if (!light.castShadow) continue;\n            if (light instanceof THREE.SpotLight) maxShadows++;\n            if (light instanceof THREE.DirectionalLight && !light.shadowCascade) maxShadows++;\n        }\n        return maxShadows;\n    }\n    // Initialization\n    function initGL() {\n        try {\n            if (!(_gl = _canvas.getContext(\"experimental-webgl\", {\n                alpha: _alpha,\n                premultipliedAlpha: _premultipliedAlpha,\n                antialias: _antialias,\n                stencil: _stencil,\n                preserveDrawingBuffer: _preserveDrawingBuffer\n            }))) throw \"Error creating WebGL context.\";\n        } catch (error) {\n            console.error(error);\n        }\n        _glExtensionTextureFloat = _gl.getExtension(\"OES_texture_float\");\n        _glExtensionStandardDerivatives = _gl.getExtension(\"OES_standard_derivatives\");\n        _glExtensionTextureFilterAnisotropic = _gl.getExtension(\"EXT_texture_filter_anisotropic\") || _gl.getExtension(\"MOZ_EXT_texture_filter_anisotropic\") || _gl.getExtension(\"WEBKIT_EXT_texture_filter_anisotropic\");\n        _glExtensionCompressedTextureS3TC = _gl.getExtension(\"WEBGL_compressed_texture_s3tc\") || _gl.getExtension(\"MOZ_WEBGL_compressed_texture_s3tc\") || _gl.getExtension(\"WEBKIT_WEBGL_compressed_texture_s3tc\");\n        if (!_glExtensionTextureFloat) console.log(\"THREE.WebGLRenderer: Float textures not supported.\");\n        if (!_glExtensionStandardDerivatives) console.log(\"THREE.WebGLRenderer: Standard derivatives not supported.\");\n        if (!_glExtensionTextureFilterAnisotropic) console.log(\"THREE.WebGLRenderer: Anisotropic texture filtering not supported.\");\n        if (!_glExtensionCompressedTextureS3TC) console.log(\"THREE.WebGLRenderer: S3TC compressed textures not supported.\");\n        if (_gl.getShaderPrecisionFormat === undefined) _gl.getShaderPrecisionFormat = function() {\n            return {\n                \"rangeMin\": 1,\n                \"rangeMax\": 1,\n                \"precision\": 1\n            };\n        };\n    }\n    function setDefaultGLState() {\n        _gl.clearColor(0, 0, 0, 1);\n        _gl.clearDepth(1);\n        _gl.clearStencil(0);\n        _gl.enable(_gl.DEPTH_TEST);\n        _gl.depthFunc(_gl.LEQUAL);\n        _gl.frontFace(_gl.CCW);\n        _gl.cullFace(_gl.BACK);\n        _gl.enable(_gl.CULL_FACE);\n        _gl.enable(_gl.BLEND);\n        _gl.blendEquation(_gl.FUNC_ADD);\n        _gl.blendFunc(_gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA);\n        _gl.clearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha);\n    }\n    // default plugins (order is important)\n    this.shadowMapPlugin = new THREE.ShadowMapPlugin();\n    this.addPrePlugin(this.shadowMapPlugin);\n    this.addPostPlugin(new THREE.SpritePlugin());\n    this.addPostPlugin(new THREE.LensFlarePlugin());\n};\n/**\n * @author szimek / https://github.com/szimek/\n * @author alteredq / http://alteredqualia.com/\n */ THREE.WebGLRenderTarget = function(width, height, options) {\n    THREE.EventDispatcher.call(this);\n    this.width = width;\n    this.height = height;\n    options = options || {};\n    this.wrapS = options.wrapS !== undefined ? options.wrapS : THREE.ClampToEdgeWrapping;\n    this.wrapT = options.wrapT !== undefined ? options.wrapT : THREE.ClampToEdgeWrapping;\n    this.magFilter = options.magFilter !== undefined ? options.magFilter : THREE.LinearFilter;\n    this.minFilter = options.minFilter !== undefined ? options.minFilter : THREE.LinearMipMapLinearFilter;\n    this.anisotropy = options.anisotropy !== undefined ? options.anisotropy : 1;\n    this.offset = new THREE.Vector2(0, 0);\n    this.repeat = new THREE.Vector2(1, 1);\n    this.format = options.format !== undefined ? options.format : THREE.RGBAFormat;\n    this.type = options.type !== undefined ? options.type : THREE.UnsignedByteType;\n    this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\n    this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;\n    this.generateMipmaps = true;\n    this.shareDepthFrom = null;\n};\nTHREE.WebGLRenderTarget.prototype.clone = function() {\n    var tmp = new THREE.WebGLRenderTarget(this.width, this.height);\n    tmp.wrapS = this.wrapS;\n    tmp.wrapT = this.wrapT;\n    tmp.magFilter = this.magFilter;\n    tmp.minFilter = this.minFilter;\n    tmp.anisotropy = this.anisotropy;\n    tmp.offset.copy(this.offset);\n    tmp.repeat.copy(this.repeat);\n    tmp.format = this.format;\n    tmp.type = this.type;\n    tmp.depthBuffer = this.depthBuffer;\n    tmp.stencilBuffer = this.stencilBuffer;\n    tmp.generateMipmaps = this.generateMipmaps;\n    tmp.shareDepthFrom = this.shareDepthFrom;\n    return tmp;\n};\nTHREE.WebGLRenderTarget.prototype.dispose = function() {\n    this.dispatchEvent({\n        type: \"dispose\"\n    });\n};\n/**\n * @author alteredq / http://alteredqualia.com\n */ THREE.WebGLRenderTargetCube = function(width, height, options) {\n    THREE.WebGLRenderTarget.call(this, width, height, options);\n    this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5\n};\nTHREE.WebGLRenderTargetCube.prototype = Object.create(THREE.WebGLRenderTarget.prototype);\n/**\n * @author mrdoob / http://mrdoob.com/\n */ THREE.RenderableVertex = function() {\n    this.positionWorld = new THREE.Vector3();\n    this.positionScreen = new THREE.Vector4();\n    this.visible = true;\n};\nTHREE.RenderableVertex.prototype.copy = function(vertex) {\n    this.positionWorld.copy(vertex.positionWorld);\n    this.positionScreen.copy(vertex.positionScreen);\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n */ THREE.RenderableFace3 = function() {\n    this.v1 = new THREE.RenderableVertex();\n    this.v2 = new THREE.RenderableVertex();\n    this.v3 = new THREE.RenderableVertex();\n    this.centroidModel = new THREE.Vector3();\n    this.normalModel = new THREE.Vector3();\n    this.normalModelView = new THREE.Vector3();\n    this.vertexNormalsLength = 0;\n    this.vertexNormalsModel = [\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3()\n    ];\n    this.vertexNormalsModelView = [\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3()\n    ];\n    this.color = null;\n    this.material = null;\n    this.uvs = [\n        []\n    ];\n    this.z = null;\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n */ THREE.RenderableFace4 = function() {\n    this.v1 = new THREE.RenderableVertex();\n    this.v2 = new THREE.RenderableVertex();\n    this.v3 = new THREE.RenderableVertex();\n    this.v4 = new THREE.RenderableVertex();\n    this.centroidModel = new THREE.Vector3();\n    this.normalModel = new THREE.Vector3();\n    this.normalModelView = new THREE.Vector3();\n    this.vertexNormalsLength = 0;\n    this.vertexNormalsModel = [\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3()\n    ];\n    this.vertexNormalsModelView = [\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3()\n    ];\n    this.color = null;\n    this.material = null;\n    this.uvs = [\n        []\n    ];\n    this.z = null;\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n */ THREE.RenderableObject = function() {\n    this.object = null;\n    this.z = null;\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n */ THREE.RenderableParticle = function() {\n    this.object = null;\n    this.x = null;\n    this.y = null;\n    this.z = null;\n    this.rotation = null;\n    this.scale = new THREE.Vector2();\n    this.material = null;\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n */ THREE.RenderableLine = function() {\n    this.z = null;\n    this.v1 = new THREE.RenderableVertex();\n    this.v2 = new THREE.RenderableVertex();\n    this.material = null;\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */ THREE.GeometryUtils = {\n    // Merge two geometries or geometry and geometry from object (using object's transform)\n    merge: function(geometry1, object2 /* mesh | geometry */ ) {\n        var matrix, normalMatrix, vertexOffset = geometry1.vertices.length, uvPosition = geometry1.faceVertexUvs[0].length, geometry2 = object2 instanceof THREE.Mesh ? object2.geometry : object2, vertices1 = geometry1.vertices, vertices2 = geometry2.vertices, faces1 = geometry1.faces, faces2 = geometry2.faces, uvs1 = geometry1.faceVertexUvs[0], uvs2 = geometry2.faceVertexUvs[0];\n        if (object2 instanceof THREE.Mesh) {\n            object2.matrixAutoUpdate && object2.updateMatrix();\n            matrix = object2.matrix;\n            normalMatrix = new THREE.Matrix3();\n            normalMatrix.getInverse(matrix);\n            normalMatrix.transpose();\n        }\n        // vertices\n        for(var i = 0, il = vertices2.length; i < il; i++){\n            var vertex = vertices2[i];\n            var vertexCopy = vertex.clone();\n            if (matrix) vertexCopy.applyMatrix4(matrix);\n            vertices1.push(vertexCopy);\n        }\n        // faces\n        for(i = 0, il = faces2.length; i < il; i++){\n            var face = faces2[i], faceCopy, normal, color, faceVertexNormals = face.vertexNormals, faceVertexColors = face.vertexColors;\n            if (face instanceof THREE.Face3) faceCopy = new THREE.Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);\n            else if (face instanceof THREE.Face4) faceCopy = new THREE.Face4(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset, face.d + vertexOffset);\n            faceCopy.normal.copy(face.normal);\n            if (normalMatrix) faceCopy.normal.applyMatrix3(normalMatrix).normalize();\n            for(var j = 0, jl = faceVertexNormals.length; j < jl; j++){\n                normal = faceVertexNormals[j].clone();\n                if (normalMatrix) normal.applyMatrix3(normalMatrix).normalize();\n                faceCopy.vertexNormals.push(normal);\n            }\n            faceCopy.color.copy(face.color);\n            for(var j = 0, jl = faceVertexColors.length; j < jl; j++){\n                color = faceVertexColors[j];\n                faceCopy.vertexColors.push(color.clone());\n            }\n            faceCopy.materialIndex = face.materialIndex;\n            faceCopy.centroid.copy(face.centroid);\n            if (matrix) faceCopy.centroid.applyMatrix4(matrix);\n            faces1.push(faceCopy);\n        }\n        // uvs\n        for(i = 0, il = uvs2.length; i < il; i++){\n            var uv = uvs2[i], uvCopy = [];\n            for(var j = 0, jl = uv.length; j < jl; j++)uvCopy.push(new THREE.Vector2(uv[j].x, uv[j].y));\n            uvs1.push(uvCopy);\n        }\n    },\n    removeMaterials: function(geometry, materialIndexArray) {\n        var materialIndexMap = {};\n        for(var i = 0, il = materialIndexArray.length; i < il; i++)materialIndexMap[materialIndexArray[i]] = true;\n        var face, newFaces = [];\n        for(var i = 0, il = geometry.faces.length; i < il; i++){\n            face = geometry.faces[i];\n            if (!(face.materialIndex in materialIndexMap)) newFaces.push(face);\n        }\n        geometry.faces = newFaces;\n    },\n    // Get random point in triangle (via barycentric coordinates)\n    // \t(uniform distribution)\n    // \thttp://www.cgafaq.info/wiki/Random_Point_In_Triangle\n    randomPointInTriangle: function(vectorA, vectorB, vectorC) {\n        var a, b, c, point = new THREE.Vector3(), tmp = THREE.GeometryUtils.__v1;\n        a = THREE.GeometryUtils.random();\n        b = THREE.GeometryUtils.random();\n        if (a + b > 1) {\n            a = 1 - a;\n            b = 1 - b;\n        }\n        c = 1 - a - b;\n        point.copy(vectorA);\n        point.multiplyScalar(a);\n        tmp.copy(vectorB);\n        tmp.multiplyScalar(b);\n        point.add(tmp);\n        tmp.copy(vectorC);\n        tmp.multiplyScalar(c);\n        point.add(tmp);\n        return point;\n    },\n    // Get random point in face (triangle / quad)\n    // (uniform distribution)\n    randomPointInFace: function(face, geometry, useCachedAreas) {\n        var vA, vB, vC, vD;\n        if (face instanceof THREE.Face3) {\n            vA = geometry.vertices[face.a];\n            vB = geometry.vertices[face.b];\n            vC = geometry.vertices[face.c];\n            return THREE.GeometryUtils.randomPointInTriangle(vA, vB, vC);\n        } else if (face instanceof THREE.Face4) {\n            vA = geometry.vertices[face.a];\n            vB = geometry.vertices[face.b];\n            vC = geometry.vertices[face.c];\n            vD = geometry.vertices[face.d];\n            var area1, area2;\n            if (useCachedAreas) {\n                if (face._area1 && face._area2) {\n                    area1 = face._area1;\n                    area2 = face._area2;\n                } else {\n                    area1 = THREE.GeometryUtils.triangleArea(vA, vB, vD);\n                    area2 = THREE.GeometryUtils.triangleArea(vB, vC, vD);\n                    face._area1 = area1;\n                    face._area2 = area2;\n                }\n            } else area1 = THREE.GeometryUtils.triangleArea(vA, vB, vD), area2 = THREE.GeometryUtils.triangleArea(vB, vC, vD);\n            var r = THREE.GeometryUtils.random() * (area1 + area2);\n            if (r < area1) return THREE.GeometryUtils.randomPointInTriangle(vA, vB, vD);\n            else return THREE.GeometryUtils.randomPointInTriangle(vB, vC, vD);\n        }\n    },\n    // Get uniformly distributed random points in mesh\n    // \t- create array with cumulative sums of face areas\n    //  - pick random number from 0 to total area\n    //  - find corresponding place in area array by binary search\n    //\t- get random point in face\n    randomPointsInGeometry: function(geometry, n) {\n        var face, i, faces = geometry.faces, vertices = geometry.vertices, il = faces.length, totalArea = 0, cumulativeAreas = [], vA, vB, vC, vD;\n        // precompute face areas\n        for(i = 0; i < il; i++){\n            face = faces[i];\n            if (face instanceof THREE.Face3) {\n                vA = vertices[face.a];\n                vB = vertices[face.b];\n                vC = vertices[face.c];\n                face._area = THREE.GeometryUtils.triangleArea(vA, vB, vC);\n            } else if (face instanceof THREE.Face4) {\n                vA = vertices[face.a];\n                vB = vertices[face.b];\n                vC = vertices[face.c];\n                vD = vertices[face.d];\n                face._area1 = THREE.GeometryUtils.triangleArea(vA, vB, vD);\n                face._area2 = THREE.GeometryUtils.triangleArea(vB, vC, vD);\n                face._area = face._area1 + face._area2;\n            }\n            totalArea += face._area;\n            cumulativeAreas[i] = totalArea;\n        }\n        // binary search cumulative areas array\n        function binarySearchIndices(value) {\n            function binarySearch(start, end) {\n                // return closest larger index\n                // if exact number is not found\n                if (end < start) return start;\n                var mid = start + Math.floor((end - start) / 2);\n                if (cumulativeAreas[mid] > value) return binarySearch(start, mid - 1);\n                else if (cumulativeAreas[mid] < value) return binarySearch(mid + 1, end);\n                else return mid;\n            }\n            var result = binarySearch(0, cumulativeAreas.length - 1);\n            return result;\n        }\n        // pick random face weighted by face area\n        var r, index, result = [];\n        var stats = {};\n        for(i = 0; i < n; i++){\n            r = THREE.GeometryUtils.random() * totalArea;\n            index = binarySearchIndices(r);\n            result[i] = THREE.GeometryUtils.randomPointInFace(faces[index], geometry, true);\n            if (!stats[index]) stats[index] = 1;\n            else stats[index] += 1;\n        }\n        return result;\n    },\n    // Get triangle area (half of parallelogram)\n    //\thttp://mathworld.wolfram.com/TriangleArea.html\n    triangleArea: function(vectorA, vectorB, vectorC) {\n        var tmp1 = THREE.GeometryUtils.__v1, tmp2 = THREE.GeometryUtils.__v2;\n        tmp1.subVectors(vectorB, vectorA);\n        tmp2.subVectors(vectorC, vectorA);\n        tmp1.cross(tmp2);\n        return 0.5 * tmp1.length();\n    },\n    // Center geometry so that 0,0,0 is in center of bounding box\n    center: function(geometry) {\n        geometry.computeBoundingBox();\n        var bb = geometry.boundingBox;\n        var offset = new THREE.Vector3();\n        offset.addVectors(bb.min, bb.max);\n        offset.multiplyScalar(-0.5);\n        geometry.applyMatrix(new THREE.Matrix4().makeTranslation(offset.x, offset.y, offset.z));\n        geometry.computeBoundingBox();\n        return offset;\n    },\n    // Normalize UVs to be from <0,1>\n    // (for now just the first set of UVs)\n    normalizeUVs: function(geometry) {\n        var uvSet = geometry.faceVertexUvs[0];\n        for(var i = 0, il = uvSet.length; i < il; i++){\n            var uvs = uvSet[i];\n            for(var j = 0, jl = uvs.length; j < jl; j++){\n                // texture repeat\n                if (uvs[j].x !== 1.0) uvs[j].x = uvs[j].x - Math.floor(uvs[j].x);\n                if (uvs[j].y !== 1.0) uvs[j].y = uvs[j].y - Math.floor(uvs[j].y);\n            }\n        }\n    },\n    triangulateQuads: function(geometry) {\n        var i, il, j, jl;\n        var faces = [];\n        var faceUvs = [];\n        var faceVertexUvs = [];\n        for(i = 0, il = geometry.faceUvs.length; i < il; i++)faceUvs[i] = [];\n        for(i = 0, il = geometry.faceVertexUvs.length; i < il; i++)faceVertexUvs[i] = [];\n        for(i = 0, il = geometry.faces.length; i < il; i++){\n            var face = geometry.faces[i];\n            if (face instanceof THREE.Face4) {\n                var a = face.a;\n                var b = face.b;\n                var c = face.c;\n                var d = face.d;\n                var triA = new THREE.Face3();\n                var triB = new THREE.Face3();\n                triA.color.copy(face.color);\n                triB.color.copy(face.color);\n                triA.materialIndex = face.materialIndex;\n                triB.materialIndex = face.materialIndex;\n                triA.a = a;\n                triA.b = b;\n                triA.c = d;\n                triB.a = b;\n                triB.b = c;\n                triB.c = d;\n                if (face.vertexColors.length === 4) {\n                    triA.vertexColors[0] = face.vertexColors[0].clone();\n                    triA.vertexColors[1] = face.vertexColors[1].clone();\n                    triA.vertexColors[2] = face.vertexColors[3].clone();\n                    triB.vertexColors[0] = face.vertexColors[1].clone();\n                    triB.vertexColors[1] = face.vertexColors[2].clone();\n                    triB.vertexColors[2] = face.vertexColors[3].clone();\n                }\n                faces.push(triA, triB);\n                for(j = 0, jl = geometry.faceVertexUvs.length; j < jl; j++)if (geometry.faceVertexUvs[j].length) {\n                    var uvs = geometry.faceVertexUvs[j][i];\n                    var uvA = uvs[0];\n                    var uvB = uvs[1];\n                    var uvC = uvs[2];\n                    var uvD = uvs[3];\n                    var uvsTriA = [\n                        uvA.clone(),\n                        uvB.clone(),\n                        uvD.clone()\n                    ];\n                    var uvsTriB = [\n                        uvB.clone(),\n                        uvC.clone(),\n                        uvD.clone()\n                    ];\n                    faceVertexUvs[j].push(uvsTriA, uvsTriB);\n                }\n                for(j = 0, jl = geometry.faceUvs.length; j < jl; j++)if (geometry.faceUvs[j].length) {\n                    var faceUv = geometry.faceUvs[j][i];\n                    faceUvs[j].push(faceUv, faceUv);\n                }\n            } else {\n                faces.push(face);\n                for(j = 0, jl = geometry.faceUvs.length; j < jl; j++)faceUvs[j].push(geometry.faceUvs[j][i]);\n                for(j = 0, jl = geometry.faceVertexUvs.length; j < jl; j++)faceVertexUvs[j].push(geometry.faceVertexUvs[j][i]);\n            }\n        }\n        geometry.faces = faces;\n        geometry.faceUvs = faceUvs;\n        geometry.faceVertexUvs = faceVertexUvs;\n        geometry.computeCentroids();\n        geometry.computeFaceNormals();\n        geometry.computeVertexNormals();\n        if (geometry.hasTangents) geometry.computeTangents();\n    },\n    setMaterialIndex: function(geometry, index, startFace, endFace) {\n        var faces = geometry.faces;\n        var start = startFace || 0;\n        var end = endFace || faces.length - 1;\n        for(var i = start; i <= end; i++)faces[i].materialIndex = index;\n    }\n};\nTHREE.GeometryUtils.random = THREE.Math.random16;\nTHREE.GeometryUtils.__v1 = new THREE.Vector3();\nTHREE.GeometryUtils.__v2 = new THREE.Vector3();\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */ THREE.ImageUtils = {\n    crossOrigin: \"anonymous\",\n    loadTexture: function(url, mapping, onLoad, onError) {\n        var image = new Image();\n        var texture = new THREE.Texture(image, mapping);\n        var loader = new THREE.ImageLoader();\n        loader.addEventListener(\"load\", function(event) {\n            texture.image = event.content;\n            texture.needsUpdate = true;\n            if (onLoad) onLoad(texture);\n        });\n        loader.addEventListener(\"error\", function(event) {\n            if (onError) onError(event.message);\n        });\n        loader.crossOrigin = this.crossOrigin;\n        loader.load(url, image);\n        texture.sourceFile = url;\n        return texture;\n    },\n    loadCompressedTexture: function(url, mapping, onLoad, onError) {\n        var texture = new THREE.CompressedTexture();\n        texture.mapping = mapping;\n        var request = new XMLHttpRequest();\n        request.onload = function() {\n            var buffer = request.response;\n            var dds = THREE.ImageUtils.parseDDS(buffer, true);\n            texture.format = dds.format;\n            texture.mipmaps = dds.mipmaps;\n            texture.image.width = dds.width;\n            texture.image.height = dds.height;\n            // gl.generateMipmap fails for compressed textures\n            // mipmaps must be embedded in the DDS file\n            // or texture filters must not use mipmapping\n            texture.generateMipmaps = false;\n            texture.needsUpdate = true;\n            if (onLoad) onLoad(texture);\n        };\n        request.onerror = onError;\n        request.open(\"GET\", url, true);\n        request.responseType = \"arraybuffer\";\n        request.send(null);\n        return texture;\n    },\n    loadTextureCube: function(array, mapping, onLoad, onError) {\n        var images = [];\n        images.loadCount = 0;\n        var texture = new THREE.Texture();\n        texture.image = images;\n        if (mapping !== undefined) texture.mapping = mapping;\n        // no flipping needed for cube textures\n        texture.flipY = false;\n        for(var i = 0, il = array.length; i < il; ++i){\n            var cubeImage = new Image();\n            images[i] = cubeImage;\n            cubeImage.onload = function() {\n                images.loadCount += 1;\n                if (images.loadCount === 6) {\n                    texture.needsUpdate = true;\n                    if (onLoad) onLoad(texture);\n                }\n            };\n            cubeImage.onerror = onError;\n            cubeImage.crossOrigin = this.crossOrigin;\n            cubeImage.src = array[i];\n        }\n        return texture;\n    },\n    loadCompressedTextureCube: function(array, mapping, onLoad, onError) {\n        var images = [];\n        images.loadCount = 0;\n        var texture = new THREE.CompressedTexture();\n        texture.image = images;\n        if (mapping !== undefined) texture.mapping = mapping;\n        // no flipping for cube textures\n        // (also flipping doesn't work for compressed textures )\n        texture.flipY = false;\n        // can't generate mipmaps for compressed textures\n        // mips must be embedded in DDS files\n        texture.generateMipmaps = false;\n        var generateCubeFaceCallback = function(rq, img) {\n            return function() {\n                var buffer = rq.response;\n                var dds = THREE.ImageUtils.parseDDS(buffer, true);\n                img.format = dds.format;\n                img.mipmaps = dds.mipmaps;\n                img.width = dds.width;\n                img.height = dds.height;\n                images.loadCount += 1;\n                if (images.loadCount === 6) {\n                    texture.format = dds.format;\n                    texture.needsUpdate = true;\n                    if (onLoad) onLoad(texture);\n                }\n            };\n        };\n        // compressed cubemap textures as 6 separate DDS files\n        if (array instanceof Array) for(var i = 0, il = array.length; i < il; ++i){\n            var cubeImage = {};\n            images[i] = cubeImage;\n            var request = new XMLHttpRequest();\n            request.onload = generateCubeFaceCallback(request, cubeImage);\n            request.onerror = onError;\n            var url = array[i];\n            request.open(\"GET\", url, true);\n            request.responseType = \"arraybuffer\";\n            request.send(null);\n        }\n        else {\n            var url = array;\n            var request = new XMLHttpRequest();\n            request.onload = function() {\n                var buffer = request.response;\n                var dds = THREE.ImageUtils.parseDDS(buffer, true);\n                if (dds.isCubemap) {\n                    var faces = dds.mipmaps.length / dds.mipmapCount;\n                    for(var f = 0; f < faces; f++){\n                        images[f] = {\n                            mipmaps: []\n                        };\n                        for(var i = 0; i < dds.mipmapCount; i++){\n                            images[f].mipmaps.push(dds.mipmaps[f * dds.mipmapCount + i]);\n                            images[f].format = dds.format;\n                            images[f].width = dds.width;\n                            images[f].height = dds.height;\n                        }\n                    }\n                    texture.format = dds.format;\n                    texture.needsUpdate = true;\n                    if (onLoad) onLoad(texture);\n                }\n            };\n            request.onerror = onError;\n            request.open(\"GET\", url, true);\n            request.responseType = \"arraybuffer\";\n            request.send(null);\n        }\n        return texture;\n    },\n    parseDDS: function(buffer, loadMipmaps) {\n        var dds = {\n            mipmaps: [],\n            width: 0,\n            height: 0,\n            format: null,\n            mipmapCount: 1\n        };\n        // Adapted from @toji's DDS utils\n        //\thttps://github.com/toji/webgl-texture-utils/blob/master/texture-util/dds.js\n        // All values and structures referenced from:\n        // http://msdn.microsoft.com/en-us/library/bb943991.aspx/\n        var DDS_MAGIC = 0x20534444;\n        var DDSD_CAPS = 0x1, DDSD_HEIGHT = 0x2, DDSD_WIDTH = 0x4, DDSD_PITCH = 0x8, DDSD_PIXELFORMAT = 0x1000, DDSD_MIPMAPCOUNT = 0x20000, DDSD_LINEARSIZE = 0x80000, DDSD_DEPTH = 0x800000;\n        var DDSCAPS_COMPLEX = 0x8, DDSCAPS_MIPMAP = 0x400000, DDSCAPS_TEXTURE = 0x1000;\n        var DDSCAPS2_CUBEMAP = 0x200, DDSCAPS2_CUBEMAP_POSITIVEX = 0x400, DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800, DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000, DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000, DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000, DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000, DDSCAPS2_VOLUME = 0x200000;\n        var DDPF_ALPHAPIXELS = 0x1, DDPF_ALPHA = 0x2, DDPF_FOURCC = 0x4, DDPF_RGB = 0x40, DDPF_YUV = 0x200, DDPF_LUMINANCE = 0x20000;\n        function fourCCToInt32(value) {\n            return value.charCodeAt(0) + (value.charCodeAt(1) << 8) + (value.charCodeAt(2) << 16) + (value.charCodeAt(3) << 24);\n        }\n        function int32ToFourCC(value) {\n            return String.fromCharCode(value & 0xff, value >> 8 & 0xff, value >> 16 & 0xff, value >> 24 & 0xff);\n        }\n        var FOURCC_DXT1 = fourCCToInt32(\"DXT1\");\n        var FOURCC_DXT3 = fourCCToInt32(\"DXT3\");\n        var FOURCC_DXT5 = fourCCToInt32(\"DXT5\");\n        var headerLengthInt = 31; // The header length in 32 bit ints\n        // Offsets into the header array\n        var off_magic = 0;\n        var off_size = 1;\n        var off_flags = 2;\n        var off_height = 3;\n        var off_width = 4;\n        var off_mipmapCount = 7;\n        var off_pfFlags = 20;\n        var off_pfFourCC = 21;\n        var off_caps = 27;\n        var off_caps2 = 28;\n        var off_caps3 = 29;\n        var off_caps4 = 30;\n        // Parse header\n        var header = new Int32Array(buffer, 0, headerLengthInt);\n        if (header[off_magic] !== DDS_MAGIC) {\n            console.error(\"ImageUtils.parseDDS(): Invalid magic number in DDS header\");\n            return dds;\n        }\n        if (!header[off_pfFlags] & DDPF_FOURCC) {\n            console.error(\"ImageUtils.parseDDS(): Unsupported format, must contain a FourCC code\");\n            return dds;\n        }\n        var blockBytes;\n        var fourCC = header[off_pfFourCC];\n        switch(fourCC){\n            case FOURCC_DXT1:\n                blockBytes = 8;\n                dds.format = THREE.RGB_S3TC_DXT1_Format;\n                break;\n            case FOURCC_DXT3:\n                blockBytes = 16;\n                dds.format = THREE.RGBA_S3TC_DXT3_Format;\n                break;\n            case FOURCC_DXT5:\n                blockBytes = 16;\n                dds.format = THREE.RGBA_S3TC_DXT5_Format;\n                break;\n            default:\n                console.error(\"ImageUtils.parseDDS(): Unsupported FourCC code: \", int32ToFourCC(fourCC));\n                return dds;\n        }\n        dds.mipmapCount = 1;\n        if (header[off_flags] & DDSD_MIPMAPCOUNT && loadMipmaps !== false) dds.mipmapCount = Math.max(1, header[off_mipmapCount]);\n        //TODO: Verify that all faces of the cubemap are present with DDSCAPS2_CUBEMAP_POSITIVEX, etc.\n        dds.isCubemap = header[off_caps2] & DDSCAPS2_CUBEMAP ? true : false;\n        dds.width = header[off_width];\n        dds.height = header[off_height];\n        var dataOffset = header[off_size] + 4;\n        // Extract mipmaps buffers\n        var width = dds.width;\n        var height = dds.height;\n        var faces = dds.isCubemap ? 6 : 1;\n        for(var face = 0; face < faces; face++){\n            for(var i = 0; i < dds.mipmapCount; i++){\n                var dataLength = Math.max(4, width) / 4 * Math.max(4, height) / 4 * blockBytes;\n                var byteArray = new Uint8Array(buffer, dataOffset, dataLength);\n                var mipmap = {\n                    \"data\": byteArray,\n                    \"width\": width,\n                    \"height\": height\n                };\n                dds.mipmaps.push(mipmap);\n                dataOffset += dataLength;\n                width = Math.max(width * 0.5, 1);\n                height = Math.max(height * 0.5, 1);\n            }\n            width = dds.width;\n            height = dds.height;\n        }\n        return dds;\n    },\n    getNormalMap: function(image, depth) {\n        // Adapted from http://www.paulbrunt.co.uk/lab/heightnormal/\n        var cross = function(a, b) {\n            return [\n                a[1] * b[2] - a[2] * b[1],\n                a[2] * b[0] - a[0] * b[2],\n                a[0] * b[1] - a[1] * b[0]\n            ];\n        };\n        var subtract = function(a, b) {\n            return [\n                a[0] - b[0],\n                a[1] - b[1],\n                a[2] - b[2]\n            ];\n        };\n        var normalize = function(a) {\n            var l = Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]);\n            return [\n                a[0] / l,\n                a[1] / l,\n                a[2] / l\n            ];\n        };\n        depth = depth | 1;\n        var width = image.width;\n        var height = image.height;\n        var canvas = document.createElement(\"canvas\");\n        canvas.width = width;\n        canvas.height = height;\n        var context = canvas.getContext(\"2d\");\n        context.drawImage(image, 0, 0);\n        var data = context.getImageData(0, 0, width, height).data;\n        var imageData = context.createImageData(width, height);\n        var output = imageData.data;\n        for(var x = 0; x < width; x++)for(var y = 0; y < height; y++){\n            var ly = y - 1 < 0 ? 0 : y - 1;\n            var uy = y + 1 > height - 1 ? height - 1 : y + 1;\n            var lx = x - 1 < 0 ? 0 : x - 1;\n            var ux = x + 1 > width - 1 ? width - 1 : x + 1;\n            var points = [];\n            var origin = [\n                0,\n                0,\n                data[(y * width + x) * 4] / 255 * depth\n            ];\n            points.push([\n                -1,\n                0,\n                data[(y * width + lx) * 4] / 255 * depth\n            ]);\n            points.push([\n                -1,\n                -1,\n                data[(ly * width + lx) * 4] / 255 * depth\n            ]);\n            points.push([\n                0,\n                -1,\n                data[(ly * width + x) * 4] / 255 * depth\n            ]);\n            points.push([\n                1,\n                -1,\n                data[(ly * width + ux) * 4] / 255 * depth\n            ]);\n            points.push([\n                1,\n                0,\n                data[(y * width + ux) * 4] / 255 * depth\n            ]);\n            points.push([\n                1,\n                1,\n                data[(uy * width + ux) * 4] / 255 * depth\n            ]);\n            points.push([\n                0,\n                1,\n                data[(uy * width + x) * 4] / 255 * depth\n            ]);\n            points.push([\n                -1,\n                1,\n                data[(uy * width + lx) * 4] / 255 * depth\n            ]);\n            var normals = [];\n            var num_points = points.length;\n            for(var i = 0; i < num_points; i++){\n                var v1 = points[i];\n                var v2 = points[(i + 1) % num_points];\n                v1 = subtract(v1, origin);\n                v2 = subtract(v2, origin);\n                normals.push(normalize(cross(v1, v2)));\n            }\n            var normal = [\n                0,\n                0,\n                0\n            ];\n            for(var i = 0; i < normals.length; i++){\n                normal[0] += normals[i][0];\n                normal[1] += normals[i][1];\n                normal[2] += normals[i][2];\n            }\n            normal[0] /= normals.length;\n            normal[1] /= normals.length;\n            normal[2] /= normals.length;\n            var idx = (y * width + x) * 4;\n            output[idx] = (normal[0] + 1.0) / 2.0 * 255 | 0;\n            output[idx + 1] = (normal[1] + 1.0) / 2.0 * 255 | 0;\n            output[idx + 2] = normal[2] * 255 | 0;\n            output[idx + 3] = 255;\n        }\n        context.putImageData(imageData, 0, 0);\n        return canvas;\n    },\n    generateDataTexture: function(width, height, color) {\n        var size = width * height;\n        var data = new Uint8Array(3 * size);\n        var r = Math.floor(color.r * 255);\n        var g = Math.floor(color.g * 255);\n        var b = Math.floor(color.b * 255);\n        for(var i = 0; i < size; i++){\n            data[i * 3] = r;\n            data[i * 3 + 1] = g;\n            data[i * 3 + 2] = b;\n        }\n        var texture = new THREE.DataTexture(data, width, height, THREE.RGBFormat);\n        texture.needsUpdate = true;\n        return texture;\n    }\n};\n/**\n * @author alteredq / http://alteredqualia.com/\n */ THREE.SceneUtils = {\n    createMultiMaterialObject: function(geometry, materials) {\n        var group = new THREE.Object3D();\n        for(var i = 0, l = materials.length; i < l; i++)group.add(new THREE.Mesh(geometry, materials[i]));\n        return group;\n    },\n    detach: function(child, parent, scene) {\n        child.applyMatrix(parent.matrixWorld);\n        parent.remove(child);\n        scene.add(child);\n    },\n    attach: function(child, scene, parent) {\n        var matrixWorldInverse = new THREE.Matrix4();\n        matrixWorldInverse.getInverse(parent.matrixWorld);\n        child.applyMatrix(matrixWorldInverse);\n        scene.remove(child);\n        parent.add(child);\n    }\n};\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * @author alteredq / http://alteredqualia.com/\n *\n * For Text operations in three.js (See TextGeometry)\n *\n * It uses techniques used in:\n *\n * \ttypeface.js and canvastext\n * \t\tFor converting fonts and rendering with javascript\n *\t\thttp://typeface.neocracy.org\n *\n *\tTriangulation ported from AS3\n *\t\tSimple Polygon Triangulation\n *\t\thttp://actionsnippet.com/?p=1462\n *\n * \tA Method to triangulate shapes with holes\n *\t\thttp://www.sakri.net/blog/2009/06/12/an-approach-to-triangulating-polygons-with-holes/\n *\n */ THREE.FontUtils = {\n    faces: {},\n    // Just for now. face[weight][style]\n    face: \"helvetiker\",\n    weight: \"normal\",\n    style: \"normal\",\n    size: 150,\n    divisions: 10,\n    getFace: function() {\n        return this.faces[this.face][this.weight][this.style];\n    },\n    loadFace: function(data) {\n        var family = data.familyName.toLowerCase();\n        var ThreeFont = this;\n        ThreeFont.faces[family] = ThreeFont.faces[family] || {};\n        ThreeFont.faces[family][data.cssFontWeight] = ThreeFont.faces[family][data.cssFontWeight] || {};\n        ThreeFont.faces[family][data.cssFontWeight][data.cssFontStyle] = data;\n        var face = ThreeFont.faces[family][data.cssFontWeight][data.cssFontStyle] = data;\n        return data;\n    },\n    drawText: function(text) {\n        var characterPts = [], allPts = [];\n        // RenderText\n        var i, p, face = this.getFace(), scale = this.size / face.resolution, offset = 0, chars = String(text).split(\"\"), length = chars.length;\n        var fontPaths = [];\n        for(i = 0; i < length; i++){\n            var path = new THREE.Path();\n            var ret = this.extractGlyphPoints(chars[i], face, scale, offset, path);\n            offset += ret.offset;\n            fontPaths.push(ret.path);\n        }\n        // get the width\n        var width = offset / 2;\n        //\n        // for ( p = 0; p < allPts.length; p++ ) {\n        //\n        // \tallPts[ p ].x -= width;\n        //\n        // }\n        //var extract = this.extractPoints( allPts, characterPts );\n        //extract.contour = allPts;\n        //extract.paths = fontPaths;\n        //extract.offset = width;\n        return {\n            paths: fontPaths,\n            offset: width\n        };\n    },\n    extractGlyphPoints: function(c, face, scale, offset, path) {\n        var pts = [];\n        var i, i2, divisions, outline, action, length, scaleX, scaleY, x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste, glyph = face.glyphs[c] || face.glyphs[\"?\"];\n        if (!glyph) return;\n        if (glyph.o) {\n            outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(\" \"));\n            length = outline.length;\n            scaleX = scale;\n            scaleY = scale;\n            for(i = 0; i < length;){\n                action = outline[i++];\n                //console.log( action );\n                switch(action){\n                    case \"m\":\n                        // Move To\n                        x = outline[i++] * scaleX + offset;\n                        y = outline[i++] * scaleY;\n                        path.moveTo(x, y);\n                        break;\n                    case \"l\":\n                        // Line To\n                        x = outline[i++] * scaleX + offset;\n                        y = outline[i++] * scaleY;\n                        path.lineTo(x, y);\n                        break;\n                    case \"q\":\n                        // QuadraticCurveTo\n                        cpx = outline[i++] * scaleX + offset;\n                        cpy = outline[i++] * scaleY;\n                        cpx1 = outline[i++] * scaleX + offset;\n                        cpy1 = outline[i++] * scaleY;\n                        path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);\n                        laste = pts[pts.length - 1];\n                        if (laste) {\n                            cpx0 = laste.x;\n                            cpy0 = laste.y;\n                            for(i2 = 1, divisions = this.divisions; i2 <= divisions; i2++){\n                                var t = i2 / divisions;\n                                var tx = THREE.Shape.Utils.b2(t, cpx0, cpx1, cpx);\n                                var ty = THREE.Shape.Utils.b2(t, cpy0, cpy1, cpy);\n                            }\n                        }\n                        break;\n                    case \"b\":\n                        // Cubic Bezier Curve\n                        cpx = outline[i++] * scaleX + offset;\n                        cpy = outline[i++] * scaleY;\n                        cpx1 = outline[i++] * scaleX + offset;\n                        cpy1 = outline[i++] * -scaleY;\n                        cpx2 = outline[i++] * scaleX + offset;\n                        cpy2 = outline[i++] * -scaleY;\n                        path.bezierCurveTo(cpx, cpy, cpx1, cpy1, cpx2, cpy2);\n                        laste = pts[pts.length - 1];\n                        if (laste) {\n                            cpx0 = laste.x;\n                            cpy0 = laste.y;\n                            for(i2 = 1, divisions = this.divisions; i2 <= divisions; i2++){\n                                var t = i2 / divisions;\n                                var tx = THREE.Shape.Utils.b3(t, cpx0, cpx1, cpx2, cpx);\n                                var ty = THREE.Shape.Utils.b3(t, cpy0, cpy1, cpy2, cpy);\n                            }\n                        }\n                        break;\n                }\n            }\n        }\n        return {\n            offset: glyph.ha * scale,\n            path: path\n        };\n    }\n};\nTHREE.FontUtils.generateShapes = function(text, parameters) {\n    // Parameters \n    parameters = parameters || {};\n    var size = parameters.size !== undefined ? parameters.size : 100;\n    var curveSegments = parameters.curveSegments !== undefined ? parameters.curveSegments : 4;\n    var font = parameters.font !== undefined ? parameters.font : \"helvetiker\";\n    var weight = parameters.weight !== undefined ? parameters.weight : \"normal\";\n    var style = parameters.style !== undefined ? parameters.style : \"normal\";\n    THREE.FontUtils.size = size;\n    THREE.FontUtils.divisions = curveSegments;\n    THREE.FontUtils.face = font;\n    THREE.FontUtils.weight = weight;\n    THREE.FontUtils.style = style;\n    // Get a Font data json object\n    var data = THREE.FontUtils.drawText(text);\n    var paths = data.paths;\n    var shapes = [];\n    for(var p = 0, pl = paths.length; p < pl; p++)Array.prototype.push.apply(shapes, paths[p].toShapes());\n    return shapes;\n};\n/**\n * This code is a quick port of code written in C++ which was submitted to\n * flipcode.com by John W. Ratcliff  // July 22, 2000\n * See original code and more information here:\n * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml\n *\n * ported to actionscript by Zevan Rosser\n * www.actionsnippet.com\n *\n * ported to javascript by Joshua Koo\n * http://www.lab4games.net/zz85/blog\n *\n */ (function(namespace) {\n    var EPSILON = 0.0000000001;\n    // takes in an contour array and returns\n    var process = function(contour, indices) {\n        var n = contour.length;\n        if (n < 3) return null;\n        var result = [], verts = [], vertIndices = [];\n        /* we want a counter-clockwise polygon in verts */ var u, v, w;\n        if (area(contour) > 0.0) for(v = 0; v < n; v++)verts[v] = v;\n        else for(v = 0; v < n; v++)verts[v] = n - 1 - v;\n        var nv = n;\n        /*  remove nv - 2 vertices, creating 1 triangle every time */ var count = 2 * nv; /* error detection */ \n        for(v = nv - 1; nv > 2;){\n            /* if we loop, it is probably a non-simple polygon */ if (count-- <= 0) {\n                //** Triangulate: ERROR - probable bad polygon!\n                //throw ( \"Warning, unable to triangulate polygon!\" );\n                //return null;\n                // Sometimes warning is fine, especially polygons are triangulated in reverse.\n                console.log(\"Warning, unable to triangulate polygon!\");\n                if (indices) return vertIndices;\n                return result;\n            }\n            /* three consecutive vertices in current polygon, <u,v,w> */ u = v;\n            if (nv <= u) u = 0; /* previous */ \n            v = u + 1;\n            if (nv <= v) v = 0; /* new v    */ \n            w = v + 1;\n            if (nv <= w) w = 0; /* next     */ \n            if (snip(contour, u, v, w, nv, verts)) {\n                var a, b, c, s, t;\n                /* true names of the vertices */ a = verts[u];\n                b = verts[v];\n                c = verts[w];\n                /* output Triangle */ result.push([\n                    contour[a],\n                    contour[b],\n                    contour[c]\n                ]);\n                vertIndices.push([\n                    verts[u],\n                    verts[v],\n                    verts[w]\n                ]);\n                /* remove v from the remaining polygon */ for(s = v, t = v + 1; t < nv; s++, t++)verts[s] = verts[t];\n                nv--;\n                /* reset error detection counter */ count = 2 * nv;\n            }\n        }\n        if (indices) return vertIndices;\n        return result;\n    };\n    // calculate area of the contour polygon\n    var area = function(contour) {\n        var n = contour.length;\n        var a = 0.0;\n        for(var p = n - 1, q = 0; q < n; p = q++)a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;\n        return a * 0.5;\n    };\n    var snip = function(contour, u, v, w, n, verts) {\n        var p;\n        var ax, ay, bx, by;\n        var cx, cy, px, py;\n        ax = contour[verts[u]].x;\n        ay = contour[verts[u]].y;\n        bx = contour[verts[v]].x;\n        by = contour[verts[v]].y;\n        cx = contour[verts[w]].x;\n        cy = contour[verts[w]].y;\n        if (EPSILON > (bx - ax) * (cy - ay) - (by - ay) * (cx - ax)) return false;\n        var aX, aY, bX, bY, cX, cY;\n        var apx, apy, bpx, bpy, cpx, cpy;\n        var cCROSSap, bCROSScp, aCROSSbp;\n        aX = cx - bx;\n        aY = cy - by;\n        bX = ax - cx;\n        bY = ay - cy;\n        cX = bx - ax;\n        cY = by - ay;\n        for(p = 0; p < n; p++){\n            if (p === u || p === v || p === w) continue;\n            px = contour[verts[p]].x;\n            py = contour[verts[p]].y;\n            apx = px - ax;\n            apy = py - ay;\n            bpx = px - bx;\n            bpy = py - by;\n            cpx = px - cx;\n            cpy = py - cy;\n            // see if p is inside triangle abc\n            aCROSSbp = aX * bpy - aY * bpx;\n            cCROSSap = cX * apy - cY * apx;\n            bCROSScp = bX * cpy - bY * cpx;\n            if (aCROSSbp >= 0.0 && bCROSScp >= 0.0 && cCROSSap >= 0.0) return false;\n        }\n        return true;\n    };\n    namespace.Triangulate = process;\n    namespace.Triangulate.area = area;\n    return namespace;\n})(THREE.FontUtils);\n// To use the typeface.js face files, hook up the API\nself._typeface_js = {\n    faces: THREE.FontUtils.faces,\n    loadFace: THREE.FontUtils.loadFace\n}; /**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * Extensible curve object\n *\n * Some common of Curve methods\n * .getPoint(t), getTangent(t)\n * .getPointAt(u), getTagentAt(u)\n * .getPoints(), .getSpacedPoints()\n * .getLength()\n * .updateArcLengths()\n *\n * This file contains following classes:\n *\n * -- 2d classes --\n * THREE.Curve\n * THREE.LineCurve\n * THREE.QuadraticBezierCurve\n * THREE.CubicBezierCurve\n * THREE.SplineCurve\n * THREE.ArcCurve\n * THREE.EllipseCurve\n *\n * -- 3d classes --\n * THREE.LineCurve3\n * THREE.QuadraticBezierCurve3\n * THREE.CubicBezierCurve3\n * THREE.SplineCurve3\n * THREE.ClosedSplineCurve3\n *\n * A series of curves can be represented as a THREE.CurvePath\n *\n **/ \n/**************************************************************\n *\tAbstract Curve base class\n **************************************************************/ THREE.Curve = function() {};\n// Virtual base class method to overwrite and implement in subclasses\n//\t- t [0 .. 1]\nTHREE.Curve.prototype.getPoint = function(t) {\n    console.log(\"Warning, getPoint() not implemented!\");\n    return null;\n};\n// Get point at relative position in curve according to arc length\n// - u [0 .. 1]\nTHREE.Curve.prototype.getPointAt = function(u) {\n    var t = this.getUtoTmapping(u);\n    return this.getPoint(t);\n};\n// Get sequence of points using getPoint( t )\nTHREE.Curve.prototype.getPoints = function(divisions) {\n    if (!divisions) divisions = 5;\n    var d, pts = [];\n    for(d = 0; d <= divisions; d++)pts.push(this.getPoint(d / divisions));\n    return pts;\n};\n// Get sequence of points using getPointAt( u )\nTHREE.Curve.prototype.getSpacedPoints = function(divisions) {\n    if (!divisions) divisions = 5;\n    var d, pts = [];\n    for(d = 0; d <= divisions; d++)pts.push(this.getPointAt(d / divisions));\n    return pts;\n};\n// Get total curve arc length\nTHREE.Curve.prototype.getLength = function() {\n    var lengths = this.getLengths();\n    return lengths[lengths.length - 1];\n};\n// Get list of cumulative segment lengths\nTHREE.Curve.prototype.getLengths = function(divisions) {\n    if (!divisions) divisions = this.__arcLengthDivisions ? this.__arcLengthDivisions : 200;\n    if (this.cacheArcLengths && this.cacheArcLengths.length == divisions + 1 && !this.needsUpdate) //console.log( \"cached\", this.cacheArcLengths );\n    return this.cacheArcLengths;\n    this.needsUpdate = false;\n    var cache = [];\n    var current, last = this.getPoint(0);\n    var p, sum = 0;\n    cache.push(0);\n    for(p = 1; p <= divisions; p++){\n        current = this.getPoint(p / divisions);\n        sum += current.distanceTo(last);\n        cache.push(sum);\n        last = current;\n    }\n    this.cacheArcLengths = cache;\n    return cache; // { sums: cache, sum:sum }; Sum is in the last element.\n};\nTHREE.Curve.prototype.updateArcLengths = function() {\n    this.needsUpdate = true;\n    this.getLengths();\n};\n// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance\nTHREE.Curve.prototype.getUtoTmapping = function(u, distance) {\n    var arcLengths = this.getLengths();\n    var i = 0, il = arcLengths.length;\n    var targetArcLength; // The targeted u distance value to get\n    if (distance) targetArcLength = distance;\n    else targetArcLength = u * arcLengths[il - 1];\n    //var time = Date.now();\n    // binary search for the index with largest value smaller than target u distance\n    var low = 0, high = il - 1, comparison;\n    while(low <= high){\n        i = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\n        comparison = arcLengths[i] - targetArcLength;\n        if (comparison < 0) {\n            low = i + 1;\n            continue;\n        } else if (comparison > 0) {\n            high = i - 1;\n            continue;\n        } else {\n            high = i;\n            break;\n        // DONE\n        }\n    }\n    i = high;\n    //console.log('b' , i, low, high, Date.now()- time);\n    if (arcLengths[i] == targetArcLength) {\n        var t = i / (il - 1);\n        return t;\n    }\n    // we could get finer grain at lengths, or use simple interpolatation between two points\n    var lengthBefore = arcLengths[i];\n    var lengthAfter = arcLengths[i + 1];\n    var segmentLength = lengthAfter - lengthBefore;\n    // determine where we are between the 'before' and 'after' points\n    var segmentFraction = (targetArcLength - lengthBefore) / segmentLength;\n    // add that fractional amount to t\n    var t = (i + segmentFraction) / (il - 1);\n    return t;\n};\n// Returns a unit vector tangent at t\n// In case any sub curve does not implement its tangent derivation,\n// 2 points a small delta apart will be used to find its gradient\n// which seems to give a reasonable approximation\nTHREE.Curve.prototype.getTangent = function(t) {\n    var delta = 0.0001;\n    var t1 = t - delta;\n    var t2 = t + delta;\n    // Capping in case of danger\n    if (t1 < 0) t1 = 0;\n    if (t2 > 1) t2 = 1;\n    var pt1 = this.getPoint(t1);\n    var pt2 = this.getPoint(t2);\n    var vec = pt2.clone().sub(pt1);\n    return vec.normalize();\n};\nTHREE.Curve.prototype.getTangentAt = function(u) {\n    var t = this.getUtoTmapping(u);\n    return this.getTangent(t);\n};\n/**************************************************************\n *\tLine\n **************************************************************/ THREE.LineCurve = function(v1, v2) {\n    this.v1 = v1;\n    this.v2 = v2;\n};\nTHREE.LineCurve.prototype = Object.create(THREE.Curve.prototype);\nTHREE.LineCurve.prototype.getPoint = function(t) {\n    var point = this.v2.clone().sub(this.v1);\n    point.multiplyScalar(t).add(this.v1);\n    return point;\n};\n// Line curve is linear, so we can overwrite default getPointAt\nTHREE.LineCurve.prototype.getPointAt = function(u) {\n    return this.getPoint(u);\n};\nTHREE.LineCurve.prototype.getTangent = function(t) {\n    var tangent = this.v2.clone().sub(this.v1);\n    return tangent.normalize();\n};\n/**************************************************************\n *\tQuadratic Bezier curve\n **************************************************************/ THREE.QuadraticBezierCurve = function(v0, v1, v2) {\n    this.v0 = v0;\n    this.v1 = v1;\n    this.v2 = v2;\n};\nTHREE.QuadraticBezierCurve.prototype = Object.create(THREE.Curve.prototype);\nTHREE.QuadraticBezierCurve.prototype.getPoint = function(t) {\n    var tx, ty;\n    tx = THREE.Shape.Utils.b2(t, this.v0.x, this.v1.x, this.v2.x);\n    ty = THREE.Shape.Utils.b2(t, this.v0.y, this.v1.y, this.v2.y);\n    return new THREE.Vector2(tx, ty);\n};\nTHREE.QuadraticBezierCurve.prototype.getTangent = function(t) {\n    var tx, ty;\n    tx = THREE.Curve.Utils.tangentQuadraticBezier(t, this.v0.x, this.v1.x, this.v2.x);\n    ty = THREE.Curve.Utils.tangentQuadraticBezier(t, this.v0.y, this.v1.y, this.v2.y);\n    // returns unit vector\n    var tangent = new THREE.Vector2(tx, ty);\n    tangent.normalize();\n    return tangent;\n};\n/**************************************************************\n *\tCubic Bezier curve\n **************************************************************/ THREE.CubicBezierCurve = function(v0, v1, v2, v3) {\n    this.v0 = v0;\n    this.v1 = v1;\n    this.v2 = v2;\n    this.v3 = v3;\n};\nTHREE.CubicBezierCurve.prototype = Object.create(THREE.Curve.prototype);\nTHREE.CubicBezierCurve.prototype.getPoint = function(t) {\n    var tx, ty;\n    tx = THREE.Shape.Utils.b3(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x);\n    ty = THREE.Shape.Utils.b3(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y);\n    return new THREE.Vector2(tx, ty);\n};\nTHREE.CubicBezierCurve.prototype.getTangent = function(t) {\n    var tx, ty;\n    tx = THREE.Curve.Utils.tangentCubicBezier(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x);\n    ty = THREE.Curve.Utils.tangentCubicBezier(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y);\n    var tangent = new THREE.Vector2(tx, ty);\n    tangent.normalize();\n    return tangent;\n};\n/**************************************************************\n *\tSpline curve\n **************************************************************/ THREE.SplineCurve = function(points /* array of Vector2 */ ) {\n    this.points = points == undefined ? [] : points;\n};\nTHREE.SplineCurve.prototype = Object.create(THREE.Curve.prototype);\nTHREE.SplineCurve.prototype.getPoint = function(t) {\n    var v = new THREE.Vector2();\n    var c = [];\n    var points = this.points, point, intPoint, weight;\n    point = (points.length - 1) * t;\n    intPoint = Math.floor(point);\n    weight = point - intPoint;\n    c[0] = intPoint == 0 ? intPoint : intPoint - 1;\n    c[1] = intPoint;\n    c[2] = intPoint > points.length - 2 ? points.length - 1 : intPoint + 1;\n    c[3] = intPoint > points.length - 3 ? points.length - 1 : intPoint + 2;\n    v.x = THREE.Curve.Utils.interpolate(points[c[0]].x, points[c[1]].x, points[c[2]].x, points[c[3]].x, weight);\n    v.y = THREE.Curve.Utils.interpolate(points[c[0]].y, points[c[1]].y, points[c[2]].y, points[c[3]].y, weight);\n    return v;\n};\n/**************************************************************\n *\tEllipse curve\n **************************************************************/ THREE.EllipseCurve = function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise) {\n    this.aX = aX;\n    this.aY = aY;\n    this.xRadius = xRadius;\n    this.yRadius = yRadius;\n    this.aStartAngle = aStartAngle;\n    this.aEndAngle = aEndAngle;\n    this.aClockwise = aClockwise;\n};\nTHREE.EllipseCurve.prototype = Object.create(THREE.Curve.prototype);\nTHREE.EllipseCurve.prototype.getPoint = function(t) {\n    var deltaAngle = this.aEndAngle - this.aStartAngle;\n    if (!this.aClockwise) t = 1 - t;\n    var angle = this.aStartAngle + t * deltaAngle;\n    var tx = this.aX + this.xRadius * Math.cos(angle);\n    var ty = this.aY + this.yRadius * Math.sin(angle);\n    return new THREE.Vector2(tx, ty);\n};\n/**************************************************************\n *\tArc curve\n **************************************************************/ THREE.ArcCurve = function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {\n    THREE.EllipseCurve.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);\n};\nTHREE.ArcCurve.prototype = Object.create(THREE.EllipseCurve.prototype);\n/**************************************************************\n *\tUtils\n **************************************************************/ THREE.Curve.Utils = {\n    tangentQuadraticBezier: function(t, p0, p1, p2) {\n        return 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1);\n    },\n    // Puay Bing, thanks for helping with this derivative!\n    tangentCubicBezier: function(t, p0, p1, p2, p3) {\n        return -3 * p0 * (1 - t) * (1 - t) + 3 * p1 * (1 - t) * (1 - t) - 6 * t * p1 * (1 - t) + 6 * t * p2 * (1 - t) - 3 * t * t * p2 + 3 * t * t * p3;\n    },\n    tangentSpline: function(t, p0, p1, p2, p3) {\n        // To check if my formulas are correct\n        var h00 = 6 * t * t - 6 * t; // derived from 2t^3 - 3t^2 + 1\n        var h10 = 3 * t * t - 4 * t + 1; // t^3 - 2t^2 + t\n        var h01 = -6 * t * t + 6 * t; // - 2t3 + 3t2\n        var h11 = 3 * t * t - 2 * t; // t3 - t2\n        return h00 + h10 + h01 + h11;\n    },\n    // Catmull-Rom\n    interpolate: function(p0, p1, p2, p3, t) {\n        var v0 = (p2 - p0) * 0.5;\n        var v1 = (p3 - p1) * 0.5;\n        var t2 = t * t;\n        var t3 = t * t2;\n        return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;\n    }\n};\n// TODO: Transformation for Curves?\n/**************************************************************\n *\t3D Curves\n **************************************************************/ // A Factory method for creating new curve subclasses\nTHREE.Curve.create = function(constructor, getPointFunc) {\n    constructor.prototype = Object.create(THREE.Curve.prototype);\n    constructor.prototype.getPoint = getPointFunc;\n    return constructor;\n};\n/**************************************************************\n *\tLine3D\n **************************************************************/ THREE.LineCurve3 = THREE.Curve.create(function(v1, v2) {\n    this.v1 = v1;\n    this.v2 = v2;\n}, function(t) {\n    var r = new THREE.Vector3();\n    r.subVectors(this.v2, this.v1); // diff\n    r.multiplyScalar(t);\n    r.add(this.v1);\n    return r;\n});\n/**************************************************************\n *\tQuadratic Bezier 3D curve\n **************************************************************/ THREE.QuadraticBezierCurve3 = THREE.Curve.create(function(v0, v1, v2) {\n    this.v0 = v0;\n    this.v1 = v1;\n    this.v2 = v2;\n}, function(t) {\n    var tx, ty, tz;\n    tx = THREE.Shape.Utils.b2(t, this.v0.x, this.v1.x, this.v2.x);\n    ty = THREE.Shape.Utils.b2(t, this.v0.y, this.v1.y, this.v2.y);\n    tz = THREE.Shape.Utils.b2(t, this.v0.z, this.v1.z, this.v2.z);\n    return new THREE.Vector3(tx, ty, tz);\n});\n/**************************************************************\n *\tCubic Bezier 3D curve\n **************************************************************/ THREE.CubicBezierCurve3 = THREE.Curve.create(function(v0, v1, v2, v3) {\n    this.v0 = v0;\n    this.v1 = v1;\n    this.v2 = v2;\n    this.v3 = v3;\n}, function(t) {\n    var tx, ty, tz;\n    tx = THREE.Shape.Utils.b3(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x);\n    ty = THREE.Shape.Utils.b3(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y);\n    tz = THREE.Shape.Utils.b3(t, this.v0.z, this.v1.z, this.v2.z, this.v3.z);\n    return new THREE.Vector3(tx, ty, tz);\n});\n/**************************************************************\n *\tSpline 3D curve\n **************************************************************/ THREE.SplineCurve3 = THREE.Curve.create(function(points /* array of Vector3 */ ) {\n    this.points = points == undefined ? [] : points;\n}, function(t) {\n    var v = new THREE.Vector3();\n    var c = [];\n    var points = this.points, point, intPoint, weight;\n    point = (points.length - 1) * t;\n    intPoint = Math.floor(point);\n    weight = point - intPoint;\n    c[0] = intPoint == 0 ? intPoint : intPoint - 1;\n    c[1] = intPoint;\n    c[2] = intPoint > points.length - 2 ? points.length - 1 : intPoint + 1;\n    c[3] = intPoint > points.length - 3 ? points.length - 1 : intPoint + 2;\n    var pt0 = points[c[0]], pt1 = points[c[1]], pt2 = points[c[2]], pt3 = points[c[3]];\n    v.x = THREE.Curve.Utils.interpolate(pt0.x, pt1.x, pt2.x, pt3.x, weight);\n    v.y = THREE.Curve.Utils.interpolate(pt0.y, pt1.y, pt2.y, pt3.y, weight);\n    v.z = THREE.Curve.Utils.interpolate(pt0.z, pt1.z, pt2.z, pt3.z, weight);\n    return v;\n});\n// THREE.SplineCurve3.prototype.getTangent = function(t) {\n// \t\tvar v = new THREE.Vector3();\n// \t\tvar c = [];\n// \t\tvar points = this.points, point, intPoint, weight;\n// \t\tpoint = ( points.length - 1 ) * t;\n// \t\tintPoint = Math.floor( point );\n// \t\tweight = point - intPoint;\n// \t\tc[ 0 ] = intPoint == 0 ? intPoint : intPoint - 1;\n// \t\tc[ 1 ] = intPoint;\n// \t\tc[ 2 ] = intPoint  > points.length - 2 ? points.length - 1 : intPoint + 1;\n// \t\tc[ 3 ] = intPoint  > points.length - 3 ? points.length - 1 : intPoint + 2;\n// \t\tvar pt0 = points[ c[0] ],\n// \t\t\tpt1 = points[ c[1] ],\n// \t\t\tpt2 = points[ c[2] ],\n// \t\t\tpt3 = points[ c[3] ];\n// \t// t = weight;\n// \tv.x = THREE.Curve.Utils.tangentSpline( t, pt0.x, pt1.x, pt2.x, pt3.x );\n// \tv.y = THREE.Curve.Utils.tangentSpline( t, pt0.y, pt1.y, pt2.y, pt3.y );\n// \tv.z = THREE.Curve.Utils.tangentSpline( t, pt0.z, pt1.z, pt2.z, pt3.z );\n// \treturn v;\n// }\n/**************************************************************\n *\tClosed Spline 3D curve\n **************************************************************/ THREE.ClosedSplineCurve3 = THREE.Curve.create(function(points /* array of Vector3 */ ) {\n    this.points = points == undefined ? [] : points;\n}, function(t) {\n    var v = new THREE.Vector3();\n    var c = [];\n    var points = this.points, point, intPoint, weight;\n    point = (points.length - 0) * t;\n    // This needs to be from 0-length +1\n    intPoint = Math.floor(point);\n    weight = point - intPoint;\n    intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / points.length) + 1) * points.length;\n    c[0] = (intPoint - 1) % points.length;\n    c[1] = intPoint % points.length;\n    c[2] = (intPoint + 1) % points.length;\n    c[3] = (intPoint + 2) % points.length;\n    v.x = THREE.Curve.Utils.interpolate(points[c[0]].x, points[c[1]].x, points[c[2]].x, points[c[3]].x, weight);\n    v.y = THREE.Curve.Utils.interpolate(points[c[0]].y, points[c[1]].y, points[c[2]].y, points[c[3]].y, weight);\n    v.z = THREE.Curve.Utils.interpolate(points[c[0]].z, points[c[1]].z, points[c[2]].z, points[c[3]].z, weight);\n    return v;\n});\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n *\n **/ /**************************************************************\n *\tCurved Path - a curve path is simply a array of connected\n *  curves, but retains the api of a curve\n **************************************************************/ THREE.CurvePath = function() {\n    this.curves = [];\n    this.bends = [];\n    this.autoClose = false; // Automatically closes the path\n};\nTHREE.CurvePath.prototype = Object.create(THREE.Curve.prototype);\nTHREE.CurvePath.prototype.add = function(curve) {\n    this.curves.push(curve);\n};\nTHREE.CurvePath.prototype.checkConnection = function() {\n// TODO\n// If the ending of curve is not connected to the starting\n// or the next curve, then, this is not a real path\n};\nTHREE.CurvePath.prototype.closePath = function() {\n    // TODO Test\n    // and verify for vector3 (needs to implement equals)\n    // Add a line curve if start and end of lines are not connected\n    var startPoint = this.curves[0].getPoint(0);\n    var endPoint = this.curves[this.curves.length - 1].getPoint(1);\n    if (!startPoint.equals(endPoint)) this.curves.push(new THREE.LineCurve(endPoint, startPoint));\n};\n// To get accurate point with reference to\n// entire path distance at time t,\n// following has to be done:\n// 1. Length of each sub path have to be known\n// 2. Locate and identify type of curve\n// 3. Get t for the curve\n// 4. Return curve.getPointAt(t')\nTHREE.CurvePath.prototype.getPoint = function(t) {\n    var d = t * this.getLength();\n    var curveLengths = this.getCurveLengths();\n    var i = 0, diff, curve;\n    // To think about boundaries points.\n    while(i < curveLengths.length){\n        if (curveLengths[i] >= d) {\n            diff = curveLengths[i] - d;\n            curve = this.curves[i];\n            var u = 1 - diff / curve.getLength();\n            return curve.getPointAt(u);\n        }\n        i++;\n    }\n    return null;\n// loop where sum != 0, sum > d , sum+1 <d\n};\n/*\nTHREE.CurvePath.prototype.getTangent = function( t ) {\n};*/ // We cannot use the default THREE.Curve getPoint() with getLength() because in\n// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\n// getPoint() depends on getLength\nTHREE.CurvePath.prototype.getLength = function() {\n    var lens = this.getCurveLengths();\n    return lens[lens.length - 1];\n};\n// Compute lengths and cache them\n// We cannot overwrite getLengths() because UtoT mapping uses it.\nTHREE.CurvePath.prototype.getCurveLengths = function() {\n    // We use cache values if curves and cache array are same length\n    if (this.cacheLengths && this.cacheLengths.length == this.curves.length) return this.cacheLengths;\n    // Get length of subsurve\n    // Push sums into cached array\n    var lengths = [], sums = 0;\n    var i, il = this.curves.length;\n    for(i = 0; i < il; i++){\n        sums += this.curves[i].getLength();\n        lengths.push(sums);\n    }\n    this.cacheLengths = lengths;\n    return lengths;\n};\n// Returns min and max coordinates, as well as centroid\nTHREE.CurvePath.prototype.getBoundingBox = function() {\n    var points = this.getPoints();\n    var maxX, maxY, maxZ;\n    var minX, minY, minZ;\n    maxX = maxY = Number.NEGATIVE_INFINITY;\n    minX = minY = Number.POSITIVE_INFINITY;\n    var p, i, il, sum;\n    var v3 = points[0] instanceof THREE.Vector3;\n    sum = v3 ? new THREE.Vector3() : new THREE.Vector2();\n    for(i = 0, il = points.length; i < il; i++){\n        p = points[i];\n        if (p.x > maxX) maxX = p.x;\n        else if (p.x < minX) minX = p.x;\n        if (p.y > maxY) maxY = p.y;\n        else if (p.y < minY) minY = p.y;\n        if (v3) {\n            if (p.z > maxZ) maxZ = p.z;\n            else if (p.z < minZ) minZ = p.z;\n        }\n        sum.add(p);\n    }\n    var ret = {\n        minX: minX,\n        minY: minY,\n        maxX: maxX,\n        maxY: maxY,\n        centroid: sum.divideScalar(il)\n    };\n    if (v3) {\n        ret.maxZ = maxZ;\n        ret.minZ = minZ;\n    }\n    return ret;\n};\n/**************************************************************\n *\tCreate Geometries Helpers\n **************************************************************/ /// Generate geometry from path points (for Line or ParticleSystem objects)\nTHREE.CurvePath.prototype.createPointsGeometry = function(divisions) {\n    var pts = this.getPoints(divisions, true);\n    return this.createGeometry(pts);\n};\n// Generate geometry from equidistance sampling along the path\nTHREE.CurvePath.prototype.createSpacedPointsGeometry = function(divisions) {\n    var pts = this.getSpacedPoints(divisions, true);\n    return this.createGeometry(pts);\n};\nTHREE.CurvePath.prototype.createGeometry = function(points) {\n    var geometry = new THREE.Geometry();\n    for(var i = 0; i < points.length; i++)geometry.vertices.push(new THREE.Vector3(points[i].x, points[i].y, points[i].z || 0));\n    return geometry;\n};\n/**************************************************************\n *\tBend / Wrap Helper Methods\n **************************************************************/ // Wrap path / Bend modifiers?\nTHREE.CurvePath.prototype.addWrapPath = function(bendpath) {\n    this.bends.push(bendpath);\n};\nTHREE.CurvePath.prototype.getTransformedPoints = function(segments, bends) {\n    var oldPts = this.getPoints(segments); // getPoints getSpacedPoints\n    var i, il;\n    if (!bends) bends = this.bends;\n    for(i = 0, il = bends.length; i < il; i++)oldPts = this.getWrapPoints(oldPts, bends[i]);\n    return oldPts;\n};\nTHREE.CurvePath.prototype.getTransformedSpacedPoints = function(segments, bends) {\n    var oldPts = this.getSpacedPoints(segments);\n    var i, il;\n    if (!bends) bends = this.bends;\n    for(i = 0, il = bends.length; i < il; i++)oldPts = this.getWrapPoints(oldPts, bends[i]);\n    return oldPts;\n};\n// This returns getPoints() bend/wrapped around the contour of a path.\n// Read http://www.planetclegg.com/projects/WarpingTextToSplines.html\nTHREE.CurvePath.prototype.getWrapPoints = function(oldPts, path) {\n    var bounds = this.getBoundingBox();\n    var i, il, p, oldX, oldY, xNorm;\n    for(i = 0, il = oldPts.length; i < il; i++){\n        p = oldPts[i];\n        oldX = p.x;\n        oldY = p.y;\n        xNorm = oldX / bounds.maxX;\n        // If using actual distance, for length > path, requires line extrusions\n        //xNorm = path.getUtoTmapping(xNorm, oldX); // 3 styles. 1) wrap stretched. 2) wrap stretch by arc length 3) warp by actual distance\n        xNorm = path.getUtoTmapping(xNorm, oldX);\n        // check for out of bounds?\n        var pathPt = path.getPoint(xNorm);\n        var normal = path.getNormalVector(xNorm).multiplyScalar(oldY);\n        p.x = pathPt.x + normal.x;\n        p.y = pathPt.y + normal.y;\n    }\n    return oldPts;\n};\n/**\n * @author alteredq / http://alteredqualia.com/\n */ THREE.Gyroscope = function() {\n    THREE.Object3D.call(this);\n};\nTHREE.Gyroscope.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.Gyroscope.prototype.updateMatrixWorld = function(force) {\n    this.matrixAutoUpdate && this.updateMatrix();\n    // update matrixWorld\n    if (this.matrixWorldNeedsUpdate || force) {\n        if (this.parent) {\n            this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\n            this.matrixWorld.decompose(this.translationWorld, this.rotationWorld, this.scaleWorld);\n            this.matrix.decompose(this.translationObject, this.rotationObject, this.scaleObject);\n            this.matrixWorld.compose(this.translationWorld, this.rotationObject, this.scaleWorld);\n        } else this.matrixWorld.copy(this.matrix);\n        this.matrixWorldNeedsUpdate = false;\n        force = true;\n    }\n    // update children\n    for(var i = 0, l = this.children.length; i < l; i++)this.children[i].updateMatrixWorld(force);\n};\nTHREE.Gyroscope.prototype.translationWorld = new THREE.Vector3();\nTHREE.Gyroscope.prototype.translationObject = new THREE.Vector3();\nTHREE.Gyroscope.prototype.rotationWorld = new THREE.Quaternion();\nTHREE.Gyroscope.prototype.rotationObject = new THREE.Quaternion();\nTHREE.Gyroscope.prototype.scaleWorld = new THREE.Vector3();\nTHREE.Gyroscope.prototype.scaleObject = new THREE.Vector3();\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * Creates free form 2d path using series of points, lines or curves.\n *\n **/ THREE.Path = function(points) {\n    THREE.CurvePath.call(this);\n    this.actions = [];\n    if (points) this.fromPoints(points);\n};\nTHREE.Path.prototype = Object.create(THREE.CurvePath.prototype);\nTHREE.PathActions = {\n    MOVE_TO: \"moveTo\",\n    LINE_TO: \"lineTo\",\n    QUADRATIC_CURVE_TO: \"quadraticCurveTo\",\n    BEZIER_CURVE_TO: \"bezierCurveTo\",\n    CSPLINE_THRU: \"splineThru\",\n    ARC: \"arc\",\n    ELLIPSE: \"ellipse\"\n};\n// TODO Clean up PATH API\n// Create path using straight lines to connect all points\n// - vectors: array of Vector2\nTHREE.Path.prototype.fromPoints = function(vectors) {\n    this.moveTo(vectors[0].x, vectors[0].y);\n    for(var v = 1, vlen = vectors.length; v < vlen; v++)this.lineTo(vectors[v].x, vectors[v].y);\n};\n// startPath() endPath()?\nTHREE.Path.prototype.moveTo = function(x, y) {\n    var args = Array.prototype.slice.call(arguments);\n    this.actions.push({\n        action: THREE.PathActions.MOVE_TO,\n        args: args\n    });\n};\nTHREE.Path.prototype.lineTo = function(x, y) {\n    var args = Array.prototype.slice.call(arguments);\n    var lastargs = this.actions[this.actions.length - 1].args;\n    var x0 = lastargs[lastargs.length - 2];\n    var y0 = lastargs[lastargs.length - 1];\n    var curve = new THREE.LineCurve(new THREE.Vector2(x0, y0), new THREE.Vector2(x, y));\n    this.curves.push(curve);\n    this.actions.push({\n        action: THREE.PathActions.LINE_TO,\n        args: args\n    });\n};\nTHREE.Path.prototype.quadraticCurveTo = function(aCPx, aCPy, aX, aY) {\n    var args = Array.prototype.slice.call(arguments);\n    var lastargs = this.actions[this.actions.length - 1].args;\n    var x0 = lastargs[lastargs.length - 2];\n    var y0 = lastargs[lastargs.length - 1];\n    var curve = new THREE.QuadraticBezierCurve(new THREE.Vector2(x0, y0), new THREE.Vector2(aCPx, aCPy), new THREE.Vector2(aX, aY));\n    this.curves.push(curve);\n    this.actions.push({\n        action: THREE.PathActions.QUADRATIC_CURVE_TO,\n        args: args\n    });\n};\nTHREE.Path.prototype.bezierCurveTo = function(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {\n    var args = Array.prototype.slice.call(arguments);\n    var lastargs = this.actions[this.actions.length - 1].args;\n    var x0 = lastargs[lastargs.length - 2];\n    var y0 = lastargs[lastargs.length - 1];\n    var curve = new THREE.CubicBezierCurve(new THREE.Vector2(x0, y0), new THREE.Vector2(aCP1x, aCP1y), new THREE.Vector2(aCP2x, aCP2y), new THREE.Vector2(aX, aY));\n    this.curves.push(curve);\n    this.actions.push({\n        action: THREE.PathActions.BEZIER_CURVE_TO,\n        args: args\n    });\n};\nTHREE.Path.prototype.splineThru = function(pts /*Array of Vector*/ ) {\n    var args = Array.prototype.slice.call(arguments);\n    var lastargs = this.actions[this.actions.length - 1].args;\n    var x0 = lastargs[lastargs.length - 2];\n    var y0 = lastargs[lastargs.length - 1];\n    //---\n    var npts = [\n        new THREE.Vector2(x0, y0)\n    ];\n    Array.prototype.push.apply(npts, pts);\n    var curve = new THREE.SplineCurve(npts);\n    this.curves.push(curve);\n    this.actions.push({\n        action: THREE.PathActions.CSPLINE_THRU,\n        args: args\n    });\n};\n// FUTURE: Change the API or follow canvas API?\nTHREE.Path.prototype.arc = function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {\n    var lastargs = this.actions[this.actions.length - 1].args;\n    var x0 = lastargs[lastargs.length - 2];\n    var y0 = lastargs[lastargs.length - 1];\n    this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);\n};\nTHREE.Path.prototype.absarc = function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {\n    this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);\n};\nTHREE.Path.prototype.ellipse = function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise) {\n    var lastargs = this.actions[this.actions.length - 1].args;\n    var x0 = lastargs[lastargs.length - 2];\n    var y0 = lastargs[lastargs.length - 1];\n    this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise);\n};\nTHREE.Path.prototype.absellipse = function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise) {\n    var args = Array.prototype.slice.call(arguments);\n    var curve = new THREE.EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise);\n    this.curves.push(curve);\n    var lastPoint = curve.getPoint(aClockwise ? 1 : 0);\n    args.push(lastPoint.x);\n    args.push(lastPoint.y);\n    this.actions.push({\n        action: THREE.PathActions.ELLIPSE,\n        args: args\n    });\n};\nTHREE.Path.prototype.getSpacedPoints = function(divisions, closedPath) {\n    if (!divisions) divisions = 40;\n    var points = [];\n    for(var i = 0; i < divisions; i++)points.push(this.getPoint(i / divisions));\n    // if ( closedPath ) {\n    //\n    // \tpoints.push( points[ 0 ] );\n    //\n    // }\n    return points;\n};\n/* Return an array of vectors based on contour of the path */ THREE.Path.prototype.getPoints = function(divisions, closedPath) {\n    if (this.useSpacedPoints) {\n        console.log(\"tata\");\n        return this.getSpacedPoints(divisions, closedPath);\n    }\n    divisions = divisions || 12;\n    var points = [];\n    var i, il, item, action, args;\n    var cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0, laste, j, t, tx, ty;\n    for(i = 0, il = this.actions.length; i < il; i++){\n        item = this.actions[i];\n        action = item.action;\n        args = item.args;\n        switch(action){\n            case THREE.PathActions.MOVE_TO:\n                points.push(new THREE.Vector2(args[0], args[1]));\n                break;\n            case THREE.PathActions.LINE_TO:\n                points.push(new THREE.Vector2(args[0], args[1]));\n                break;\n            case THREE.PathActions.QUADRATIC_CURVE_TO:\n                cpx = args[2];\n                cpy = args[3];\n                cpx1 = args[0];\n                cpy1 = args[1];\n                if (points.length > 0) {\n                    laste = points[points.length - 1];\n                    cpx0 = laste.x;\n                    cpy0 = laste.y;\n                } else {\n                    laste = this.actions[i - 1].args;\n                    cpx0 = laste[laste.length - 2];\n                    cpy0 = laste[laste.length - 1];\n                }\n                for(j = 1; j <= divisions; j++){\n                    t = j / divisions;\n                    tx = THREE.Shape.Utils.b2(t, cpx0, cpx1, cpx);\n                    ty = THREE.Shape.Utils.b2(t, cpy0, cpy1, cpy);\n                    points.push(new THREE.Vector2(tx, ty));\n                }\n                break;\n            case THREE.PathActions.BEZIER_CURVE_TO:\n                cpx = args[4];\n                cpy = args[5];\n                cpx1 = args[0];\n                cpy1 = args[1];\n                cpx2 = args[2];\n                cpy2 = args[3];\n                if (points.length > 0) {\n                    laste = points[points.length - 1];\n                    cpx0 = laste.x;\n                    cpy0 = laste.y;\n                } else {\n                    laste = this.actions[i - 1].args;\n                    cpx0 = laste[laste.length - 2];\n                    cpy0 = laste[laste.length - 1];\n                }\n                for(j = 1; j <= divisions; j++){\n                    t = j / divisions;\n                    tx = THREE.Shape.Utils.b3(t, cpx0, cpx1, cpx2, cpx);\n                    ty = THREE.Shape.Utils.b3(t, cpy0, cpy1, cpy2, cpy);\n                    points.push(new THREE.Vector2(tx, ty));\n                }\n                break;\n            case THREE.PathActions.CSPLINE_THRU:\n                laste = this.actions[i - 1].args;\n                var last = new THREE.Vector2(laste[laste.length - 2], laste[laste.length - 1]);\n                var spts = [\n                    last\n                ];\n                var n = divisions * args[0].length;\n                spts = spts.concat(args[0]);\n                var spline = new THREE.SplineCurve(spts);\n                for(j = 1; j <= n; j++)points.push(spline.getPointAt(j / n));\n                break;\n            case THREE.PathActions.ARC:\n                var aX = args[0], aY = args[1], aRadius = args[2], aStartAngle = args[3], aEndAngle = args[4], aClockwise = !!args[5];\n                var deltaAngle = aEndAngle - aStartAngle;\n                var angle;\n                var tdivisions = divisions * 2;\n                for(j = 1; j <= tdivisions; j++){\n                    t = j / tdivisions;\n                    if (!aClockwise) t = 1 - t;\n                    angle = aStartAngle + t * deltaAngle;\n                    tx = aX + aRadius * Math.cos(angle);\n                    ty = aY + aRadius * Math.sin(angle);\n                    //console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\n                    points.push(new THREE.Vector2(tx, ty));\n                }\n                break;\n            case THREE.PathActions.ELLIPSE:\n                var aX = args[0], aY = args[1], xRadius = args[2], yRadius = args[3], aStartAngle = args[4], aEndAngle = args[5], aClockwise = !!args[6];\n                var deltaAngle = aEndAngle - aStartAngle;\n                var angle;\n                var tdivisions = divisions * 2;\n                for(j = 1; j <= tdivisions; j++){\n                    t = j / tdivisions;\n                    if (!aClockwise) t = 1 - t;\n                    angle = aStartAngle + t * deltaAngle;\n                    tx = aX + xRadius * Math.cos(angle);\n                    ty = aY + yRadius * Math.sin(angle);\n                    //console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\n                    points.push(new THREE.Vector2(tx, ty));\n                }\n                break;\n        } // end switch\n    }\n    // Normalize to remove the closing point by default.\n    var lastPoint = points[points.length - 1];\n    var EPSILON = 0.0000000001;\n    if (Math.abs(lastPoint.x - points[0].x) < EPSILON && Math.abs(lastPoint.y - points[0].y) < EPSILON) points.splice(points.length - 1, 1);\n    if (closedPath) points.push(points[0]);\n    return points;\n};\n// Breaks path into shapes\nTHREE.Path.prototype.toShapes = function() {\n    var i, il, item, action, args;\n    var subPaths = [], lastPath = new THREE.Path();\n    for(i = 0, il = this.actions.length; i < il; i++){\n        item = this.actions[i];\n        args = item.args;\n        action = item.action;\n        if (action == THREE.PathActions.MOVE_TO) {\n            if (lastPath.actions.length != 0) {\n                subPaths.push(lastPath);\n                lastPath = new THREE.Path();\n            }\n        }\n        lastPath[action].apply(lastPath, args);\n    }\n    if (lastPath.actions.length != 0) subPaths.push(lastPath);\n    // console.log(subPaths);\n    if (subPaths.length == 0) return [];\n    var tmpPath, tmpShape, shapes = [];\n    var holesFirst = !THREE.Shape.Utils.isClockWise(subPaths[0].getPoints());\n    // console.log(\"Holes first\", holesFirst);\n    if (subPaths.length == 1) {\n        tmpPath = subPaths[0];\n        tmpShape = new THREE.Shape();\n        tmpShape.actions = tmpPath.actions;\n        tmpShape.curves = tmpPath.curves;\n        shapes.push(tmpShape);\n        return shapes;\n    }\n    if (holesFirst) {\n        tmpShape = new THREE.Shape();\n        for(i = 0, il = subPaths.length; i < il; i++){\n            tmpPath = subPaths[i];\n            if (THREE.Shape.Utils.isClockWise(tmpPath.getPoints())) {\n                tmpShape.actions = tmpPath.actions;\n                tmpShape.curves = tmpPath.curves;\n                shapes.push(tmpShape);\n                tmpShape = new THREE.Shape();\n            //console.log('cw', i);\n            } else tmpShape.holes.push(tmpPath);\n        }\n    } else {\n        // Shapes first\n        for(i = 0, il = subPaths.length; i < il; i++){\n            tmpPath = subPaths[i];\n            if (THREE.Shape.Utils.isClockWise(tmpPath.getPoints())) {\n                if (tmpShape) shapes.push(tmpShape);\n                tmpShape = new THREE.Shape();\n                tmpShape.actions = tmpPath.actions;\n                tmpShape.curves = tmpPath.curves;\n            } else tmpShape.holes.push(tmpPath);\n        }\n        shapes.push(tmpShape);\n    }\n    //console.log(\"shape\", shapes);\n    return shapes;\n};\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * Defines a 2d shape plane using paths.\n **/ // STEP 1 Create a path.\n// STEP 2 Turn path into shape.\n// STEP 3 ExtrudeGeometry takes in Shape/Shapes\n// STEP 3a - Extract points from each shape, turn to vertices\n// STEP 3b - Triangulate each shape, add faces.\nTHREE.Shape = function() {\n    THREE.Path.apply(this, arguments);\n    this.holes = [];\n};\nTHREE.Shape.prototype = Object.create(THREE.Path.prototype);\n// Convenience method to return ExtrudeGeometry\nTHREE.Shape.prototype.extrude = function(options) {\n    var extruded = new THREE.ExtrudeGeometry(this, options);\n    return extruded;\n};\n// Convenience method to return ShapeGeometry\nTHREE.Shape.prototype.makeGeometry = function(options) {\n    var geometry = new THREE.ShapeGeometry(this, options);\n    return geometry;\n};\n// Get points of holes\nTHREE.Shape.prototype.getPointsHoles = function(divisions) {\n    var i, il = this.holes.length, holesPts = [];\n    for(i = 0; i < il; i++)holesPts[i] = this.holes[i].getTransformedPoints(divisions, this.bends);\n    return holesPts;\n};\n// Get points of holes (spaced by regular distance)\nTHREE.Shape.prototype.getSpacedPointsHoles = function(divisions) {\n    var i, il = this.holes.length, holesPts = [];\n    for(i = 0; i < il; i++)holesPts[i] = this.holes[i].getTransformedSpacedPoints(divisions, this.bends);\n    return holesPts;\n};\n// Get points of shape and holes (keypoints based on segments parameter)\nTHREE.Shape.prototype.extractAllPoints = function(divisions) {\n    return {\n        shape: this.getTransformedPoints(divisions),\n        holes: this.getPointsHoles(divisions)\n    };\n};\nTHREE.Shape.prototype.extractPoints = function(divisions) {\n    if (this.useSpacedPoints) return this.extractAllSpacedPoints(divisions);\n    return this.extractAllPoints(divisions);\n};\n//\n// THREE.Shape.prototype.extractAllPointsWithBend = function ( divisions, bend ) {\n//\n// \treturn {\n//\n// \t\tshape: this.transform( bend, divisions ),\n// \t\tholes: this.getPointsHoles( divisions, bend )\n//\n// \t};\n//\n// };\n// Get points of shape and holes (spaced by regular distance)\nTHREE.Shape.prototype.extractAllSpacedPoints = function(divisions) {\n    return {\n        shape: this.getTransformedSpacedPoints(divisions),\n        holes: this.getSpacedPointsHoles(divisions)\n    };\n};\n/**************************************************************\n *\tUtils\n **************************************************************/ THREE.Shape.Utils = {\n    /*\n\t\tcontour - array of vector2 for contour\n\t\tholes   - array of array of vector2\n\t*/ removeHoles: function(contour, holes) {\n        var shape = contour.concat(); // work on this shape\n        var allpoints = shape.concat();\n        /* For each isolated shape, find the closest points and break to the hole to allow triangulation */ var prevShapeVert, nextShapeVert, prevHoleVert, nextHoleVert, holeIndex, shapeIndex, shapeId, shapeGroup, h, h2, hole, shortest, d, p, pts1, pts2, tmpShape1, tmpShape2, tmpHole1, tmpHole2, verts = [];\n        for(h = 0; h < holes.length; h++){\n            hole = holes[h];\n            /*\n\t\t\tshapeholes[ h ].concat(); // preserves original\n\t\t\tholes.push( hole );\n\t\t\t*/ Array.prototype.push.apply(allpoints, hole);\n            shortest = Number.POSITIVE_INFINITY;\n            // Find the shortest pair of pts between shape and hole\n            // Note: Actually, I'm not sure now if we could optimize this to be faster than O(m*n)\n            // Using distanceToSquared() intead of distanceTo() should speed a little\n            // since running square roots operations are reduced.\n            for(h2 = 0; h2 < hole.length; h2++){\n                pts1 = hole[h2];\n                var dist = [];\n                for(p = 0; p < shape.length; p++){\n                    pts2 = shape[p];\n                    d = pts1.distanceToSquared(pts2);\n                    dist.push(d);\n                    if (d < shortest) {\n                        shortest = d;\n                        holeIndex = h2;\n                        shapeIndex = p;\n                    }\n                }\n            }\n            //console.log(\"shortest\", shortest, dist);\n            prevShapeVert = shapeIndex - 1 >= 0 ? shapeIndex - 1 : shape.length - 1;\n            prevHoleVert = holeIndex - 1 >= 0 ? holeIndex - 1 : hole.length - 1;\n            var areaapts = [\n                hole[holeIndex],\n                shape[shapeIndex],\n                shape[prevShapeVert]\n            ];\n            var areaa = THREE.FontUtils.Triangulate.area(areaapts);\n            var areabpts = [\n                hole[holeIndex],\n                hole[prevHoleVert],\n                shape[shapeIndex]\n            ];\n            var areab = THREE.FontUtils.Triangulate.area(areabpts);\n            var shapeOffset = 1;\n            var holeOffset = -1;\n            var oldShapeIndex = shapeIndex, oldHoleIndex = holeIndex;\n            shapeIndex += shapeOffset;\n            holeIndex += holeOffset;\n            if (shapeIndex < 0) shapeIndex += shape.length;\n            shapeIndex %= shape.length;\n            if (holeIndex < 0) holeIndex += hole.length;\n            holeIndex %= hole.length;\n            prevShapeVert = shapeIndex - 1 >= 0 ? shapeIndex - 1 : shape.length - 1;\n            prevHoleVert = holeIndex - 1 >= 0 ? holeIndex - 1 : hole.length - 1;\n            areaapts = [\n                hole[holeIndex],\n                shape[shapeIndex],\n                shape[prevShapeVert]\n            ];\n            var areaa2 = THREE.FontUtils.Triangulate.area(areaapts);\n            areabpts = [\n                hole[holeIndex],\n                hole[prevHoleVert],\n                shape[shapeIndex]\n            ];\n            var areab2 = THREE.FontUtils.Triangulate.area(areabpts);\n            //console.log(areaa,areab ,areaa2,areab2, ( areaa + areab ),  ( areaa2 + areab2 ));\n            if (areaa + areab > areaa2 + areab2) {\n                // In case areas are not correct.\n                //console.log(\"USE THIS\");\n                shapeIndex = oldShapeIndex;\n                holeIndex = oldHoleIndex;\n                if (shapeIndex < 0) shapeIndex += shape.length;\n                shapeIndex %= shape.length;\n                if (holeIndex < 0) holeIndex += hole.length;\n                holeIndex %= hole.length;\n                prevShapeVert = shapeIndex - 1 >= 0 ? shapeIndex - 1 : shape.length - 1;\n                prevHoleVert = holeIndex - 1 >= 0 ? holeIndex - 1 : hole.length - 1;\n            }\n            tmpShape1 = shape.slice(0, shapeIndex);\n            tmpShape2 = shape.slice(shapeIndex);\n            tmpHole1 = hole.slice(holeIndex);\n            tmpHole2 = hole.slice(0, holeIndex);\n            // Should check orders here again?\n            var trianglea = [\n                hole[holeIndex],\n                shape[shapeIndex],\n                shape[prevShapeVert]\n            ];\n            var triangleb = [\n                hole[holeIndex],\n                hole[prevHoleVert],\n                shape[shapeIndex]\n            ];\n            verts.push(trianglea);\n            verts.push(triangleb);\n            shape = tmpShape1.concat(tmpHole1).concat(tmpHole2).concat(tmpShape2);\n        }\n        return {\n            shape: shape,\n            /* shape with no holes */ isolatedPts: verts,\n            /* isolated faces */ allpoints: allpoints\n        };\n    },\n    triangulateShape: function(contour, holes) {\n        var shapeWithoutHoles = THREE.Shape.Utils.removeHoles(contour, holes);\n        var shape = shapeWithoutHoles.shape, allpoints = shapeWithoutHoles.allpoints, isolatedPts = shapeWithoutHoles.isolatedPts;\n        var triangles = THREE.FontUtils.Triangulate(shape, false); // True returns indices for points of spooled shape\n        // To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.\n        //console.log( \"triangles\",triangles, triangles.length );\n        //console.log( \"allpoints\",allpoints, allpoints.length );\n        var i, il, f, face, key, index, allPointsMap = {}, isolatedPointsMap = {};\n        // prepare all points map\n        for(i = 0, il = allpoints.length; i < il; i++){\n            key = allpoints[i].x + \":\" + allpoints[i].y;\n            if (allPointsMap[key] !== undefined) console.log(\"Duplicate point\", key);\n            allPointsMap[key] = i;\n        }\n        // check all face vertices against all points map\n        for(i = 0, il = triangles.length; i < il; i++){\n            face = triangles[i];\n            for(f = 0; f < 3; f++){\n                key = face[f].x + \":\" + face[f].y;\n                index = allPointsMap[key];\n                if (index !== undefined) face[f] = index;\n            }\n        }\n        // check isolated points vertices against all points map\n        for(i = 0, il = isolatedPts.length; i < il; i++){\n            face = isolatedPts[i];\n            for(f = 0; f < 3; f++){\n                key = face[f].x + \":\" + face[f].y;\n                index = allPointsMap[key];\n                if (index !== undefined) face[f] = index;\n            }\n        }\n        return triangles.concat(isolatedPts);\n    },\n    /*\n\ttriangulate2 : function( pts, holes ) {\n\n\t\t// For use with Poly2Tri.js\n\n\t\tvar allpts = pts.concat();\n\t\tvar shape = [];\n\t\tfor (var p in pts) {\n\t\t\tshape.push(new js.poly2tri.Point(pts[p].x, pts[p].y));\n\t\t}\n\n\t\tvar swctx = new js.poly2tri.SweepContext(shape);\n\n\t\tfor (var h in holes) {\n\t\t\tvar aHole = holes[h];\n\t\t\tvar newHole = []\n\t\t\tfor (i in aHole) {\n\t\t\t\tnewHole.push(new js.poly2tri.Point(aHole[i].x, aHole[i].y));\n\t\t\t\tallpts.push(aHole[i]);\n\t\t\t}\n\t\t\tswctx.AddHole(newHole);\n\t\t}\n\n\t\tvar find;\n\t\tvar findIndexForPt = function (pt) {\n\t\t\tfind = new THREE.Vector2(pt.x, pt.y);\n\t\t\tvar p;\n\t\t\tfor (p=0, pl = allpts.length; p<pl; p++) {\n\t\t\t\tif (allpts[p].equals(find)) return p;\n\t\t\t}\n\t\t\treturn -1;\n\t\t};\n\n\t\t// triangulate\n\t\tjs.poly2tri.sweep.Triangulate(swctx);\n\n\t\tvar triangles =  swctx.GetTriangles();\n\t\tvar tr ;\n\t\tvar facesPts = [];\n\t\tfor (var t in triangles) {\n\t\t\ttr =  triangles[t];\n\t\t\tfacesPts.push([\n\t\t\t\tfindIndexForPt(tr.GetPoint(0)),\n\t\t\t\tfindIndexForPt(tr.GetPoint(1)),\n\t\t\t\tfindIndexForPt(tr.GetPoint(2))\n\t\t\t\t\t]);\n\t\t}\n\n\n\t//\tconsole.log(facesPts);\n\t//\tconsole.log(\"triangles\", triangles.length, triangles);\n\n\t\t// Returns array of faces with 3 element each\n\treturn facesPts;\n\t},\n*/ isClockWise: function(pts) {\n        return THREE.FontUtils.Triangulate.area(pts) < 0;\n    },\n    // Bezier Curves formulas obtained from\n    // http://en.wikipedia.org/wiki/B%C3%A9zier_curve\n    // Quad Bezier Functions\n    b2p0: function(t, p) {\n        var k = 1 - t;\n        return k * k * p;\n    },\n    b2p1: function(t, p) {\n        return 2 * (1 - t) * t * p;\n    },\n    b2p2: function(t, p) {\n        return t * t * p;\n    },\n    b2: function(t, p0, p1, p2) {\n        return this.b2p0(t, p0) + this.b2p1(t, p1) + this.b2p2(t, p2);\n    },\n    // Cubic Bezier Functions\n    b3p0: function(t, p) {\n        var k = 1 - t;\n        return k * k * k * p;\n    },\n    b3p1: function(t, p) {\n        var k = 1 - t;\n        return 3 * k * k * t * p;\n    },\n    b3p2: function(t, p) {\n        var k = 1 - t;\n        return 3 * k * t * t * p;\n    },\n    b3p3: function(t, p) {\n        return t * t * t * p;\n    },\n    b3: function(t, p0, p1, p2, p3) {\n        return this.b3p0(t, p0) + this.b3p1(t, p1) + this.b3p2(t, p2) + this.b3p3(t, p3);\n    }\n};\n/**\n * @author mikael emtinger / http://gomo.se/\n */ THREE.AnimationHandler = function() {\n    var playing = [];\n    var library = {};\n    var that = {};\n    //--- update ---\n    that.update = function(deltaTimeMS) {\n        for(var i = 0; i < playing.length; i++)playing[i].update(deltaTimeMS);\n    };\n    //--- add ---\n    that.addToUpdate = function(animation) {\n        if (playing.indexOf(animation) === -1) playing.push(animation);\n    };\n    //--- remove ---\n    that.removeFromUpdate = function(animation) {\n        var index = playing.indexOf(animation);\n        if (index !== -1) playing.splice(index, 1);\n    };\n    //--- add ---\n    that.add = function(data) {\n        if (library[data.name] !== undefined) console.log(\"THREE.AnimationHandler.add: Warning! \" + data.name + \" already exists in library. Overwriting.\");\n        library[data.name] = data;\n        initData(data);\n    };\n    //--- get ---\n    that.get = function(name) {\n        if (typeof name === \"string\") {\n            if (library[name]) return library[name];\n            else {\n                console.log(\"THREE.AnimationHandler.get: Couldn't find animation \" + name);\n                return null;\n            }\n        }\n    };\n    //--- parse ---\n    that.parse = function(root) {\n        // setup hierarchy\n        var hierarchy = [];\n        if (root instanceof THREE.SkinnedMesh) for(var b = 0; b < root.bones.length; b++)hierarchy.push(root.bones[b]);\n        else parseRecurseHierarchy(root, hierarchy);\n        return hierarchy;\n    };\n    var parseRecurseHierarchy = function(root, hierarchy) {\n        hierarchy.push(root);\n        for(var c = 0; c < root.children.length; c++)parseRecurseHierarchy(root.children[c], hierarchy);\n    };\n    //--- init data ---\n    var initData = function(data) {\n        if (data.initialized === true) return;\n        // loop through all keys\n        for(var h = 0; h < data.hierarchy.length; h++){\n            for(var k = 0; k < data.hierarchy[h].keys.length; k++){\n                // remove minus times\n                if (data.hierarchy[h].keys[k].time < 0) data.hierarchy[h].keys[k].time = 0;\n                // create quaternions\n                if (data.hierarchy[h].keys[k].rot !== undefined && !(data.hierarchy[h].keys[k].rot instanceof THREE.Quaternion)) {\n                    var quat = data.hierarchy[h].keys[k].rot;\n                    data.hierarchy[h].keys[k].rot = new THREE.Quaternion(quat[0], quat[1], quat[2], quat[3]);\n                }\n            }\n            // prepare morph target keys\n            if (data.hierarchy[h].keys.length && data.hierarchy[h].keys[0].morphTargets !== undefined) {\n                // get all used\n                var usedMorphTargets = {};\n                for(var k = 0; k < data.hierarchy[h].keys.length; k++)for(var m = 0; m < data.hierarchy[h].keys[k].morphTargets.length; m++){\n                    var morphTargetName = data.hierarchy[h].keys[k].morphTargets[m];\n                    usedMorphTargets[morphTargetName] = -1;\n                }\n                data.hierarchy[h].usedMorphTargets = usedMorphTargets;\n                // set all used on all frames\n                for(var k = 0; k < data.hierarchy[h].keys.length; k++){\n                    var influences = {};\n                    for(var morphTargetName in usedMorphTargets){\n                        for(var m = 0; m < data.hierarchy[h].keys[k].morphTargets.length; m++)if (data.hierarchy[h].keys[k].morphTargets[m] === morphTargetName) {\n                            influences[morphTargetName] = data.hierarchy[h].keys[k].morphTargetsInfluences[m];\n                            break;\n                        }\n                        if (m === data.hierarchy[h].keys[k].morphTargets.length) influences[morphTargetName] = 0;\n                    }\n                    data.hierarchy[h].keys[k].morphTargetsInfluences = influences;\n                }\n            }\n            // remove all keys that are on the same time\n            for(var k = 1; k < data.hierarchy[h].keys.length; k++)if (data.hierarchy[h].keys[k].time === data.hierarchy[h].keys[k - 1].time) {\n                data.hierarchy[h].keys.splice(k, 1);\n                k--;\n            }\n            // set index\n            for(var k = 0; k < data.hierarchy[h].keys.length; k++)data.hierarchy[h].keys[k].index = k;\n        }\n        // JIT\n        var lengthInFrames = parseInt(data.length * data.fps, 10);\n        data.JIT = {};\n        data.JIT.hierarchy = [];\n        for(var h = 0; h < data.hierarchy.length; h++)data.JIT.hierarchy.push(new Array(lengthInFrames));\n        // done\n        data.initialized = true;\n    };\n    // interpolation types\n    that.LINEAR = 0;\n    that.CATMULLROM = 1;\n    that.CATMULLROM_FORWARD = 2;\n    return that;\n}();\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */ THREE.Animation = function(root, name, interpolationType) {\n    this.root = root;\n    this.data = THREE.AnimationHandler.get(name);\n    this.hierarchy = THREE.AnimationHandler.parse(root);\n    this.currentTime = 0;\n    this.timeScale = 1;\n    this.isPlaying = false;\n    this.isPaused = true;\n    this.loop = true;\n    this.interpolationType = interpolationType !== undefined ? interpolationType : THREE.AnimationHandler.LINEAR;\n    this.points = [];\n    this.target = new THREE.Vector3();\n};\nTHREE.Animation.prototype.play = function(loop, startTimeMS) {\n    if (this.isPlaying === false) {\n        this.isPlaying = true;\n        this.loop = loop !== undefined ? loop : true;\n        this.currentTime = startTimeMS !== undefined ? startTimeMS : 0;\n        // reset key cache\n        var h, hl = this.hierarchy.length, object;\n        for(h = 0; h < hl; h++){\n            object = this.hierarchy[h];\n            if (this.interpolationType !== THREE.AnimationHandler.CATMULLROM_FORWARD) object.useQuaternion = true;\n            object.matrixAutoUpdate = true;\n            if (object.animationCache === undefined) {\n                object.animationCache = {};\n                object.animationCache.prevKey = {\n                    pos: 0,\n                    rot: 0,\n                    scl: 0\n                };\n                object.animationCache.nextKey = {\n                    pos: 0,\n                    rot: 0,\n                    scl: 0\n                };\n                object.animationCache.originalMatrix = object instanceof THREE.Bone ? object.skinMatrix : object.matrix;\n            }\n            var prevKey = object.animationCache.prevKey;\n            var nextKey = object.animationCache.nextKey;\n            prevKey.pos = this.data.hierarchy[h].keys[0];\n            prevKey.rot = this.data.hierarchy[h].keys[0];\n            prevKey.scl = this.data.hierarchy[h].keys[0];\n            nextKey.pos = this.getNextKeyWith(\"pos\", h, 1);\n            nextKey.rot = this.getNextKeyWith(\"rot\", h, 1);\n            nextKey.scl = this.getNextKeyWith(\"scl\", h, 1);\n        }\n        this.update(0);\n    }\n    this.isPaused = false;\n    THREE.AnimationHandler.addToUpdate(this);\n};\nTHREE.Animation.prototype.pause = function() {\n    if (this.isPaused === true) THREE.AnimationHandler.addToUpdate(this);\n    else THREE.AnimationHandler.removeFromUpdate(this);\n    this.isPaused = !this.isPaused;\n};\nTHREE.Animation.prototype.stop = function() {\n    this.isPlaying = false;\n    this.isPaused = false;\n    THREE.AnimationHandler.removeFromUpdate(this);\n};\nTHREE.Animation.prototype.update = function(deltaTimeMS) {\n    // early out\n    if (this.isPlaying === false) return;\n    // vars\n    var types = [\n        \"pos\",\n        \"rot\",\n        \"scl\"\n    ];\n    var type;\n    var scale;\n    var vector;\n    var prevXYZ, nextXYZ;\n    var prevKey, nextKey;\n    var object;\n    var animationCache;\n    var frame;\n    var JIThierarchy = this.data.JIT.hierarchy;\n    var currentTime, unloopedCurrentTime;\n    var currentPoint, forwardPoint, angle;\n    this.currentTime += deltaTimeMS * this.timeScale;\n    unloopedCurrentTime = this.currentTime;\n    currentTime = this.currentTime = this.currentTime % this.data.length;\n    frame = parseInt(Math.min(currentTime * this.data.fps, this.data.length * this.data.fps), 10);\n    for(var h = 0, hl = this.hierarchy.length; h < hl; h++){\n        object = this.hierarchy[h];\n        animationCache = object.animationCache;\n        // loop through pos/rot/scl\n        for(var t = 0; t < 3; t++){\n            // get keys\n            type = types[t];\n            prevKey = animationCache.prevKey[type];\n            nextKey = animationCache.nextKey[type];\n            // switch keys?\n            if (nextKey.time <= unloopedCurrentTime) {\n                // did we loop?\n                if (currentTime < unloopedCurrentTime) {\n                    if (this.loop) {\n                        prevKey = this.data.hierarchy[h].keys[0];\n                        nextKey = this.getNextKeyWith(type, h, 1);\n                        while(nextKey.time < currentTime){\n                            prevKey = nextKey;\n                            nextKey = this.getNextKeyWith(type, h, nextKey.index + 1);\n                        }\n                    } else {\n                        this.stop();\n                        return;\n                    }\n                } else do {\n                    prevKey = nextKey;\n                    nextKey = this.getNextKeyWith(type, h, nextKey.index + 1);\n                }while (nextKey.time < currentTime);\n                animationCache.prevKey[type] = prevKey;\n                animationCache.nextKey[type] = nextKey;\n            }\n            object.matrixAutoUpdate = true;\n            object.matrixWorldNeedsUpdate = true;\n            scale = (currentTime - prevKey.time) / (nextKey.time - prevKey.time);\n            prevXYZ = prevKey[type];\n            nextXYZ = nextKey[type];\n            // check scale error\n            if (scale < 0 || scale > 1) {\n                console.log(\"THREE.Animation.update: Warning! Scale out of bounds:\" + scale + \" on bone \" + h);\n                scale = scale < 0 ? 0 : 1;\n            }\n            // interpolate\n            if (type === \"pos\") {\n                vector = object.position;\n                if (this.interpolationType === THREE.AnimationHandler.LINEAR) {\n                    vector.x = prevXYZ[0] + (nextXYZ[0] - prevXYZ[0]) * scale;\n                    vector.y = prevXYZ[1] + (nextXYZ[1] - prevXYZ[1]) * scale;\n                    vector.z = prevXYZ[2] + (nextXYZ[2] - prevXYZ[2]) * scale;\n                } else if (this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD) {\n                    this.points[0] = this.getPrevKeyWith(\"pos\", h, prevKey.index - 1)[\"pos\"];\n                    this.points[1] = prevXYZ;\n                    this.points[2] = nextXYZ;\n                    this.points[3] = this.getNextKeyWith(\"pos\", h, nextKey.index + 1)[\"pos\"];\n                    scale = scale * 0.33 + 0.33;\n                    currentPoint = this.interpolateCatmullRom(this.points, scale);\n                    vector.x = currentPoint[0];\n                    vector.y = currentPoint[1];\n                    vector.z = currentPoint[2];\n                    if (this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD) {\n                        forwardPoint = this.interpolateCatmullRom(this.points, scale * 1.01);\n                        this.target.set(forwardPoint[0], forwardPoint[1], forwardPoint[2]);\n                        this.target.sub(vector);\n                        this.target.y = 0;\n                        this.target.normalize();\n                        angle = Math.atan2(this.target.x, this.target.z);\n                        object.rotation.set(0, angle, 0);\n                    }\n                }\n            } else if (type === \"rot\") THREE.Quaternion.slerp(prevXYZ, nextXYZ, object.quaternion, scale);\n            else if (type === \"scl\") {\n                vector = object.scale;\n                vector.x = prevXYZ[0] + (nextXYZ[0] - prevXYZ[0]) * scale;\n                vector.y = prevXYZ[1] + (nextXYZ[1] - prevXYZ[1]) * scale;\n                vector.z = prevXYZ[2] + (nextXYZ[2] - prevXYZ[2]) * scale;\n            }\n        }\n    }\n};\n// Catmull-Rom spline\nTHREE.Animation.prototype.interpolateCatmullRom = function(points, scale) {\n    var c = [], v3 = [], point, intPoint, weight, w2, w3, pa, pb, pc, pd;\n    point = (points.length - 1) * scale;\n    intPoint = Math.floor(point);\n    weight = point - intPoint;\n    c[0] = intPoint === 0 ? intPoint : intPoint - 1;\n    c[1] = intPoint;\n    c[2] = intPoint > points.length - 2 ? intPoint : intPoint + 1;\n    c[3] = intPoint > points.length - 3 ? intPoint : intPoint + 2;\n    pa = points[c[0]];\n    pb = points[c[1]];\n    pc = points[c[2]];\n    pd = points[c[3]];\n    w2 = weight * weight;\n    w3 = weight * w2;\n    v3[0] = this.interpolate(pa[0], pb[0], pc[0], pd[0], weight, w2, w3);\n    v3[1] = this.interpolate(pa[1], pb[1], pc[1], pd[1], weight, w2, w3);\n    v3[2] = this.interpolate(pa[2], pb[2], pc[2], pd[2], weight, w2, w3);\n    return v3;\n};\nTHREE.Animation.prototype.interpolate = function(p0, p1, p2, p3, t, t2, t3) {\n    var v0 = (p2 - p0) * 0.5, v1 = (p3 - p1) * 0.5;\n    return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;\n};\n// Get next key with\nTHREE.Animation.prototype.getNextKeyWith = function(type, h, key) {\n    var keys = this.data.hierarchy[h].keys;\n    if (this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD) key = key < keys.length - 1 ? key : keys.length - 1;\n    else key = key % keys.length;\n    for(; key < keys.length; key++){\n        if (keys[key][type] !== undefined) return keys[key];\n    }\n    return this.data.hierarchy[h].keys[0];\n};\n// Get previous key with\nTHREE.Animation.prototype.getPrevKeyWith = function(type, h, key) {\n    var keys = this.data.hierarchy[h].keys;\n    if (this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD) key = key > 0 ? key : 0;\n    else key = key >= 0 ? key : key + keys.length;\n    for(; key >= 0; key--){\n        if (keys[key][type] !== undefined) return keys[key];\n    }\n    return this.data.hierarchy[h].keys[keys.length - 1];\n};\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author khang duong\n * @author erik kitson\n */ THREE.KeyFrameAnimation = function(root, data, JITCompile) {\n    this.root = root;\n    this.data = THREE.AnimationHandler.get(data);\n    this.hierarchy = THREE.AnimationHandler.parse(root);\n    this.currentTime = 0;\n    this.timeScale = 0.001;\n    this.isPlaying = false;\n    this.isPaused = true;\n    this.loop = true;\n    this.JITCompile = JITCompile !== undefined ? JITCompile : true;\n    // initialize to first keyframes\n    for(var h = 0, hl = this.hierarchy.length; h < hl; h++){\n        var keys = this.data.hierarchy[h].keys, sids = this.data.hierarchy[h].sids, obj = this.hierarchy[h];\n        if (keys.length && sids) {\n            for(var s = 0; s < sids.length; s++){\n                var sid = sids[s], next = this.getNextKeyWith(sid, h, 0);\n                if (next) next.apply(sid);\n            }\n            obj.matrixAutoUpdate = false;\n            this.data.hierarchy[h].node.updateMatrix();\n            obj.matrixWorldNeedsUpdate = true;\n        }\n    }\n};\n// Play\nTHREE.KeyFrameAnimation.prototype.play = function(loop, startTimeMS) {\n    if (!this.isPlaying) {\n        this.isPlaying = true;\n        this.loop = loop !== undefined ? loop : true;\n        this.currentTime = startTimeMS !== undefined ? startTimeMS : 0;\n        this.startTimeMs = startTimeMS;\n        this.startTime = 10000000;\n        this.endTime = -this.startTime;\n        // reset key cache\n        var h, hl = this.hierarchy.length, object, node;\n        for(h = 0; h < hl; h++){\n            object = this.hierarchy[h];\n            node = this.data.hierarchy[h];\n            object.useQuaternion = true;\n            if (node.animationCache === undefined) {\n                node.animationCache = {};\n                node.animationCache.prevKey = null;\n                node.animationCache.nextKey = null;\n                node.animationCache.originalMatrix = object instanceof THREE.Bone ? object.skinMatrix : object.matrix;\n            }\n            var keys = this.data.hierarchy[h].keys;\n            if (keys.length) {\n                node.animationCache.prevKey = keys[0];\n                node.animationCache.nextKey = keys[1];\n                this.startTime = Math.min(keys[0].time, this.startTime);\n                this.endTime = Math.max(keys[keys.length - 1].time, this.endTime);\n            }\n        }\n        this.update(0);\n    }\n    this.isPaused = false;\n    THREE.AnimationHandler.addToUpdate(this);\n};\n// Pause\nTHREE.KeyFrameAnimation.prototype.pause = function() {\n    if (this.isPaused) THREE.AnimationHandler.addToUpdate(this);\n    else THREE.AnimationHandler.removeFromUpdate(this);\n    this.isPaused = !this.isPaused;\n};\n// Stop\nTHREE.KeyFrameAnimation.prototype.stop = function() {\n    this.isPlaying = false;\n    this.isPaused = false;\n    THREE.AnimationHandler.removeFromUpdate(this);\n    // reset JIT matrix and remove cache\n    for(var h = 0; h < this.data.hierarchy.length; h++){\n        var obj = this.hierarchy[h];\n        var node = this.data.hierarchy[h];\n        if (node.animationCache !== undefined) {\n            var original = node.animationCache.originalMatrix;\n            if (obj instanceof THREE.Bone) {\n                original.copy(obj.skinMatrix);\n                obj.skinMatrix = original;\n            } else {\n                original.copy(obj.matrix);\n                obj.matrix = original;\n            }\n            delete node.animationCache;\n        }\n    }\n};\n// Update\nTHREE.KeyFrameAnimation.prototype.update = function(deltaTimeMS) {\n    // early out\n    if (!this.isPlaying) return;\n    // vars\n    var prevKey, nextKey;\n    var object;\n    var node;\n    var frame;\n    var JIThierarchy = this.data.JIT.hierarchy;\n    var currentTime, unloopedCurrentTime;\n    var looped;\n    // update\n    this.currentTime += deltaTimeMS * this.timeScale;\n    unloopedCurrentTime = this.currentTime;\n    currentTime = this.currentTime = this.currentTime % this.data.length;\n    // if looped around, the current time should be based on the startTime\n    if (currentTime < this.startTimeMs) currentTime = this.currentTime = this.startTimeMs + currentTime;\n    frame = parseInt(Math.min(currentTime * this.data.fps, this.data.length * this.data.fps), 10);\n    looped = currentTime < unloopedCurrentTime;\n    if (looped && !this.loop) {\n        // Set the animation to the last keyframes and stop\n        for(var h = 0, hl = this.hierarchy.length; h < hl; h++){\n            var keys = this.data.hierarchy[h].keys, sids = this.data.hierarchy[h].sids, end = keys.length - 1, obj = this.hierarchy[h];\n            if (keys.length) {\n                for(var s = 0; s < sids.length; s++){\n                    var sid = sids[s], prev = this.getPrevKeyWith(sid, h, end);\n                    if (prev) prev.apply(sid);\n                }\n                this.data.hierarchy[h].node.updateMatrix();\n                obj.matrixWorldNeedsUpdate = true;\n            }\n        }\n        this.stop();\n        return;\n    }\n    // check pre-infinity\n    if (currentTime < this.startTime) return;\n    // update\n    for(var h = 0, hl = this.hierarchy.length; h < hl; h++){\n        object = this.hierarchy[h];\n        node = this.data.hierarchy[h];\n        var keys = node.keys, animationCache = node.animationCache;\n        // use JIT?\n        if (this.JITCompile && JIThierarchy[h][frame] !== undefined) {\n            if (object instanceof THREE.Bone) {\n                object.skinMatrix = JIThierarchy[h][frame];\n                object.matrixWorldNeedsUpdate = false;\n            } else {\n                object.matrix = JIThierarchy[h][frame];\n                object.matrixWorldNeedsUpdate = true;\n            }\n        } else if (keys.length) {\n            // make sure so original matrix and not JIT matrix is set\n            if (this.JITCompile && animationCache) {\n                if (object instanceof THREE.Bone) object.skinMatrix = animationCache.originalMatrix;\n                else object.matrix = animationCache.originalMatrix;\n            }\n            prevKey = animationCache.prevKey;\n            nextKey = animationCache.nextKey;\n            if (prevKey && nextKey) {\n                // switch keys?\n                if (nextKey.time <= unloopedCurrentTime) {\n                    // did we loop?\n                    if (looped && this.loop) {\n                        prevKey = keys[0];\n                        nextKey = keys[1];\n                        while(nextKey.time < currentTime){\n                            prevKey = nextKey;\n                            nextKey = keys[prevKey.index + 1];\n                        }\n                    } else if (!looped) {\n                        var lastIndex = keys.length - 1;\n                        while(nextKey.time < currentTime && nextKey.index !== lastIndex){\n                            prevKey = nextKey;\n                            nextKey = keys[prevKey.index + 1];\n                        }\n                    }\n                    animationCache.prevKey = prevKey;\n                    animationCache.nextKey = nextKey;\n                }\n                if (nextKey.time >= currentTime) prevKey.interpolate(nextKey, currentTime);\n                else prevKey.interpolate(nextKey, nextKey.time);\n            }\n            this.data.hierarchy[h].node.updateMatrix();\n            object.matrixWorldNeedsUpdate = true;\n        }\n    }\n    // update JIT?\n    if (this.JITCompile) {\n        if (JIThierarchy[0][frame] === undefined) {\n            this.hierarchy[0].updateMatrixWorld(true);\n            for(var h = 0; h < this.hierarchy.length; h++)if (this.hierarchy[h] instanceof THREE.Bone) JIThierarchy[h][frame] = this.hierarchy[h].skinMatrix.clone();\n            else JIThierarchy[h][frame] = this.hierarchy[h].matrix.clone();\n        }\n    }\n};\n// Get next key with\nTHREE.KeyFrameAnimation.prototype.getNextKeyWith = function(sid, h, key) {\n    var keys = this.data.hierarchy[h].keys;\n    key = key % keys.length;\n    for(; key < keys.length; key++){\n        if (keys[key].hasTarget(sid)) return keys[key];\n    }\n    return keys[0];\n};\n// Get previous key with\nTHREE.KeyFrameAnimation.prototype.getPrevKeyWith = function(sid, h, key) {\n    var keys = this.data.hierarchy[h].keys;\n    key = key >= 0 ? key : key + keys.length;\n    for(; key >= 0; key--){\n        if (keys[key].hasTarget(sid)) return keys[key];\n    }\n    return keys[keys.length - 1];\n};\n/**\n * Camera for rendering cube maps\n *\t- renders scene into axis-aligned cube\n *\n * @author alteredq / http://alteredqualia.com/\n */ THREE.CubeCamera = function(near, far, cubeResolution) {\n    THREE.Object3D.call(this);\n    var fov = 90, aspect = 1;\n    var cameraPX = new THREE.PerspectiveCamera(fov, aspect, near, far);\n    cameraPX.up.set(0, -1, 0);\n    cameraPX.lookAt(new THREE.Vector3(1, 0, 0));\n    this.add(cameraPX);\n    var cameraNX = new THREE.PerspectiveCamera(fov, aspect, near, far);\n    cameraNX.up.set(0, -1, 0);\n    cameraNX.lookAt(new THREE.Vector3(-1, 0, 0));\n    this.add(cameraNX);\n    var cameraPY = new THREE.PerspectiveCamera(fov, aspect, near, far);\n    cameraPY.up.set(0, 0, 1);\n    cameraPY.lookAt(new THREE.Vector3(0, 1, 0));\n    this.add(cameraPY);\n    var cameraNY = new THREE.PerspectiveCamera(fov, aspect, near, far);\n    cameraNY.up.set(0, 0, -1);\n    cameraNY.lookAt(new THREE.Vector3(0, -1, 0));\n    this.add(cameraNY);\n    var cameraPZ = new THREE.PerspectiveCamera(fov, aspect, near, far);\n    cameraPZ.up.set(0, -1, 0);\n    cameraPZ.lookAt(new THREE.Vector3(0, 0, 1));\n    this.add(cameraPZ);\n    var cameraNZ = new THREE.PerspectiveCamera(fov, aspect, near, far);\n    cameraNZ.up.set(0, -1, 0);\n    cameraNZ.lookAt(new THREE.Vector3(0, 0, -1));\n    this.add(cameraNZ);\n    this.renderTarget = new THREE.WebGLRenderTargetCube(cubeResolution, cubeResolution, {\n        format: THREE.RGBFormat,\n        magFilter: THREE.LinearFilter,\n        minFilter: THREE.LinearFilter\n    });\n    this.updateCubeMap = function(renderer, scene) {\n        var renderTarget = this.renderTarget;\n        var generateMipmaps = renderTarget.generateMipmaps;\n        renderTarget.generateMipmaps = false;\n        renderTarget.activeCubeFace = 0;\n        renderer.render(scene, cameraPX, renderTarget);\n        renderTarget.activeCubeFace = 1;\n        renderer.render(scene, cameraNX, renderTarget);\n        renderTarget.activeCubeFace = 2;\n        renderer.render(scene, cameraPY, renderTarget);\n        renderTarget.activeCubeFace = 3;\n        renderer.render(scene, cameraNY, renderTarget);\n        renderTarget.activeCubeFace = 4;\n        renderer.render(scene, cameraPZ, renderTarget);\n        renderTarget.generateMipmaps = generateMipmaps;\n        renderTarget.activeCubeFace = 5;\n        renderer.render(scene, cameraNZ, renderTarget);\n    };\n};\nTHREE.CubeCamera.prototype = Object.create(THREE.Object3D.prototype);\n/*\n *\t@author zz85 / http://twitter.com/blurspline / http://www.lab4games.net/zz85/blog\n *\n *\tA general perpose camera, for setting FOV, Lens Focal Length,\n *\t\tand switching between perspective and orthographic views easily.\n *\t\tUse this only if you do not wish to manage\n *\t\tboth a Orthographic and Perspective Camera\n *\n */ THREE.CombinedCamera = function(width, height, fov, near, far, orthoNear, orthoFar) {\n    THREE.Camera.call(this);\n    this.fov = fov;\n    this.left = -width / 2;\n    this.right = width / 2;\n    this.top = height / 2;\n    this.bottom = -height / 2;\n    // We could also handle the projectionMatrix internally, but just wanted to test nested camera objects\n    this.cameraO = new THREE.OrthographicCamera(width / -2, width / 2, height / 2, height / -2, orthoNear, orthoFar);\n    this.cameraP = new THREE.PerspectiveCamera(fov, width / height, near, far);\n    this.zoom = 1;\n    this.toPerspective();\n    var aspect = width / height;\n};\nTHREE.CombinedCamera.prototype = Object.create(THREE.Camera.prototype);\nTHREE.CombinedCamera.prototype.toPerspective = function() {\n    // Switches to the Perspective Camera\n    this.near = this.cameraP.near;\n    this.far = this.cameraP.far;\n    this.cameraP.fov = this.fov / this.zoom;\n    this.cameraP.updateProjectionMatrix();\n    this.projectionMatrix = this.cameraP.projectionMatrix;\n    this.inPerspectiveMode = true;\n    this.inOrthographicMode = false;\n};\nTHREE.CombinedCamera.prototype.toOrthographic = function() {\n    // Switches to the Orthographic camera estimating viewport from Perspective\n    var fov = this.fov;\n    var aspect = this.cameraP.aspect;\n    var near = this.cameraP.near;\n    var far = this.cameraP.far;\n    // The size that we set is the mid plane of the viewing frustum\n    var hyperfocus = (near + far) / 2;\n    var halfHeight = Math.tan(fov / 2) * hyperfocus;\n    var planeHeight = 2 * halfHeight;\n    var planeWidth = planeHeight * aspect;\n    var halfWidth = planeWidth / 2;\n    halfHeight /= this.zoom;\n    halfWidth /= this.zoom;\n    this.cameraO.left = -halfWidth;\n    this.cameraO.right = halfWidth;\n    this.cameraO.top = halfHeight;\n    this.cameraO.bottom = -halfHeight;\n    // this.cameraO.left = -farHalfWidth;\n    // this.cameraO.right = farHalfWidth;\n    // this.cameraO.top = farHalfHeight;\n    // this.cameraO.bottom = -farHalfHeight;\n    // this.cameraO.left = this.left / this.zoom;\n    // this.cameraO.right = this.right / this.zoom;\n    // this.cameraO.top = this.top / this.zoom;\n    // this.cameraO.bottom = this.bottom / this.zoom;\n    this.cameraO.updateProjectionMatrix();\n    this.near = this.cameraO.near;\n    this.far = this.cameraO.far;\n    this.projectionMatrix = this.cameraO.projectionMatrix;\n    this.inPerspectiveMode = false;\n    this.inOrthographicMode = true;\n};\nTHREE.CombinedCamera.prototype.setSize = function(width, height) {\n    this.cameraP.aspect = width / height;\n    this.left = -width / 2;\n    this.right = width / 2;\n    this.top = height / 2;\n    this.bottom = -height / 2;\n};\nTHREE.CombinedCamera.prototype.setFov = function(fov) {\n    this.fov = fov;\n    if (this.inPerspectiveMode) this.toPerspective();\n    else this.toOrthographic();\n};\n// For mantaining similar API with PerspectiveCamera\nTHREE.CombinedCamera.prototype.updateProjectionMatrix = function() {\n    if (this.inPerspectiveMode) this.toPerspective();\n    else {\n        this.toPerspective();\n        this.toOrthographic();\n    }\n};\n/*\n* Uses Focal Length (in mm) to estimate and set FOV\n* 35mm (fullframe) camera is used if frame size is not specified;\n* Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html\n*/ THREE.CombinedCamera.prototype.setLens = function(focalLength, frameHeight) {\n    if (frameHeight === undefined) frameHeight = 24;\n    var fov = 2 * THREE.Math.radToDeg(Math.atan(frameHeight / (focalLength * 2)));\n    this.setFov(fov);\n    return fov;\n};\nTHREE.CombinedCamera.prototype.setZoom = function(zoom) {\n    this.zoom = zoom;\n    if (this.inPerspectiveMode) this.toPerspective();\n    else this.toOrthographic();\n};\nTHREE.CombinedCamera.prototype.toFrontView = function() {\n    this.rotation.x = 0;\n    this.rotation.y = 0;\n    this.rotation.z = 0;\n    // should we be modifing the matrix instead?\n    this.rotationAutoUpdate = false;\n};\nTHREE.CombinedCamera.prototype.toBackView = function() {\n    this.rotation.x = 0;\n    this.rotation.y = Math.PI;\n    this.rotation.z = 0;\n    this.rotationAutoUpdate = false;\n};\nTHREE.CombinedCamera.prototype.toLeftView = function() {\n    this.rotation.x = 0;\n    this.rotation.y = -Math.PI / 2;\n    this.rotation.z = 0;\n    this.rotationAutoUpdate = false;\n};\nTHREE.CombinedCamera.prototype.toRightView = function() {\n    this.rotation.x = 0;\n    this.rotation.y = Math.PI / 2;\n    this.rotation.z = 0;\n    this.rotationAutoUpdate = false;\n};\nTHREE.CombinedCamera.prototype.toTopView = function() {\n    this.rotation.x = -Math.PI / 2;\n    this.rotation.y = 0;\n    this.rotation.z = 0;\n    this.rotationAutoUpdate = false;\n};\nTHREE.CombinedCamera.prototype.toBottomView = function() {\n    this.rotation.x = Math.PI / 2;\n    this.rotation.y = 0;\n    this.rotation.z = 0;\n    this.rotationAutoUpdate = false;\n};\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n *\t- 3d asterisk shape (for line pieces THREE.Line)\n */ THREE.AsteriskGeometry = function(innerRadius, outerRadius) {\n    THREE.Geometry.call(this);\n    var sd = innerRadius;\n    var ed = outerRadius;\n    var sd2 = 0.707 * sd;\n    var ed2 = 0.707 * ed;\n    var rays = [\n        [\n            sd,\n            0,\n            0\n        ],\n        [\n            ed,\n            0,\n            0\n        ],\n        [\n            -sd,\n            0,\n            0\n        ],\n        [\n            -ed,\n            0,\n            0\n        ],\n        [\n            0,\n            sd,\n            0\n        ],\n        [\n            0,\n            ed,\n            0\n        ],\n        [\n            0,\n            -sd,\n            0\n        ],\n        [\n            0,\n            -ed,\n            0\n        ],\n        [\n            0,\n            0,\n            sd\n        ],\n        [\n            0,\n            0,\n            ed\n        ],\n        [\n            0,\n            0,\n            -sd\n        ],\n        [\n            0,\n            0,\n            -ed\n        ],\n        [\n            sd2,\n            sd2,\n            0\n        ],\n        [\n            ed2,\n            ed2,\n            0\n        ],\n        [\n            -sd2,\n            -sd2,\n            0\n        ],\n        [\n            -ed2,\n            -ed2,\n            0\n        ],\n        [\n            sd2,\n            -sd2,\n            0\n        ],\n        [\n            ed2,\n            -ed2,\n            0\n        ],\n        [\n            -sd2,\n            sd2,\n            0\n        ],\n        [\n            -ed2,\n            ed2,\n            0\n        ],\n        [\n            sd2,\n            0,\n            sd2\n        ],\n        [\n            ed2,\n            0,\n            ed2\n        ],\n        [\n            -sd2,\n            0,\n            -sd2\n        ],\n        [\n            -ed2,\n            0,\n            -ed2\n        ],\n        [\n            sd2,\n            0,\n            -sd2\n        ],\n        [\n            ed2,\n            0,\n            -ed2\n        ],\n        [\n            -sd2,\n            0,\n            sd2\n        ],\n        [\n            -ed2,\n            0,\n            ed2\n        ],\n        [\n            0,\n            sd2,\n            sd2\n        ],\n        [\n            0,\n            ed2,\n            ed2\n        ],\n        [\n            0,\n            -sd2,\n            -sd2\n        ],\n        [\n            0,\n            -ed2,\n            -ed2\n        ],\n        [\n            0,\n            sd2,\n            -sd2\n        ],\n        [\n            0,\n            ed2,\n            -ed2\n        ],\n        [\n            0,\n            -sd2,\n            sd2\n        ],\n        [\n            0,\n            -ed2,\n            ed2\n        ]\n    ];\n    for(var i = 0, il = rays.length; i < il; i++){\n        var x = rays[i][0];\n        var y = rays[i][1];\n        var z = rays[i][2];\n        this.vertices.push(new THREE.Vector3(x, y, z));\n    }\n};\nTHREE.AsteriskGeometry.prototype = Object.create(THREE.Geometry.prototype); /**\n * @author hughes\n */ \nTHREE.CircleGeometry = function(radius, segments, thetaStart, thetaLength) {\n    THREE.Geometry.call(this);\n    radius = radius || 50;\n    thetaStart = thetaStart !== undefined ? thetaStart : 0;\n    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n    segments = segments !== undefined ? Math.max(3, segments) : 8;\n    var i, uvs = [], center = new THREE.Vector3(), centerUV = new THREE.Vector2(0.5, 0.5);\n    this.vertices.push(center);\n    uvs.push(centerUV);\n    for(i = 0; i <= segments; i++){\n        var vertex = new THREE.Vector3();\n        vertex.x = radius * Math.cos(thetaStart + i / segments * thetaLength);\n        vertex.y = radius * Math.sin(thetaStart + i / segments * thetaLength);\n        this.vertices.push(vertex);\n        uvs.push(new THREE.Vector2((vertex.x / radius + 1) / 2, -(vertex.y / radius + 1) / 2 + 1));\n    }\n    var n = new THREE.Vector3(0, 0, -1);\n    for(i = 1; i <= segments; i++){\n        var v1 = i;\n        var v2 = i + 1;\n        var v3 = 0;\n        this.faces.push(new THREE.Face3(v1, v2, v3, [\n            n,\n            n,\n            n\n        ]));\n        this.faceVertexUvs[0].push([\n            uvs[i],\n            uvs[i + 1],\n            centerUV\n        ]);\n    }\n    this.computeCentroids();\n    this.computeFaceNormals();\n    this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius);\n};\nTHREE.CircleGeometry.prototype = Object.create(THREE.Geometry.prototype);\n/**\n * @author mrdoob / http://mrdoob.com/\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as\n */ THREE.CubeGeometry = function(width, height, depth, widthSegments, heightSegments, depthSegments) {\n    THREE.Geometry.call(this);\n    var scope = this;\n    this.width = width;\n    this.height = height;\n    this.depth = depth;\n    this.widthSegments = widthSegments || 1;\n    this.heightSegments = heightSegments || 1;\n    this.depthSegments = depthSegments || 1;\n    var width_half = this.width / 2;\n    var height_half = this.height / 2;\n    var depth_half = this.depth / 2;\n    buildPlane(\"z\", \"y\", -1, -1, this.depth, this.height, width_half, 0); // px\n    buildPlane(\"z\", \"y\", 1, -1, this.depth, this.height, -width_half, 1); // nx\n    buildPlane(\"x\", \"z\", 1, 1, this.width, this.depth, height_half, 2); // py\n    buildPlane(\"x\", \"z\", 1, -1, this.width, this.depth, -height_half, 3); // ny\n    buildPlane(\"x\", \"y\", 1, -1, this.width, this.height, depth_half, 4); // pz\n    buildPlane(\"x\", \"y\", -1, -1, this.width, this.height, -depth_half, 5); // nz\n    function buildPlane(u, v, udir, vdir, width, height, depth, materialIndex) {\n        var w, ix, iy, gridX = scope.widthSegments, gridY = scope.heightSegments, width_half = width / 2, height_half = height / 2, offset = scope.vertices.length;\n        if (u === \"x\" && v === \"y\" || u === \"y\" && v === \"x\") w = \"z\";\n        else if (u === \"x\" && v === \"z\" || u === \"z\" && v === \"x\") {\n            w = \"y\";\n            gridY = scope.depthSegments;\n        } else if (u === \"z\" && v === \"y\" || u === \"y\" && v === \"z\") {\n            w = \"x\";\n            gridX = scope.depthSegments;\n        }\n        var gridX1 = gridX + 1, gridY1 = gridY + 1, segment_width = width / gridX, segment_height = height / gridY, normal = new THREE.Vector3();\n        normal[w] = depth > 0 ? 1 : -1;\n        for(iy = 0; iy < gridY1; iy++)for(ix = 0; ix < gridX1; ix++){\n            var vector = new THREE.Vector3();\n            vector[u] = (ix * segment_width - width_half) * udir;\n            vector[v] = (iy * segment_height - height_half) * vdir;\n            vector[w] = depth;\n            scope.vertices.push(vector);\n        }\n        for(iy = 0; iy < gridY; iy++)for(ix = 0; ix < gridX; ix++){\n            var a = ix + gridX1 * iy;\n            var b = ix + gridX1 * (iy + 1);\n            var c = ix + 1 + gridX1 * (iy + 1);\n            var d = ix + 1 + gridX1 * iy;\n            var face = new THREE.Face4(a + offset, b + offset, c + offset, d + offset);\n            face.normal.copy(normal);\n            face.vertexNormals.push(normal.clone(), normal.clone(), normal.clone(), normal.clone());\n            face.materialIndex = materialIndex;\n            scope.faces.push(face);\n            scope.faceVertexUvs[0].push([\n                new THREE.Vector2(ix / gridX, 1 - iy / gridY),\n                new THREE.Vector2(ix / gridX, 1 - (iy + 1) / gridY),\n                new THREE.Vector2((ix + 1) / gridX, 1 - (iy + 1) / gridY),\n                new THREE.Vector2((ix + 1) / gridX, 1 - iy / gridY)\n            ]);\n        }\n    }\n    this.computeCentroids();\n    this.mergeVertices();\n};\nTHREE.CubeGeometry.prototype = Object.create(THREE.Geometry.prototype);\n/**\n * @author mrdoob / http://mrdoob.com/\n */ THREE.CylinderGeometry = function(radiusTop, radiusBottom, height, radiusSegments, heightSegments, openEnded) {\n    THREE.Geometry.call(this);\n    radiusTop = radiusTop !== undefined ? radiusTop : 20;\n    radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;\n    height = height !== undefined ? height : 100;\n    var heightHalf = height / 2;\n    var segmentsX = radiusSegments || 8;\n    var segmentsY = heightSegments || 1;\n    var x, y, vertices = [], uvs = [];\n    for(y = 0; y <= segmentsY; y++){\n        var verticesRow = [];\n        var uvsRow = [];\n        var v = y / segmentsY;\n        var radius = v * (radiusBottom - radiusTop) + radiusTop;\n        for(x = 0; x <= segmentsX; x++){\n            var u = x / segmentsX;\n            var vertex = new THREE.Vector3();\n            vertex.x = radius * Math.sin(u * Math.PI * 2);\n            vertex.y = -v * height + heightHalf;\n            vertex.z = radius * Math.cos(u * Math.PI * 2);\n            this.vertices.push(vertex);\n            verticesRow.push(this.vertices.length - 1);\n            uvsRow.push(new THREE.Vector2(u, 1 - v));\n        }\n        vertices.push(verticesRow);\n        uvs.push(uvsRow);\n    }\n    var tanTheta = (radiusBottom - radiusTop) / height;\n    var na, nb;\n    for(x = 0; x < segmentsX; x++){\n        if (radiusTop !== 0) {\n            na = this.vertices[vertices[0][x]].clone();\n            nb = this.vertices[vertices[0][x + 1]].clone();\n        } else {\n            na = this.vertices[vertices[1][x]].clone();\n            nb = this.vertices[vertices[1][x + 1]].clone();\n        }\n        na.setY(Math.sqrt(na.x * na.x + na.z * na.z) * tanTheta).normalize();\n        nb.setY(Math.sqrt(nb.x * nb.x + nb.z * nb.z) * tanTheta).normalize();\n        for(y = 0; y < segmentsY; y++){\n            var v1 = vertices[y][x];\n            var v2 = vertices[y + 1][x];\n            var v3 = vertices[y + 1][x + 1];\n            var v4 = vertices[y][x + 1];\n            var n1 = na.clone();\n            var n2 = na.clone();\n            var n3 = nb.clone();\n            var n4 = nb.clone();\n            var uv1 = uvs[y][x].clone();\n            var uv2 = uvs[y + 1][x].clone();\n            var uv3 = uvs[y + 1][x + 1].clone();\n            var uv4 = uvs[y][x + 1].clone();\n            this.faces.push(new THREE.Face4(v1, v2, v3, v4, [\n                n1,\n                n2,\n                n3,\n                n4\n            ]));\n            this.faceVertexUvs[0].push([\n                uv1,\n                uv2,\n                uv3,\n                uv4\n            ]);\n        }\n    }\n    // top cap\n    if (!openEnded && radiusTop > 0) {\n        this.vertices.push(new THREE.Vector3(0, heightHalf, 0));\n        for(x = 0; x < segmentsX; x++){\n            var v1 = vertices[0][x];\n            var v2 = vertices[0][x + 1];\n            var v3 = this.vertices.length - 1;\n            var n1 = new THREE.Vector3(0, 1, 0);\n            var n2 = new THREE.Vector3(0, 1, 0);\n            var n3 = new THREE.Vector3(0, 1, 0);\n            var uv1 = uvs[0][x].clone();\n            var uv2 = uvs[0][x + 1].clone();\n            var uv3 = new THREE.Vector2(uv2.u, 0);\n            this.faces.push(new THREE.Face3(v1, v2, v3, [\n                n1,\n                n2,\n                n3\n            ]));\n            this.faceVertexUvs[0].push([\n                uv1,\n                uv2,\n                uv3\n            ]);\n        }\n    }\n    // bottom cap\n    if (!openEnded && radiusBottom > 0) {\n        this.vertices.push(new THREE.Vector3(0, -heightHalf, 0));\n        for(x = 0; x < segmentsX; x++){\n            var v1 = vertices[y][x + 1];\n            var v2 = vertices[y][x];\n            var v3 = this.vertices.length - 1;\n            var n1 = new THREE.Vector3(0, -1, 0);\n            var n2 = new THREE.Vector3(0, -1, 0);\n            var n3 = new THREE.Vector3(0, -1, 0);\n            var uv1 = uvs[y][x + 1].clone();\n            var uv2 = uvs[y][x].clone();\n            var uv3 = new THREE.Vector2(uv2.u, 1);\n            this.faces.push(new THREE.Face3(v1, v2, v3, [\n                n1,\n                n2,\n                n3\n            ]));\n            this.faceVertexUvs[0].push([\n                uv1,\n                uv2,\n                uv3\n            ]);\n        }\n    }\n    this.computeCentroids();\n    this.computeFaceNormals();\n};\nTHREE.CylinderGeometry.prototype = Object.create(THREE.Geometry.prototype);\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n *\n * Creates extruded geometry from a path shape.\n *\n * parameters = {\n *\n *  size: <float>, // size of the text\n *  height: <float>, // thickness to extrude text\n *  curveSegments: <int>, // number of points on the curves\n *  steps: <int>, // number of points for z-side extrusions / used for subdividing segements of extrude spline too\n *  amount: <int>, // Amount\n *\n *  bevelEnabled: <bool>, // turn on bevel\n *  bevelThickness: <float>, // how deep into text bevel goes\n *  bevelSize: <float>, // how far from text outline is bevel\n *  bevelSegments: <int>, // number of bevel layers\n *\n *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)\n *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals\n *\n *  material: <int> // material index for front and back faces\n *  extrudeMaterial: <int> // material index for extrusion and beveled faces\n *  uvGenerator: <Object> // object that provides UV generator functions\n *\n * }\n **/ THREE.ExtrudeGeometry = function(shapes, options) {\n    if (typeof shapes === \"undefined\") {\n        shapes = [];\n        return;\n    }\n    THREE.Geometry.call(this);\n    shapes = shapes instanceof Array ? shapes : [\n        shapes\n    ];\n    this.shapebb = shapes[shapes.length - 1].getBoundingBox();\n    this.addShapeList(shapes, options);\n    this.computeCentroids();\n    this.computeFaceNormals();\n// can't really use automatic vertex normals\n// as then front and back sides get smoothed too\n// should do separate smoothing just for sides\n//this.computeVertexNormals();\n//console.log( \"took\", ( Date.now() - startTime ) );\n};\nTHREE.ExtrudeGeometry.prototype = Object.create(THREE.Geometry.prototype);\nTHREE.ExtrudeGeometry.prototype.addShapeList = function(shapes, options) {\n    var sl = shapes.length;\n    for(var s = 0; s < sl; s++){\n        var shape = shapes[s];\n        this.addShape(shape, options);\n    }\n};\nTHREE.ExtrudeGeometry.prototype.addShape = function(shape, options) {\n    var amount = options.amount !== undefined ? options.amount : 100;\n    var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10\n    var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8\n    var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\n    var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false\n    var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n    var steps = options.steps !== undefined ? options.steps : 1;\n    var extrudePath = options.extrudePath;\n    var extrudePts, extrudeByPath = false;\n    var material = options.material;\n    var extrudeMaterial = options.extrudeMaterial;\n    // Use default WorldUVGenerator if no UV generators are specified.\n    var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;\n    var shapebb = this.shapebb;\n    //shapebb = shape.getBoundingBox();\n    var splineTube, binormal, normal, position2;\n    if (extrudePath) {\n        extrudePts = extrudePath.getSpacedPoints(steps);\n        extrudeByPath = true;\n        bevelEnabled = false; // bevels not supported for path extrusion\n        // SETUP TNB variables\n        // Reuse TNB from TubeGeomtry for now.\n        // TODO1 - have a .isClosed in spline?\n        splineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames(extrudePath, steps, false);\n        // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\n        binormal = new THREE.Vector3();\n        normal = new THREE.Vector3();\n        position2 = new THREE.Vector3();\n    }\n    // Safeguards if bevels are not enabled\n    if (!bevelEnabled) {\n        bevelSegments = 0;\n        bevelThickness = 0;\n        bevelSize = 0;\n    }\n    // Variables initalization\n    var ahole, h, hl; // looping of holes\n    var scope = this;\n    var bevelPoints = [];\n    var shapesOffset = this.vertices.length;\n    var shapePoints = shape.extractPoints(curveSegments);\n    var vertices = shapePoints.shape;\n    var holes = shapePoints.holes;\n    var reverse = !THREE.Shape.Utils.isClockWise(vertices);\n    if (reverse) {\n        vertices = vertices.reverse();\n        // Maybe we should also check if holes are in the opposite direction, just to be safe ...\n        for(h = 0, hl = holes.length; h < hl; h++){\n            ahole = holes[h];\n            if (THREE.Shape.Utils.isClockWise(ahole)) holes[h] = ahole.reverse();\n        }\n        reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!\n    }\n    var faces = THREE.Shape.Utils.triangulateShape(vertices, holes);\n    /* Vertices */ var contour = vertices; // vertices has all points but contour has only points of circumference\n    for(h = 0, hl = holes.length; h < hl; h++){\n        ahole = holes[h];\n        vertices = vertices.concat(ahole);\n    }\n    function scalePt2(pt, vec, size) {\n        if (!vec) console.log(\"die\");\n        return vec.clone().multiplyScalar(size).add(pt);\n    }\n    var b, bs, t, z, vert, vlen = vertices.length, face, flen = faces.length, cont, clen = contour.length;\n    // Find directions for point movement\n    var RAD_TO_DEGREES = 180 / Math.PI;\n    function getBevelVec(pt_i, pt_j, pt_k) {\n        // Algorithm 2\n        return getBevelVec2(pt_i, pt_j, pt_k);\n    }\n    function getBevelVec1(pt_i, pt_j, pt_k) {\n        var anglea = Math.atan2(pt_j.y - pt_i.y, pt_j.x - pt_i.x);\n        var angleb = Math.atan2(pt_k.y - pt_i.y, pt_k.x - pt_i.x);\n        if (anglea > angleb) angleb += Math.PI * 2;\n        var anglec = (anglea + angleb) / 2;\n        //console.log('angle1', anglea * RAD_TO_DEGREES,'angle2', angleb * RAD_TO_DEGREES, 'anglec', anglec *RAD_TO_DEGREES);\n        var x = -Math.cos(anglec);\n        var y = -Math.sin(anglec);\n        var vec = new THREE.Vector2(x, y); //.normalize();\n        return vec;\n    }\n    function getBevelVec2(pt_i, pt_j, pt_k) {\n        var a = THREE.ExtrudeGeometry.__v1, b = THREE.ExtrudeGeometry.__v2, v_hat = THREE.ExtrudeGeometry.__v3, w_hat = THREE.ExtrudeGeometry.__v4, p = THREE.ExtrudeGeometry.__v5, q = THREE.ExtrudeGeometry.__v6, v, w, v_dot_w_hat, q_sub_p_dot_w_hat, s, intersection;\n        // good reading for line-line intersection\n        // http://sputsoft.com/blog/2010/03/line-line-intersection.html\n        // define a as vector j->i\n        // define b as vectot k->i\n        a.set(pt_i.x - pt_j.x, pt_i.y - pt_j.y);\n        b.set(pt_i.x - pt_k.x, pt_i.y - pt_k.y);\n        // get unit vectors\n        v = a.normalize();\n        w = b.normalize();\n        // normals from pt i\n        v_hat.set(-v.y, v.x);\n        w_hat.set(w.y, -w.x);\n        // pts from i\n        p.copy(pt_i).add(v_hat);\n        q.copy(pt_i).add(w_hat);\n        if (p.equals(q)) //console.log(\"Warning: lines are straight\");\n        return w_hat.clone();\n        // Points from j, k. helps prevents points cross overover most of the time\n        p.copy(pt_j).add(v_hat);\n        q.copy(pt_k).add(w_hat);\n        v_dot_w_hat = v.dot(w_hat);\n        q_sub_p_dot_w_hat = q.sub(p).dot(w_hat);\n        // We should not reach these conditions\n        if (v_dot_w_hat === 0) {\n            console.log(\"Either infinite or no solutions!\");\n            if (q_sub_p_dot_w_hat === 0) console.log(\"Its finite solutions.\");\n            else console.log(\"Too bad, no solutions.\");\n        }\n        s = q_sub_p_dot_w_hat / v_dot_w_hat;\n        if (s < 0) // in case of emergecy, revert to algorithm 1.\n        return getBevelVec1(pt_i, pt_j, pt_k);\n        intersection = v.multiplyScalar(s).add(p);\n        return intersection.sub(pt_i).clone(); // Don't normalize!, otherwise sharp corners become ugly\n    }\n    var contourMovements = [];\n    for(var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++){\n        if (j === il) j = 0;\n        if (k === il) k = 0;\n        //  (j)---(i)---(k)\n        // console.log('i,j,k', i, j , k)\n        var pt_i = contour[i];\n        var pt_j = contour[j];\n        var pt_k = contour[k];\n        contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);\n    }\n    var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();\n    for(h = 0, hl = holes.length; h < hl; h++){\n        ahole = holes[h];\n        oneHoleMovements = [];\n        for(i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++){\n            if (j === il) j = 0;\n            if (k === il) k = 0;\n            //  (j)---(i)---(k)\n            oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);\n        }\n        holesMovements.push(oneHoleMovements);\n        verticesMovements = verticesMovements.concat(oneHoleMovements);\n    }\n    // Loop bevelSegments, 1 for the front, 1 for the back\n    for(b = 0; b < bevelSegments; b++){\n        //for ( b = bevelSegments; b > 0; b -- ) {\n        t = b / bevelSegments;\n        z = bevelThickness * (1 - t);\n        //z = bevelThickness * t;\n        bs = bevelSize * Math.sin(t * Math.PI / 2); // curved\n        //bs = bevelSize * t ; // linear\n        // contract shape\n        for(i = 0, il = contour.length; i < il; i++){\n            vert = scalePt2(contour[i], contourMovements[i], bs);\n            //vert = scalePt( contour[ i ], contourCentroid, bs, false );\n            v(vert.x, vert.y, -z);\n        }\n        // expand holes\n        for(h = 0, hl = holes.length; h < hl; h++){\n            ahole = holes[h];\n            oneHoleMovements = holesMovements[h];\n            for(i = 0, il = ahole.length; i < il; i++){\n                vert = scalePt2(ahole[i], oneHoleMovements[i], bs);\n                //vert = scalePt( ahole[ i ], holesCentroids[ h ], bs, true );\n                v(vert.x, vert.y, -z);\n            }\n        }\n    }\n    bs = bevelSize;\n    // Back facing vertices\n    for(i = 0; i < vlen; i++){\n        vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];\n        if (!extrudeByPath) v(vert.x, vert.y, 0);\n        else {\n            // v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\n            normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);\n            binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);\n            position2.copy(extrudePts[0]).add(normal).add(binormal);\n            v(position2.x, position2.y, position2.z);\n        }\n    }\n    // Add stepped vertices...\n    // Including front facing vertices\n    var s;\n    for(s = 1; s <= steps; s++)for(i = 0; i < vlen; i++){\n        vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];\n        if (!extrudeByPath) v(vert.x, vert.y, amount / steps * s);\n        else {\n            // v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\n            normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);\n            binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);\n            position2.copy(extrudePts[s]).add(normal).add(binormal);\n            v(position2.x, position2.y, position2.z);\n        }\n    }\n    // Add bevel segments planes\n    //for ( b = 1; b <= bevelSegments; b ++ ) {\n    for(b = bevelSegments - 1; b >= 0; b--){\n        t = b / bevelSegments;\n        z = bevelThickness * (1 - t);\n        //bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );\n        bs = bevelSize * Math.sin(t * Math.PI / 2);\n        // contract shape\n        for(i = 0, il = contour.length; i < il; i++){\n            vert = scalePt2(contour[i], contourMovements[i], bs);\n            v(vert.x, vert.y, amount + z);\n        }\n        // expand holes\n        for(h = 0, hl = holes.length; h < hl; h++){\n            ahole = holes[h];\n            oneHoleMovements = holesMovements[h];\n            for(i = 0, il = ahole.length; i < il; i++){\n                vert = scalePt2(ahole[i], oneHoleMovements[i], bs);\n                if (!extrudeByPath) v(vert.x, vert.y, amount + z);\n                else v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);\n            }\n        }\n    }\n    /* Faces */ // Top and bottom faces\n    buildLidFaces();\n    // Sides faces\n    buildSideFaces();\n    /////  Internal functions\n    function buildLidFaces() {\n        if (bevelEnabled) {\n            var layer = 0; // steps + 1\n            var offset = vlen * layer;\n            // Bottom faces\n            for(i = 0; i < flen; i++){\n                face = faces[i];\n                f3(face[2] + offset, face[1] + offset, face[0] + offset, true);\n            }\n            layer = steps + bevelSegments * 2;\n            offset = vlen * layer;\n            // Top faces\n            for(i = 0; i < flen; i++){\n                face = faces[i];\n                f3(face[0] + offset, face[1] + offset, face[2] + offset, false);\n            }\n        } else {\n            // Bottom faces\n            for(i = 0; i < flen; i++){\n                face = faces[i];\n                f3(face[2], face[1], face[0], true);\n            }\n            // Top faces\n            for(i = 0; i < flen; i++){\n                face = faces[i];\n                f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps, false);\n            }\n        }\n    }\n    // Create faces for the z-sides of the shape\n    function buildSideFaces() {\n        var layeroffset = 0;\n        sidewalls(contour, layeroffset);\n        layeroffset += contour.length;\n        for(h = 0, hl = holes.length; h < hl; h++){\n            ahole = holes[h];\n            sidewalls(ahole, layeroffset);\n            //, true\n            layeroffset += ahole.length;\n        }\n    }\n    function sidewalls(contour, layeroffset) {\n        var j, k;\n        i = contour.length;\n        while(--i >= 0){\n            j = i;\n            k = i - 1;\n            if (k < 0) k = contour.length - 1;\n            //console.log('b', i,j, i-1, k,vertices.length);\n            var s = 0, sl = steps + bevelSegments * 2;\n            for(s = 0; s < sl; s++){\n                var slen1 = vlen * s;\n                var slen2 = vlen * (s + 1);\n                var a = layeroffset + j + slen1, b = layeroffset + k + slen1, c = layeroffset + k + slen2, d = layeroffset + j + slen2;\n                f4(a, b, c, d, contour, s, sl, j, k);\n            }\n        }\n    }\n    function v(x, y, z) {\n        scope.vertices.push(new THREE.Vector3(x, y, z));\n    }\n    function f3(a, b, c, isBottom) {\n        a += shapesOffset;\n        b += shapesOffset;\n        c += shapesOffset;\n        // normal, color, material\n        scope.faces.push(new THREE.Face3(a, b, c, null, null, material));\n        var uvs = isBottom ? uvgen.generateBottomUV(scope, shape, options, a, b, c) : uvgen.generateTopUV(scope, shape, options, a, b, c);\n        scope.faceVertexUvs[0].push(uvs);\n    }\n    function f4(a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2) {\n        a += shapesOffset;\n        b += shapesOffset;\n        c += shapesOffset;\n        d += shapesOffset;\n        scope.faces.push(new THREE.Face4(a, b, c, d, null, null, extrudeMaterial));\n        var uvs = uvgen.generateSideWallUV(scope, shape, wallContour, options, a, b, c, d, stepIndex, stepsLength, contourIndex1, contourIndex2);\n        scope.faceVertexUvs[0].push(uvs);\n    }\n};\nTHREE.ExtrudeGeometry.WorldUVGenerator = {\n    generateTopUV: function(geometry, extrudedShape, extrudeOptions, indexA, indexB, indexC) {\n        var ax = geometry.vertices[indexA].x, ay = geometry.vertices[indexA].y, bx = geometry.vertices[indexB].x, by = geometry.vertices[indexB].y, cx = geometry.vertices[indexC].x, cy = geometry.vertices[indexC].y;\n        return [\n            new THREE.Vector2(ax, ay),\n            new THREE.Vector2(bx, by),\n            new THREE.Vector2(cx, cy)\n        ];\n    },\n    generateBottomUV: function(geometry, extrudedShape, extrudeOptions, indexA, indexB, indexC) {\n        return this.generateTopUV(geometry, extrudedShape, extrudeOptions, indexA, indexB, indexC);\n    },\n    generateSideWallUV: function(geometry, extrudedShape, wallContour, extrudeOptions, indexA, indexB, indexC, indexD, stepIndex, stepsLength, contourIndex1, contourIndex2) {\n        var ax = geometry.vertices[indexA].x, ay = geometry.vertices[indexA].y, az = geometry.vertices[indexA].z, bx = geometry.vertices[indexB].x, by = geometry.vertices[indexB].y, bz = geometry.vertices[indexB].z, cx = geometry.vertices[indexC].x, cy = geometry.vertices[indexC].y, cz = geometry.vertices[indexC].z, dx = geometry.vertices[indexD].x, dy = geometry.vertices[indexD].y, dz = geometry.vertices[indexD].z;\n        if (Math.abs(ay - by) < 0.01) return [\n            new THREE.Vector2(ax, 1 - az),\n            new THREE.Vector2(bx, 1 - bz),\n            new THREE.Vector2(cx, 1 - cz),\n            new THREE.Vector2(dx, 1 - dz)\n        ];\n        else return [\n            new THREE.Vector2(ay, 1 - az),\n            new THREE.Vector2(by, 1 - bz),\n            new THREE.Vector2(cy, 1 - cz),\n            new THREE.Vector2(dy, 1 - dz)\n        ];\n    }\n};\nTHREE.ExtrudeGeometry.__v1 = new THREE.Vector2();\nTHREE.ExtrudeGeometry.__v2 = new THREE.Vector2();\nTHREE.ExtrudeGeometry.__v3 = new THREE.Vector2();\nTHREE.ExtrudeGeometry.__v4 = new THREE.Vector2();\nTHREE.ExtrudeGeometry.__v5 = new THREE.Vector2();\nTHREE.ExtrudeGeometry.__v6 = new THREE.Vector2();\n/**\n * @author jonobr1 / http://jonobr1.com\n *\n * Creates a one-sided polygonal geometry from a path shape. Similar to\n * ExtrudeGeometry.\n *\n * parameters = {\n *\n *\tcurveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.\n *\n *\tmaterial: <int> // material index for front and back faces\n *\tuvGenerator: <Object> // object that provides UV generator functions\n *\n * }\n **/ THREE.ShapeGeometry = function(shapes, options) {\n    THREE.Geometry.call(this);\n    if (shapes instanceof Array === false) shapes = [\n        shapes\n    ];\n    this.shapebb = shapes[shapes.length - 1].getBoundingBox();\n    this.addShapeList(shapes, options);\n    this.computeCentroids();\n    this.computeFaceNormals();\n};\nTHREE.ShapeGeometry.prototype = Object.create(THREE.Geometry.prototype);\n/**\n * Add an array of shapes to THREE.ShapeGeometry.\n */ THREE.ShapeGeometry.prototype.addShapeList = function(shapes, options) {\n    for(var i = 0, l = shapes.length; i < l; i++)this.addShape(shapes[i], options);\n    return this;\n};\n/**\n * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.\n */ THREE.ShapeGeometry.prototype.addShape = function(shape, options) {\n    if (options === undefined) options = {};\n    var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n    var material = options.material;\n    var uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;\n    var shapebb = this.shapebb;\n    //\n    var i, l, hole, s;\n    var shapesOffset = this.vertices.length;\n    var shapePoints = shape.extractPoints(curveSegments);\n    var vertices = shapePoints.shape;\n    var holes = shapePoints.holes;\n    var reverse = !THREE.Shape.Utils.isClockWise(vertices);\n    if (reverse) {\n        vertices = vertices.reverse();\n        // Maybe we should also check if holes are in the opposite direction, just to be safe...\n        for(i = 0, l = holes.length; i < l; i++){\n            hole = holes[i];\n            if (THREE.Shape.Utils.isClockWise(hole)) holes[i] = hole.reverse();\n        }\n        reverse = false;\n    }\n    var faces = THREE.Shape.Utils.triangulateShape(vertices, holes);\n    // Vertices\n    var contour = vertices;\n    for(i = 0, l = holes.length; i < l; i++){\n        hole = holes[i];\n        vertices = vertices.concat(hole);\n    }\n    //\n    var vert, vlen = vertices.length;\n    var face, flen = faces.length;\n    var cont, clen = contour.length;\n    for(i = 0; i < vlen; i++){\n        vert = vertices[i];\n        this.vertices.push(new THREE.Vector3(vert.x, vert.y, 0));\n    }\n    for(i = 0; i < flen; i++){\n        face = faces[i];\n        var a = face[0] + shapesOffset;\n        var b = face[1] + shapesOffset;\n        var c = face[2] + shapesOffset;\n        this.faces.push(new THREE.Face3(a, b, c, null, null, material));\n        this.faceVertexUvs[0].push(uvgen.generateBottomUV(this, shape, options, a, b, c));\n    }\n};\n/**\n * @author astrodud / http://astrodud.isgreat.org/\n * @author zz85 / https://github.com/zz85\n * @author bhouston / http://exocortex.com\n */ // points - to create a closed torus, one must use a set of points \n//    like so: [ a, b, c, d, a ], see first is the same as last.\n// segments - the number of circumference segments to create\n// phiStart - the starting radian\n// phiLength - the radian (0 to 2*PI) range of the lathed section\n//    2*pi is a closed lathe, less than 2PI is a portion.\nTHREE.LatheGeometry = function(points, segments, phiStart, phiLength) {\n    THREE.Geometry.call(this);\n    segments = segments || 12;\n    phiStart = phiStart || 0;\n    phiLength = phiLength || 2 * Math.PI;\n    var inversePointLength = 1.0 / (points.length - 1);\n    var inverseSegments = 1.0 / segments;\n    for(var i = 0, il = segments; i <= il; i++){\n        var phi = phiStart + i * inverseSegments * phiLength;\n        var c = Math.cos(phi), s = Math.sin(phi);\n        for(var j = 0, jl = points.length; j < jl; j++){\n            var pt = points[j];\n            var vertex = new THREE.Vector3();\n            vertex.x = c * pt.x - s * pt.y;\n            vertex.y = s * pt.x + c * pt.y;\n            vertex.z = pt.z;\n            this.vertices.push(vertex);\n        }\n    }\n    var np = points.length;\n    for(var i = 0, il = segments; i < il; i++)for(var j = 0, jl = points.length - 1; j < jl; j++){\n        var base = j + np * i;\n        var a = base;\n        var b = base + np;\n        var c = base + 1 + np;\n        var d = base + 1;\n        this.faces.push(new THREE.Face4(a, b, c, d));\n        var u0 = i * inverseSegments;\n        var v0 = j * inversePointLength;\n        var u1 = u0 + inverseSegments;\n        var v1 = v0 + inversePointLength;\n        this.faceVertexUvs[0].push([\n            new THREE.Vector2(u0, v0),\n            new THREE.Vector2(u1, v0),\n            new THREE.Vector2(u1, v1),\n            new THREE.Vector2(u0, v1)\n        ]);\n    }\n    this.mergeVertices();\n    this.computeCentroids();\n    this.computeFaceNormals();\n    this.computeVertexNormals();\n};\nTHREE.LatheGeometry.prototype = Object.create(THREE.Geometry.prototype);\n/**\n * @author mrdoob / http://mrdoob.com/\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\n */ THREE.PlaneGeometry = function(width, height, widthSegments, heightSegments) {\n    THREE.Geometry.call(this);\n    this.width = width;\n    this.height = height;\n    this.widthSegments = widthSegments || 1;\n    this.heightSegments = heightSegments || 1;\n    var ix, iz;\n    var width_half = width / 2;\n    var height_half = height / 2;\n    var gridX = this.widthSegments;\n    var gridZ = this.heightSegments;\n    var gridX1 = gridX + 1;\n    var gridZ1 = gridZ + 1;\n    var segment_width = this.width / gridX;\n    var segment_height = this.height / gridZ;\n    var normal = new THREE.Vector3(0, 0, 1);\n    for(iz = 0; iz < gridZ1; iz++)for(ix = 0; ix < gridX1; ix++){\n        var x = ix * segment_width - width_half;\n        var y = iz * segment_height - height_half;\n        this.vertices.push(new THREE.Vector3(x, -y, 0));\n    }\n    for(iz = 0; iz < gridZ; iz++)for(ix = 0; ix < gridX; ix++){\n        var a = ix + gridX1 * iz;\n        var b = ix + gridX1 * (iz + 1);\n        var c = ix + 1 + gridX1 * (iz + 1);\n        var d = ix + 1 + gridX1 * iz;\n        var face = new THREE.Face4(a, b, c, d);\n        face.normal.copy(normal);\n        face.vertexNormals.push(normal.clone(), normal.clone(), normal.clone(), normal.clone());\n        this.faces.push(face);\n        this.faceVertexUvs[0].push([\n            new THREE.Vector2(ix / gridX, 1 - iz / gridZ),\n            new THREE.Vector2(ix / gridX, 1 - (iz + 1) / gridZ),\n            new THREE.Vector2((ix + 1) / gridX, 1 - (iz + 1) / gridZ),\n            new THREE.Vector2((ix + 1) / gridX, 1 - iz / gridZ)\n        ]);\n    }\n    this.computeCentroids();\n};\nTHREE.PlaneGeometry.prototype = Object.create(THREE.Geometry.prototype);\n/**\n * @author mrdoob / http://mrdoob.com/\n */ THREE.SphereGeometry = function(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {\n    THREE.Geometry.call(this);\n    this.radius = radius || 50;\n    this.widthSegments = Math.max(3, Math.floor(widthSegments) || 8);\n    this.heightSegments = Math.max(2, Math.floor(heightSegments) || 6);\n    phiStart = phiStart !== undefined ? phiStart : 0;\n    phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;\n    thetaStart = thetaStart !== undefined ? thetaStart : 0;\n    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;\n    var x, y, vertices = [], uvs = [];\n    for(y = 0; y <= this.heightSegments; y++){\n        var verticesRow = [];\n        var uvsRow = [];\n        for(x = 0; x <= this.widthSegments; x++){\n            var u = x / this.widthSegments;\n            var v = y / this.heightSegments;\n            var vertex = new THREE.Vector3();\n            vertex.x = -this.radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);\n            vertex.y = this.radius * Math.cos(thetaStart + v * thetaLength);\n            vertex.z = this.radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);\n            this.vertices.push(vertex);\n            verticesRow.push(this.vertices.length - 1);\n            uvsRow.push(new THREE.Vector2(u, 1 - v));\n        }\n        vertices.push(verticesRow);\n        uvs.push(uvsRow);\n    }\n    for(y = 0; y < this.heightSegments; y++)for(x = 0; x < this.widthSegments; x++){\n        var v1 = vertices[y][x + 1];\n        var v2 = vertices[y][x];\n        var v3 = vertices[y + 1][x];\n        var v4 = vertices[y + 1][x + 1];\n        var n1 = this.vertices[v1].clone().normalize();\n        var n2 = this.vertices[v2].clone().normalize();\n        var n3 = this.vertices[v3].clone().normalize();\n        var n4 = this.vertices[v4].clone().normalize();\n        var uv1 = uvs[y][x + 1].clone();\n        var uv2 = uvs[y][x].clone();\n        var uv3 = uvs[y + 1][x].clone();\n        var uv4 = uvs[y + 1][x + 1].clone();\n        if (Math.abs(this.vertices[v1].y) === this.radius) {\n            this.faces.push(new THREE.Face3(v1, v3, v4, [\n                n1,\n                n3,\n                n4\n            ]));\n            this.faceVertexUvs[0].push([\n                uv1,\n                uv3,\n                uv4\n            ]);\n        } else if (Math.abs(this.vertices[v3].y) === this.radius) {\n            this.faces.push(new THREE.Face3(v1, v2, v3, [\n                n1,\n                n2,\n                n3\n            ]));\n            this.faceVertexUvs[0].push([\n                uv1,\n                uv2,\n                uv3\n            ]);\n        } else {\n            this.faces.push(new THREE.Face4(v1, v2, v3, v4, [\n                n1,\n                n2,\n                n3,\n                n4\n            ]));\n            this.faceVertexUvs[0].push([\n                uv1,\n                uv2,\n                uv3,\n                uv4\n            ]);\n        }\n    }\n    this.computeCentroids();\n    this.computeFaceNormals();\n    this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius);\n};\nTHREE.SphereGeometry.prototype = Object.create(THREE.Geometry.prototype);\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * @author alteredq / http://alteredqualia.com/\n *\n * For creating 3D text geometry in three.js\n *\n * Text = 3D Text\n *\n * parameters = {\n *  size: \t\t\t<float>, \t// size of the text\n *  height: \t\t<float>, \t// thickness to extrude text\n *  curveSegments: \t<int>,\t\t// number of points on the curves\n *\n *  font: \t\t\t<string>,\t\t// font name\n *  weight: \t\t<string>,\t\t// font weight (normal, bold)\n *  style: \t\t\t<string>,\t\t// font style  (normal, italics)\n *\n *  bevelEnabled:\t<bool>,\t\t\t// turn on bevel\n *  bevelThickness: <float>, \t\t// how deep into text bevel goes\n *  bevelSize:\t\t<float>, \t\t// how far from text outline is bevel\n *  }\n *\n */ /*\tUsage Examples\n\n\t// TextGeometry wrapper\n\n\tvar text3d = new TextGeometry( text, options );\n\n\t// Complete manner\n\n\tvar textShapes = THREE.FontUtils.generateShapes( text, options );\n\tvar text3d = new ExtrudeGeometry( textShapes, options );\n\n*/ THREE.TextGeometry = function(text, parameters) {\n    var textShapes = THREE.FontUtils.generateShapes(text, parameters);\n    // translate parameters to ExtrudeGeometry API\n    parameters.amount = parameters.height !== undefined ? parameters.height : 50;\n    // defaults\n    if (parameters.bevelThickness === undefined) parameters.bevelThickness = 10;\n    if (parameters.bevelSize === undefined) parameters.bevelSize = 8;\n    if (parameters.bevelEnabled === undefined) parameters.bevelEnabled = false;\n    THREE.ExtrudeGeometry.call(this, textShapes, parameters);\n};\nTHREE.TextGeometry.prototype = Object.create(THREE.ExtrudeGeometry.prototype);\n/**\n * @author oosmoxiecode\n * @author mrdoob / http://mrdoob.com/\n * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888\n */ THREE.TorusGeometry = function(radius, tube, radialSegments, tubularSegments, arc) {\n    THREE.Geometry.call(this);\n    var scope = this;\n    this.radius = radius || 100;\n    this.tube = tube || 40;\n    this.radialSegments = radialSegments || 8;\n    this.tubularSegments = tubularSegments || 6;\n    this.arc = arc || Math.PI * 2;\n    var center = new THREE.Vector3(), uvs = [], normals = [];\n    for(var j = 0; j <= this.radialSegments; j++)for(var i = 0; i <= this.tubularSegments; i++){\n        var u = i / this.tubularSegments * this.arc;\n        var v = j / this.radialSegments * Math.PI * 2;\n        center.x = this.radius * Math.cos(u);\n        center.y = this.radius * Math.sin(u);\n        var vertex = new THREE.Vector3();\n        vertex.x = (this.radius + this.tube * Math.cos(v)) * Math.cos(u);\n        vertex.y = (this.radius + this.tube * Math.cos(v)) * Math.sin(u);\n        vertex.z = this.tube * Math.sin(v);\n        this.vertices.push(vertex);\n        uvs.push(new THREE.Vector2(i / this.tubularSegments, j / this.radialSegments));\n        normals.push(vertex.clone().sub(center).normalize());\n    }\n    for(var j = 1; j <= this.radialSegments; j++)for(var i = 1; i <= this.tubularSegments; i++){\n        var a = (this.tubularSegments + 1) * j + i - 1;\n        var b = (this.tubularSegments + 1) * (j - 1) + i - 1;\n        var c = (this.tubularSegments + 1) * (j - 1) + i;\n        var d = (this.tubularSegments + 1) * j + i;\n        var face = new THREE.Face4(a, b, c, d, [\n            normals[a],\n            normals[b],\n            normals[c],\n            normals[d]\n        ]);\n        face.normal.add(normals[a]);\n        face.normal.add(normals[b]);\n        face.normal.add(normals[c]);\n        face.normal.add(normals[d]);\n        face.normal.normalize();\n        this.faces.push(face);\n        this.faceVertexUvs[0].push([\n            uvs[a].clone(),\n            uvs[b].clone(),\n            uvs[c].clone(),\n            uvs[d].clone()\n        ]);\n    }\n    this.computeCentroids();\n};\nTHREE.TorusGeometry.prototype = Object.create(THREE.Geometry.prototype);\n/**\n * @author oosmoxiecode\n * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473\n */ THREE.TorusKnotGeometry = function(radius, tube, radialSegments, tubularSegments, p, q, heightScale) {\n    THREE.Geometry.call(this);\n    var scope = this;\n    this.radius = radius || 100;\n    this.tube = tube || 40;\n    this.radialSegments = radialSegments || 64;\n    this.tubularSegments = tubularSegments || 8;\n    this.p = p || 2;\n    this.q = q || 3;\n    this.heightScale = heightScale || 1;\n    this.grid = new Array(this.radialSegments);\n    var tang = new THREE.Vector3();\n    var n = new THREE.Vector3();\n    var bitan = new THREE.Vector3();\n    for(var i = 0; i < this.radialSegments; ++i){\n        this.grid[i] = new Array(this.tubularSegments);\n        for(var j = 0; j < this.tubularSegments; ++j){\n            var u = i / this.radialSegments * 2 * this.p * Math.PI;\n            var v = j / this.tubularSegments * 2 * Math.PI;\n            var p1 = getPos(u, v, this.q, this.p, this.radius, this.heightScale);\n            var p2 = getPos(u + 0.01, v, this.q, this.p, this.radius, this.heightScale);\n            var cx, cy;\n            tang.subVectors(p2, p1);\n            n.addVectors(p2, p1);\n            bitan.crossVectors(tang, n);\n            n.crossVectors(bitan, tang);\n            bitan.normalize();\n            n.normalize();\n            cx = -this.tube * Math.cos(v); // TODO: Hack: Negating it so it faces outside.\n            cy = this.tube * Math.sin(v);\n            p1.x += cx * n.x + cy * bitan.x;\n            p1.y += cx * n.y + cy * bitan.y;\n            p1.z += cx * n.z + cy * bitan.z;\n            this.grid[i][j] = vert(p1.x, p1.y, p1.z);\n        }\n    }\n    for(var i = 0; i < this.radialSegments; ++i)for(var j = 0; j < this.tubularSegments; ++j){\n        var ip = (i + 1) % this.radialSegments;\n        var jp = (j + 1) % this.tubularSegments;\n        var a = this.grid[i][j];\n        var b = this.grid[ip][j];\n        var c = this.grid[ip][jp];\n        var d = this.grid[i][jp];\n        var uva = new THREE.Vector2(i / this.radialSegments, j / this.tubularSegments);\n        var uvb = new THREE.Vector2((i + 1) / this.radialSegments, j / this.tubularSegments);\n        var uvc = new THREE.Vector2((i + 1) / this.radialSegments, (j + 1) / this.tubularSegments);\n        var uvd = new THREE.Vector2(i / this.radialSegments, (j + 1) / this.tubularSegments);\n        this.faces.push(new THREE.Face4(a, b, c, d));\n        this.faceVertexUvs[0].push([\n            uva,\n            uvb,\n            uvc,\n            uvd\n        ]);\n    }\n    this.computeCentroids();\n    this.computeFaceNormals();\n    this.computeVertexNormals();\n    function vert(x, y, z) {\n        return scope.vertices.push(new THREE.Vector3(x, y, z)) - 1;\n    }\n    function getPos(u, v, in_q, in_p, radius, heightScale) {\n        var cu = Math.cos(u);\n        var cv = Math.cos(v);\n        var su = Math.sin(u);\n        var quOverP = in_q / in_p * u;\n        var cs = Math.cos(quOverP);\n        var tx = radius * (2 + cs) * 0.5 * cu;\n        var ty = radius * (2 + cs) * su * 0.5;\n        var tz = heightScale * radius * Math.sin(quOverP) * 0.5;\n        return new THREE.Vector3(tx, ty, tz);\n    }\n};\nTHREE.TorusKnotGeometry.prototype = Object.create(THREE.Geometry.prototype);\n/**\n * @author WestLangley / https://github.com/WestLangley\n * @author zz85 / https://github.com/zz85\n * @author miningold / https://github.com/miningold\n *\n * Modified from the TorusKnotGeometry by @oosmoxiecode\n *\n * Creates a tube which extrudes along a 3d spline\n *\n * Uses parallel transport frames as described in\n * http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n */ THREE.TubeGeometry = function(path, segments, radius, radiusSegments, closed, debug) {\n    THREE.Geometry.call(this);\n    this.path = path;\n    this.segments = segments || 64;\n    this.radius = radius || 1;\n    this.radiusSegments = radiusSegments || 8;\n    this.closed = closed || false;\n    if (debug) this.debug = new THREE.Object3D();\n    this.grid = [];\n    var scope = this, tangent, normal, binormal, numpoints = this.segments + 1, x, y, z, tx, ty, tz, u, v, cx, cy, pos, pos2 = new THREE.Vector3(), i, j, ip, jp, a, b, c, d, uva, uvb, uvc, uvd;\n    var frames = new THREE.TubeGeometry.FrenetFrames(this.path, this.segments, this.closed), tangents = frames.tangents, normals = frames.normals, binormals = frames.binormals;\n    // proxy internals\n    this.tangents = tangents;\n    this.normals = normals;\n    this.binormals = binormals;\n    function vert(x, y, z) {\n        return scope.vertices.push(new THREE.Vector3(x, y, z)) - 1;\n    }\n    // consruct the grid\n    for(i = 0; i < numpoints; i++){\n        this.grid[i] = [];\n        u = i / (numpoints - 1);\n        pos = path.getPointAt(u);\n        tangent = tangents[i];\n        normal = normals[i];\n        binormal = binormals[i];\n        if (this.debug) {\n            this.debug.add(new THREE.ArrowHelper(tangent, pos, radius, 0x0000ff));\n            this.debug.add(new THREE.ArrowHelper(normal, pos, radius, 0xff0000));\n            this.debug.add(new THREE.ArrowHelper(binormal, pos, radius, 0x00ff00));\n        }\n        for(j = 0; j < this.radiusSegments; j++){\n            v = j / this.radiusSegments * 2 * Math.PI;\n            cx = -this.radius * Math.cos(v); // TODO: Hack: Negating it so it faces outside.\n            cy = this.radius * Math.sin(v);\n            pos2.copy(pos);\n            pos2.x += cx * normal.x + cy * binormal.x;\n            pos2.y += cx * normal.y + cy * binormal.y;\n            pos2.z += cx * normal.z + cy * binormal.z;\n            this.grid[i][j] = vert(pos2.x, pos2.y, pos2.z);\n        }\n    }\n    // construct the mesh\n    for(i = 0; i < this.segments; i++)for(j = 0; j < this.radiusSegments; j++){\n        ip = this.closed ? (i + 1) % this.segments : i + 1;\n        jp = (j + 1) % this.radiusSegments;\n        a = this.grid[i][j]; // *** NOT NECESSARILY PLANAR ! ***\n        b = this.grid[ip][j];\n        c = this.grid[ip][jp];\n        d = this.grid[i][jp];\n        uva = new THREE.Vector2(i / this.segments, j / this.radiusSegments);\n        uvb = new THREE.Vector2((i + 1) / this.segments, j / this.radiusSegments);\n        uvc = new THREE.Vector2((i + 1) / this.segments, (j + 1) / this.radiusSegments);\n        uvd = new THREE.Vector2(i / this.segments, (j + 1) / this.radiusSegments);\n        this.faces.push(new THREE.Face4(a, b, c, d));\n        this.faceVertexUvs[0].push([\n            uva,\n            uvb,\n            uvc,\n            uvd\n        ]);\n    }\n    this.computeCentroids();\n    this.computeFaceNormals();\n    this.computeVertexNormals();\n};\nTHREE.TubeGeometry.prototype = Object.create(THREE.Geometry.prototype);\n// For computing of Frenet frames, exposing the tangents, normals and binormals the spline\nTHREE.TubeGeometry.FrenetFrames = function(path, segments, closed) {\n    var tangent = new THREE.Vector3(), normal = new THREE.Vector3(), binormal = new THREE.Vector3(), tangents = [], normals = [], binormals = [], vec = new THREE.Vector3(), mat = new THREE.Matrix4(), numpoints = segments + 1, theta, epsilon = 0.0001, smallest, tx, ty, tz, i, u, v;\n    // expose internals\n    this.tangents = tangents;\n    this.normals = normals;\n    this.binormals = binormals;\n    // compute the tangent vectors for each segment on the path\n    for(i = 0; i < numpoints; i++){\n        u = i / (numpoints - 1);\n        tangents[i] = path.getTangentAt(u);\n        tangents[i].normalize();\n    }\n    initialNormal3();\n    function initialNormal1(lastBinormal) {\n        // fixed start binormal. Has dangers of 0 vectors\n        normals[0] = new THREE.Vector3();\n        binormals[0] = new THREE.Vector3();\n        if (lastBinormal === undefined) lastBinormal = new THREE.Vector3(0, 0, 1);\n        normals[0].crossVectors(lastBinormal, tangents[0]).normalize();\n        binormals[0].crossVectors(tangents[0], normals[0]).normalize();\n    }\n    function initialNormal2() {\n        // This uses the Frenet-Serret formula for deriving binormal\n        var t2 = path.getTangentAt(epsilon);\n        normals[0] = new THREE.Vector3().subVectors(t2, tangents[0]).normalize();\n        binormals[0] = new THREE.Vector3().crossVectors(tangents[0], normals[0]);\n        normals[0].crossVectors(binormals[0], tangents[0]).normalize(); // last binormal x tangent\n        binormals[0].crossVectors(tangents[0], normals[0]).normalize();\n    }\n    function initialNormal3() {\n        // select an initial normal vector perpenicular to the first tangent vector,\n        // and in the direction of the smallest tangent xyz component\n        normals[0] = new THREE.Vector3();\n        binormals[0] = new THREE.Vector3();\n        smallest = Number.MAX_VALUE;\n        tx = Math.abs(tangents[0].x);\n        ty = Math.abs(tangents[0].y);\n        tz = Math.abs(tangents[0].z);\n        if (tx <= smallest) {\n            smallest = tx;\n            normal.set(1, 0, 0);\n        }\n        if (ty <= smallest) {\n            smallest = ty;\n            normal.set(0, 1, 0);\n        }\n        if (tz <= smallest) normal.set(0, 0, 1);\n        vec.crossVectors(tangents[0], normal).normalize();\n        normals[0].crossVectors(tangents[0], vec);\n        binormals[0].crossVectors(tangents[0], normals[0]);\n    }\n    // compute the slowly-varying normal and binormal vectors for each segment on the path\n    for(i = 1; i < numpoints; i++){\n        normals[i] = normals[i - 1].clone();\n        binormals[i] = binormals[i - 1].clone();\n        vec.crossVectors(tangents[i - 1], tangents[i]);\n        if (vec.length() > epsilon) {\n            vec.normalize();\n            theta = Math.acos(tangents[i - 1].dot(tangents[i]));\n            normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));\n        }\n        binormals[i].crossVectors(tangents[i], normals[i]);\n    }\n    // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n    if (closed) {\n        theta = Math.acos(normals[0].dot(normals[numpoints - 1]));\n        theta /= numpoints - 1;\n        if (tangents[0].dot(vec.crossVectors(normals[0], normals[numpoints - 1])) > 0) theta = -theta;\n        for(i = 1; i < numpoints; i++){\n            // twist a little...\n            normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));\n            binormals[i].crossVectors(tangents[i], normals[i]);\n        }\n    }\n};\n/**\n * @author clockworkgeek / https://github.com/clockworkgeek\n * @author timothypratley / https://github.com/timothypratley\n */ THREE.PolyhedronGeometry = function(vertices, faces, radius, detail) {\n    THREE.Geometry.call(this);\n    radius = radius || 1;\n    detail = detail || 0;\n    var that = this;\n    for(var i = 0, l = vertices.length; i < l; i++)prepare(new THREE.Vector3(vertices[i][0], vertices[i][1], vertices[i][2]));\n    var midpoints = [], p = this.vertices;\n    for(var i = 0, l = faces.length; i < l; i++)make(p[faces[i][0]], p[faces[i][1]], p[faces[i][2]], detail);\n    this.mergeVertices();\n    // Apply radius\n    for(var i = 0, l = this.vertices.length; i < l; i++)this.vertices[i].multiplyScalar(radius);\n    // Project vector onto sphere's surface\n    function prepare(vector) {\n        var vertex = vector.normalize().clone();\n        vertex.index = that.vertices.push(vertex) - 1;\n        // Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.\n        var u = azimuth(vector) / 2 / Math.PI + 0.5;\n        var v = inclination(vector) / Math.PI + 0.5;\n        vertex.uv = new THREE.Vector2(u, 1 - v);\n        return vertex;\n    }\n    // Approximate a curved face with recursively sub-divided triangles.\n    function make(v1, v2, v3, detail) {\n        if (detail < 1) {\n            var face = new THREE.Face3(v1.index, v2.index, v3.index, [\n                v1.clone(),\n                v2.clone(),\n                v3.clone()\n            ]);\n            face.centroid.add(v1).add(v2).add(v3).divideScalar(3);\n            face.normal = face.centroid.clone().normalize();\n            that.faces.push(face);\n            var azi = azimuth(face.centroid);\n            that.faceVertexUvs[0].push([\n                correctUV(v1.uv, v1, azi),\n                correctUV(v2.uv, v2, azi),\n                correctUV(v3.uv, v3, azi)\n            ]);\n        } else {\n            detail -= 1;\n            // split triangle into 4 smaller triangles\n            make(v1, midpoint(v1, v2), midpoint(v1, v3), detail); // top quadrant\n            make(midpoint(v1, v2), v2, midpoint(v2, v3), detail); // left quadrant\n            make(midpoint(v1, v3), midpoint(v2, v3), v3, detail); // right quadrant\n            make(midpoint(v1, v2), midpoint(v2, v3), midpoint(v1, v3), detail); // center quadrant\n        }\n    }\n    function midpoint(v1, v2) {\n        if (!midpoints[v1.index]) midpoints[v1.index] = [];\n        if (!midpoints[v2.index]) midpoints[v2.index] = [];\n        var mid = midpoints[v1.index][v2.index];\n        if (mid === undefined) // generate mean point and project to surface with prepare()\n        midpoints[v1.index][v2.index] = midpoints[v2.index][v1.index] = mid = prepare(new THREE.Vector3().addVectors(v1, v2).divideScalar(2));\n        return mid;\n    }\n    // Angle around the Y axis, counter-clockwise when looking from above.\n    function azimuth(vector) {\n        return Math.atan2(vector.z, -vector.x);\n    }\n    // Angle above the XZ plane.\n    function inclination(vector) {\n        return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));\n    }\n    // Texture fixing helper. Spheres have some odd behaviours.\n    function correctUV(uv, vector, azimuth) {\n        if (azimuth < 0 && uv.x === 1) uv = new THREE.Vector2(uv.x - 1, uv.y);\n        if (vector.x === 0 && vector.z === 0) uv = new THREE.Vector2(azimuth / 2 / Math.PI + 0.5, uv.y);\n        return uv;\n    }\n    this.computeCentroids();\n    this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius);\n};\nTHREE.PolyhedronGeometry.prototype = Object.create(THREE.Geometry.prototype);\n/**\n * @author timothypratley / https://github.com/timothypratley\n */ THREE.IcosahedronGeometry = function(radius, detail) {\n    var t = (1 + Math.sqrt(5)) / 2;\n    var vertices = [\n        [\n            -1,\n            t,\n            0\n        ],\n        [\n            1,\n            t,\n            0\n        ],\n        [\n            -1,\n            -t,\n            0\n        ],\n        [\n            1,\n            -t,\n            0\n        ],\n        [\n            0,\n            -1,\n            t\n        ],\n        [\n            0,\n            1,\n            t\n        ],\n        [\n            0,\n            -1,\n            -t\n        ],\n        [\n            0,\n            1,\n            -t\n        ],\n        [\n            t,\n            0,\n            -1\n        ],\n        [\n            t,\n            0,\n            1\n        ],\n        [\n            -t,\n            0,\n            -1\n        ],\n        [\n            -t,\n            0,\n            1\n        ]\n    ];\n    var faces = [\n        [\n            0,\n            11,\n            5\n        ],\n        [\n            0,\n            5,\n            1\n        ],\n        [\n            0,\n            1,\n            7\n        ],\n        [\n            0,\n            7,\n            10\n        ],\n        [\n            0,\n            10,\n            11\n        ],\n        [\n            1,\n            5,\n            9\n        ],\n        [\n            5,\n            11,\n            4\n        ],\n        [\n            11,\n            10,\n            2\n        ],\n        [\n            10,\n            7,\n            6\n        ],\n        [\n            7,\n            1,\n            8\n        ],\n        [\n            3,\n            9,\n            4\n        ],\n        [\n            3,\n            4,\n            2\n        ],\n        [\n            3,\n            2,\n            6\n        ],\n        [\n            3,\n            6,\n            8\n        ],\n        [\n            3,\n            8,\n            9\n        ],\n        [\n            4,\n            9,\n            5\n        ],\n        [\n            2,\n            4,\n            11\n        ],\n        [\n            6,\n            2,\n            10\n        ],\n        [\n            8,\n            6,\n            7\n        ],\n        [\n            9,\n            8,\n            1\n        ]\n    ];\n    THREE.PolyhedronGeometry.call(this, vertices, faces, radius, detail);\n};\nTHREE.IcosahedronGeometry.prototype = Object.create(THREE.Geometry.prototype);\n/**\n * @author timothypratley / https://github.com/timothypratley\n */ THREE.OctahedronGeometry = function(radius, detail) {\n    var vertices = [\n        [\n            1,\n            0,\n            0\n        ],\n        [\n            -1,\n            0,\n            0\n        ],\n        [\n            0,\n            1,\n            0\n        ],\n        [\n            0,\n            -1,\n            0\n        ],\n        [\n            0,\n            0,\n            1\n        ],\n        [\n            0,\n            0,\n            -1\n        ]\n    ];\n    var faces = [\n        [\n            0,\n            2,\n            4\n        ],\n        [\n            0,\n            4,\n            3\n        ],\n        [\n            0,\n            3,\n            5\n        ],\n        [\n            0,\n            5,\n            2\n        ],\n        [\n            1,\n            2,\n            5\n        ],\n        [\n            1,\n            5,\n            3\n        ],\n        [\n            1,\n            3,\n            4\n        ],\n        [\n            1,\n            4,\n            2\n        ]\n    ];\n    THREE.PolyhedronGeometry.call(this, vertices, faces, radius, detail);\n};\nTHREE.OctahedronGeometry.prototype = Object.create(THREE.Geometry.prototype);\n/**\n * @author timothypratley / https://github.com/timothypratley\n */ THREE.TetrahedronGeometry = function(radius, detail) {\n    var vertices = [\n        [\n            1,\n            1,\n            1\n        ],\n        [\n            -1,\n            -1,\n            1\n        ],\n        [\n            -1,\n            1,\n            -1\n        ],\n        [\n            1,\n            -1,\n            -1\n        ]\n    ];\n    var faces = [\n        [\n            2,\n            1,\n            0\n        ],\n        [\n            0,\n            3,\n            2\n        ],\n        [\n            1,\n            3,\n            0\n        ],\n        [\n            2,\n            3,\n            1\n        ]\n    ];\n    THREE.PolyhedronGeometry.call(this, vertices, faces, radius, detail);\n};\nTHREE.TetrahedronGeometry.prototype = Object.create(THREE.Geometry.prototype);\n/**\n * @author zz85 / https://github.com/zz85\n * Parametric Surfaces Geometry\n * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\n *\n * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements, useTris );\n *\n */ THREE.ParametricGeometry = function(func, slices, stacks, useTris) {\n    THREE.Geometry.call(this);\n    var verts = this.vertices;\n    var faces = this.faces;\n    var uvs = this.faceVertexUvs[0];\n    useTris = useTris === undefined ? false : useTris;\n    var i, il, j, p;\n    var u, v;\n    var stackCount = stacks + 1;\n    var sliceCount = slices + 1;\n    for(i = 0; i <= stacks; i++){\n        v = i / stacks;\n        for(j = 0; j <= slices; j++){\n            u = j / slices;\n            p = func(u, v);\n            verts.push(p);\n        }\n    }\n    var a, b, c, d;\n    var uva, uvb, uvc, uvd;\n    for(i = 0; i < stacks; i++)for(j = 0; j < slices; j++){\n        a = i * sliceCount + j;\n        b = i * sliceCount + j + 1;\n        c = (i + 1) * sliceCount + j;\n        d = (i + 1) * sliceCount + j + 1;\n        uva = new THREE.Vector2(j / slices, i / stacks);\n        uvb = new THREE.Vector2((j + 1) / slices, i / stacks);\n        uvc = new THREE.Vector2(j / slices, (i + 1) / stacks);\n        uvd = new THREE.Vector2((j + 1) / slices, (i + 1) / stacks);\n        if (useTris) {\n            faces.push(new THREE.Face3(a, b, c));\n            faces.push(new THREE.Face3(b, d, c));\n            uvs.push([\n                uva,\n                uvb,\n                uvc\n            ]);\n            uvs.push([\n                uvb,\n                uvd,\n                uvc\n            ]);\n        } else {\n            faces.push(new THREE.Face4(a, b, d, c));\n            uvs.push([\n                uva,\n                uvb,\n                uvd,\n                uvc\n            ]);\n        }\n    }\n    // console.log(this);\n    // magic bullet\n    // var diff = this.mergeVertices();\n    // console.log('removed ', diff, ' vertices by merging');\n    this.computeCentroids();\n    this.computeFaceNormals();\n    this.computeVertexNormals();\n};\nTHREE.ParametricGeometry.prototype = Object.create(THREE.Geometry.prototype);\n/**\n * @author qiao / https://github.com/qiao\n * @fileoverview This is a convex hull generator using the incremental method. \n * The complexity is O(n^2) where n is the number of vertices.\n * O(nlogn) algorithms do exist, but they are much more complicated.\n *\n * Benchmark: \n *\n *  Platform: CPU: P7350 @2.00GHz Engine: V8\n *\n *  Num Vertices\tTime(ms)\n *\n *     10           1\n *     20           3\n *     30           19\n *     40           48\n *     50           107\n */ THREE.ConvexGeometry = function(vertices) {\n    THREE.Geometry.call(this);\n    var faces = [\n        [\n            0,\n            1,\n            2\n        ],\n        [\n            0,\n            2,\n            1\n        ]\n    ];\n    for(var i = 3; i < vertices.length; i++)addPoint(i);\n    function addPoint(vertexId) {\n        var vertex = vertices[vertexId].clone();\n        var mag = vertex.length();\n        vertex.x += mag * randomOffset();\n        vertex.y += mag * randomOffset();\n        vertex.z += mag * randomOffset();\n        var hole = [];\n        for(var f = 0; f < faces.length;){\n            var face = faces[f];\n            // for each face, if the vertex can see it,\n            // then we try to add the face's edges into the hole.\n            if (visible(face, vertex)) {\n                for(var e = 0; e < 3; e++){\n                    var edge = [\n                        face[e],\n                        face[(e + 1) % 3]\n                    ];\n                    var boundary = true;\n                    // remove duplicated edges.\n                    for(var h = 0; h < hole.length; h++)if (equalEdge(hole[h], edge)) {\n                        hole[h] = hole[hole.length - 1];\n                        hole.pop();\n                        boundary = false;\n                        break;\n                    }\n                    if (boundary) hole.push(edge);\n                }\n                // remove faces[ f ]\n                faces[f] = faces[faces.length - 1];\n                faces.pop();\n            } else f++;\n        }\n        // construct the new faces formed by the edges of the hole and the vertex\n        for(var h = 0; h < hole.length; h++)faces.push([\n            hole[h][0],\n            hole[h][1],\n            vertexId\n        ]);\n    }\n    /**\n\t * Whether the face is visible from the vertex\n\t */ function visible(face, vertex) {\n        var va = vertices[face[0]];\n        var vb = vertices[face[1]];\n        var vc = vertices[face[2]];\n        var n = normal(va, vb, vc);\n        // distance from face to origin\n        var dist = n.dot(va);\n        return n.dot(vertex) >= dist;\n    }\n    /**\n\t * Face normal\n\t */ function normal(va, vb, vc) {\n        var cb = new THREE.Vector3();\n        var ab = new THREE.Vector3();\n        cb.subVectors(vc, vb);\n        ab.subVectors(va, vb);\n        cb.cross(ab);\n        cb.normalize();\n        return cb;\n    }\n    /**\n\t * Detect whether two edges are equal.\n\t * Note that when constructing the convex hull, two same edges can only\n\t * be of the negative direction.\n\t */ function equalEdge(ea, eb) {\n        return ea[0] === eb[1] && ea[1] === eb[0];\n    }\n    /**\n\t * Create a random offset between -1e-6 and 1e-6.\n\t */ function randomOffset() {\n        return (Math.random() - 0.5) * 2 * 1e-6;\n    }\n    /**\n\t * XXX: Not sure if this is the correct approach. Need someone to review.\n\t */ function vertexUv(vertex) {\n        var mag = vertex.length();\n        return new THREE.Vector2(vertex.x / mag, vertex.y / mag);\n    }\n    // Push vertices into `this.vertices`, skipping those inside the hull\n    var id = 0;\n    var newId = new Array(vertices.length); // map from old vertex id to new id\n    for(var i = 0; i < faces.length; i++){\n        var face = faces[i];\n        for(var j = 0; j < 3; j++){\n            if (newId[face[j]] === undefined) {\n                newId[face[j]] = id++;\n                this.vertices.push(vertices[face[j]]);\n            }\n            face[j] = newId[face[j]];\n        }\n    }\n    // Convert faces into instances of THREE.Face3\n    for(var i = 0; i < faces.length; i++)this.faces.push(new THREE.Face3(faces[i][0], faces[i][1], faces[i][2]));\n    // Compute UVs\n    for(var i = 0; i < this.faces.length; i++){\n        var face = this.faces[i];\n        this.faceVertexUvs[0].push([\n            vertexUv(this.vertices[face.a]),\n            vertexUv(this.vertices[face.b]),\n            vertexUv(this.vertices[face.c])\n        ]);\n    }\n    this.computeCentroids();\n    this.computeFaceNormals();\n    this.computeVertexNormals();\n};\nTHREE.ConvexGeometry.prototype = Object.create(THREE.Geometry.prototype);\n/**\n * @author sroucheray / http://sroucheray.org/\n * @author mrdoob / http://mrdoob.com/\n */ THREE.AxisHelper = function(size) {\n    var geometry = new THREE.Geometry();\n    geometry.vertices.push(new THREE.Vector3(), new THREE.Vector3(size || 1, 0, 0), new THREE.Vector3(), new THREE.Vector3(0, size || 1, 0), new THREE.Vector3(), new THREE.Vector3(0, 0, size || 1));\n    geometry.colors.push(new THREE.Color(0xff0000), new THREE.Color(0xffaa00), new THREE.Color(0x00ff00), new THREE.Color(0xaaff00), new THREE.Color(0x0000ff), new THREE.Color(0x00aaff));\n    var material = new THREE.LineBasicMaterial({\n        vertexColors: THREE.VertexColors\n    });\n    THREE.Line.call(this, geometry, material, THREE.LinePieces);\n};\nTHREE.AxisHelper.prototype = Object.create(THREE.Line.prototype);\n/**\n * @author WestLangley / http://github.com/WestLangley\n * @author zz85 / https://github.com/zz85\n * @author bhouston / https://exocortex.com\n *\n * Creates an arrow for visualizing directions\n *\n * Parameters:\n *  dir - Vector3\n *  origin - Vector3\n *  length - Number\n *  hex - color in hex value\n */ THREE.ArrowHelper = function(dir, origin, length, hex) {\n    THREE.Object3D.call(this);\n    if (length === undefined) length = 20;\n    if (hex === undefined) hex = 0xffff00;\n    var lineGeometry = new THREE.Geometry();\n    lineGeometry.vertices.push(new THREE.Vector3(0, 0, 0));\n    lineGeometry.vertices.push(new THREE.Vector3(0, 1, 0));\n    this.line = new THREE.Line(lineGeometry, new THREE.LineBasicMaterial({\n        color: hex\n    }));\n    this.add(this.line);\n    var coneGeometry = new THREE.CylinderGeometry(0, 0.05, 0.25, 5, 1);\n    this.cone = new THREE.Mesh(coneGeometry, new THREE.MeshBasicMaterial({\n        color: hex\n    }));\n    this.cone.position.set(0, 1, 0);\n    this.add(this.cone);\n    if (origin instanceof THREE.Vector3) this.position = origin;\n    this.setDirection(dir);\n    this.setLength(length);\n};\nTHREE.ArrowHelper.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.ArrowHelper.prototype.setDirection = function(dir) {\n    var d = THREE.ArrowHelper.__v1.copy(dir).normalize();\n    if (d.y > 0.999) this.rotation.set(0, 0, 0);\n    else if (d.y < -0.999) this.rotation.set(Math.PI, 0, 0);\n    else {\n        var axis = THREE.ArrowHelper.__v2.set(d.z, 0, -d.x).normalize();\n        var radians = Math.acos(d.y);\n        var quaternion = THREE.ArrowHelper.__q1.setFromAxisAngle(axis, radians);\n        this.rotation.setEulerFromQuaternion(quaternion, this.eulerOrder);\n    }\n};\nTHREE.ArrowHelper.prototype.setLength = function(length) {\n    this.scale.set(length, length, length);\n};\nTHREE.ArrowHelper.prototype.setColor = function(hex) {\n    this.line.material.color.setHex(hex);\n    this.cone.material.color.setHex(hex);\n};\nTHREE.ArrowHelper.__v1 = new THREE.Vector3();\nTHREE.ArrowHelper.__v2 = new THREE.Vector3();\nTHREE.ArrowHelper.__q1 = new THREE.Quaternion();\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n *\t- shows frustum, line of sight and up of the camera\n *\t- suitable for fast updates\n * \t- based on frustum visualization in lightgl.js shadowmap example\n *\t\thttp://evanw.github.com/lightgl.js/tests/shadowmap.html\n */ THREE.CameraHelper = function(camera) {\n    THREE.Line.call(this);\n    var scope = this;\n    this.geometry = new THREE.Geometry();\n    this.material = new THREE.LineBasicMaterial({\n        color: 0xffffff,\n        vertexColors: THREE.FaceColors\n    });\n    this.type = THREE.LinePieces;\n    this.matrixWorld = camera.matrixWorld;\n    this.matrixAutoUpdate = false;\n    this.pointMap = {};\n    // colors\n    var hexFrustum = 0xffaa00;\n    var hexCone = 0xff0000;\n    var hexUp = 0x00aaff;\n    var hexTarget = 0xffffff;\n    var hexCross = 0x333333;\n    // near\n    addLine(\"n1\", \"n2\", hexFrustum);\n    addLine(\"n2\", \"n4\", hexFrustum);\n    addLine(\"n4\", \"n3\", hexFrustum);\n    addLine(\"n3\", \"n1\", hexFrustum);\n    // far\n    addLine(\"f1\", \"f2\", hexFrustum);\n    addLine(\"f2\", \"f4\", hexFrustum);\n    addLine(\"f4\", \"f3\", hexFrustum);\n    addLine(\"f3\", \"f1\", hexFrustum);\n    // sides\n    addLine(\"n1\", \"f1\", hexFrustum);\n    addLine(\"n2\", \"f2\", hexFrustum);\n    addLine(\"n3\", \"f3\", hexFrustum);\n    addLine(\"n4\", \"f4\", hexFrustum);\n    // cone\n    addLine(\"p\", \"n1\", hexCone);\n    addLine(\"p\", \"n2\", hexCone);\n    addLine(\"p\", \"n3\", hexCone);\n    addLine(\"p\", \"n4\", hexCone);\n    // up\n    addLine(\"u1\", \"u2\", hexUp);\n    addLine(\"u2\", \"u3\", hexUp);\n    addLine(\"u3\", \"u1\", hexUp);\n    // target\n    addLine(\"c\", \"t\", hexTarget);\n    addLine(\"p\", \"c\", hexCross);\n    // cross\n    addLine(\"cn1\", \"cn2\", hexCross);\n    addLine(\"cn3\", \"cn4\", hexCross);\n    addLine(\"cf1\", \"cf2\", hexCross);\n    addLine(\"cf3\", \"cf4\", hexCross);\n    this.camera = camera;\n    function addLine(a, b, hex) {\n        addPoint(a, hex);\n        addPoint(b, hex);\n    }\n    function addPoint(id, hex) {\n        scope.geometry.vertices.push(new THREE.Vector3());\n        scope.geometry.colors.push(new THREE.Color(hex));\n        if (scope.pointMap[id] === undefined) scope.pointMap[id] = [];\n        scope.pointMap[id].push(scope.geometry.vertices.length - 1);\n    }\n    this.update(camera);\n};\nTHREE.CameraHelper.prototype = Object.create(THREE.Line.prototype);\nTHREE.CameraHelper.prototype.update = function() {\n    var scope = this;\n    var w = 1, h = 1;\n    // we need just camera projection matrix\n    // world matrix must be identity\n    THREE.CameraHelper.__c.projectionMatrix.copy(this.camera.projectionMatrix);\n    // center / target\n    setPoint(\"c\", 0, 0, -1);\n    setPoint(\"t\", 0, 0, 1);\n    // near\n    setPoint(\"n1\", -w, -h, -1);\n    setPoint(\"n2\", w, -h, -1);\n    setPoint(\"n3\", -w, h, -1);\n    setPoint(\"n4\", w, h, -1);\n    // far\n    setPoint(\"f1\", -w, -h, 1);\n    setPoint(\"f2\", w, -h, 1);\n    setPoint(\"f3\", -w, h, 1);\n    setPoint(\"f4\", w, h, 1);\n    // up\n    setPoint(\"u1\", w * 0.7, h * 1.1, -1);\n    setPoint(\"u2\", -w * 0.7, h * 1.1, -1);\n    setPoint(\"u3\", 0, h * 2, -1);\n    // cross\n    setPoint(\"cf1\", -w, 0, 1);\n    setPoint(\"cf2\", w, 0, 1);\n    setPoint(\"cf3\", 0, -h, 1);\n    setPoint(\"cf4\", 0, h, 1);\n    setPoint(\"cn1\", -w, 0, -1);\n    setPoint(\"cn2\", w, 0, -1);\n    setPoint(\"cn3\", 0, -h, -1);\n    setPoint(\"cn4\", 0, h, -1);\n    function setPoint(point, x, y, z) {\n        THREE.CameraHelper.__v.set(x, y, z);\n        THREE.CameraHelper.__projector.unprojectVector(THREE.CameraHelper.__v, THREE.CameraHelper.__c);\n        var points = scope.pointMap[point];\n        if (points !== undefined) for(var i = 0, il = points.length; i < il; i++)scope.geometry.vertices[points[i]].copy(THREE.CameraHelper.__v);\n    }\n    this.geometry.verticesNeedUpdate = true;\n};\nTHREE.CameraHelper.__projector = new THREE.Projector();\nTHREE.CameraHelper.__v = new THREE.Vector3();\nTHREE.CameraHelper.__c = new THREE.Camera();\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n *\t- shows directional light color, intensity, position, orientation and target\n */ THREE.DirectionalLightHelper = function(light, sphereSize) {\n    THREE.Object3D.call(this);\n    this.light = light;\n    // position\n    this.position = light.position;\n    // direction\n    this.direction = new THREE.Vector3();\n    this.direction.subVectors(light.target.position, light.position);\n    // color\n    var intensity = THREE.Math.clamp(light.intensity, 0, 1);\n    this.color = light.color.clone();\n    this.color.multiplyScalar(intensity);\n    var hexColor = this.color.getHex();\n    // light helper\n    var bulbGeometry = new THREE.SphereGeometry(sphereSize, 16, 8);\n    var raysGeometry = new THREE.AsteriskGeometry(sphereSize * 1.25, sphereSize * 2.25);\n    var bulbMaterial = new THREE.MeshBasicMaterial({\n        color: hexColor,\n        fog: false\n    });\n    var raysMaterial = new THREE.LineBasicMaterial({\n        color: hexColor,\n        fog: false\n    });\n    this.lightSphere = new THREE.Mesh(bulbGeometry, bulbMaterial);\n    this.lightRays = new THREE.Line(raysGeometry, raysMaterial, THREE.LinePieces);\n    this.add(this.lightSphere);\n    this.add(this.lightRays);\n    this.lightSphere.properties.isGizmo = true;\n    this.lightSphere.properties.gizmoSubject = light;\n    this.lightSphere.properties.gizmoRoot = this;\n    // light target helper\n    this.targetSphere = null;\n    if (light.target.properties.targetInverse !== undefined) {\n        var targetGeo = new THREE.SphereGeometry(sphereSize, 8, 4);\n        var targetMaterial = new THREE.MeshBasicMaterial({\n            color: hexColor,\n            wireframe: true,\n            fog: false\n        });\n        this.targetSphere = new THREE.Mesh(targetGeo, targetMaterial);\n        this.targetSphere.position = light.target.position;\n        this.targetSphere.properties.isGizmo = true;\n        this.targetSphere.properties.gizmoSubject = light.target;\n        this.targetSphere.properties.gizmoRoot = this.targetSphere;\n        var lineMaterial = new THREE.LineDashedMaterial({\n            color: hexColor,\n            dashSize: 4,\n            gapSize: 4,\n            opacity: 0.75,\n            transparent: true,\n            fog: false\n        });\n        var lineGeometry = new THREE.Geometry();\n        lineGeometry.vertices.push(this.position.clone());\n        lineGeometry.vertices.push(this.targetSphere.position.clone());\n        lineGeometry.computeLineDistances();\n        this.targetLine = new THREE.Line(lineGeometry, lineMaterial);\n        this.targetLine.properties.isGizmo = true;\n    }\n    //\n    this.properties.isGizmo = true;\n};\nTHREE.DirectionalLightHelper.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.DirectionalLightHelper.prototype.update = function() {\n    // update arrow orientation\n    // pointing from light to target\n    this.direction.subVectors(this.light.target.position, this.light.position);\n    // update arrow, spheres, rays and line colors to light color * light intensity\n    var intensity = THREE.Math.clamp(this.light.intensity, 0, 1);\n    this.color.copy(this.light.color);\n    this.color.multiplyScalar(intensity);\n    this.lightSphere.material.color.copy(this.color);\n    this.lightRays.material.color.copy(this.color);\n    // Only update targetSphere and targetLine if available\n    if (this.targetSphere !== null) {\n        this.targetSphere.material.color.copy(this.color);\n        this.targetLine.material.color.copy(this.color);\n        // update target line vertices\n        this.targetLine.geometry.vertices[0].copy(this.light.position);\n        this.targetLine.geometry.vertices[1].copy(this.light.target.position);\n        this.targetLine.geometry.computeLineDistances();\n        this.targetLine.geometry.verticesNeedUpdate = true;\n    }\n};\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n *\t- shows hemisphere light intensity, sky and ground colors and directions\n */ THREE.HemisphereLightHelper = function(light, sphereSize, arrowLength, domeSize) {\n    THREE.Object3D.call(this);\n    this.light = light;\n    // position\n    this.position = light.position;\n    //\n    var intensity = THREE.Math.clamp(light.intensity, 0, 1);\n    // sky color\n    this.color = light.color.clone();\n    this.color.multiplyScalar(intensity);\n    var hexColor = this.color.getHex();\n    // ground color\n    this.groundColor = light.groundColor.clone();\n    this.groundColor.multiplyScalar(intensity);\n    var hexColorGround = this.groundColor.getHex();\n    // double colored light bulb\n    var bulbGeometry = new THREE.SphereGeometry(sphereSize, 16, 8, 0, Math.PI * 2, 0, Math.PI * 0.5);\n    var bulbGroundGeometry = new THREE.SphereGeometry(sphereSize, 16, 8, 0, Math.PI * 2, Math.PI * 0.5, Math.PI);\n    var bulbSkyMaterial = new THREE.MeshBasicMaterial({\n        color: hexColor,\n        fog: false\n    });\n    var bulbGroundMaterial = new THREE.MeshBasicMaterial({\n        color: hexColorGround,\n        fog: false\n    });\n    for(var i = 0, il = bulbGeometry.faces.length; i < il; i++)bulbGeometry.faces[i].materialIndex = 0;\n    for(var i = 0, il = bulbGroundGeometry.faces.length; i < il; i++)bulbGroundGeometry.faces[i].materialIndex = 1;\n    THREE.GeometryUtils.merge(bulbGeometry, bulbGroundGeometry);\n    this.lightSphere = new THREE.Mesh(bulbGeometry, new THREE.MeshFaceMaterial([\n        bulbSkyMaterial,\n        bulbGroundMaterial\n    ]));\n    // arrows for sky and ground light directions\n    this.lightArrow = new THREE.ArrowHelper(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, (sphereSize + arrowLength) * 1.1, 0), arrowLength, hexColor);\n    this.lightArrow.rotation.x = Math.PI;\n    this.lightArrowGround = new THREE.ArrowHelper(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, (sphereSize + arrowLength) * -1.1, 0), arrowLength, hexColorGround);\n    var joint = new THREE.Object3D();\n    joint.rotation.x = -Math.PI * 0.5;\n    joint.add(this.lightSphere);\n    joint.add(this.lightArrow);\n    joint.add(this.lightArrowGround);\n    this.add(joint);\n    //\n    this.lightSphere.properties.isGizmo = true;\n    this.lightSphere.properties.gizmoSubject = light;\n    this.lightSphere.properties.gizmoRoot = this;\n    //\n    this.properties.isGizmo = true;\n    //\n    this.target = new THREE.Vector3();\n    this.lookAt(this.target);\n};\nTHREE.HemisphereLightHelper.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.HemisphereLightHelper.prototype.update = function() {\n    // update sphere sky and ground colors to light color * light intensity\n    var intensity = THREE.Math.clamp(this.light.intensity, 0, 1);\n    this.color.copy(this.light.color);\n    this.color.multiplyScalar(intensity);\n    this.groundColor.copy(this.light.groundColor);\n    this.groundColor.multiplyScalar(intensity);\n    this.lightSphere.material.materials[0].color.copy(this.color);\n    this.lightSphere.material.materials[1].color.copy(this.groundColor);\n    this.lightArrow.setColor(this.color.getHex());\n    this.lightArrowGround.setColor(this.groundColor.getHex());\n    this.lookAt(this.target);\n};\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n *\t- shows point light color, intensity, position and distance\n */ THREE.PointLightHelper = function(light, sphereSize) {\n    THREE.Object3D.call(this);\n    this.light = light;\n    // position\n    this.position = light.position;\n    // color\n    var intensity = THREE.Math.clamp(light.intensity, 0, 1);\n    this.color = light.color.clone();\n    this.color.multiplyScalar(intensity);\n    var hexColor = this.color.getHex();\n    // light helper\n    var bulbGeometry = new THREE.SphereGeometry(sphereSize, 16, 8);\n    var raysGeometry = new THREE.AsteriskGeometry(sphereSize * 1.25, sphereSize * 2.25);\n    var distanceGeometry = new THREE.IcosahedronGeometry(1, 2);\n    var bulbMaterial = new THREE.MeshBasicMaterial({\n        color: hexColor,\n        fog: false\n    });\n    var raysMaterial = new THREE.LineBasicMaterial({\n        color: hexColor,\n        fog: false\n    });\n    var distanceMaterial = new THREE.MeshBasicMaterial({\n        color: hexColor,\n        fog: false,\n        wireframe: true,\n        opacity: 0.1,\n        transparent: true\n    });\n    this.lightSphere = new THREE.Mesh(bulbGeometry, bulbMaterial);\n    this.lightRays = new THREE.Line(raysGeometry, raysMaterial, THREE.LinePieces);\n    this.lightDistance = new THREE.Mesh(distanceGeometry, distanceMaterial);\n    var d = light.distance;\n    if (d === 0.0) this.lightDistance.visible = false;\n    else this.lightDistance.scale.set(d, d, d);\n    this.add(this.lightSphere);\n    this.add(this.lightRays);\n    this.add(this.lightDistance);\n    //\n    this.lightSphere.properties.isGizmo = true;\n    this.lightSphere.properties.gizmoSubject = light;\n    this.lightSphere.properties.gizmoRoot = this;\n    //\n    this.properties.isGizmo = true;\n};\nTHREE.PointLightHelper.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.PointLightHelper.prototype.update = function() {\n    // update sphere and rays colors to light color * light intensity\n    var intensity = THREE.Math.clamp(this.light.intensity, 0, 1);\n    this.color.copy(this.light.color);\n    this.color.multiplyScalar(intensity);\n    this.lightSphere.material.color.copy(this.color);\n    this.lightRays.material.color.copy(this.color);\n    this.lightDistance.material.color.copy(this.color);\n    //\n    var d = this.light.distance;\n    if (d === 0.0) this.lightDistance.visible = false;\n    else {\n        this.lightDistance.visible = true;\n        this.lightDistance.scale.set(d, d, d);\n    }\n};\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n *\t- shows spot light color, intensity, position, orientation, light cone and target\n */ THREE.SpotLightHelper = function(light, sphereSize) {\n    THREE.Object3D.call(this);\n    this.light = light;\n    // position\n    this.position = light.position;\n    // direction\n    this.direction = new THREE.Vector3();\n    this.direction.subVectors(light.target.position, light.position);\n    // color\n    var intensity = THREE.Math.clamp(light.intensity, 0, 1);\n    this.color = light.color.clone();\n    this.color.multiplyScalar(intensity);\n    var hexColor = this.color.getHex();\n    // light helper\n    var bulbGeometry = new THREE.SphereGeometry(sphereSize, 16, 8);\n    var raysGeometry = new THREE.AsteriskGeometry(sphereSize * 1.25, sphereSize * 2.25);\n    var coneGeometry = new THREE.CylinderGeometry(0.0001, 1, 1, 8, 1, true);\n    var coneMatrix = new THREE.Matrix4();\n    coneMatrix.rotateX(-Math.PI / 2);\n    coneMatrix.translate(new THREE.Vector3(0, -0.5, 0));\n    coneGeometry.applyMatrix(coneMatrix);\n    var bulbMaterial = new THREE.MeshBasicMaterial({\n        color: hexColor,\n        fog: false\n    });\n    var raysMaterial = new THREE.LineBasicMaterial({\n        color: hexColor,\n        fog: false\n    });\n    var coneMaterial = new THREE.MeshBasicMaterial({\n        color: hexColor,\n        fog: false,\n        wireframe: true,\n        opacity: 0.3,\n        transparent: true\n    });\n    this.lightSphere = new THREE.Mesh(bulbGeometry, bulbMaterial);\n    this.lightCone = new THREE.Mesh(coneGeometry, coneMaterial);\n    var coneLength = light.distance ? light.distance : 10000;\n    var coneWidth = coneLength * Math.tan(light.angle * 0.5) * 2;\n    this.lightCone.scale.set(coneWidth, coneWidth, coneLength);\n    this.lightRays = new THREE.Line(raysGeometry, raysMaterial, THREE.LinePieces);\n    this.gyroscope = new THREE.Gyroscope();\n    this.gyroscope.add(this.lightSphere);\n    this.gyroscope.add(this.lightRays);\n    this.add(this.gyroscope);\n    this.add(this.lightCone);\n    this.lookAt(light.target.position);\n    this.lightSphere.properties.isGizmo = true;\n    this.lightSphere.properties.gizmoSubject = light;\n    this.lightSphere.properties.gizmoRoot = this;\n    // light target helper\n    this.targetSphere = null;\n    if (light.target.properties.targetInverse !== undefined) {\n        var targetGeo = new THREE.SphereGeometry(sphereSize, 8, 4);\n        var targetMaterial = new THREE.MeshBasicMaterial({\n            color: hexColor,\n            wireframe: true,\n            fog: false\n        });\n        this.targetSphere = new THREE.Mesh(targetGeo, targetMaterial);\n        this.targetSphere.position = light.target.position;\n        this.targetSphere.properties.isGizmo = true;\n        this.targetSphere.properties.gizmoSubject = light.target;\n        this.targetSphere.properties.gizmoRoot = this.targetSphere;\n        var lineMaterial = new THREE.LineDashedMaterial({\n            color: hexColor,\n            dashSize: 4,\n            gapSize: 4,\n            opacity: 0.75,\n            transparent: true,\n            fog: false\n        });\n        var lineGeometry = new THREE.Geometry();\n        lineGeometry.vertices.push(this.position.clone());\n        lineGeometry.vertices.push(this.targetSphere.position.clone());\n        lineGeometry.computeLineDistances();\n        this.targetLine = new THREE.Line(lineGeometry, lineMaterial);\n        this.targetLine.properties.isGizmo = true;\n    }\n    //\n    this.properties.isGizmo = true;\n};\nTHREE.SpotLightHelper.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.SpotLightHelper.prototype.update = function() {\n    // update arrow orientation\n    // pointing from light to target\n    this.direction.subVectors(this.light.target.position, this.light.position);\n    // update light cone orientation and size\n    this.lookAt(this.light.target.position);\n    var coneLength = this.light.distance ? this.light.distance : 10000;\n    var coneWidth = coneLength * Math.tan(this.light.angle * 0.5) * 2;\n    this.lightCone.scale.set(coneWidth, coneWidth, coneLength);\n    // update arrow, spheres, rays and line colors to light color * light intensity\n    var intensity = THREE.Math.clamp(this.light.intensity, 0, 1);\n    this.color.copy(this.light.color);\n    this.color.multiplyScalar(intensity);\n    this.lightSphere.material.color.copy(this.color);\n    this.lightRays.material.color.copy(this.color);\n    this.lightCone.material.color.copy(this.color);\n    // Only update targetSphere and targetLine if available\n    if (this.targetSphere !== null) {\n        this.targetSphere.material.color.copy(this.color);\n        this.targetLine.material.color.copy(this.color);\n        // update target line vertices\n        this.targetLine.geometry.vertices[0].copy(this.light.position);\n        this.targetLine.geometry.vertices[1].copy(this.light.target.position);\n        this.targetLine.geometry.computeLineDistances();\n        this.targetLine.geometry.verticesNeedUpdate = true;\n    }\n};\n/**\n * @author alteredq / http://alteredqualia.com/\n */ THREE.ImmediateRenderObject = function() {\n    THREE.Object3D.call(this);\n    this.render = function(renderCallback) {};\n};\nTHREE.ImmediateRenderObject.prototype = Object.create(THREE.Object3D.prototype);\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */ THREE.LensFlare = function(texture, size, distance, blending, color) {\n    THREE.Object3D.call(this);\n    this.lensFlares = [];\n    this.positionScreen = new THREE.Vector3();\n    this.customUpdateCallback = undefined;\n    if (texture !== undefined) this.add(texture, size, distance, blending, color);\n};\nTHREE.LensFlare.prototype = Object.create(THREE.Object3D.prototype);\n/*\n * Add: adds another flare\n */ THREE.LensFlare.prototype.add = function(texture, size, distance, blending, color, opacity) {\n    if (size === undefined) size = -1;\n    if (distance === undefined) distance = 0;\n    if (opacity === undefined) opacity = 1;\n    if (color === undefined) color = new THREE.Color(0xffffff);\n    if (blending === undefined) blending = THREE.NormalBlending;\n    distance = Math.min(distance, Math.max(0, distance));\n    this.lensFlares.push({\n        texture: texture,\n        size: size,\n        distance: distance,\n        x: 0,\n        y: 0,\n        z: 0,\n        scale: 1,\n        rotation: 1,\n        opacity: opacity,\n        color: color,\n        blending: blending\n    }); // blending\n};\n/*\n * Update lens flares update positions on all flares based on the screen position\n * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.\n */ THREE.LensFlare.prototype.updateLensFlares = function() {\n    var f, fl = this.lensFlares.length;\n    var flare;\n    var vecX = -this.positionScreen.x * 2;\n    var vecY = -this.positionScreen.y * 2;\n    for(f = 0; f < fl; f++){\n        flare = this.lensFlares[f];\n        flare.x = this.positionScreen.x + vecX * flare.distance;\n        flare.y = this.positionScreen.y + vecY * flare.distance;\n        flare.wantedRotation = flare.x * Math.PI * 0.25;\n        flare.rotation += (flare.wantedRotation - flare.rotation) * 0.25;\n    }\n};\n/**\n * @author alteredq / http://alteredqualia.com/\n */ THREE.MorphBlendMesh = function(geometry, material) {\n    THREE.Mesh.call(this, geometry, material);\n    this.animationsMap = {};\n    this.animationsList = [];\n    // prepare default animation\n    // (all frames played together in 1 second)\n    var numFrames = this.geometry.morphTargets.length;\n    var name = \"__default\";\n    var startFrame = 0;\n    var endFrame = numFrames - 1;\n    var fps = numFrames / 1;\n    this.createAnimation(name, startFrame, endFrame, fps);\n    this.setAnimationWeight(name, 1);\n};\nTHREE.MorphBlendMesh.prototype = Object.create(THREE.Mesh.prototype);\nTHREE.MorphBlendMesh.prototype.createAnimation = function(name, start, end, fps) {\n    var animation = {\n        startFrame: start,\n        endFrame: end,\n        length: end - start + 1,\n        fps: fps,\n        duration: (end - start) / fps,\n        lastFrame: 0,\n        currentFrame: 0,\n        active: false,\n        time: 0,\n        direction: 1,\n        weight: 1,\n        directionBackwards: false,\n        mirroredLoop: false\n    };\n    this.animationsMap[name] = animation;\n    this.animationsList.push(animation);\n};\nTHREE.MorphBlendMesh.prototype.autoCreateAnimations = function(fps) {\n    var pattern = /([a-z]+)(\\d+)/;\n    var firstAnimation, frameRanges = {};\n    var geometry = this.geometry;\n    for(var i = 0, il = geometry.morphTargets.length; i < il; i++){\n        var morph = geometry.morphTargets[i];\n        var chunks = morph.name.match(pattern);\n        if (chunks && chunks.length > 1) {\n            var name = chunks[1];\n            var num = chunks[2];\n            if (!frameRanges[name]) frameRanges[name] = {\n                start: Infinity,\n                end: -Infinity\n            };\n            var range = frameRanges[name];\n            if (i < range.start) range.start = i;\n            if (i > range.end) range.end = i;\n            if (!firstAnimation) firstAnimation = name;\n        }\n    }\n    for(var name in frameRanges){\n        var range = frameRanges[name];\n        this.createAnimation(name, range.start, range.end, fps);\n    }\n    this.firstAnimation = firstAnimation;\n};\nTHREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function(name) {\n    var animation = this.animationsMap[name];\n    if (animation) {\n        animation.direction = 1;\n        animation.directionBackwards = false;\n    }\n};\nTHREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function(name) {\n    var animation = this.animationsMap[name];\n    if (animation) {\n        animation.direction = -1;\n        animation.directionBackwards = true;\n    }\n};\nTHREE.MorphBlendMesh.prototype.setAnimationFPS = function(name, fps) {\n    var animation = this.animationsMap[name];\n    if (animation) {\n        animation.fps = fps;\n        animation.duration = (animation.end - animation.start) / animation.fps;\n    }\n};\nTHREE.MorphBlendMesh.prototype.setAnimationDuration = function(name, duration) {\n    var animation = this.animationsMap[name];\n    if (animation) {\n        animation.duration = duration;\n        animation.fps = (animation.end - animation.start) / animation.duration;\n    }\n};\nTHREE.MorphBlendMesh.prototype.setAnimationWeight = function(name, weight) {\n    var animation = this.animationsMap[name];\n    if (animation) animation.weight = weight;\n};\nTHREE.MorphBlendMesh.prototype.setAnimationTime = function(name, time) {\n    var animation = this.animationsMap[name];\n    if (animation) animation.time = time;\n};\nTHREE.MorphBlendMesh.prototype.getAnimationTime = function(name) {\n    var time = 0;\n    var animation = this.animationsMap[name];\n    if (animation) time = animation.time;\n    return time;\n};\nTHREE.MorphBlendMesh.prototype.getAnimationDuration = function(name) {\n    var duration = -1;\n    var animation = this.animationsMap[name];\n    if (animation) duration = animation.duration;\n    return duration;\n};\nTHREE.MorphBlendMesh.prototype.playAnimation = function(name) {\n    var animation = this.animationsMap[name];\n    if (animation) {\n        animation.time = 0;\n        animation.active = true;\n    } else console.warn(\"animation[\" + name + \"] undefined\");\n};\nTHREE.MorphBlendMesh.prototype.stopAnimation = function(name) {\n    var animation = this.animationsMap[name];\n    if (animation) animation.active = false;\n};\nTHREE.MorphBlendMesh.prototype.update = function(delta) {\n    for(var i = 0, il = this.animationsList.length; i < il; i++){\n        var animation = this.animationsList[i];\n        if (!animation.active) continue;\n        var frameTime = animation.duration / animation.length;\n        animation.time += animation.direction * delta;\n        if (animation.mirroredLoop) {\n            if (animation.time > animation.duration || animation.time < 0) {\n                animation.direction *= -1;\n                if (animation.time > animation.duration) {\n                    animation.time = animation.duration;\n                    animation.directionBackwards = true;\n                }\n                if (animation.time < 0) {\n                    animation.time = 0;\n                    animation.directionBackwards = false;\n                }\n            }\n        } else {\n            animation.time = animation.time % animation.duration;\n            if (animation.time < 0) animation.time += animation.duration;\n        }\n        var keyframe = animation.startFrame + THREE.Math.clamp(Math.floor(animation.time / frameTime), 0, animation.length - 1);\n        var weight = animation.weight;\n        if (keyframe !== animation.currentFrame) {\n            this.morphTargetInfluences[animation.lastFrame] = 0;\n            this.morphTargetInfluences[animation.currentFrame] = 1 * weight;\n            this.morphTargetInfluences[keyframe] = 0;\n            animation.lastFrame = animation.currentFrame;\n            animation.currentFrame = keyframe;\n        }\n        var mix = animation.time % frameTime / frameTime;\n        if (animation.directionBackwards) mix = 1 - mix;\n        this.morphTargetInfluences[animation.currentFrame] = mix * weight;\n        this.morphTargetInfluences[animation.lastFrame] = (1 - mix) * weight;\n    }\n};\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */ THREE.LensFlarePlugin = function() {\n    var _gl, _renderer, _precision, _lensFlare = {};\n    this.init = function(renderer) {\n        _gl = renderer.context;\n        _renderer = renderer;\n        _precision = renderer.getPrecision();\n        _lensFlare.vertices = new Float32Array(16);\n        _lensFlare.faces = new Uint16Array(6);\n        var i = 0;\n        _lensFlare.vertices[i++] = -1;\n        _lensFlare.vertices[i++] = -1; // vertex\n        _lensFlare.vertices[i++] = 0;\n        _lensFlare.vertices[i++] = 0; // uv... etc.\n        _lensFlare.vertices[i++] = 1;\n        _lensFlare.vertices[i++] = -1;\n        _lensFlare.vertices[i++] = 1;\n        _lensFlare.vertices[i++] = 0;\n        _lensFlare.vertices[i++] = 1;\n        _lensFlare.vertices[i++] = 1;\n        _lensFlare.vertices[i++] = 1;\n        _lensFlare.vertices[i++] = 1;\n        _lensFlare.vertices[i++] = -1;\n        _lensFlare.vertices[i++] = 1;\n        _lensFlare.vertices[i++] = 0;\n        _lensFlare.vertices[i++] = 1;\n        i = 0;\n        _lensFlare.faces[i++] = 0;\n        _lensFlare.faces[i++] = 1;\n        _lensFlare.faces[i++] = 2;\n        _lensFlare.faces[i++] = 0;\n        _lensFlare.faces[i++] = 2;\n        _lensFlare.faces[i++] = 3;\n        // buffers\n        _lensFlare.vertexBuffer = _gl.createBuffer();\n        _lensFlare.elementBuffer = _gl.createBuffer();\n        _gl.bindBuffer(_gl.ARRAY_BUFFER, _lensFlare.vertexBuffer);\n        _gl.bufferData(_gl.ARRAY_BUFFER, _lensFlare.vertices, _gl.STATIC_DRAW);\n        _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, _lensFlare.elementBuffer);\n        _gl.bufferData(_gl.ELEMENT_ARRAY_BUFFER, _lensFlare.faces, _gl.STATIC_DRAW);\n        // textures\n        _lensFlare.tempTexture = _gl.createTexture();\n        _lensFlare.occlusionTexture = _gl.createTexture();\n        _gl.bindTexture(_gl.TEXTURE_2D, _lensFlare.tempTexture);\n        _gl.texImage2D(_gl.TEXTURE_2D, 0, _gl.RGB, 16, 16, 0, _gl.RGB, _gl.UNSIGNED_BYTE, null);\n        _gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);\n        _gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);\n        _gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_MAG_FILTER, _gl.NEAREST);\n        _gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_MIN_FILTER, _gl.NEAREST);\n        _gl.bindTexture(_gl.TEXTURE_2D, _lensFlare.occlusionTexture);\n        _gl.texImage2D(_gl.TEXTURE_2D, 0, _gl.RGBA, 16, 16, 0, _gl.RGBA, _gl.UNSIGNED_BYTE, null);\n        _gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);\n        _gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);\n        _gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_MAG_FILTER, _gl.NEAREST);\n        _gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_MIN_FILTER, _gl.NEAREST);\n        if (_gl.getParameter(_gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS) <= 0) {\n            _lensFlare.hasVertexTexture = false;\n            _lensFlare.program = createProgram(THREE.ShaderFlares[\"lensFlare\"], _precision);\n        } else {\n            _lensFlare.hasVertexTexture = true;\n            _lensFlare.program = createProgram(THREE.ShaderFlares[\"lensFlareVertexTexture\"], _precision);\n        }\n        _lensFlare.attributes = {};\n        _lensFlare.uniforms = {};\n        _lensFlare.attributes.vertex = _gl.getAttribLocation(_lensFlare.program, \"position\");\n        _lensFlare.attributes.uv = _gl.getAttribLocation(_lensFlare.program, \"uv\");\n        _lensFlare.uniforms.renderType = _gl.getUniformLocation(_lensFlare.program, \"renderType\");\n        _lensFlare.uniforms.map = _gl.getUniformLocation(_lensFlare.program, \"map\");\n        _lensFlare.uniforms.occlusionMap = _gl.getUniformLocation(_lensFlare.program, \"occlusionMap\");\n        _lensFlare.uniforms.opacity = _gl.getUniformLocation(_lensFlare.program, \"opacity\");\n        _lensFlare.uniforms.color = _gl.getUniformLocation(_lensFlare.program, \"color\");\n        _lensFlare.uniforms.scale = _gl.getUniformLocation(_lensFlare.program, \"scale\");\n        _lensFlare.uniforms.rotation = _gl.getUniformLocation(_lensFlare.program, \"rotation\");\n        _lensFlare.uniforms.screenPosition = _gl.getUniformLocation(_lensFlare.program, \"screenPosition\");\n    };\n    /*\n\t * Render lens flares\n\t * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,\n\t *         reads these back and calculates occlusion.\n\t *         Then _lensFlare.update_lensFlares() is called to re-position and\n\t *         update transparency of flares. Then they are rendered.\n\t *\n\t */ this.render = function(scene, camera, viewportWidth, viewportHeight) {\n        var flares = scene.__webglFlares, nFlares = flares.length;\n        if (!nFlares) return;\n        var tempPosition = new THREE.Vector3();\n        var invAspect = viewportHeight / viewportWidth, halfViewportWidth = viewportWidth * 0.5, halfViewportHeight = viewportHeight * 0.5;\n        var size = 16 / viewportHeight, scale = new THREE.Vector2(size * invAspect, size);\n        var screenPosition = new THREE.Vector3(1, 1, 0), screenPositionPixels = new THREE.Vector2(1, 1);\n        var uniforms = _lensFlare.uniforms, attributes = _lensFlare.attributes;\n        // set _lensFlare program and reset blending\n        _gl.useProgram(_lensFlare.program);\n        _gl.enableVertexAttribArray(_lensFlare.attributes.vertex);\n        _gl.enableVertexAttribArray(_lensFlare.attributes.uv);\n        // loop through all lens flares to update their occlusion and positions\n        // setup gl and common used attribs/unforms\n        _gl.uniform1i(uniforms.occlusionMap, 0);\n        _gl.uniform1i(uniforms.map, 1);\n        _gl.bindBuffer(_gl.ARRAY_BUFFER, _lensFlare.vertexBuffer);\n        _gl.vertexAttribPointer(attributes.vertex, 2, _gl.FLOAT, false, 16, 0);\n        _gl.vertexAttribPointer(attributes.uv, 2, _gl.FLOAT, false, 16, 8);\n        _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, _lensFlare.elementBuffer);\n        _gl.disable(_gl.CULL_FACE);\n        _gl.depthMask(false);\n        var i, j, jl, flare, sprite;\n        for(i = 0; i < nFlares; i++){\n            size = 16 / viewportHeight;\n            scale.set(size * invAspect, size);\n            // calc object screen position\n            flare = flares[i];\n            tempPosition.set(flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14]);\n            tempPosition.applyMatrix4(camera.matrixWorldInverse);\n            tempPosition.applyProjection(camera.projectionMatrix);\n            // setup arrays for gl programs\n            screenPosition.copy(tempPosition);\n            screenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;\n            screenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;\n            // screen cull\n            if (_lensFlare.hasVertexTexture || screenPositionPixels.x > 0 && screenPositionPixels.x < viewportWidth && screenPositionPixels.y > 0 && screenPositionPixels.y < viewportHeight) {\n                // save current RGB to temp texture\n                _gl.activeTexture(_gl.TEXTURE1);\n                _gl.bindTexture(_gl.TEXTURE_2D, _lensFlare.tempTexture);\n                _gl.copyTexImage2D(_gl.TEXTURE_2D, 0, _gl.RGB, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0);\n                // render pink quad\n                _gl.uniform1i(uniforms.renderType, 0);\n                _gl.uniform2f(uniforms.scale, scale.x, scale.y);\n                _gl.uniform3f(uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z);\n                _gl.disable(_gl.BLEND);\n                _gl.enable(_gl.DEPTH_TEST);\n                _gl.drawElements(_gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0);\n                // copy result to occlusionMap\n                _gl.activeTexture(_gl.TEXTURE0);\n                _gl.bindTexture(_gl.TEXTURE_2D, _lensFlare.occlusionTexture);\n                _gl.copyTexImage2D(_gl.TEXTURE_2D, 0, _gl.RGBA, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0);\n                // restore graphics\n                _gl.uniform1i(uniforms.renderType, 1);\n                _gl.disable(_gl.DEPTH_TEST);\n                _gl.activeTexture(_gl.TEXTURE1);\n                _gl.bindTexture(_gl.TEXTURE_2D, _lensFlare.tempTexture);\n                _gl.drawElements(_gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0);\n                // update object positions\n                flare.positionScreen.copy(screenPosition);\n                if (flare.customUpdateCallback) flare.customUpdateCallback(flare);\n                else flare.updateLensFlares();\n                // render flares\n                _gl.uniform1i(uniforms.renderType, 2);\n                _gl.enable(_gl.BLEND);\n                for(j = 0, jl = flare.lensFlares.length; j < jl; j++){\n                    sprite = flare.lensFlares[j];\n                    if (sprite.opacity > 0.001 && sprite.scale > 0.001) {\n                        screenPosition.x = sprite.x;\n                        screenPosition.y = sprite.y;\n                        screenPosition.z = sprite.z;\n                        size = sprite.size * sprite.scale / viewportHeight;\n                        scale.x = size * invAspect;\n                        scale.y = size;\n                        _gl.uniform3f(uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z);\n                        _gl.uniform2f(uniforms.scale, scale.x, scale.y);\n                        _gl.uniform1f(uniforms.rotation, sprite.rotation);\n                        _gl.uniform1f(uniforms.opacity, sprite.opacity);\n                        _gl.uniform3f(uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b);\n                        _renderer.setBlending(sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst);\n                        _renderer.setTexture(sprite.texture, 1);\n                        _gl.drawElements(_gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0);\n                    }\n                }\n            }\n        }\n        // restore gl\n        _gl.enable(_gl.CULL_FACE);\n        _gl.enable(_gl.DEPTH_TEST);\n        _gl.depthMask(true);\n    };\n    function createProgram(shader, precision) {\n        var program = _gl.createProgram();\n        var fragmentShader = _gl.createShader(_gl.FRAGMENT_SHADER);\n        var vertexShader = _gl.createShader(_gl.VERTEX_SHADER);\n        var prefix = \"precision \" + precision + \" float;\\n\";\n        _gl.shaderSource(fragmentShader, prefix + shader.fragmentShader);\n        _gl.shaderSource(vertexShader, prefix + shader.vertexShader);\n        _gl.compileShader(fragmentShader);\n        _gl.compileShader(vertexShader);\n        _gl.attachShader(program, fragmentShader);\n        _gl.attachShader(program, vertexShader);\n        _gl.linkProgram(program);\n        return program;\n    }\n};\n/**\n * @author alteredq / http://alteredqualia.com/\n */ THREE.ShadowMapPlugin = function() {\n    var _gl, _renderer, _depthMaterial, _depthMaterialMorph, _depthMaterialSkin, _depthMaterialMorphSkin, _frustum = new THREE.Frustum(), _projScreenMatrix = new THREE.Matrix4(), _min = new THREE.Vector3(), _max = new THREE.Vector3(), _matrixPosition = new THREE.Vector3();\n    this.init = function(renderer) {\n        _gl = renderer.context;\n        _renderer = renderer;\n        var depthShader = THREE.ShaderLib[\"depthRGBA\"];\n        var depthUniforms = THREE.UniformsUtils.clone(depthShader.uniforms);\n        _depthMaterial = new THREE.ShaderMaterial({\n            fragmentShader: depthShader.fragmentShader,\n            vertexShader: depthShader.vertexShader,\n            uniforms: depthUniforms\n        });\n        _depthMaterialMorph = new THREE.ShaderMaterial({\n            fragmentShader: depthShader.fragmentShader,\n            vertexShader: depthShader.vertexShader,\n            uniforms: depthUniforms,\n            morphTargets: true\n        });\n        _depthMaterialSkin = new THREE.ShaderMaterial({\n            fragmentShader: depthShader.fragmentShader,\n            vertexShader: depthShader.vertexShader,\n            uniforms: depthUniforms,\n            skinning: true\n        });\n        _depthMaterialMorphSkin = new THREE.ShaderMaterial({\n            fragmentShader: depthShader.fragmentShader,\n            vertexShader: depthShader.vertexShader,\n            uniforms: depthUniforms,\n            morphTargets: true,\n            skinning: true\n        });\n        _depthMaterial._shadowPass = true;\n        _depthMaterialMorph._shadowPass = true;\n        _depthMaterialSkin._shadowPass = true;\n        _depthMaterialMorphSkin._shadowPass = true;\n    };\n    this.render = function(scene, camera) {\n        if (!(_renderer.shadowMapEnabled && _renderer.shadowMapAutoUpdate)) return;\n        this.update(scene, camera);\n    };\n    this.update = function(scene, camera) {\n        var i, il, j, jl, n, shadowMap, shadowMatrix, shadowCamera, program, buffer, material, webglObject, object, light, renderList, lights = [], k = 0, fog = null;\n        // set GL state for depth map\n        _gl.clearColor(1, 1, 1, 1);\n        _gl.disable(_gl.BLEND);\n        _gl.enable(_gl.CULL_FACE);\n        _gl.frontFace(_gl.CCW);\n        if (_renderer.shadowMapCullFace === THREE.CullFaceFront) _gl.cullFace(_gl.FRONT);\n        else _gl.cullFace(_gl.BACK);\n        _renderer.setDepthTest(true);\n        // preprocess lights\n        // \t- skip lights that are not casting shadows\n        //\t- create virtual lights for cascaded shadow maps\n        for(i = 0, il = scene.__lights.length; i < il; i++){\n            light = scene.__lights[i];\n            if (!light.castShadow) continue;\n            if (light instanceof THREE.DirectionalLight && light.shadowCascade) for(n = 0; n < light.shadowCascadeCount; n++){\n                var virtualLight;\n                if (!light.shadowCascadeArray[n]) {\n                    virtualLight = createVirtualLight(light, n);\n                    virtualLight.originalCamera = camera;\n                    var gyro = new THREE.Gyroscope();\n                    gyro.position = light.shadowCascadeOffset;\n                    gyro.add(virtualLight);\n                    gyro.add(virtualLight.target);\n                    camera.add(gyro);\n                    light.shadowCascadeArray[n] = virtualLight;\n                    console.log(\"Created virtualLight\", virtualLight);\n                } else virtualLight = light.shadowCascadeArray[n];\n                updateVirtualLight(light, n);\n                lights[k] = virtualLight;\n                k++;\n            }\n            else {\n                lights[k] = light;\n                k++;\n            }\n        }\n        // render depth map\n        for(i = 0, il = lights.length; i < il; i++){\n            light = lights[i];\n            if (!light.shadowMap) {\n                var shadowFilter = THREE.LinearFilter;\n                if (_renderer.shadowMapType === THREE.PCFSoftShadowMap) shadowFilter = THREE.NearestFilter;\n                var pars = {\n                    minFilter: shadowFilter,\n                    magFilter: shadowFilter,\n                    format: THREE.RGBAFormat\n                };\n                light.shadowMap = new THREE.WebGLRenderTarget(light.shadowMapWidth, light.shadowMapHeight, pars);\n                light.shadowMapSize = new THREE.Vector2(light.shadowMapWidth, light.shadowMapHeight);\n                light.shadowMatrix = new THREE.Matrix4();\n            }\n            if (!light.shadowCamera) {\n                if (light instanceof THREE.SpotLight) light.shadowCamera = new THREE.PerspectiveCamera(light.shadowCameraFov, light.shadowMapWidth / light.shadowMapHeight, light.shadowCameraNear, light.shadowCameraFar);\n                else if (light instanceof THREE.DirectionalLight) light.shadowCamera = new THREE.OrthographicCamera(light.shadowCameraLeft, light.shadowCameraRight, light.shadowCameraTop, light.shadowCameraBottom, light.shadowCameraNear, light.shadowCameraFar);\n                else {\n                    console.error(\"Unsupported light type for shadow\");\n                    continue;\n                }\n                scene.add(light.shadowCamera);\n                if (_renderer.autoUpdateScene) scene.updateMatrixWorld();\n            }\n            if (light.shadowCameraVisible && !light.cameraHelper) {\n                light.cameraHelper = new THREE.CameraHelper(light.shadowCamera);\n                light.shadowCamera.add(light.cameraHelper);\n            }\n            if (light.isVirtual && virtualLight.originalCamera == camera) updateShadowCamera(camera, light);\n            shadowMap = light.shadowMap;\n            shadowMatrix = light.shadowMatrix;\n            shadowCamera = light.shadowCamera;\n            shadowCamera.position.getPositionFromMatrix(light.matrixWorld);\n            _matrixPosition.getPositionFromMatrix(light.target.matrixWorld);\n            shadowCamera.lookAt(_matrixPosition);\n            shadowCamera.updateMatrixWorld();\n            shadowCamera.matrixWorldInverse.getInverse(shadowCamera.matrixWorld);\n            if (light.cameraHelper) light.cameraHelper.visible = light.shadowCameraVisible;\n            if (light.shadowCameraVisible) light.cameraHelper.update();\n            // compute shadow matrix\n            shadowMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n            shadowMatrix.multiply(shadowCamera.projectionMatrix);\n            shadowMatrix.multiply(shadowCamera.matrixWorldInverse);\n            // update camera matrices and frustum\n            _projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);\n            _frustum.setFromMatrix(_projScreenMatrix);\n            // render shadow map\n            _renderer.setRenderTarget(shadowMap);\n            _renderer.clear();\n            // set object matrices & frustum culling\n            renderList = scene.__webglObjects;\n            for(j = 0, jl = renderList.length; j < jl; j++){\n                webglObject = renderList[j];\n                object = webglObject.object;\n                webglObject.render = false;\n                if (object.visible && object.castShadow) {\n                    if (!(object instanceof THREE.Mesh || object instanceof THREE.ParticleSystem) || !object.frustumCulled || _frustum.intersectsObject(object)) {\n                        object._modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);\n                        webglObject.render = true;\n                    }\n                }\n            }\n            // render regular objects\n            var objectMaterial, useMorphing, useSkinning;\n            for(j = 0, jl = renderList.length; j < jl; j++){\n                webglObject = renderList[j];\n                if (webglObject.render) {\n                    object = webglObject.object;\n                    buffer = webglObject.buffer;\n                    // culling is overriden globally for all objects\n                    // while rendering depth map\n                    // need to deal with MeshFaceMaterial somehow\n                    // in that case just use the first of material.materials for now\n                    // (proper solution would require to break objects by materials\n                    //  similarly to regular rendering and then set corresponding\n                    //  depth materials per each chunk instead of just once per object)\n                    objectMaterial = getObjectMaterial(object);\n                    useMorphing = object.geometry.morphTargets.length > 0 && objectMaterial.morphTargets;\n                    useSkinning = object instanceof THREE.SkinnedMesh && objectMaterial.skinning;\n                    if (object.customDepthMaterial) material = object.customDepthMaterial;\n                    else if (useSkinning) material = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;\n                    else if (useMorphing) material = _depthMaterialMorph;\n                    else material = _depthMaterial;\n                    if (buffer instanceof THREE.BufferGeometry) _renderer.renderBufferDirect(shadowCamera, scene.__lights, fog, material, buffer, object);\n                    else _renderer.renderBuffer(shadowCamera, scene.__lights, fog, material, buffer, object);\n                }\n            }\n            // set matrices and render immediate objects\n            renderList = scene.__webglObjectsImmediate;\n            for(j = 0, jl = renderList.length; j < jl; j++){\n                webglObject = renderList[j];\n                object = webglObject.object;\n                if (object.visible && object.castShadow) {\n                    object._modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);\n                    _renderer.renderImmediateObject(shadowCamera, scene.__lights, fog, _depthMaterial, object);\n                }\n            }\n        }\n        // restore GL state\n        var clearColor = _renderer.getClearColor(), clearAlpha = _renderer.getClearAlpha();\n        _gl.clearColor(clearColor.r, clearColor.g, clearColor.b, clearAlpha);\n        _gl.enable(_gl.BLEND);\n        if (_renderer.shadowMapCullFace === THREE.CullFaceFront) _gl.cullFace(_gl.BACK);\n    };\n    function createVirtualLight(light, cascade) {\n        var virtualLight = new THREE.DirectionalLight();\n        virtualLight.isVirtual = true;\n        virtualLight.onlyShadow = true;\n        virtualLight.castShadow = true;\n        virtualLight.shadowCameraNear = light.shadowCameraNear;\n        virtualLight.shadowCameraFar = light.shadowCameraFar;\n        virtualLight.shadowCameraLeft = light.shadowCameraLeft;\n        virtualLight.shadowCameraRight = light.shadowCameraRight;\n        virtualLight.shadowCameraBottom = light.shadowCameraBottom;\n        virtualLight.shadowCameraTop = light.shadowCameraTop;\n        virtualLight.shadowCameraVisible = light.shadowCameraVisible;\n        virtualLight.shadowDarkness = light.shadowDarkness;\n        virtualLight.shadowBias = light.shadowCascadeBias[cascade];\n        virtualLight.shadowMapWidth = light.shadowCascadeWidth[cascade];\n        virtualLight.shadowMapHeight = light.shadowCascadeHeight[cascade];\n        virtualLight.pointsWorld = [];\n        virtualLight.pointsFrustum = [];\n        var pointsWorld = virtualLight.pointsWorld, pointsFrustum = virtualLight.pointsFrustum;\n        for(var i = 0; i < 8; i++){\n            pointsWorld[i] = new THREE.Vector3();\n            pointsFrustum[i] = new THREE.Vector3();\n        }\n        var nearZ = light.shadowCascadeNearZ[cascade];\n        var farZ = light.shadowCascadeFarZ[cascade];\n        pointsFrustum[0].set(-1, -1, nearZ);\n        pointsFrustum[1].set(1, -1, nearZ);\n        pointsFrustum[2].set(-1, 1, nearZ);\n        pointsFrustum[3].set(1, 1, nearZ);\n        pointsFrustum[4].set(-1, -1, farZ);\n        pointsFrustum[5].set(1, -1, farZ);\n        pointsFrustum[6].set(-1, 1, farZ);\n        pointsFrustum[7].set(1, 1, farZ);\n        return virtualLight;\n    }\n    // Synchronize virtual light with the original light\n    function updateVirtualLight(light, cascade) {\n        var virtualLight = light.shadowCascadeArray[cascade];\n        virtualLight.position.copy(light.position);\n        virtualLight.target.position.copy(light.target.position);\n        virtualLight.lookAt(virtualLight.target);\n        virtualLight.shadowCameraVisible = light.shadowCameraVisible;\n        virtualLight.shadowDarkness = light.shadowDarkness;\n        virtualLight.shadowBias = light.shadowCascadeBias[cascade];\n        var nearZ = light.shadowCascadeNearZ[cascade];\n        var farZ = light.shadowCascadeFarZ[cascade];\n        var pointsFrustum = virtualLight.pointsFrustum;\n        pointsFrustum[0].z = nearZ;\n        pointsFrustum[1].z = nearZ;\n        pointsFrustum[2].z = nearZ;\n        pointsFrustum[3].z = nearZ;\n        pointsFrustum[4].z = farZ;\n        pointsFrustum[5].z = farZ;\n        pointsFrustum[6].z = farZ;\n        pointsFrustum[7].z = farZ;\n    }\n    // Fit shadow camera's ortho frustum to camera frustum\n    function updateShadowCamera(camera, light) {\n        var shadowCamera = light.shadowCamera, pointsFrustum = light.pointsFrustum, pointsWorld = light.pointsWorld;\n        _min.set(Infinity, Infinity, Infinity);\n        _max.set(-Infinity, -Infinity, -Infinity);\n        for(var i = 0; i < 8; i++){\n            var p = pointsWorld[i];\n            p.copy(pointsFrustum[i]);\n            THREE.ShadowMapPlugin.__projector.unprojectVector(p, camera);\n            p.applyMatrix4(shadowCamera.matrixWorldInverse);\n            if (p.x < _min.x) _min.x = p.x;\n            if (p.x > _max.x) _max.x = p.x;\n            if (p.y < _min.y) _min.y = p.y;\n            if (p.y > _max.y) _max.y = p.y;\n            if (p.z < _min.z) _min.z = p.z;\n            if (p.z > _max.z) _max.z = p.z;\n        }\n        shadowCamera.left = _min.x;\n        shadowCamera.right = _max.x;\n        shadowCamera.top = _max.y;\n        shadowCamera.bottom = _min.y;\n        // can't really fit near/far\n        //shadowCamera.near = _min.z;\n        //shadowCamera.far = _max.z;\n        shadowCamera.updateProjectionMatrix();\n    }\n    // For the moment just ignore objects that have multiple materials with different animation methods\n    // Only the first material will be taken into account for deciding which depth material to use for shadow maps\n    function getObjectMaterial(object) {\n        return object.material instanceof THREE.MeshFaceMaterial ? object.material.materials[0] : object.material;\n    }\n};\nTHREE.ShadowMapPlugin.__projector = new THREE.Projector();\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */ THREE.SpritePlugin = function() {\n    var _gl, _renderer, _precision, _sprite = {};\n    this.init = function(renderer) {\n        _gl = renderer.context;\n        _renderer = renderer;\n        _precision = renderer.getPrecision();\n        _sprite.vertices = new Float32Array(16);\n        _sprite.faces = new Uint16Array(6);\n        var i = 0;\n        _sprite.vertices[i++] = -1;\n        _sprite.vertices[i++] = -1; // vertex 0\n        _sprite.vertices[i++] = 0;\n        _sprite.vertices[i++] = 0; // uv 0\n        _sprite.vertices[i++] = 1;\n        _sprite.vertices[i++] = -1; // vertex 1\n        _sprite.vertices[i++] = 1;\n        _sprite.vertices[i++] = 0; // uv 1\n        _sprite.vertices[i++] = 1;\n        _sprite.vertices[i++] = 1; // vertex 2\n        _sprite.vertices[i++] = 1;\n        _sprite.vertices[i++] = 1; // uv 2\n        _sprite.vertices[i++] = -1;\n        _sprite.vertices[i++] = 1; // vertex 3\n        _sprite.vertices[i++] = 0;\n        _sprite.vertices[i++] = 1; // uv 3\n        i = 0;\n        _sprite.faces[i++] = 0;\n        _sprite.faces[i++] = 1;\n        _sprite.faces[i++] = 2;\n        _sprite.faces[i++] = 0;\n        _sprite.faces[i++] = 2;\n        _sprite.faces[i++] = 3;\n        _sprite.vertexBuffer = _gl.createBuffer();\n        _sprite.elementBuffer = _gl.createBuffer();\n        _gl.bindBuffer(_gl.ARRAY_BUFFER, _sprite.vertexBuffer);\n        _gl.bufferData(_gl.ARRAY_BUFFER, _sprite.vertices, _gl.STATIC_DRAW);\n        _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, _sprite.elementBuffer);\n        _gl.bufferData(_gl.ELEMENT_ARRAY_BUFFER, _sprite.faces, _gl.STATIC_DRAW);\n        _sprite.program = createProgram(THREE.ShaderSprite[\"sprite\"], _precision);\n        _sprite.attributes = {};\n        _sprite.uniforms = {};\n        _sprite.attributes.position = _gl.getAttribLocation(_sprite.program, \"position\");\n        _sprite.attributes.uv = _gl.getAttribLocation(_sprite.program, \"uv\");\n        _sprite.uniforms.uvOffset = _gl.getUniformLocation(_sprite.program, \"uvOffset\");\n        _sprite.uniforms.uvScale = _gl.getUniformLocation(_sprite.program, \"uvScale\");\n        _sprite.uniforms.rotation = _gl.getUniformLocation(_sprite.program, \"rotation\");\n        _sprite.uniforms.scale = _gl.getUniformLocation(_sprite.program, \"scale\");\n        _sprite.uniforms.alignment = _gl.getUniformLocation(_sprite.program, \"alignment\");\n        _sprite.uniforms.color = _gl.getUniformLocation(_sprite.program, \"color\");\n        _sprite.uniforms.map = _gl.getUniformLocation(_sprite.program, \"map\");\n        _sprite.uniforms.opacity = _gl.getUniformLocation(_sprite.program, \"opacity\");\n        _sprite.uniforms.useScreenCoordinates = _gl.getUniformLocation(_sprite.program, \"useScreenCoordinates\");\n        _sprite.uniforms.sizeAttenuation = _gl.getUniformLocation(_sprite.program, \"sizeAttenuation\");\n        _sprite.uniforms.screenPosition = _gl.getUniformLocation(_sprite.program, \"screenPosition\");\n        _sprite.uniforms.modelViewMatrix = _gl.getUniformLocation(_sprite.program, \"modelViewMatrix\");\n        _sprite.uniforms.projectionMatrix = _gl.getUniformLocation(_sprite.program, \"projectionMatrix\");\n        _sprite.uniforms.fogType = _gl.getUniformLocation(_sprite.program, \"fogType\");\n        _sprite.uniforms.fogDensity = _gl.getUniformLocation(_sprite.program, \"fogDensity\");\n        _sprite.uniforms.fogNear = _gl.getUniformLocation(_sprite.program, \"fogNear\");\n        _sprite.uniforms.fogFar = _gl.getUniformLocation(_sprite.program, \"fogFar\");\n        _sprite.uniforms.fogColor = _gl.getUniformLocation(_sprite.program, \"fogColor\");\n        _sprite.uniforms.alphaTest = _gl.getUniformLocation(_sprite.program, \"alphaTest\");\n    };\n    this.render = function(scene, camera, viewportWidth, viewportHeight) {\n        var sprites = scene.__webglSprites, nSprites = sprites.length;\n        if (!nSprites) return;\n        var attributes = _sprite.attributes, uniforms = _sprite.uniforms;\n        var invAspect = viewportHeight / viewportWidth;\n        var halfViewportWidth = viewportWidth * 0.5, halfViewportHeight = viewportHeight * 0.5;\n        // setup gl\n        _gl.useProgram(_sprite.program);\n        _gl.enableVertexAttribArray(attributes.position);\n        _gl.enableVertexAttribArray(attributes.uv);\n        _gl.disable(_gl.CULL_FACE);\n        _gl.enable(_gl.BLEND);\n        _gl.bindBuffer(_gl.ARRAY_BUFFER, _sprite.vertexBuffer);\n        _gl.vertexAttribPointer(attributes.position, 2, _gl.FLOAT, false, 16, 0);\n        _gl.vertexAttribPointer(attributes.uv, 2, _gl.FLOAT, false, 16, 8);\n        _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, _sprite.elementBuffer);\n        _gl.uniformMatrix4fv(uniforms.projectionMatrix, false, camera.projectionMatrix.elements);\n        _gl.activeTexture(_gl.TEXTURE0);\n        _gl.uniform1i(uniforms.map, 0);\n        var oldFogType = 0;\n        var sceneFogType = 0;\n        var fog = scene.fog;\n        if (fog) {\n            _gl.uniform3f(uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b);\n            if (fog instanceof THREE.Fog) {\n                _gl.uniform1f(uniforms.fogNear, fog.near);\n                _gl.uniform1f(uniforms.fogFar, fog.far);\n                _gl.uniform1i(uniforms.fogType, 1);\n                oldFogType = 1;\n                sceneFogType = 1;\n            } else if (fog instanceof THREE.FogExp2) {\n                _gl.uniform1f(uniforms.fogDensity, fog.density);\n                _gl.uniform1i(uniforms.fogType, 2);\n                oldFogType = 2;\n                sceneFogType = 2;\n            }\n        } else {\n            _gl.uniform1i(uniforms.fogType, 0);\n            oldFogType = 0;\n            sceneFogType = 0;\n        }\n        // update positions and sort\n        var i, sprite, material, screenPosition, size, fogType, scale = [];\n        for(i = 0; i < nSprites; i++){\n            sprite = sprites[i];\n            material = sprite.material;\n            if (!sprite.visible || material.opacity === 0) continue;\n            if (!material.useScreenCoordinates) {\n                sprite._modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, sprite.matrixWorld);\n                sprite.z = -sprite._modelViewMatrix.elements[14];\n            } else sprite.z = -sprite.position.z;\n        }\n        sprites.sort(painterSortStable);\n        // render all sprites\n        for(i = 0; i < nSprites; i++){\n            sprite = sprites[i];\n            material = sprite.material;\n            if (!sprite.visible || material.opacity === 0) continue;\n            if (material.map && material.map.image && material.map.image.width) {\n                _gl.uniform1f(uniforms.alphaTest, material.alphaTest);\n                if (material.useScreenCoordinates === true) {\n                    _gl.uniform1i(uniforms.useScreenCoordinates, 1);\n                    _gl.uniform3f(uniforms.screenPosition, (sprite.position.x * _renderer.devicePixelRatio - halfViewportWidth) / halfViewportWidth, (halfViewportHeight - sprite.position.y * _renderer.devicePixelRatio) / halfViewportHeight, Math.max(0, Math.min(1, sprite.position.z)));\n                    scale[0] = _renderer.devicePixelRatio;\n                    scale[1] = _renderer.devicePixelRatio;\n                } else {\n                    _gl.uniform1i(uniforms.useScreenCoordinates, 0);\n                    _gl.uniform1i(uniforms.sizeAttenuation, material.sizeAttenuation ? 1 : 0);\n                    _gl.uniformMatrix4fv(uniforms.modelViewMatrix, false, sprite._modelViewMatrix.elements);\n                    scale[0] = 1;\n                    scale[1] = 1;\n                }\n                if (scene.fog && material.fog) fogType = sceneFogType;\n                else fogType = 0;\n                if (oldFogType !== fogType) {\n                    _gl.uniform1i(uniforms.fogType, fogType);\n                    oldFogType = fogType;\n                }\n                size = 1 / (material.scaleByViewport ? viewportHeight : 1);\n                scale[0] *= size * invAspect * sprite.scale.x;\n                scale[1] *= size * sprite.scale.y;\n                _gl.uniform2f(uniforms.uvScale, material.uvScale.x, material.uvScale.y);\n                _gl.uniform2f(uniforms.uvOffset, material.uvOffset.x, material.uvOffset.y);\n                _gl.uniform2f(uniforms.alignment, material.alignment.x, material.alignment.y);\n                _gl.uniform1f(uniforms.opacity, material.opacity);\n                _gl.uniform3f(uniforms.color, material.color.r, material.color.g, material.color.b);\n                _gl.uniform1f(uniforms.rotation, sprite.rotation);\n                _gl.uniform2fv(uniforms.scale, scale);\n                _renderer.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst);\n                _renderer.setDepthTest(material.depthTest);\n                _renderer.setDepthWrite(material.depthWrite);\n                _renderer.setTexture(material.map, 0);\n                _gl.drawElements(_gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0);\n            }\n        }\n        // restore gl\n        _gl.enable(_gl.CULL_FACE);\n    };\n    function createProgram(shader, precision) {\n        var program = _gl.createProgram();\n        var fragmentShader = _gl.createShader(_gl.FRAGMENT_SHADER);\n        var vertexShader = _gl.createShader(_gl.VERTEX_SHADER);\n        var prefix = \"precision \" + precision + \" float;\\n\";\n        _gl.shaderSource(fragmentShader, prefix + shader.fragmentShader);\n        _gl.shaderSource(vertexShader, prefix + shader.vertexShader);\n        _gl.compileShader(fragmentShader);\n        _gl.compileShader(vertexShader);\n        _gl.attachShader(program, fragmentShader);\n        _gl.attachShader(program, vertexShader);\n        _gl.linkProgram(program);\n        return program;\n    }\n    function painterSortStable(a, b) {\n        if (a.z !== b.z) return b.z - a.z;\n        else return b.id - a.id;\n    }\n};\n/**\n * @author alteredq / http://alteredqualia.com/\n */ THREE.DepthPassPlugin = function() {\n    this.enabled = false;\n    this.renderTarget = null;\n    var _gl, _renderer, _depthMaterial, _depthMaterialMorph, _depthMaterialSkin, _depthMaterialMorphSkin, _frustum = new THREE.Frustum(), _projScreenMatrix = new THREE.Matrix4();\n    this.init = function(renderer) {\n        _gl = renderer.context;\n        _renderer = renderer;\n        var depthShader = THREE.ShaderLib[\"depthRGBA\"];\n        var depthUniforms = THREE.UniformsUtils.clone(depthShader.uniforms);\n        _depthMaterial = new THREE.ShaderMaterial({\n            fragmentShader: depthShader.fragmentShader,\n            vertexShader: depthShader.vertexShader,\n            uniforms: depthUniforms\n        });\n        _depthMaterialMorph = new THREE.ShaderMaterial({\n            fragmentShader: depthShader.fragmentShader,\n            vertexShader: depthShader.vertexShader,\n            uniforms: depthUniforms,\n            morphTargets: true\n        });\n        _depthMaterialSkin = new THREE.ShaderMaterial({\n            fragmentShader: depthShader.fragmentShader,\n            vertexShader: depthShader.vertexShader,\n            uniforms: depthUniforms,\n            skinning: true\n        });\n        _depthMaterialMorphSkin = new THREE.ShaderMaterial({\n            fragmentShader: depthShader.fragmentShader,\n            vertexShader: depthShader.vertexShader,\n            uniforms: depthUniforms,\n            morphTargets: true,\n            skinning: true\n        });\n        _depthMaterial._shadowPass = true;\n        _depthMaterialMorph._shadowPass = true;\n        _depthMaterialSkin._shadowPass = true;\n        _depthMaterialMorphSkin._shadowPass = true;\n    };\n    this.render = function(scene, camera) {\n        if (!this.enabled) return;\n        this.update(scene, camera);\n    };\n    this.update = function(scene, camera) {\n        var i, il, j, jl, n, program, buffer, material, webglObject, object, light, renderList, fog = null;\n        // set GL state for depth map\n        _gl.clearColor(1, 1, 1, 1);\n        _gl.disable(_gl.BLEND);\n        _renderer.setDepthTest(true);\n        // update scene\n        if (_renderer.autoUpdateScene) scene.updateMatrixWorld();\n        // update camera matrices and frustum\n        camera.matrixWorldInverse.getInverse(camera.matrixWorld);\n        _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);\n        _frustum.setFromMatrix(_projScreenMatrix);\n        // render depth map\n        _renderer.setRenderTarget(this.renderTarget);\n        _renderer.clear();\n        // set object matrices & frustum culling\n        renderList = scene.__webglObjects;\n        for(j = 0, jl = renderList.length; j < jl; j++){\n            webglObject = renderList[j];\n            object = webglObject.object;\n            webglObject.render = false;\n            if (object.visible) {\n                if (!(object instanceof THREE.Mesh || object instanceof THREE.ParticleSystem) || !object.frustumCulled || _frustum.intersectsObject(object)) {\n                    object._modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);\n                    webglObject.render = true;\n                }\n            }\n        }\n        // render regular objects\n        var objectMaterial, useMorphing, useSkinning;\n        for(j = 0, jl = renderList.length; j < jl; j++){\n            webglObject = renderList[j];\n            if (webglObject.render) {\n                object = webglObject.object;\n                buffer = webglObject.buffer;\n                // todo: create proper depth material for particles\n                if (object instanceof THREE.ParticleSystem && !object.customDepthMaterial) continue;\n                objectMaterial = getObjectMaterial(object);\n                if (objectMaterial) _renderer.setMaterialFaces(object.material);\n                useMorphing = object.geometry.morphTargets.length > 0 && objectMaterial.morphTargets;\n                useSkinning = object instanceof THREE.SkinnedMesh && objectMaterial.skinning;\n                if (object.customDepthMaterial) material = object.customDepthMaterial;\n                else if (useSkinning) material = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;\n                else if (useMorphing) material = _depthMaterialMorph;\n                else material = _depthMaterial;\n                if (buffer instanceof THREE.BufferGeometry) _renderer.renderBufferDirect(camera, scene.__lights, fog, material, buffer, object);\n                else _renderer.renderBuffer(camera, scene.__lights, fog, material, buffer, object);\n            }\n        }\n        // set matrices and render immediate objects\n        renderList = scene.__webglObjectsImmediate;\n        for(j = 0, jl = renderList.length; j < jl; j++){\n            webglObject = renderList[j];\n            object = webglObject.object;\n            if (object.visible) {\n                object._modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);\n                _renderer.renderImmediateObject(camera, scene.__lights, fog, _depthMaterial, object);\n            }\n        }\n        // restore GL state\n        var clearColor = _renderer.getClearColor(), clearAlpha = _renderer.getClearAlpha();\n        _gl.clearColor(clearColor.r, clearColor.g, clearColor.b, clearAlpha);\n        _gl.enable(_gl.BLEND);\n    };\n    // For the moment just ignore objects that have multiple materials with different animation methods\n    // Only the first material will be taken into account for deciding which depth material to use\n    function getObjectMaterial(object) {\n        return object.material instanceof THREE.MeshFaceMaterial ? object.material.materials[0] : object.material;\n    }\n};\n/**\n * @author mikael emtinger / http://gomo.se/\n *\n */ THREE.ShaderFlares = {\n    \"lensFlareVertexTexture\": {\n        vertexShader: [\n            \"uniform lowp int renderType;\",\n            \"uniform vec3 screenPosition;\",\n            \"uniform vec2 scale;\",\n            \"uniform float rotation;\",\n            \"uniform sampler2D occlusionMap;\",\n            \"attribute vec2 position;\",\n            \"attribute vec2 uv;\",\n            \"varying vec2 vUV;\",\n            \"varying float vVisibility;\",\n            \"void main() {\",\n            \"vUV = uv;\",\n            \"vec2 pos = position;\",\n            \"if( renderType == 2 ) {\",\n            \"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) ) +\",\n            \"texture2D( occlusionMap, vec2( 0.5, 0.1 ) ) +\",\n            \"texture2D( occlusionMap, vec2( 0.9, 0.1 ) ) +\",\n            \"texture2D( occlusionMap, vec2( 0.9, 0.5 ) ) +\",\n            \"texture2D( occlusionMap, vec2( 0.9, 0.9 ) ) +\",\n            \"texture2D( occlusionMap, vec2( 0.5, 0.9 ) ) +\",\n            \"texture2D( occlusionMap, vec2( 0.1, 0.9 ) ) +\",\n            \"texture2D( occlusionMap, vec2( 0.1, 0.5 ) ) +\",\n            \"texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\",\n            \"vVisibility = (       visibility.r / 9.0 ) *\",\n            \"( 1.0 - visibility.g / 9.0 ) *\",\n            \"(       visibility.b / 9.0 ) *\",\n            \"( 1.0 - visibility.a / 9.0 );\",\n            \"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\n            \"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\n            \"}\",\n            \"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\n            \"}\"\n        ].join(\"\\n\"),\n        fragmentShader: [\n            \"uniform lowp int renderType;\",\n            \"uniform sampler2D map;\",\n            \"uniform float opacity;\",\n            \"uniform vec3 color;\",\n            \"varying vec2 vUV;\",\n            \"varying float vVisibility;\",\n            \"void main() {\",\n            // pink square\n            \"if( renderType == 0 ) {\",\n            \"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\",\n            // restore\n            \"} else if( renderType == 1 ) {\",\n            \"gl_FragColor = texture2D( map, vUV );\",\n            // flare\n            \"} else {\",\n            \"vec4 texture = texture2D( map, vUV );\",\n            \"texture.a *= opacity * vVisibility;\",\n            \"gl_FragColor = texture;\",\n            \"gl_FragColor.rgb *= color;\",\n            \"}\",\n            \"}\"\n        ].join(\"\\n\")\n    },\n    \"lensFlare\": {\n        vertexShader: [\n            \"uniform lowp int renderType;\",\n            \"uniform vec3 screenPosition;\",\n            \"uniform vec2 scale;\",\n            \"uniform float rotation;\",\n            \"attribute vec2 position;\",\n            \"attribute vec2 uv;\",\n            \"varying vec2 vUV;\",\n            \"void main() {\",\n            \"vUV = uv;\",\n            \"vec2 pos = position;\",\n            \"if( renderType == 2 ) {\",\n            \"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\n            \"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\n            \"}\",\n            \"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\n            \"}\"\n        ].join(\"\\n\"),\n        fragmentShader: [\n            \"precision mediump float;\",\n            \"uniform lowp int renderType;\",\n            \"uniform sampler2D map;\",\n            \"uniform sampler2D occlusionMap;\",\n            \"uniform float opacity;\",\n            \"uniform vec3 color;\",\n            \"varying vec2 vUV;\",\n            \"void main() {\",\n            // pink square\n            \"if( renderType == 0 ) {\",\n            \"gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );\",\n            // restore\n            \"} else if( renderType == 1 ) {\",\n            \"gl_FragColor = texture2D( map, vUV );\",\n            // flare\n            \"} else {\",\n            \"float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a +\",\n            \"texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a +\",\n            \"texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a +\",\n            \"texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;\",\n            \"visibility = ( 1.0 - visibility / 4.0 );\",\n            \"vec4 texture = texture2D( map, vUV );\",\n            \"texture.a *= opacity * visibility;\",\n            \"gl_FragColor = texture;\",\n            \"gl_FragColor.rgb *= color;\",\n            \"}\",\n            \"}\"\n        ].join(\"\\n\")\n    }\n};\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n *\n */ THREE.ShaderSprite = {\n    \"sprite\": {\n        vertexShader: [\n            \"uniform int useScreenCoordinates;\",\n            \"uniform int sizeAttenuation;\",\n            \"uniform vec3 screenPosition;\",\n            \"uniform mat4 modelViewMatrix;\",\n            \"uniform mat4 projectionMatrix;\",\n            \"uniform float rotation;\",\n            \"uniform vec2 scale;\",\n            \"uniform vec2 alignment;\",\n            \"uniform vec2 uvOffset;\",\n            \"uniform vec2 uvScale;\",\n            \"attribute vec2 position;\",\n            \"attribute vec2 uv;\",\n            \"varying vec2 vUV;\",\n            \"void main() {\",\n            \"vUV = uvOffset + uv * uvScale;\",\n            \"vec2 alignedPosition = position + alignment;\",\n            \"vec2 rotatedPosition;\",\n            \"rotatedPosition.x = ( cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y ) * scale.x;\",\n            \"rotatedPosition.y = ( sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y ) * scale.y;\",\n            \"vec4 finalPosition;\",\n            \"if( useScreenCoordinates != 0 ) {\",\n            \"finalPosition = vec4( screenPosition.xy + rotatedPosition, screenPosition.z, 1.0 );\",\n            \"} else {\",\n            \"finalPosition = projectionMatrix * modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\",\n            \"finalPosition.xy += rotatedPosition * ( sizeAttenuation == 1 ? 1.0 : finalPosition.z );\",\n            \"}\",\n            \"gl_Position = finalPosition;\",\n            \"}\"\n        ].join(\"\\n\"),\n        fragmentShader: [\n            \"uniform vec3 color;\",\n            \"uniform sampler2D map;\",\n            \"uniform float opacity;\",\n            \"uniform int fogType;\",\n            \"uniform vec3 fogColor;\",\n            \"uniform float fogDensity;\",\n            \"uniform float fogNear;\",\n            \"uniform float fogFar;\",\n            \"uniform float alphaTest;\",\n            \"varying vec2 vUV;\",\n            \"void main() {\",\n            \"vec4 texture = texture2D( map, vUV );\",\n            \"if ( texture.a < alphaTest ) discard;\",\n            \"gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );\",\n            \"if ( fogType > 0 ) {\",\n            \"float depth = gl_FragCoord.z / gl_FragCoord.w;\",\n            \"float fogFactor = 0.0;\",\n            \"if ( fogType == 1 ) {\",\n            \"fogFactor = smoothstep( fogNear, fogFar, depth );\",\n            \"} else {\",\n            \"const float LOG2 = 1.442695;\",\n            \"float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\",\n            \"fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\",\n            \"}\",\n            \"gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\",\n            \"}\",\n            \"}\"\n        ].join(\"\\n\")\n    }\n};\n\n//# sourceMappingURL=index.07b7c40d.js.map\n","/**\n * @author mrdoob / http://mrdoob.com/\n * @author Larry Battle / http://bateru.com/news\n */\n\nvar THREE = THREE || { REVISION: '56' };\n\nself.console = self.console || {\n\n\tinfo: function () {},\n\tlog: function () {},\n\tdebug: function () {},\n\twarn: function () {},\n\terror: function () {}\n\n};\n\nself.Int32Array = self.Int32Array || Array;\nself.Float32Array = self.Float32Array || Array;\n\nString.prototype.trim = String.prototype.trim || function () {\n\n\treturn this.replace( /^\\s+|\\s+$/g, '' );\n\n};\n\n// based on https://github.com/documentcloud/underscore/blob/bf657be243a075b5e72acc8a83e6f12a564d8f55/underscore.js#L767\nTHREE.extend = function ( obj, source ) {\n\n\t// ECMAScript5 compatibility based on: http://www.nczonline.net/blog/2012/12/11/are-your-mixins-ecmascript-5-compatible/\n\tif ( Object.keys ) {\n\n\t\tvar keys = Object.keys( source );\n\n\t\tfor (var i = 0, il = keys.length; i < il; i++) {\n\n\t\t\tvar prop = keys[i];\n\t\t\tObject.defineProperty( obj, prop, Object.getOwnPropertyDescriptor( source, prop ) );\n\n\t\t}\n\n\t} else {\n\n\t\tvar safeHasOwnProperty = {}.hasOwnProperty;\n\n\t\tfor ( var prop in source ) {\n\n\t\t\tif ( safeHasOwnProperty.call( source, prop ) ) {\n\n\t\t\t\tobj[prop] = source[prop];\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn obj;\n\n};\n\n// http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating\n\n// requestAnimationFrame polyfill by Erik Mller\n// fixes from Paul Irish and Tino Zijdel\n\n( function () {\n\n\tvar lastTime = 0;\n\tvar vendors = [ 'ms', 'moz', 'webkit', 'o' ];\n\n\tfor ( var x = 0; x < vendors.length && !window.requestAnimationFrame; ++ x ) {\n\n\t\twindow.requestAnimationFrame = window[ vendors[ x ] + 'RequestAnimationFrame' ];\n\t\twindow.cancelAnimationFrame = window[ vendors[ x ] + 'CancelAnimationFrame' ] || window[ vendors[ x ] + 'CancelRequestAnimationFrame' ];\n\n\t}\n\n\tif ( window.requestAnimationFrame === undefined ) {\n\n\t\twindow.requestAnimationFrame = function ( callback ) {\n\n\t\t\tvar currTime = Date.now(), timeToCall = Math.max( 0, 16 - ( currTime - lastTime ) );\n\t\t\tvar id = window.setTimeout( function() { callback( currTime + timeToCall ); }, timeToCall );\n\t\t\tlastTime = currTime + timeToCall;\n\t\t\treturn id;\n\n\t\t};\n\n\t}\n\n\twindow.cancelAnimationFrame = window.cancelAnimationFrame || function ( id ) { window.clearTimeout( id ) };\n\n}() );\n\n// GL STATE CONSTANTS\n\nTHREE.CullFaceNone = 0;\nTHREE.CullFaceBack = 1;\nTHREE.CullFaceFront = 2;\nTHREE.CullFaceFrontBack = 3;\n\nTHREE.FrontFaceDirectionCW = 0;\nTHREE.FrontFaceDirectionCCW = 1;\n\n// SHADOWING TYPES\n\nTHREE.BasicShadowMap = 0;\nTHREE.PCFShadowMap = 1;\nTHREE.PCFSoftShadowMap = 2;\n\n// MATERIAL CONSTANTS\n\n// side\n\nTHREE.FrontSide = 0;\nTHREE.BackSide = 1;\nTHREE.DoubleSide = 2;\n\n// shading\n\nTHREE.NoShading = 0;\nTHREE.FlatShading = 1;\nTHREE.SmoothShading = 2;\n\n// colors\n\nTHREE.NoColors = 0;\nTHREE.FaceColors = 1;\nTHREE.VertexColors = 2;\n\n// blending modes\n\nTHREE.NoBlending = 0;\nTHREE.NormalBlending = 1;\nTHREE.AdditiveBlending = 2;\nTHREE.SubtractiveBlending = 3;\nTHREE.MultiplyBlending = 4;\nTHREE.CustomBlending = 5;\n\n// custom blending equations\n// (numbers start from 100 not to clash with other\n//  mappings to OpenGL constants defined in Texture.js)\n\nTHREE.AddEquation = 100;\nTHREE.SubtractEquation = 101;\nTHREE.ReverseSubtractEquation = 102;\n\n// custom blending destination factors\n\nTHREE.ZeroFactor = 200;\nTHREE.OneFactor = 201;\nTHREE.SrcColorFactor = 202;\nTHREE.OneMinusSrcColorFactor = 203;\nTHREE.SrcAlphaFactor = 204;\nTHREE.OneMinusSrcAlphaFactor = 205;\nTHREE.DstAlphaFactor = 206;\nTHREE.OneMinusDstAlphaFactor = 207;\n\n// custom blending source factors\n\n//THREE.ZeroFactor = 200;\n//THREE.OneFactor = 201;\n//THREE.SrcAlphaFactor = 204;\n//THREE.OneMinusSrcAlphaFactor = 205;\n//THREE.DstAlphaFactor = 206;\n//THREE.OneMinusDstAlphaFactor = 207;\nTHREE.DstColorFactor = 208;\nTHREE.OneMinusDstColorFactor = 209;\nTHREE.SrcAlphaSaturateFactor = 210;\n\n\n// TEXTURE CONSTANTS\n\nTHREE.MultiplyOperation = 0;\nTHREE.MixOperation = 1;\nTHREE.AddOperation = 2;\n\n// Mapping modes\n\nTHREE.UVMapping = function () {};\n\nTHREE.CubeReflectionMapping = function () {};\nTHREE.CubeRefractionMapping = function () {};\n\nTHREE.SphericalReflectionMapping = function () {};\nTHREE.SphericalRefractionMapping = function () {};\n\n// Wrapping modes\n\nTHREE.RepeatWrapping = 1000;\nTHREE.ClampToEdgeWrapping = 1001;\nTHREE.MirroredRepeatWrapping = 1002;\n\n// Filters\n\nTHREE.NearestFilter = 1003;\nTHREE.NearestMipMapNearestFilter = 1004;\nTHREE.NearestMipMapLinearFilter = 1005;\nTHREE.LinearFilter = 1006;\nTHREE.LinearMipMapNearestFilter = 1007;\nTHREE.LinearMipMapLinearFilter = 1008;\n\n// Data types\n\nTHREE.UnsignedByteType = 1009;\nTHREE.ByteType = 1010;\nTHREE.ShortType = 1011;\nTHREE.UnsignedShortType = 1012;\nTHREE.IntType = 1013;\nTHREE.UnsignedIntType = 1014;\nTHREE.FloatType = 1015;\n\n// Pixel types\n\n//THREE.UnsignedByteType = 1009;\nTHREE.UnsignedShort4444Type = 1016;\nTHREE.UnsignedShort5551Type = 1017;\nTHREE.UnsignedShort565Type = 1018;\n\n// Pixel formats\n\nTHREE.AlphaFormat = 1019;\nTHREE.RGBFormat = 1020;\nTHREE.RGBAFormat = 1021;\nTHREE.LuminanceFormat = 1022;\nTHREE.LuminanceAlphaFormat = 1023;\n\n// Compressed texture formats\n\nTHREE.RGB_S3TC_DXT1_Format = 2001;\nTHREE.RGBA_S3TC_DXT1_Format = 2002;\nTHREE.RGBA_S3TC_DXT3_Format = 2003;\nTHREE.RGBA_S3TC_DXT5_Format = 2004;\n\n/*\n// Potential future PVRTC compressed texture formats\nTHREE.RGB_PVRTC_4BPPV1_Format = 2100;\nTHREE.RGB_PVRTC_2BPPV1_Format = 2101;\nTHREE.RGBA_PVRTC_4BPPV1_Format = 2102;\nTHREE.RGBA_PVRTC_2BPPV1_Format = 2103;\n*/\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Color = function ( value ) {\n\n\tif ( value !== undefined ) this.set( value );\n\n\treturn this;\n\n};\n\nTHREE.extend( THREE.Color.prototype, {\n\n\tr: 1, g: 1, b: 1,\n\n\tset: function ( value ) {\n\n\t\tswitch ( typeof value ) {\n\n\t\t\tcase \"number\":\n\t\t\t\tthis.setHex( value );\n\t\t\t\tbreak;\n\n\t\t\tcase \"string\":\n\t\t\t\tthis.setStyle( value );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t},\n\n\tsetHex: function ( hex ) {\n\n\t\thex = Math.floor( hex );\n\n\t\tthis.r = ( hex >> 16 & 255 ) / 255;\n\t\tthis.g = ( hex >> 8 & 255 ) / 255;\n\t\tthis.b = ( hex & 255 ) / 255;\n\n\t\treturn this;\n\n\t},\n\n\tsetRGB: function ( r, g, b ) {\n\n\t\tthis.r = r;\n\t\tthis.g = g;\n\t\tthis.b = b;\n\n\t\treturn this;\n\n\t},\n\n\tsetHSV: function ( h, s, v ) {\n\n\t\tconsole.log( 'DEPRECATED: Color\\'s .setHSV() will be removed. Use .setHSL( h, s, l ) instead.' );\n\t\treturn this.setHSL(h,s*v/((h=(2-s)*v)<1?h:2-h),h/2); // https://gist.github.com/xpansive/1337890\n\n\t},\n\n\tsetHSL: function ( h, s, l ) {\n\n\t\t// h,s,l ranges are in 0.0 - 1.0\n\n\t\tif ( s === 0 ) {\n\n\t\t\tthis.r = this.g = this.b = l;\n\n\t\t} else {\n\n\t\t\tvar hue2rgb = function ( p, q, t ) {\n\n\t\t\t\tif ( t < 0 ) t += 1;\n\t\t\t\tif ( t > 1 ) t -= 1;\n\t\t\t\tif ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\n\t\t\t\tif ( t < 1 / 2 ) return q;\n\t\t\t\tif ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\n\t\t\t\treturn p;\n\n\t\t\t};\n\n\t\t\tvar p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\n\t\t\tvar q = ( 2 * l ) - p;\n\n\t\t\tthis.r = hue2rgb( q, p, h + 1 / 3 );\n\t\t\tthis.g = hue2rgb( q, p, h );\n\t\t\tthis.b = hue2rgb( q, p, h - 1 / 3 );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetStyle: function ( style ) {\n\n\t\t// rgb(255,0,0)\n\n\t\tif ( /^rgb\\((\\d+),(\\d+),(\\d+)\\)$/i.test( style ) ) {\n\n\t\t\tvar color = /^rgb\\((\\d+),(\\d+),(\\d+)\\)$/i.exec( style );\n\n\t\t\tthis.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;\n\t\t\tthis.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;\n\t\t\tthis.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t// rgb(100%,0%,0%)\n\n\t\tif ( /^rgb\\((\\d+)\\%,(\\d+)\\%,(\\d+)\\%\\)$/i.test( style ) ) {\n\n\t\t\tvar color = /^rgb\\((\\d+)\\%,(\\d+)\\%,(\\d+)\\%\\)$/i.exec( style );\n\n\t\t\tthis.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;\n\t\t\tthis.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;\n\t\t\tthis.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t// #ff0000\n\n\t\tif ( /^\\#([0-9a-f]{6})$/i.test( style ) ) {\n\n\t\t\tvar color = /^\\#([0-9a-f]{6})$/i.exec( style );\n\n\t\t\tthis.setHex( parseInt( color[ 1 ], 16 ) );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t// #f00\n\n\t\tif ( /^\\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test( style ) ) {\n\n\t\t\tvar color = /^\\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec( style );\n\n\t\t\tthis.setHex( parseInt( color[ 1 ] + color[ 1 ] + color[ 2 ] + color[ 2 ] + color[ 3 ] + color[ 3 ], 16 ) );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t// red\n\n\t\tif ( /^(\\w+)$/i.test( style ) ) {\n\n\t\t\tthis.setHex( THREE.ColorKeywords[ style ] );\n\n\t\t\treturn this;\n\n\t\t}\n\n\n\t},\n\n\tcopy: function ( color ) {\n\n\t\tthis.r = color.r;\n\t\tthis.g = color.g;\n\t\tthis.b = color.b;\n\n\t\treturn this;\n\n\t},\n\n\tcopyGammaToLinear: function ( color ) {\n\n\t\tthis.r = color.r * color.r;\n\t\tthis.g = color.g * color.g;\n\t\tthis.b = color.b * color.b;\n\n\t\treturn this;\n\n\t},\n\n\tcopyLinearToGamma: function ( color ) {\n\n\t\tthis.r = Math.sqrt( color.r );\n\t\tthis.g = Math.sqrt( color.g );\n\t\tthis.b = Math.sqrt( color.b );\n\n\t\treturn this;\n\n\t},\n\n\tconvertGammaToLinear: function () {\n\n\t\tvar r = this.r, g = this.g, b = this.b;\n\n\t\tthis.r = r * r;\n\t\tthis.g = g * g;\n\t\tthis.b = b * b;\n\n\t\treturn this;\n\n\t},\n\n\tconvertLinearToGamma: function () {\n\n\t\tthis.r = Math.sqrt( this.r );\n\t\tthis.g = Math.sqrt( this.g );\n\t\tthis.b = Math.sqrt( this.b );\n\n\t\treturn this;\n\n\t},\n\n\tgetHex: function () {\n\n\t\treturn ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;\n\n\t},\n\n\tgetHexString: function () {\n\n\t\treturn ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );\n\n\t},\n\n\tgetHSL: function () {\n\n\t\tvar hsl = { h: 0, s: 0, l: 0 };\n\n\t\treturn function () {\n\n\t\t\t// h,s,l ranges are in 0.0 - 1.0\n\n\t\t\tvar r = this.r, g = this.g, b = this.b;\n\n\t\t\tvar max = Math.max( r, g, b );\n\t\t\tvar min = Math.min( r, g, b );\n\n\t\t\tvar hue, saturation;\n\t\t\tvar lightness = ( min + max ) / 2.0;\n\n\t\t\tif ( min === max ) {\n\n\t\t\t\thue = 0;\n\t\t\t\tsaturation = 0;\n\n\t\t\t} else {\n\n\t\t\t\tvar delta = max - min;\n\n\t\t\t\tsaturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\n\n\t\t\t\tswitch ( max ) {\n\n\t\t\t\t\tcase r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\n\t\t\t\t\tcase g: hue = ( b - r ) / delta + 2; break;\n\t\t\t\t\tcase b: hue = ( r - g ) / delta + 4; break;\n\n\t\t\t\t}\n\n\t\t\t\thue /= 6;\n\n\t\t\t}\n\n\t\t\thsl.h = hue;\n\t\t\thsl.s = saturation;\n\t\t\thsl.l = lightness;\n\n\t\t\treturn hsl;\n\n\t\t};\n\n\t}(),\n\n\tgetStyle: function () {\n\n\t\treturn 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';\n\n\t},\n\n\toffsetHSL: function ( h, s, l ) {\n\n\t\tvar hsl = this.getHSL();\n\n\t\thsl.h += h; hsl.s += s; hsl.l += l;\n\n\t\tthis.setHSL( hsl.h, hsl.s, hsl.l );\n\n\t\treturn this;\n\n\t},\n\n\tadd: function ( color ) {\n\n\t\tthis.r += color.r;\n\t\tthis.g += color.g;\n\t\tthis.b += color.b;\n\n\t\treturn this;\n\n\t},\n\n\taddColors: function ( color1, color2 ) {\n\n\t\tthis.r = color1.r + color2.r;\n\t\tthis.g = color1.g + color2.g;\n\t\tthis.b = color1.b + color2.b;\n\n\t\treturn this;\n\n\t},\n\n\taddScalar: function ( s ) {\n\n\t\tthis.r += s;\n\t\tthis.g += s;\n\t\tthis.b += s;\n\n\t\treturn this;\n\n\t},\n\n\tmultiply: function ( color ) {\n\n\t\tthis.r *= color.r;\n\t\tthis.g *= color.g;\n\t\tthis.b *= color.b;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( s ) {\n\n\t\tthis.r *= s;\n\t\tthis.g *= s;\n\t\tthis.b *= s;\n\n\t\treturn this;\n\n\t},\n\n\tlerp: function ( color, alpha ) {\n\n\t\tthis.r += ( color.r - this.r ) * alpha;\n\t\tthis.g += ( color.g - this.g ) * alpha;\n\t\tthis.b += ( color.b - this.b ) * alpha;\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new THREE.Color().setRGB( this.r, this.g, this.b );\n\n\t}\n\n} );\n\nTHREE.ColorKeywords = { \"aliceblue\": 0xF0F8FF, \"antiquewhite\": 0xFAEBD7, \"aqua\": 0x00FFFF, \"aquamarine\": 0x7FFFD4, \"azure\": 0xF0FFFF,\n\"beige\": 0xF5F5DC, \"bisque\": 0xFFE4C4, \"black\": 0x000000, \"blanchedalmond\": 0xFFEBCD, \"blue\": 0x0000FF, \"blueviolet\": 0x8A2BE2,\n\"brown\": 0xA52A2A, \"burlywood\": 0xDEB887, \"cadetblue\": 0x5F9EA0, \"chartreuse\": 0x7FFF00, \"chocolate\": 0xD2691E, \"coral\": 0xFF7F50,\n\"cornflowerblue\": 0x6495ED, \"cornsilk\": 0xFFF8DC, \"crimson\": 0xDC143C, \"cyan\": 0x00FFFF, \"darkblue\": 0x00008B, \"darkcyan\": 0x008B8B,\n\"darkgoldenrod\": 0xB8860B, \"darkgray\": 0xA9A9A9, \"darkgreen\": 0x006400, \"darkgrey\": 0xA9A9A9, \"darkkhaki\": 0xBDB76B, \"darkmagenta\": 0x8B008B,\n\"darkolivegreen\": 0x556B2F, \"darkorange\": 0xFF8C00, \"darkorchid\": 0x9932CC, \"darkred\": 0x8B0000, \"darksalmon\": 0xE9967A, \"darkseagreen\": 0x8FBC8F,\n\"darkslateblue\": 0x483D8B, \"darkslategray\": 0x2F4F4F, \"darkslategrey\": 0x2F4F4F, \"darkturquoise\": 0x00CED1, \"darkviolet\": 0x9400D3,\n\"deeppink\": 0xFF1493, \"deepskyblue\": 0x00BFFF, \"dimgray\": 0x696969, \"dimgrey\": 0x696969, \"dodgerblue\": 0x1E90FF, \"firebrick\": 0xB22222,\n\"floralwhite\": 0xFFFAF0, \"forestgreen\": 0x228B22, \"fuchsia\": 0xFF00FF, \"gainsboro\": 0xDCDCDC, \"ghostwhite\": 0xF8F8FF, \"gold\": 0xFFD700,\n\"goldenrod\": 0xDAA520, \"gray\": 0x808080, \"green\": 0x008000, \"greenyellow\": 0xADFF2F, \"grey\": 0x808080, \"honeydew\": 0xF0FFF0, \"hotpink\": 0xFF69B4,\n\"indianred\": 0xCD5C5C, \"indigo\": 0x4B0082, \"ivory\": 0xFFFFF0, \"khaki\": 0xF0E68C, \"lavender\": 0xE6E6FA, \"lavenderblush\": 0xFFF0F5, \"lawngreen\": 0x7CFC00,\n\"lemonchiffon\": 0xFFFACD, \"lightblue\": 0xADD8E6, \"lightcoral\": 0xF08080, \"lightcyan\": 0xE0FFFF, \"lightgoldenrodyellow\": 0xFAFAD2, \"lightgray\": 0xD3D3D3,\n\"lightgreen\": 0x90EE90, \"lightgrey\": 0xD3D3D3, \"lightpink\": 0xFFB6C1, \"lightsalmon\": 0xFFA07A, \"lightseagreen\": 0x20B2AA, \"lightskyblue\": 0x87CEFA,\n\"lightslategray\": 0x778899, \"lightslategrey\": 0x778899, \"lightsteelblue\": 0xB0C4DE, \"lightyellow\": 0xFFFFE0, \"lime\": 0x00FF00, \"limegreen\": 0x32CD32,\n\"linen\": 0xFAF0E6, \"magenta\": 0xFF00FF, \"maroon\": 0x800000, \"mediumaquamarine\": 0x66CDAA, \"mediumblue\": 0x0000CD, \"mediumorchid\": 0xBA55D3,\n\"mediumpurple\": 0x9370DB, \"mediumseagreen\": 0x3CB371, \"mediumslateblue\": 0x7B68EE, \"mediumspringgreen\": 0x00FA9A, \"mediumturquoise\": 0x48D1CC,\n\"mediumvioletred\": 0xC71585, \"midnightblue\": 0x191970, \"mintcream\": 0xF5FFFA, \"mistyrose\": 0xFFE4E1, \"moccasin\": 0xFFE4B5, \"navajowhite\": 0xFFDEAD,\n\"navy\": 0x000080, \"oldlace\": 0xFDF5E6, \"olive\": 0x808000, \"olivedrab\": 0x6B8E23, \"orange\": 0xFFA500, \"orangered\": 0xFF4500, \"orchid\": 0xDA70D6,\n\"palegoldenrod\": 0xEEE8AA, \"palegreen\": 0x98FB98, \"paleturquoise\": 0xAFEEEE, \"palevioletred\": 0xDB7093, \"papayawhip\": 0xFFEFD5, \"peachpuff\": 0xFFDAB9,\n\"peru\": 0xCD853F, \"pink\": 0xFFC0CB, \"plum\": 0xDDA0DD, \"powderblue\": 0xB0E0E6, \"purple\": 0x800080, \"red\": 0xFF0000, \"rosybrown\": 0xBC8F8F,\n\"royalblue\": 0x4169E1, \"saddlebrown\": 0x8B4513, \"salmon\": 0xFA8072, \"sandybrown\": 0xF4A460, \"seagreen\": 0x2E8B57, \"seashell\": 0xFFF5EE,\n\"sienna\": 0xA0522D, \"silver\": 0xC0C0C0, \"skyblue\": 0x87CEEB, \"slateblue\": 0x6A5ACD, \"slategray\": 0x708090, \"slategrey\": 0x708090, \"snow\": 0xFFFAFA,\n\"springgreen\": 0x00FF7F, \"steelblue\": 0x4682B4, \"tan\": 0xD2B48C, \"teal\": 0x008080, \"thistle\": 0xD8BFD8, \"tomato\": 0xFF6347, \"turquoise\": 0x40E0D0,\n\"violet\": 0xEE82EE, \"wheat\": 0xF5DEB3, \"white\": 0xFFFFFF, \"whitesmoke\": 0xF5F5F5, \"yellow\": 0xFFFF00, \"yellowgreen\": 0x9ACD32 };\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author bhouston / http://exocortex.com\n */\n\nTHREE.Quaternion = function( x, y, z, w ) {\n\n\tthis.x = x || 0;\n\tthis.y = y || 0;\n\tthis.z = z || 0;\n\tthis.w = ( w !== undefined ) ? w : 1;\n\n};\n\nTHREE.extend( THREE.Quaternion.prototype, {\n\n\tset: function ( x, y, z, w ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\tthis.w = w;\n\n\t\treturn this;\n\n\t},\n\n\tcopy: function ( q ) {\n\n\t\tthis.x = q.x;\n\t\tthis.y = q.y;\n\t\tthis.z = q.z;\n\t\tthis.w = q.w;\n\n\t\treturn this;\n\n\t},\n\n\tsetFromEuler: function ( v, order ) {\n\n\t\t// http://www.mathworks.com/matlabcentral/fileexchange/\n\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n\t\t//\tcontent/SpinCalc.m\n\n\t\tvar c1 = Math.cos( v.x / 2 );\n\t\tvar c2 = Math.cos( v.y / 2 );\n\t\tvar c3 = Math.cos( v.z / 2 );\n\t\tvar s1 = Math.sin( v.x / 2 );\n\t\tvar s2 = Math.sin( v.y / 2 );\n\t\tvar s3 = Math.sin( v.z / 2 );\n\n\t\tif ( order === undefined || order === 'XYZ' ) {\n\n\t\t\tthis.x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\tthis.y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\tthis.z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\tthis.w = c1 * c2 * c3 - s1 * s2 * s3;\n\n\t\t} else if ( order === 'YXZ' ) {\n\n\t\t\tthis.x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\tthis.y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\tthis.z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\tthis.w = c1 * c2 * c3 + s1 * s2 * s3;\n\n\t\t} else if ( order === 'ZXY' ) {\n\n\t\t\tthis.x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\tthis.y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\tthis.z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\tthis.w = c1 * c2 * c3 - s1 * s2 * s3;\n\n\t\t} else if ( order === 'ZYX' ) {\n\n\t\t\tthis.x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\tthis.y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\tthis.z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\tthis.w = c1 * c2 * c3 + s1 * s2 * s3;\n\n\t\t} else if ( order === 'YZX' ) {\n\n\t\t\tthis.x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\tthis.y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\tthis.z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\tthis.w = c1 * c2 * c3 - s1 * s2 * s3;\n\n\t\t} else if ( order === 'XZY' ) {\n\n\t\t\tthis.x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\tthis.y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\tthis.z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\tthis.w = c1 * c2 * c3 + s1 * s2 * s3;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetFromAxisAngle: function ( axis, angle ) {\n\n\t\t// from http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n\t\t// axis have to be normalized\n\n\t\tvar halfAngle = angle / 2,\n\t\t\ts = Math.sin( halfAngle );\n\n\t\tthis.x = axis.x * s;\n\t\tthis.y = axis.y * s;\n\t\tthis.z = axis.z * s;\n\t\tthis.w = Math.cos( halfAngle );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromRotationMatrix: function ( m ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tvar te = m.elements,\n\n\t\t\tm11 = te[0], m12 = te[4], m13 = te[8],\n\t\t\tm21 = te[1], m22 = te[5], m23 = te[9],\n\t\t\tm31 = te[2], m32 = te[6], m33 = te[10],\n\n\t\t\ttrace = m11 + m22 + m33,\n\t\t\ts;\n\n\t\tif ( trace > 0 ) {\n\n\t\t\ts = 0.5 / Math.sqrt( trace + 1.0 );\n\n\t\t\tthis.w = 0.25 / s;\n\t\t\tthis.x = ( m32 - m23 ) * s;\n\t\t\tthis.y = ( m13 - m31 ) * s;\n\t\t\tthis.z = ( m21 - m12 ) * s;\n\n\t\t} else if ( m11 > m22 && m11 > m33 ) {\n\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\n\n\t\t\tthis.w = (m32 - m23 ) / s;\n\t\t\tthis.x = 0.25 * s;\n\t\t\tthis.y = (m12 + m21 ) / s;\n\t\t\tthis.z = (m13 + m31 ) / s;\n\n\t\t} else if ( m22 > m33 ) {\n\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\n\n\t\t\tthis.w = (m13 - m31 ) / s;\n\t\t\tthis.x = (m12 + m21 ) / s;\n\t\t\tthis.y = 0.25 * s;\n\t\t\tthis.z = (m23 + m32 ) / s;\n\n\t\t} else {\n\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\n\n\t\t\tthis.w = ( m21 - m12 ) / s;\n\t\t\tthis.x = ( m13 + m31 ) / s;\n\t\t\tthis.y = ( m23 + m32 ) / s;\n\t\t\tthis.z = 0.25 * s;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tinverse: function () {\n\n\t\tthis.conjugate().normalize();\n\n\t\treturn this;\n\n\t},\n\n\tconjugate: function () {\n\n\t\tthis.x *= -1;\n\t\tthis.y *= -1;\n\t\tthis.z *= -1;\n\n\t\treturn this;\n\n\t},\n\n\tlengthSq: function () {\n\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n\n\t},\n\n\tlength: function () {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\n\n\t},\n\n\tnormalize: function () {\n\n\t\tvar l = this.length();\n\n\t\tif ( l === 0 ) {\n\n\t\t\tthis.x = 0;\n\t\t\tthis.y = 0;\n\t\t\tthis.z = 0;\n\t\t\tthis.w = 1;\n\n\t\t} else {\n\n\t\t\tl = 1 / l;\n\n\t\t\tthis.x = this.x * l;\n\t\t\tthis.y = this.y * l;\n\t\t\tthis.z = this.z * l;\n\t\t\tthis.w = this.w * l;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tmultiply: function ( q, p ) {\n\n\t\tif ( p !== undefined ) {\n\n\t\t\tconsole.warn( 'DEPRECATED: Quaternion\\'s .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );\n\t\t\treturn this.multiplyQuaternions( q, p );\n\n\t\t}\n\n\t\treturn this.multiplyQuaternions( this, q );\n\n\t},\n\n\tmultiplyQuaternions: function ( a, b ) {\n\n\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n\n\t\tvar qax = a.x, qay = a.y, qaz = a.z, qaw = a.w;\n\t\tvar qbx = b.x, qby = b.y, qbz = b.z, qbw = b.w;\n\n\t\tthis.x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n\t\tthis.y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n\t\tthis.z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n\t\tthis.w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyVector3: function ( vector ) {\n\n\t\tconsole.warn( 'DEPRECATED: Quaternion\\'s .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );\n\t\treturn vector.applyQuaternion( this );\n\n\t},\n\n\tslerp: function ( qb, t ) {\n\n\t\tvar x = this.x, y = this.y, z = this.z, w = this.w;\n\n\t\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\n\t\tvar cosHalfTheta = w * qb.w + x * qb.x + y * qb.y + z * qb.z;\n\n\t\tif ( cosHalfTheta < 0 ) {\n\n\t\t\tthis.w = -qb.w;\n\t\t\tthis.x = -qb.x;\n\t\t\tthis.y = -qb.y;\n\t\t\tthis.z = -qb.z;\n\n\t\t\tcosHalfTheta = -cosHalfTheta;\n\n\t\t} else {\n\n\t\t\tthis.copy( qb );\n\n\t\t}\n\n\t\tif ( cosHalfTheta >= 1.0 ) {\n\n\t\t\tthis.w = w;\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tvar halfTheta = Math.acos( cosHalfTheta );\n\t\tvar sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );\n\n\t\tif ( Math.abs( sinHalfTheta ) < 0.001 ) {\n\n\t\t\tthis.w = 0.5 * ( w + this.w );\n\t\t\tthis.x = 0.5 * ( x + this.x );\n\t\t\tthis.y = 0.5 * ( y + this.y );\n\t\t\tthis.z = 0.5 * ( z + this.z );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tvar ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\n\t\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\n\n\t\tthis.w = ( w * ratioA + this.w * ratioB );\n\t\tthis.x = ( x * ratioA + this.x * ratioB );\n\t\tthis.y = ( y * ratioA + this.y * ratioB );\n\t\tthis.z = ( z * ratioA + this.z * ratioB );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new THREE.Quaternion( this.x, this.y, this.z, this.w );\n\n\t}\n\n} );\n\nTHREE.Quaternion.slerp = function ( qa, qb, qm, t ) {\n\n\treturn qm.copy( qa ).slerp( qb, t );\n\n}\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author philogb / http://blog.thejit.org/\n * @author egraether / http://egraether.com/\n * @author zz85 / http://www.lab4games.net/zz85/blog\n */\n\nTHREE.Vector2 = function ( x, y ) {\n\n\tthis.x = x || 0;\n\tthis.y = y || 0;\n\n};\n\nTHREE.extend( THREE.Vector2.prototype, {\n\n\tset: function ( x, y ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetX: function ( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t},\n\n\tsetY: function ( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t},\n\n\n\tsetComponent: function ( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tdefault: throw new Error( \"index is out of range: \" + index );\n\n\t\t}\n\n\t},\n\n\tgetComponent: function ( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tdefault: throw new Error( \"index is out of range: \" + index );\n\n\t\t}\n\n\t},\n\n\tcopy: function ( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\n\t\treturn this;\n\n\t},\n\n\tadd: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'DEPRECATED: Vector2\\'s .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\treturn this.addVectors( v, w );\n\n\t\t}\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\n\t\treturn this;\n\n\t},\n\n\taddVectors: function ( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\n\t\treturn this;\n\n\t},\n\n\taddScalar: function ( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\n\t\treturn this;\n\n\t},\n\n\tsub: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'DEPRECATED: Vector2\\'s .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\treturn this.subVectors( v, w );\n\n\t\t}\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\n\t\treturn this;\n\n\t},\n\n\tsubVectors: function ( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( s ) {\n\n\t\tthis.x *= s;\n\t\tthis.y *= s;\n\n\t\treturn this;\n\n\t},\n\n\tdivideScalar: function ( s ) {\n\n\t\tif ( s !== 0 ) {\n\n\t\t\tthis.x /= s;\n\t\t\tthis.y /= s;\n\n\t\t} else {\n\n\t\t\tthis.set( 0, 0 );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tmin: function ( v ) {\n\n\t\tif ( this.x > v.x ) {\n\n\t\t\tthis.x = v.x;\n\n\t\t}\n\n\t\tif ( this.y > v.y ) {\n\n\t\t\tthis.y = v.y;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tmax: function ( v ) {\n\n\t\tif ( this.x < v.x ) {\n\n\t\t\tthis.x = v.x;\n\n\t\t}\n\n\t\tif ( this.y < v.y ) {\n\n\t\t\tthis.y = v.y;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tclamp: function ( min, max ) {\n\n\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\n\t\tif ( this.x < min.x ) {\n\n\t\t\tthis.x = min.x;\n\n\t\t} else if ( this.x > max.x ) {\n\n\t\t\tthis.x = max.x;\n\n\t\t}\n\n\t\tif ( this.y < min.y ) {\n\n\t\t\tthis.y = min.y;\n\n\t\t} else if ( this.y > max.y ) {\n\n\t\t\tthis.y = max.y;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tnegate: function() {\n\n\t\treturn this.multiplyScalar( - 1 );\n\n\t},\n\n\tdot: function ( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y;\n\n\t},\n\n\tlengthSq: function () {\n\n\t\treturn this.x * this.x + this.y * this.y;\n\n\t},\n\n\tlength: function () {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y );\n\n\t},\n\n\tnormalize: function () {\n\n\t\treturn this.divideScalar( this.length() );\n\n\t},\n\n\tdistanceTo: function ( v ) {\n\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t},\n\n\tdistanceToSquared: function ( v ) {\n\n\t\tvar dx = this.x - v.x, dy = this.y - v.y;\n\t\treturn dx * dx + dy * dy;\n\n\t},\n\n\tsetLength: function ( l ) {\n\n\t\tvar oldLength = this.length();\n\n\t\tif ( oldLength !== 0 && l !== oldLength ) {\n\n\t\t\tthis.multiplyScalar( l / oldLength );\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tlerp: function ( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\n\t\treturn this;\n\n\t},\n\n\tequals: function( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\n\n\t},\n\n\ttoArray: function () {\n\n\t\treturn [ this.x, this.y ];\n\t\t\n\t},\n\n\tclone: function () {\n\n\t\treturn new THREE.Vector2( this.x, this.y );\n\n\t}\n\n} );\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author *kile / http://kile.stravaganza.org/\n * @author philogb / http://blog.thejit.org/\n * @author mikael emtinger / http://gomo.se/\n * @author egraether / http://egraether.com/\n * @author WestLangley / http://github.com/WestLangley\n */\n\nTHREE.Vector3 = function ( x, y, z ) {\n\n\tthis.x = x || 0;\n\tthis.y = y || 0;\n\tthis.z = z || 0;\n\n};\n\nTHREE.extend( THREE.Vector3.prototype, {\n\n\tset: function ( x, y, z ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetX: function ( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t},\n\n\tsetY: function ( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetZ: function ( z ) {\n\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetComponent: function ( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tcase 2: this.z = value; break;\n\t\t\tdefault: throw new Error( \"index is out of range: \" + index );\n\n\t\t}\n\n\t},\n\n\tgetComponent: function ( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tcase 2: return this.z;\n\t\t\tdefault: throw new Error( \"index is out of range: \" + index );\n\n\t\t}\n\n\t},\n\n\tcopy: function ( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\t\tthis.z = v.z;\n\n\t\treturn this;\n\n\t},\n\n\tadd: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'DEPRECATED: Vector3\\'s .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\treturn this.addVectors( v, w );\n\n\t\t}\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\t\tthis.z += v.z;\n\n\t\treturn this;\n\n\t},\n\n\taddScalar: function ( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\t\tthis.z += s;\n\n\t\treturn this;\n\n\t},\n\n\taddVectors: function ( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\t\tthis.z = a.z + b.z;\n\n\t\treturn this;\n\n\t},\n\n\tsub: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'DEPRECATED: Vector3\\'s .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\treturn this.subVectors( v, w );\n\n\t\t}\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\t\tthis.z -= v.z;\n\n\t\treturn this;\n\n\t},\n\n\tsubVectors: function ( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\t\tthis.z = a.z - b.z;\n\n\t\treturn this;\n\n\t},\n\n\tmultiply: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'DEPRECATED: Vector3\\'s .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );\n\t\t\treturn this.multiplyVectors( v, w );\n\n\t\t}\n\n\t\tthis.x *= v.x;\n\t\tthis.y *= v.y;\n\t\tthis.z *= v.z;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( s ) {\n\n\t\tthis.x *= s;\n\t\tthis.y *= s;\n\t\tthis.z *= s;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyVectors: function ( a, b ) {\n\n\t\tthis.x = a.x * b.x;\n\t\tthis.y = a.y * b.y;\n\t\tthis.z = a.z * b.z;\n\n\t\treturn this;\n\n\t},\n\n\tapplyMatrix3: function ( m ) {\n\n\t\tvar x = this.x;\n\t\tvar y = this.y;\n\t\tvar z = this.z;\n\n\t\tvar e = m.elements;\n\n\t\tthis.x = e[0] * x + e[3] * y + e[6] * z;\n\t\tthis.y = e[1] * x + e[4] * y + e[7] * z;\n\t\tthis.z = e[2] * x + e[5] * y + e[8] * z;\n\n\t\treturn this;\n\n\t},\n\n\tapplyMatrix4: function ( m ) {\n\n\t\t// input: THREE.Matrix4 affine matrix\n\n\t\tvar x = this.x, y = this.y, z = this.z;\n\n\t\tvar e = m.elements;\n\n\t\tthis.x = e[0] * x + e[4] * y + e[8]  * z + e[12];\n\t\tthis.y = e[1] * x + e[5] * y + e[9]  * z + e[13];\n\t\tthis.z = e[2] * x + e[6] * y + e[10] * z + e[14];\n\n\t\treturn this;\n\n\t},\n\n\tapplyProjection: function ( m ) {\n\n\t\t// input: THREE.Matrix4 projection matrix\n\n\t\tvar x = this.x, y = this.y, z = this.z;\n\n\t\tvar e = m.elements;\n\t\tvar d = 1 / ( e[3] * x + e[7] * y + e[11] * z + e[15] ); // perspective divide\n\n\t\tthis.x = ( e[0] * x + e[4] * y + e[8]  * z + e[12] ) * d;\n\t\tthis.y = ( e[1] * x + e[5] * y + e[9]  * z + e[13] ) * d;\n\t\tthis.z = ( e[2] * x + e[6] * y + e[10] * z + e[14] ) * d;\n\n\t\treturn this;\n\n\t},\n\n\tapplyQuaternion: function ( q ) {\n\n\t\tvar x = this.x;\n\t\tvar y = this.y;\n\t\tvar z = this.z;\n\n\t\tvar qx = q.x;\n\t\tvar qy = q.y;\n\t\tvar qz = q.z;\n\t\tvar qw = q.w;\n\n\t\t// calculate quat * vector\n\n\t\tvar ix =  qw * x + qy * z - qz * y;\n\t\tvar iy =  qw * y + qz * x - qx * z;\n\t\tvar iz =  qw * z + qx * y - qy * x;\n\t\tvar iw = -qx * x - qy * y - qz * z;\n\n\t\t// calculate result * inverse quat\n\n\t\tthis.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n\t\tthis.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n\t\tthis.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n\n\t\treturn this;\n\n\t},\n\n\tapplyEuler: function () {\n\n\t\tvar q1 = new THREE.Quaternion();\n\n\t\treturn function ( v, eulerOrder ) {\n\n\t\t\tvar quaternion = q1.setFromEuler( v, eulerOrder );\n\n\t\t\tthis.applyQuaternion( quaternion );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tapplyAxisAngle: function () {\n\n\t\tvar q1 = new THREE.Quaternion();\n\n\t\treturn function ( axis, angle ) {\n\n\t\t\tvar quaternion = q1.setFromAxisAngle( axis, angle );\n\n\t\t\tthis.applyQuaternion( quaternion );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\ttransformDirection: function ( m ) {\n\n\t\t// input: THREE.Matrix4 affine matrix\n\t\t// vector interpreted as a direction\n\n\t\tvar x = this.x, y = this.y, z = this.z;\n\n\t\tvar e = m.elements;\n\n\t\tthis.x = e[0] * x + e[4] * y + e[8]  * z;\n\t\tthis.y = e[1] * x + e[5] * y + e[9]  * z;\n\t\tthis.z = e[2] * x + e[6] * y + e[10] * z;\n\n\t\tthis.normalize();\n\n\t\treturn this;\n\n\t},\n\n\tdivide: function ( v ) {\n\n\t\tthis.x /= v.x;\n\t\tthis.y /= v.y;\n\t\tthis.z /= v.z;\n\n\t\treturn this;\n\n\t},\n\n\tdivideScalar: function ( s ) {\n\n\t\tif ( s !== 0 ) {\n\n\t\t\tthis.x /= s;\n\t\t\tthis.y /= s;\n\t\t\tthis.z /= s;\n\n\t\t} else {\n\n\t\t\tthis.x = 0;\n\t\t\tthis.y = 0;\n\t\t\tthis.z = 0;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tmin: function ( v ) {\n\n\t\tif ( this.x > v.x ) {\n\n\t\t\tthis.x = v.x;\n\n\t\t}\n\n\t\tif ( this.y > v.y ) {\n\n\t\t\tthis.y = v.y;\n\n\t\t}\n\n\t\tif ( this.z > v.z ) {\n\n\t\t\tthis.z = v.z;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tmax: function ( v ) {\n\n\t\tif ( this.x < v.x ) {\n\n\t\t\tthis.x = v.x;\n\n\t\t}\n\n\t\tif ( this.y < v.y ) {\n\n\t\t\tthis.y = v.y;\n\n\t\t}\n\n\t\tif ( this.z < v.z ) {\n\n\t\t\tthis.z = v.z;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tclamp: function ( min, max ) {\n\n\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\n\t\tif ( this.x < min.x ) {\n\n\t\t\tthis.x = min.x;\n\n\t\t} else if ( this.x > max.x ) {\n\n\t\t\tthis.x = max.x;\n\n\t\t}\n\n\t\tif ( this.y < min.y ) {\n\n\t\t\tthis.y = min.y;\n\n\t\t} else if ( this.y > max.y ) {\n\n\t\t\tthis.y = max.y;\n\n\t\t}\n\n\t\tif ( this.z < min.z ) {\n\n\t\t\tthis.z = min.z;\n\n\t\t} else if ( this.z > max.z ) {\n\n\t\t\tthis.z = max.z;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tnegate: function () {\n\n\t\treturn this.multiplyScalar( - 1 );\n\n\t},\n\n\tdot: function ( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\n\n\t},\n\n\tlengthSq: function () {\n\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\n\n\t},\n\n\tlength: function () {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\n\n\t},\n\n\tlengthManhattan: function () {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\n\n\t},\n\n\tnormalize: function () {\n\n\t\treturn this.divideScalar( this.length() );\n\n\t},\n\n\tsetLength: function ( l ) {\n\n\t\tvar oldLength = this.length();\n\n\t\tif ( oldLength !== 0 && l !== oldLength  ) {\n\n\t\t\tthis.multiplyScalar( l / oldLength );\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tlerp: function ( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\tthis.z += ( v.z - this.z ) * alpha;\n\n\t\treturn this;\n\n\t},\n\n\tcross: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'DEPRECATED: Vector3\\'s .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );\n\t\t\treturn this.crossVectors( v, w );\n\n\t\t}\n\n\t\tvar x = this.x, y = this.y, z = this.z;\n\n\t\tthis.x = y * v.z - z * v.y;\n\t\tthis.y = z * v.x - x * v.z;\n\t\tthis.z = x * v.y - y * v.x;\n\n\t\treturn this;\n\n\t},\n\n\tcrossVectors: function ( a, b ) {\n\n\t\tthis.x = a.y * b.z - a.z * b.y;\n\t\tthis.y = a.z * b.x - a.x * b.z;\n\t\tthis.z = a.x * b.y - a.y * b.x;\n\n\t\treturn this;\n\n\t},\n\n\tprojectOnVector: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function( vector ) {\n\n\t\t\tv1.copy( vector ).normalize();\n\t\t\tvar d = this.dot( v1 );\n\t\t\treturn this.copy( v1 ).multiplyScalar( d );\n\n\t\t};\n\n\t}(),\n\n\tprojectOnPlane: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function( planeNormal ) {\n\n\t\t\tv1.copy( this ).projectOnVector( planeNormal );\n\n\t\t\treturn this.sub( v1 );\n\n\t\t}\n\n\t}(),\n\n\treflect: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function ( vector ) {\n\n\t\t    v1.copy( this ).projectOnVector( vector ).multiplyScalar( 2 );\n\n\t\t    return this.subVectors( v1, this );\n\n\t\t}\n\n\t}(),\n\n\tangleTo: function ( v ) {\n\n\t\tvar theta = this.dot( v ) / ( this.length() * v.length() );\n\n\t\t// clamp, to handle numerical problems\n\n\t\treturn Math.acos( THREE.Math.clamp( theta, -1, 1 ) );\n\n\t},\n\n\tdistanceTo: function ( v ) {\n\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t},\n\n\tdistanceToSquared: function ( v ) {\n\n\t\tvar dx = this.x - v.x;\n\t\tvar dy = this.y - v.y;\n\t\tvar dz = this.z - v.z;\n\n\t\treturn dx * dx + dy * dy + dz * dz;\n\n\t},\n\n\tgetPositionFromMatrix: function ( m ) {\n\n\t\tthis.x = m.elements[12];\n\t\tthis.y = m.elements[13];\n\t\tthis.z = m.elements[14];\n\n\t\treturn this;\n\n\t},\n\n\tsetEulerFromRotationMatrix: function ( m, order ) {\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\t// clamp, to handle numerical problems\n\n\t\tfunction clamp( x ) {\n\n\t\t\treturn Math.min( Math.max( x, -1 ), 1 );\n\n\t\t}\n\n\t\tvar te = m.elements;\n\t\tvar m11 = te[0], m12 = te[4], m13 = te[8];\n\t\tvar m21 = te[1], m22 = te[5], m23 = te[9];\n\t\tvar m31 = te[2], m32 = te[6], m33 = te[10];\n\n\t\tif ( order === undefined || order === 'XYZ' ) {\n\n\t\t\tthis.y = Math.asin( clamp( m13 ) );\n\n\t\t\tif ( Math.abs( m13 ) < 0.99999 ) {\n\n\t\t\t\tthis.x = Math.atan2( - m23, m33 );\n\t\t\t\tthis.z = Math.atan2( - m12, m11 );\n\n\t\t\t} else {\n\n\t\t\t\tthis.x = Math.atan2( m32, m22 );\n\t\t\t\tthis.z = 0;\n\n\t\t\t}\n\n\t\t} else if ( order === 'YXZ' ) {\n\n\t\t\tthis.x = Math.asin( - clamp( m23 ) );\n\n\t\t\tif ( Math.abs( m23 ) < 0.99999 ) {\n\n\t\t\t\tthis.y = Math.atan2( m13, m33 );\n\t\t\t\tthis.z = Math.atan2( m21, m22 );\n\n\t\t\t} else {\n\n\t\t\t\tthis.y = Math.atan2( - m31, m11 );\n\t\t\t\tthis.z = 0;\n\n\t\t\t}\n\n\t\t} else if ( order === 'ZXY' ) {\n\n\t\t\tthis.x = Math.asin( clamp( m32 ) );\n\n\t\t\tif ( Math.abs( m32 ) < 0.99999 ) {\n\n\t\t\t\tthis.y = Math.atan2( - m31, m33 );\n\t\t\t\tthis.z = Math.atan2( - m12, m22 );\n\n\t\t\t} else {\n\n\t\t\t\tthis.y = 0;\n\t\t\t\tthis.z = Math.atan2( m21, m11 );\n\n\t\t\t}\n\n\t\t} else if ( order === 'ZYX' ) {\n\n\t\t\tthis.y = Math.asin( - clamp( m31 ) );\n\n\t\t\tif ( Math.abs( m31 ) < 0.99999 ) {\n\n\t\t\t\tthis.x = Math.atan2( m32, m33 );\n\t\t\t\tthis.z = Math.atan2( m21, m11 );\n\n\t\t\t} else {\n\n\t\t\t\tthis.x = 0;\n\t\t\t\tthis.z = Math.atan2( - m12, m22 );\n\n\t\t\t}\n\n\t\t} else if ( order === 'YZX' ) {\n\n\t\t\tthis.z = Math.asin( clamp( m21 ) );\n\n\t\t\tif ( Math.abs( m21 ) < 0.99999 ) {\n\n\t\t\t\tthis.x = Math.atan2( - m23, m22 );\n\t\t\t\tthis.y = Math.atan2( - m31, m11 );\n\n\t\t\t} else {\n\n\t\t\t\tthis.x = 0;\n\t\t\t\tthis.y = Math.atan2( m13, m33 );\n\n\t\t\t}\n\n\t\t} else if ( order === 'XZY' ) {\n\n\t\t\tthis.z = Math.asin( - clamp( m12 ) );\n\n\t\t\tif ( Math.abs( m12 ) < 0.99999 ) {\n\n\t\t\t\tthis.x = Math.atan2( m32, m22 );\n\t\t\t\tthis.y = Math.atan2( m13, m11 );\n\n\t\t\t} else {\n\n\t\t\t\tthis.x = Math.atan2( - m23, m33 );\n\t\t\t\tthis.y = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetEulerFromQuaternion: function ( q, order ) {\n\n\t\t// q is assumed to be normalized\n\n\t\t// clamp, to handle numerical problems\n\n\t\tfunction clamp( x ) {\n\n\t\t\treturn Math.min( Math.max( x, -1 ), 1 );\n\n\t\t}\n\n\t\t// http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/content/SpinCalc.m\n\n\t\tvar sqx = q.x * q.x;\n\t\tvar sqy = q.y * q.y;\n\t\tvar sqz = q.z * q.z;\n\t\tvar sqw = q.w * q.w;\n\n\t\tif ( order === undefined || order === 'XYZ' ) {\n\n\t\t\tthis.x = Math.atan2( 2 * ( q.x * q.w - q.y * q.z ), ( sqw - sqx - sqy + sqz ) );\n\t\t\tthis.y = Math.asin(  clamp( 2 * ( q.x * q.z + q.y * q.w ) ) );\n\t\t\tthis.z = Math.atan2( 2 * ( q.z * q.w - q.x * q.y ), ( sqw + sqx - sqy - sqz ) );\n\n\t\t} else if ( order ===  'YXZ' ) {\n\n\t\t\tthis.x = Math.asin(  clamp( 2 * ( q.x * q.w - q.y * q.z ) ) );\n\t\t\tthis.y = Math.atan2( 2 * ( q.x * q.z + q.y * q.w ), ( sqw - sqx - sqy + sqz ) );\n\t\t\tthis.z = Math.atan2( 2 * ( q.x * q.y + q.z * q.w ), ( sqw - sqx + sqy - sqz ) );\n\n\t\t} else if ( order === 'ZXY' ) {\n\n\t\t\tthis.x = Math.asin(  clamp( 2 * ( q.x * q.w + q.y * q.z ) ) );\n\t\t\tthis.y = Math.atan2( 2 * ( q.y * q.w - q.z * q.x ), ( sqw - sqx - sqy + sqz ) );\n\t\t\tthis.z = Math.atan2( 2 * ( q.z * q.w - q.x * q.y ), ( sqw - sqx + sqy - sqz ) );\n\n\t\t} else if ( order === 'ZYX' ) {\n\n\t\t\tthis.x = Math.atan2( 2 * ( q.x * q.w + q.z * q.y ), ( sqw - sqx - sqy + sqz ) );\n\t\t\tthis.y = Math.asin(  clamp( 2 * ( q.y * q.w - q.x * q.z ) ) );\n\t\t\tthis.z = Math.atan2( 2 * ( q.x * q.y + q.z * q.w ), ( sqw + sqx - sqy - sqz ) );\n\n\t\t} else if ( order === 'YZX' ) {\n\n\t\t\tthis.x = Math.atan2( 2 * ( q.x * q.w - q.z * q.y ), ( sqw - sqx + sqy - sqz ) );\n\t\t\tthis.y = Math.atan2( 2 * ( q.y * q.w - q.x * q.z ), ( sqw + sqx - sqy - sqz ) );\n\t\t\tthis.z = Math.asin(  clamp( 2 * ( q.x * q.y + q.z * q.w ) ) );\n\n\t\t} else if ( order === 'XZY' ) {\n\n\t\t\tthis.x = Math.atan2( 2 * ( q.x * q.w + q.y * q.z ), ( sqw - sqx + sqy - sqz ) );\n\t\t\tthis.y = Math.atan2( 2 * ( q.x * q.z + q.y * q.w ), ( sqw + sqx - sqy - sqz ) );\n\t\t\tthis.z = Math.asin(  clamp( 2 * ( q.z * q.w - q.x * q.y ) ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tgetScaleFromMatrix: function ( m ) {\n\n\t\tvar sx = this.set( m.elements[0], m.elements[1], m.elements[2] ).length();\n\t\tvar sy = this.set( m.elements[4], m.elements[5], m.elements[6] ).length();\n\t\tvar sz = this.set( m.elements[8], m.elements[9], m.elements[10] ).length();\n\n\t\tthis.x = sx;\n\t\tthis.y = sy;\n\t\tthis.z = sz;\n\n\t\treturn this;\n\t},\n\n\tequals: function ( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\n\n\t},\n\n\ttoArray: function () {\n\n\t\treturn [ this.x, this.y, this.z ];\n\t\t\n\t},\n\n\tclone: function () {\n\n\t\treturn new THREE.Vector3( this.x, this.y, this.z );\n\n\t}\n\n} );\n/**\n * @author supereggbert / http://www.paulbrunt.co.uk/\n * @author philogb / http://blog.thejit.org/\n * @author mikael emtinger / http://gomo.se/\n * @author egraether / http://egraether.com/\n * @author WestLangley / http://github.com/WestLangley\n */\n\nTHREE.Vector4 = function ( x, y, z, w ) {\n\n\tthis.x = x || 0;\n\tthis.y = y || 0;\n\tthis.z = z || 0;\n\tthis.w = ( w !== undefined ) ? w : 1;\n\n};\n\nTHREE.extend( THREE.Vector4.prototype, {\n\n\tset: function ( x, y, z, w ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\tthis.w = w;\n\n\t\treturn this;\n\n\t},\n\n\tsetX: function ( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t},\n\n\tsetY: function ( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetZ: function ( z ) {\n\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetW: function ( w ) {\n\n\t\tthis.w = w;\n\n\t\treturn this;\n\n\t},\n\n\tsetComponent: function ( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tcase 2: this.z = value; break;\n\t\t\tcase 3: this.w = value; break;\n\t\t\tdefault: throw new Error( \"index is out of range: \" + index );\n\n\t\t}\n\n\t},\n\n\tgetComponent: function ( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tcase 2: return this.z;\n\t\t\tcase 3: return this.w;\n\t\t\tdefault: throw new Error( \"index is out of range: \" + index );\n\n\t\t}\n\n\t},\n\n\tcopy: function ( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\t\tthis.z = v.z;\n\t\tthis.w = ( v.w !== undefined ) ? v.w : 1;\n\n\t\treturn this;\n\n\t},\n\n\tadd: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'DEPRECATED: Vector4\\'s .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\treturn this.addVectors( v, w );\n\n\t\t}\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\t\tthis.z += v.z;\n\t\tthis.w += v.w;\n\n\t\treturn this;\n\n\t},\n\n\taddScalar: function ( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\t\tthis.z += s;\n\t\tthis.w += s;\n\n\t\treturn this;\n\n\t},\n\n\taddVectors: function ( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\t\tthis.z = a.z + b.z;\n\t\tthis.w = a.w + b.w;\n\n\t\treturn this;\n\n\t},\n\n\tsub: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'DEPRECATED: Vector4\\'s .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\treturn this.subVectors( v, w );\n\n\t\t}\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\t\tthis.z -= v.z;\n\t\tthis.w -= v.w;\n\n\t\treturn this;\n\n\t},\n\n\tsubVectors: function ( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\t\tthis.z = a.z - b.z;\n\t\tthis.w = a.w - b.w;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( s ) {\n\n\t\tthis.x *= s;\n\t\tthis.y *= s;\n\t\tthis.z *= s;\n\t\tthis.w *= s;\n\n\t\treturn this;\n\n\t},\n\n\tapplyMatrix4: function ( m ) {\n\n\t\tvar x = this.x;\n\t\tvar y = this.y;\n\t\tvar z = this.z;\n\t\tvar w = this.w;\n\n\t\tvar e = m.elements;\n\n\t\tthis.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;\n\t\tthis.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;\n\t\tthis.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;\n\t\tthis.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;\n\n\t\treturn this;\n\n\t},\n\n\tdivideScalar: function ( s ) {\n\n\t\tif ( s !== 0 ) {\n\n\t\t\tthis.x /= s;\n\t\t\tthis.y /= s;\n\t\t\tthis.z /= s;\n\t\t\tthis.w /= s;\n\n\t\t} else {\n\n\t\t\tthis.x = 0;\n\t\t\tthis.y = 0;\n\t\t\tthis.z = 0;\n\t\t\tthis.w = 1;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetAxisAngleFromQuaternion: function ( q ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\n\n\t\t// q is assumed to be normalized\n\n\t\tthis.w = 2 * Math.acos( q.w );\n\n\t\tvar s = Math.sqrt( 1 - q.w * q.w );\n\n\t\tif ( s < 0.0001 ) {\n\n\t\t\t this.x = 1;\n\t\t\t this.y = 0;\n\t\t\t this.z = 0;\n\n\t\t} else {\n\n\t\t\t this.x = q.x / s;\n\t\t\t this.y = q.y / s;\n\t\t\t this.z = q.z / s;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetAxisAngleFromRotationMatrix: function ( m ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tvar angle, x, y, z,\t\t// variables for result\n\t\t\tepsilon = 0.01,\t\t// margin to allow for rounding errors\n\t\t\tepsilon2 = 0.1,\t\t// margin to distinguish between 0 and 180 degrees\n\n\t\t\tte = m.elements,\n\n\t\t\tm11 = te[0], m12 = te[4], m13 = te[8],\n\t\t\tm21 = te[1], m22 = te[5], m23 = te[9],\n\t\t\tm31 = te[2], m32 = te[6], m33 = te[10];\n\n\t\tif ( ( Math.abs( m12 - m21 ) < epsilon )\n\t\t  && ( Math.abs( m13 - m31 ) < epsilon )\n\t\t  && ( Math.abs( m23 - m32 ) < epsilon ) ) {\n\n\t\t\t// singularity found\n\t\t\t// first check for identity matrix which must have +1 for all terms\n\t\t\t// in leading diagonal and zero in other terms\n\n\t\t\tif ( ( Math.abs( m12 + m21 ) < epsilon2 )\n\t\t\t  && ( Math.abs( m13 + m31 ) < epsilon2 )\n\t\t\t  && ( Math.abs( m23 + m32 ) < epsilon2 )\n\t\t\t  && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\n\n\t\t\t\t// this singularity is identity matrix so angle = 0\n\n\t\t\t\tthis.set( 1, 0, 0, 0 );\n\n\t\t\t\treturn this; // zero angle, arbitrary axis\n\n\t\t\t}\n\n\t\t\t// otherwise this singularity is angle = 180\n\n\t\t\tangle = Math.PI;\n\n\t\t\tvar xx = ( m11 + 1 ) / 2;\n\t\t\tvar yy = ( m22 + 1 ) / 2;\n\t\t\tvar zz = ( m33 + 1 ) / 2;\n\t\t\tvar xy = ( m12 + m21 ) / 4;\n\t\t\tvar xz = ( m13 + m31 ) / 4;\n\t\t\tvar yz = ( m23 + m32 ) / 4;\n\n\t\t\tif ( ( xx > yy ) && ( xx > zz ) ) { // m11 is the largest diagonal term\n\n\t\t\t\tif ( xx < epsilon ) {\n\n\t\t\t\t\tx = 0;\n\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\tz = 0.707106781;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tx = Math.sqrt( xx );\n\t\t\t\t\ty = xy / x;\n\t\t\t\t\tz = xz / x;\n\n\t\t\t\t}\n\n\t\t\t} else if ( yy > zz ) { // m22 is the largest diagonal term\n\n\t\t\t\tif ( yy < epsilon ) {\n\n\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\ty = 0;\n\t\t\t\t\tz = 0.707106781;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ty = Math.sqrt( yy );\n\t\t\t\t\tx = xy / y;\n\t\t\t\t\tz = yz / y;\n\n\t\t\t\t}\n\n\t\t\t} else { // m33 is the largest diagonal term so base result on this\n\n\t\t\t\tif ( zz < epsilon ) {\n\n\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\tz = 0;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tz = Math.sqrt( zz );\n\t\t\t\t\tx = xz / z;\n\t\t\t\t\ty = yz / z;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.set( x, y, z, angle );\n\n\t\t\treturn this; // return 180 deg rotation\n\n\t\t}\n\n\t\t// as we have reached here there are no singularities so we can handle normally\n\n\t\tvar s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 )\n\t\t\t\t\t\t + ( m13 - m31 ) * ( m13 - m31 )\n\t\t\t\t\t\t + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\n\n\t\tif ( Math.abs( s ) < 0.001 ) s = 1;\n\n\t\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\n\t\t// caught by singularity test above, but I've left it in just in case\n\n\t\tthis.x = ( m32 - m23 ) / s;\n\t\tthis.y = ( m13 - m31 ) / s;\n\t\tthis.z = ( m21 - m12 ) / s;\n\t\tthis.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\n\n\t\treturn this;\n\n\t},\n\n\tmin: function ( v ) {\n\n\t\tif ( this.x > v.x ) {\n\n\t\t\tthis.x = v.x;\n\n\t\t}\n\n\t\tif ( this.y > v.y ) {\n\n\t\t\tthis.y = v.y;\n\n\t\t}\n\n\t\tif ( this.z > v.z ) {\n\n\t\t\tthis.z = v.z;\n\n\t\t}\n\n\t\tif ( this.w > v.w ) {\n\n\t\t\tthis.w = v.w;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tmax: function ( v ) {\n\n\t\tif ( this.x < v.x ) {\n\n\t\t\tthis.x = v.x;\n\n\t\t}\n\n\t\tif ( this.y < v.y ) {\n\n\t\t\tthis.y = v.y;\n\n\t\t}\n\n\t\tif ( this.z < v.z ) {\n\n\t\t\tthis.z = v.z;\n\n\t\t}\n\n\t\tif ( this.w < v.w ) {\n\n\t\t\tthis.w = v.w;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tclamp: function ( min, max ) {\n\n\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\n\t\tif ( this.x < min.x ) {\n\n\t\t\tthis.x = min.x;\n\n\t\t} else if ( this.x > max.x ) {\n\n\t\t\tthis.x = max.x;\n\n\t\t}\n\n\t\tif ( this.y < min.y ) {\n\n\t\t\tthis.y = min.y;\n\n\t\t} else if ( this.y > max.y ) {\n\n\t\t\tthis.y = max.y;\n\n\t\t}\n\n\t\tif ( this.z < min.z ) {\n\n\t\t\tthis.z = min.z;\n\n\t\t} else if ( this.z > max.z ) {\n\n\t\t\tthis.z = max.z;\n\n\t\t}\n\n\t\tif ( this.w < min.w ) {\n\n\t\t\tthis.w = min.w;\n\n\t\t} else if ( this.w > max.w ) {\n\n\t\t\tthis.w = max.w;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tnegate: function() {\n\n\t\treturn this.multiplyScalar( -1 );\n\n\t},\n\n\tdot: function ( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n\n\t},\n\n\tlengthSq: function () {\n\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n\n\t},\n\n\tlength: function () {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\n\n\t},\n\n\tlengthManhattan: function () {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\n\n\t},\n\n\tnormalize: function () {\n\n\t\treturn this.divideScalar( this.length() );\n\n\t},\n\n\tsetLength: function ( l ) {\n\n\t\tvar oldLength = this.length();\n\n\t\tif ( oldLength !== 0 && l !== oldLength ) {\n\n\t\t\tthis.multiplyScalar( l / oldLength );\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tlerp: function ( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\tthis.z += ( v.z - this.z ) * alpha;\n\t\tthis.w += ( v.w - this.w ) * alpha;\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\n\n\t},\n\n\ttoArray: function () {\n\n\t\treturn [ this.x, this.y, this.z, this.w ];\n\t\t\n\t},\n\n\tclone: function () {\n\n\t\treturn new THREE.Vector4( this.x, this.y, this.z, this.w );\n\n\t}\n\n} );\n/**\n * @author bhouston / http://exocortex.com\n */\n\nTHREE.Box2 = function ( min, max ) {\n\n\tthis.min = ( min !== undefined ) ? min : new THREE.Vector2( Infinity, Infinity );\n\tthis.max = ( max !== undefined ) ? max : new THREE.Vector2( -Infinity, -Infinity );\n\n};\n\nTHREE.extend( THREE.Box2.prototype, {\n\n\tset: function ( min, max ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromPoints: function ( points ) {\n\n\t\tif ( points.length > 0 ) {\n\n\t\t\tvar point = points[ 0 ];\n\n\t\t\tthis.min.copy( point );\n\t\t\tthis.max.copy( point );\n\n\t\t\tfor ( var i = 1, il = points.length; i < il; i ++ ) {\n\n\t\t\t\tpoint = points[ i ];\n\n\t\t\t\tif ( point.x < this.min.x ) {\n\n\t\t\t\t\tthis.min.x = point.x;\n\n\t\t\t\t} else if ( point.x > this.max.x ) {\n\n\t\t\t\t\tthis.max.x = point.x;\n\n\t\t\t\t}\n\n\t\t\t\tif ( point.y < this.min.y ) {\n\n\t\t\t\t\tthis.min.y = point.y;\n\n\t\t\t\t} else if ( point.y > this.max.y ) {\n\n\t\t\t\t\tthis.max.y = point.y;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.makeEmpty();\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetFromCenterAndSize: function() {\n\n\t\tvar v1 = new THREE.Vector2();\n\n\t\treturn function ( center, size ) {\n\n\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\n\t\t\tthis.min.copy( center ).sub( halfSize );\n\t\t\tthis.max.copy( center ).add( halfSize );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tcopy: function ( box ) {\n\n\t\tthis.min.copy( box.min );\n\t\tthis.max.copy( box.max );\n\n\t\treturn this;\n\n\t},\n\n\tmakeEmpty: function () {\n\n\t\tthis.min.x = this.min.y = Infinity;\n\t\tthis.max.x = this.max.y = -Infinity;\n\n\t\treturn this;\n\n\t},\n\n\tempty: function () {\n\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );\n\n\t},\n\n\tcenter: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector2();\n\t\treturn result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\n\t},\n\n\tsize: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector2();\n\t\treturn result.subVectors( this.max, this.min );\n\n\t},\n\n\texpandByPoint: function ( point ) {\n\n\t\tthis.min.min( point );\n\t\tthis.max.max( point );\n\n\t\treturn this;\n\t},\n\n\texpandByVector: function ( vector ) {\n\n\t\tthis.min.sub( vector );\n\t\tthis.max.add( vector );\n\n\t\treturn this;\n\t},\n\n\texpandByScalar: function ( scalar ) {\n\n\t\tthis.min.addScalar( -scalar );\n\t\tthis.max.addScalar( scalar );\n\n\t\treturn this;\n\t},\n\n\tcontainsPoint: function ( point ) {\n\n\t\tif ( point.x < this.min.x || point.x > this.max.x ||\n\t\t     point.y < this.min.y || point.y > this.max.y ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tcontainsBox: function ( box ) {\n\n\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\n\t\t     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t},\n\n\tgetParameter: function ( point ) {\n\n\t\t// This can potentially have a divide by zero if the box\n\t\t// has a size dimension of 0.\n\n\t\treturn new THREE.Vector2(\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y )\n\t\t);\n\n\t},\n\n\tisIntersectionBox: function ( box ) {\n\n\t\t// using 6 splitting planes to rule out intersections.\n\n\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t     box.max.y < this.min.y || box.min.y > this.max.y ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tclampPoint: function ( point, optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector2();\n\t\treturn result.copy( point ).clamp( this.min, this.max );\n\n\t},\n\n\tdistanceToPoint: function() {\n\n\t\tvar v1 = new THREE.Vector2();\n\n\t\treturn function ( point ) {\n\n\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\n\t\t\treturn clampedPoint.sub( point ).length();\n\n\t\t};\n\n\t}(),\n\n\tintersect: function ( box ) {\n\n\t\tthis.min.max( box.min );\n\t\tthis.max.min( box.max );\n\n\t\treturn this;\n\n\t},\n\n\tunion: function ( box ) {\n\n\t\tthis.min.min( box.min );\n\t\tthis.max.max( box.max );\n\n\t\treturn this;\n\n\t},\n\n\ttranslate: function ( offset ) {\n\n\t\tthis.min.add( offset );\n\t\tthis.max.add( offset );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( box ) {\n\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new THREE.Box2().copy( this );\n\n\t}\n\n} );\n/**\n * @author bhouston / http://exocortex.com\n */\n\nTHREE.Box3 = function ( min, max ) {\n\n\tthis.min = ( min !== undefined ) ? min : new THREE.Vector3( Infinity, Infinity, Infinity );\n\tthis.max = ( max !== undefined ) ? max : new THREE.Vector3( -Infinity, -Infinity, -Infinity );\n\n};\n\nTHREE.extend( THREE.Box3.prototype, {\n\n\tset: function ( min, max ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromPoints: function ( points ) {\n\n\t\tif ( points.length > 0 ) {\n\n\t\t\tvar point = points[ 0 ];\n\n\t\t\tthis.min.copy( point );\n\t\t\tthis.max.copy( point );\n\n\t\t\tfor ( var i = 1, il = points.length; i < il; i ++ ) {\n\n\t\t\t\tpoint = points[ i ];\n\n\t\t\t\tif ( point.x < this.min.x ) {\n\n\t\t\t\t\tthis.min.x = point.x;\n\n\t\t\t\t} else if ( point.x > this.max.x ) {\n\n\t\t\t\t\tthis.max.x = point.x;\n\n\t\t\t\t}\n\n\t\t\t\tif ( point.y < this.min.y ) {\n\n\t\t\t\t\tthis.min.y = point.y;\n\n\t\t\t\t} else if ( point.y > this.max.y ) {\n\n\t\t\t\t\tthis.max.y = point.y;\n\n\t\t\t\t}\n\n\t\t\t\tif ( point.z < this.min.z ) {\n\n\t\t\t\t\tthis.min.z = point.z;\n\n\t\t\t\t} else if ( point.z > this.max.z ) {\n\n\t\t\t\t\tthis.max.z = point.z;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.makeEmpty();\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetFromCenterAndSize: function() {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function ( center, size ) {\n\n\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\n\n\t\t\tthis.min.copy( center ).sub( halfSize );\n\t\t\tthis.max.copy( center ).add( halfSize );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tcopy: function ( box ) {\n\n\t\tthis.min.copy( box.min );\n\t\tthis.max.copy( box.max );\n\n\t\treturn this;\n\n\t},\n\n\tmakeEmpty: function () {\n\n\t\tthis.min.x = this.min.y = this.min.z = Infinity;\n\t\tthis.max.x = this.max.y = this.max.z = -Infinity;\n\n\t\treturn this;\n\n\t},\n\n\tempty: function () {\n\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\n\n\t},\n\n\tcenter: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\n\t},\n\n\tsize: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.subVectors( this.max, this.min );\n\n\t},\n\n\texpandByPoint: function ( point ) {\n\n\t\tthis.min.min( point );\n\t\tthis.max.max( point );\n\n\t\treturn this;\n\n\t},\n\n\texpandByVector: function ( vector ) {\n\n\t\tthis.min.sub( vector );\n\t\tthis.max.add( vector );\n\n\t\treturn this;\n\n\t},\n\n\texpandByScalar: function ( scalar ) {\n\n\t\tthis.min.addScalar( -scalar );\n\t\tthis.max.addScalar( scalar );\n\n\t\treturn this;\n\n\t},\n\n\tcontainsPoint: function ( point ) {\n\n\t\tif ( point.x < this.min.x || point.x > this.max.x ||\n\t\t     point.y < this.min.y || point.y > this.max.y ||\n\t\t     point.z < this.min.z || point.z > this.max.z ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tcontainsBox: function ( box ) {\n\n\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\n\t\t\t ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&\n\t\t\t ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t},\n\n\tgetParameter: function ( point ) {\n\n\t\t// This can potentially have a divide by zero if the box\n\t\t// has a size dimension of 0.\n\n\t\treturn new THREE.Vector3(\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\n\t\t\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\n\t\t);\n\n\t},\n\n\tisIntersectionBox: function ( box ) {\n\n\t\t// using 6 splitting planes to rule out intersections.\n\n\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t     box.max.y < this.min.y || box.min.y > this.max.y ||\n\t\t     box.max.z < this.min.z || box.min.z > this.max.z ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tclampPoint: function ( point, optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.copy( point ).clamp( this.min, this.max );\n\n\t},\n\n\tdistanceToPoint: function() {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function ( point ) {\n\n\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\n\t\t\treturn clampedPoint.sub( point ).length();\n\n\t\t};\n\n\t}(),\n\n\tgetBoundingSphere: function() {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new THREE.Sphere();\n\n\t\t\tresult.center = this.center();\n\t\t\tresult.radius = this.size( v1 ).length() * 0.5;\n\n\t\t\treturn result;\n\n\t\t};\n\n\t}(),\n\n\tintersect: function ( box ) {\n\n\t\tthis.min.max( box.min );\n\t\tthis.max.min( box.max );\n\n\t\treturn this;\n\n\t},\n\n\tunion: function ( box ) {\n\n\t\tthis.min.min( box.min );\n\t\tthis.max.max( box.max );\n\n\t\treturn this;\n\n\t},\n\n\tapplyMatrix4: function() {\n\n\t\tvar points = [\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3()\n\t\t\t];\n\n\t\treturn function ( matrix ) {\n\n\t\t\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\n\t\t\tpoints[0].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\n\t\t\tpoints[1].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\n\t\t\tpoints[2].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\n\t\t\tpoints[3].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\n\t\t\tpoints[4].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\n\t\t\tpoints[5].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\n\t\t\tpoints[6].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\n\t\t\tpoints[7].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );  // 111\n\n\t\t\tthis.makeEmpty();\n\t\t\tthis.setFromPoints( points );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\ttranslate: function ( offset ) {\n\n\t\tthis.min.add( offset );\n\t\tthis.max.add( offset );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( box ) {\n\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new THREE.Box3().copy( this );\n\n\t}\n\n} );\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author bhouston / http://exocortex.com\n */\n\nTHREE.Matrix3 = function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\n\n\tthis.elements = new Float32Array(9);\n\n\tthis.set(\n\n\t\t( n11 !== undefined ) ? n11 : 1, n12 || 0, n13 || 0,\n\t\tn21 || 0, ( n22 !== undefined ) ? n22 : 1, n23 || 0,\n\t\tn31 || 0, n32 || 0, ( n33 !== undefined ) ? n33 : 1\n\n\t);\n};\n\nTHREE.extend( THREE.Matrix3.prototype, {\n\n\tset: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[0] = n11; te[3] = n12; te[6] = n13;\n\t\tte[1] = n21; te[4] = n22; te[7] = n23;\n\t\tte[2] = n31; te[5] = n32; te[8] = n33;\n\n\t\treturn this;\n\n\t},\n\n\tidentity: function () {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0,\n\t\t\t0, 1, 0,\n\t\t\t0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tcopy: function ( m ) {\n\n\t\tvar me = m.elements;\n\n\t\tthis.set(\n\n\t\t\tme[0], me[3], me[6],\n\t\t\tme[1], me[4], me[7],\n\t\t\tme[2], me[5], me[8]\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyVector3: function ( vector ) {\n\n\t\tconsole.warn( 'DEPRECATED: Matrix3\\'s .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );\n\t\treturn vector.applyMatrix3( this );\n\n\t},\n\n\tmultiplyVector3Array: function() {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function ( a ) {\n\n\t\t\tfor ( var i = 0, il = a.length; i < il; i += 3 ) {\n\n\t\t\t\tv1.x = a[ i ];\n\t\t\t\tv1.y = a[ i + 1 ];\n\t\t\t\tv1.z = a[ i + 2 ];\n\n\t\t\t\tv1.applyMatrix3(this);\n\n\t\t\t\ta[ i ]     = v1.x;\n\t\t\t\ta[ i + 1 ] = v1.y;\n\t\t\t\ta[ i + 2 ] = v1.z;\n\n\t\t\t}\n\n\t\t\treturn a;\n\n\t\t};\n\n\t}(),\n\n\tmultiplyScalar: function ( s ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[0] *= s; te[3] *= s; te[6] *= s;\n\t\tte[1] *= s; te[4] *= s; te[7] *= s;\n\t\tte[2] *= s; te[5] *= s; te[8] *= s;\n\n\t\treturn this;\n\n\t},\n\n\tdeterminant: function () {\n\n\t\tvar te = this.elements;\n\n\t\tvar a = te[0], b = te[1], c = te[2],\n\t\t\td = te[3], e = te[4], f = te[5],\n\t\t\tg = te[6], h = te[7], i = te[8];\n\n\t\treturn a*e*i - a*f*h - b*d*i + b*f*g + c*d*h - c*e*g;\n\n\t},\n\n\tgetInverse: function ( matrix, throwOnInvertible ) {\n\n\t\t// input: THREE.Matrix4\n\t\t// ( based on http://code.google.com/p/webgl-mjs/ )\n\n\t\tvar me = matrix.elements;\n\t\tvar te = this.elements;\n\n\t\tte[ 0 ] =   me[10] * me[5] - me[6] * me[9];\n\t\tte[ 1 ] = - me[10] * me[1] + me[2] * me[9];\n\t\tte[ 2 ] =   me[6] * me[1] - me[2] * me[5];\n\t\tte[ 3 ] = - me[10] * me[4] + me[6] * me[8];\n\t\tte[ 4 ] =   me[10] * me[0] - me[2] * me[8];\n\t\tte[ 5 ] = - me[6] * me[0] + me[2] * me[4];\n\t\tte[ 6 ] =   me[9] * me[4] - me[5] * me[8];\n\t\tte[ 7 ] = - me[9] * me[0] + me[1] * me[8];\n\t\tte[ 8 ] =   me[5] * me[0] - me[1] * me[4];\n\n\t\tvar det = me[ 0 ] * te[ 0 ] + me[ 1 ] * te[ 3 ] + me[ 2 ] * te[ 6 ];\n\n\t\t// no inverse\n\n\t\tif ( det === 0 ) {\n\n\t\t\tvar msg = \"Matrix3.getInverse(): can't invert matrix, determinant is 0\";\n\n\t\t\tif ( throwOnInvertible || false ) {\n\n\t\t\t\tthrow new Error( msg ); \n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( msg );\n\n\t\t\t}\n\n\t\t\tthis.identity();\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tthis.multiplyScalar( 1.0 / det );\n\n\t\treturn this;\n\n\t},\n\n\ttranspose: function () {\n\n\t\tvar tmp, m = this.elements;\n\n\t\ttmp = m[1]; m[1] = m[3]; m[3] = tmp;\n\t\ttmp = m[2]; m[2] = m[6]; m[6] = tmp;\n\t\ttmp = m[5]; m[5] = m[7]; m[7] = tmp;\n\n\t\treturn this;\n\n\t},\n\n\tgetNormalMatrix: function ( m ) {\n\n\t\t// input: THREE.Matrix4\n\n\t\tthis.getInverse( m ).transpose();\n\n\t\treturn this;\n\n\t},\n\n\ttransposeIntoArray: function ( r ) {\n\n\t\tvar m = this.elements;\n\n\t\tr[ 0 ] = m[ 0 ];\n\t\tr[ 1 ] = m[ 3 ];\n\t\tr[ 2 ] = m[ 6 ];\n\t\tr[ 3 ] = m[ 1 ];\n\t\tr[ 4 ] = m[ 4 ];\n\t\tr[ 5 ] = m[ 7 ];\n\t\tr[ 6 ] = m[ 2 ];\n\t\tr[ 7 ] = m[ 5 ];\n\t\tr[ 8 ] = m[ 8 ];\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\tvar te = this.elements;\n\n\t\treturn new THREE.Matrix3(\n\n\t\t\tte[0], te[3], te[6],\n\t\t\tte[1], te[4], te[7],\n\t\t\tte[2], te[5], te[8]\n\n\t\t);\n\n\t}\n\n} );\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author supereggbert / http://www.paulbrunt.co.uk/\n * @author philogb / http://blog.thejit.org/\n * @author jordi_ros / http://plattsoft.com\n * @author D1plo1d / http://github.com/D1plo1d\n * @author alteredq / http://alteredqualia.com/\n * @author mikael emtinger / http://gomo.se/\n * @author timknip / http://www.floorplanner.com/\n * @author bhouston / http://exocortex.com\n */\n\n\nTHREE.Matrix4 = function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\n\n\tvar te = this.elements = new Float32Array( 16 );\n\n\t// TODO: if n11 is undefined, then just set to identity, otherwise copy all other values into matrix\n\t//   we should not support semi specification of Matrix4, it is just weird.\n\n\tte[0] = ( n11 !== undefined ) ? n11 : 1; te[4] = n12 || 0; te[8] = n13 || 0; te[12] = n14 || 0;\n\tte[1] = n21 || 0; te[5] = ( n22 !== undefined ) ? n22 : 1; te[9] = n23 || 0; te[13] = n24 || 0;\n\tte[2] = n31 || 0; te[6] = n32 || 0; te[10] = ( n33 !== undefined ) ? n33 : 1; te[14] = n34 || 0;\n\tte[3] = n41 || 0; te[7] = n42 || 0; te[11] = n43 || 0; te[15] = ( n44 !== undefined ) ? n44 : 1;\n\n};\n\nTHREE.extend( THREE.Matrix4.prototype, {\n\n\tset: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[0] = n11; te[4] = n12; te[8] = n13; te[12] = n14;\n\t\tte[1] = n21; te[5] = n22; te[9] = n23; te[13] = n24;\n\t\tte[2] = n31; te[6] = n32; te[10] = n33; te[14] = n34;\n\t\tte[3] = n41; te[7] = n42; te[11] = n43; te[15] = n44;\n\n\t\treturn this;\n\n\t},\n\n\tidentity: function () {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0, 0,\n\t\t\t0, 1, 0, 0,\n\t\t\t0, 0, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tcopy: function ( m ) {\n\n\t\tvar me = m.elements;\n\n\t\tthis.set(\n\n\t\t\tme[0], me[4], me[8], me[12],\n\t\t\tme[1], me[5], me[9], me[13],\n\t\t\tme[2], me[6], me[10], me[14],\n\t\t\tme[3], me[7], me[11], me[15]\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tsetRotationFromEuler: function ( v, order ) {\n\n\t\tvar te = this.elements;\n\n\t\tvar x = v.x, y = v.y, z = v.z;\n\t\tvar a = Math.cos( x ), b = Math.sin( x );\n\t\tvar c = Math.cos( y ), d = Math.sin( y );\n\t\tvar e = Math.cos( z ), f = Math.sin( z );\n\n\t\tif ( order === undefined || order === 'XYZ' ) {\n\n\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\tte[0] = c * e;\n\t\t\tte[4] = - c * f;\n\t\t\tte[8] = d;\n\n\t\t\tte[1] = af + be * d;\n\t\t\tte[5] = ae - bf * d;\n\t\t\tte[9] = - b * c;\n\n\t\t\tte[2] = bf - ae * d;\n\t\t\tte[6] = be + af * d;\n\t\t\tte[10] = a * c;\n\n\t\t} else if ( order === 'YXZ' ) {\n\n\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\tte[0] = ce + df * b;\n\t\t\tte[4] = de * b - cf;\n\t\t\tte[8] = a * d;\n\n\t\t\tte[1] = a * f;\n\t\t\tte[5] = a * e;\n\t\t\tte[9] = - b;\n\n\t\t\tte[2] = cf * b - de;\n\t\t\tte[6] = df + ce * b;\n\t\t\tte[10] = a * c;\n\n\t\t} else if ( order === 'ZXY' ) {\n\n\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\tte[0] = ce - df * b;\n\t\t\tte[4] = - a * f;\n\t\t\tte[8] = de + cf * b;\n\n\t\t\tte[1] = cf + de * b;\n\t\t\tte[5] = a * e;\n\t\t\tte[9] = df - ce * b;\n\n\t\t\tte[2] = - a * d;\n\t\t\tte[6] = b;\n\t\t\tte[10] = a * c;\n\n\t\t} else if ( order === 'ZYX' ) {\n\n\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\tte[0] = c * e;\n\t\t\tte[4] = be * d - af;\n\t\t\tte[8] = ae * d + bf;\n\n\t\t\tte[1] = c * f;\n\t\t\tte[5] = bf * d + ae;\n\t\t\tte[9] = af * d - be;\n\n\t\t\tte[2] = - d;\n\t\t\tte[6] = b * c;\n\t\t\tte[10] = a * c;\n\n\t\t} else if ( order === 'YZX' ) {\n\n\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\tte[0] = c * e;\n\t\t\tte[4] = bd - ac * f;\n\t\t\tte[8] = bc * f + ad;\n\n\t\t\tte[1] = f;\n\t\t\tte[5] = a * e;\n\t\t\tte[9] = - b * e;\n\n\t\t\tte[2] = - d * e;\n\t\t\tte[6] = ad * f + bc;\n\t\t\tte[10] = ac - bd * f;\n\n\t\t} else if ( order === 'XZY' ) {\n\n\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\tte[0] = c * e;\n\t\t\tte[4] = - f;\n\t\t\tte[8] = d * e;\n\n\t\t\tte[1] = ac * f + bd;\n\t\t\tte[5] = a * e;\n\t\t\tte[9] = ad * f - bc;\n\n\t\t\tte[2] = bc * f - ad;\n\t\t\tte[6] = b * e;\n\t\t\tte[10] = bd * f + ac;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetRotationFromQuaternion: function ( q ) {\n\n\t\tvar te = this.elements;\n\n\t\tvar x = q.x, y = q.y, z = q.z, w = q.w;\n\t\tvar x2 = x + x, y2 = y + y, z2 = z + z;\n\t\tvar xx = x * x2, xy = x * y2, xz = x * z2;\n\t\tvar yy = y * y2, yz = y * z2, zz = z * z2;\n\t\tvar wx = w * x2, wy = w * y2, wz = w * z2;\n\n\t\tte[0] = 1 - ( yy + zz );\n\t\tte[4] = xy - wz;\n\t\tte[8] = xz + wy;\n\n\t\tte[1] = xy + wz;\n\t\tte[5] = 1 - ( xx + zz );\n\t\tte[9] = yz - wx;\n\n\t\tte[2] = xz - wy;\n\t\tte[6] = yz + wx;\n\t\tte[10] = 1 - ( xx + yy );\n\n\t\treturn this;\n\n\t},\n\n\tlookAt: function() {\n\n\t\tvar x = new THREE.Vector3();\n\t\tvar y = new THREE.Vector3();\n\t\tvar z = new THREE.Vector3();\n\n\t\treturn function ( eye, target, up ) {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tz.subVectors( eye, target ).normalize();\n\n\t\t\tif ( z.length() === 0 ) {\n\n\t\t\t\tz.z = 1;\n\n\t\t\t}\n\n\t\t\tx.crossVectors( up, z ).normalize();\n\n\t\t\tif ( x.length() === 0 ) {\n\n\t\t\t\tz.x += 0.0001;\n\t\t\t\tx.crossVectors( up, z ).normalize();\n\n\t\t\t}\n\n\t\t\ty.crossVectors( z, x );\n\n\n\t\t\tte[0] = x.x; te[4] = y.x; te[8] = z.x;\n\t\t\tte[1] = x.y; te[5] = y.y; te[9] = z.y;\n\t\t\tte[2] = x.z; te[6] = y.z; te[10] = z.z;\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tmultiply: function ( m, n ) {\n\n\t\tif ( n !== undefined ) {\n\n\t\t\tconsole.warn( 'DEPRECATED: Matrix4\\'s .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );\n\t\t\treturn this.multiplyMatrices( m, n );\n\n\t\t}\n\n\t\treturn this.multiplyMatrices( this, m );\n\n\t},\n\n\tmultiplyMatrices: function ( a, b ) {\n\n\t\tvar ae = a.elements;\n\t\tvar be = b.elements;\n\t\tvar te = this.elements;\n\n\t\tvar a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];\n\t\tvar a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];\n\t\tvar a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];\n\t\tvar a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];\n\n\t\tvar b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];\n\t\tvar b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];\n\t\tvar b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];\n\t\tvar b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];\n\n\t\tte[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n\t\tte[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n\t\tte[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n\t\tte[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n\n\t\tte[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n\t\tte[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n\t\tte[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n\t\tte[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n\n\t\tte[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n\t\tte[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n\t\tte[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n\t\tte[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n\n\t\tte[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n\t\tte[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n\t\tte[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n\t\tte[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyToArray: function ( a, b, r ) {\n\n\t\tvar te = this.elements;\n\n\t\tthis.multiplyMatrices( a, b );\n\n\t\tr[ 0 ] = te[0]; r[ 1 ] = te[1]; r[ 2 ] = te[2]; r[ 3 ] = te[3];\n\t\tr[ 4 ] = te[4]; r[ 5 ] = te[5]; r[ 6 ] = te[6]; r[ 7 ] = te[7];\n\t\tr[ 8 ]  = te[8]; r[ 9 ]  = te[9]; r[ 10 ] = te[10]; r[ 11 ] = te[11];\n\t\tr[ 12 ] = te[12]; r[ 13 ] = te[13]; r[ 14 ] = te[14]; r[ 15 ] = te[15];\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( s ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[0] *= s; te[4] *= s; te[8] *= s; te[12] *= s;\n\t\tte[1] *= s; te[5] *= s; te[9] *= s; te[13] *= s;\n\t\tte[2] *= s; te[6] *= s; te[10] *= s; te[14] *= s;\n\t\tte[3] *= s; te[7] *= s; te[11] *= s; te[15] *= s;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyVector3: function ( vector ) {\n\n\t\tconsole.warn( 'DEPRECATED: Matrix4\\'s .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );\n\t\treturn vector.applyProjection( this );\n\n\t},\n\n\tmultiplyVector4: function ( vector ) {\n\n\t\tconsole.warn( 'DEPRECATED: Matrix4\\'s .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n\t\treturn vector.applyMatrix4( this );\n\n\t},\n\n\tmultiplyVector3Array: function() {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function ( a ) {\n\n\t\t\tfor ( var i = 0, il = a.length; i < il; i += 3 ) {\n\n\t\t\t\tv1.x = a[ i ];\n\t\t\t\tv1.y = a[ i + 1 ];\n\t\t\t\tv1.z = a[ i + 2 ];\n\n\t\t\t\tv1.applyProjection( this );\n\n\t\t\t\ta[ i ]     = v1.x;\n\t\t\t\ta[ i + 1 ] = v1.y;\n\t\t\t\ta[ i + 2 ] = v1.z;\n\n\t\t\t}\n\n\t\t\treturn a;\n\n\t\t};\n\n\t}(),\n\n\trotateAxis: function ( v ) {\n\n\t\tvar te = this.elements;\n\t\tvar vx = v.x, vy = v.y, vz = v.z;\n\n\t\tv.x = vx * te[0] + vy * te[4] + vz * te[8];\n\t\tv.y = vx * te[1] + vy * te[5] + vz * te[9];\n\t\tv.z = vx * te[2] + vy * te[6] + vz * te[10];\n\n\t\tv.normalize();\n\n\t\treturn v;\n\n\t},\n\n\tcrossVector: function ( a ) {\n\n\t\tvar te = this.elements;\n\t\tvar v = new THREE.Vector4();\n\n\t\tv.x = te[0] * a.x + te[4] * a.y + te[8] * a.z + te[12] * a.w;\n\t\tv.y = te[1] * a.x + te[5] * a.y + te[9] * a.z + te[13] * a.w;\n\t\tv.z = te[2] * a.x + te[6] * a.y + te[10] * a.z + te[14] * a.w;\n\n\t\tv.w = ( a.w ) ? te[3] * a.x + te[7] * a.y + te[11] * a.z + te[15] * a.w : 1;\n\n\t\treturn v;\n\n\t},\n\n\tdeterminant: function () {\n\n\t\tvar te = this.elements;\n\n\t\tvar n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];\n\t\tvar n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];\n\t\tvar n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];\n\t\tvar n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];\n\n\t\t//TODO: make this more efficient\n\t\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\n\n\t\treturn (\n\t\t\tn41 * (\n\t\t\t\t+n14 * n23 * n32\n\t\t\t\t-n13 * n24 * n32\n\t\t\t\t-n14 * n22 * n33\n\t\t\t\t+n12 * n24 * n33\n\t\t\t\t+n13 * n22 * n34\n\t\t\t\t-n12 * n23 * n34\n\t\t\t) +\n\t\t\tn42 * (\n\t\t\t\t+n11 * n23 * n34\n\t\t\t\t-n11 * n24 * n33\n\t\t\t\t+n14 * n21 * n33\n\t\t\t\t-n13 * n21 * n34\n\t\t\t\t+n13 * n24 * n31\n\t\t\t\t-n14 * n23 * n31\n\t\t\t) +\n\t\t\tn43 * (\n\t\t\t\t+n11 * n24 * n32\n\t\t\t\t-n11 * n22 * n34\n\t\t\t\t-n14 * n21 * n32\n\t\t\t\t+n12 * n21 * n34\n\t\t\t\t+n14 * n22 * n31\n\t\t\t\t-n12 * n24 * n31\n\t\t\t) +\n\t\t\tn44 * (\n\t\t\t\t-n13 * n22 * n31\n\t\t\t\t-n11 * n23 * n32\n\t\t\t\t+n11 * n22 * n33\n\t\t\t\t+n13 * n21 * n32\n\t\t\t\t-n12 * n21 * n33\n\t\t\t\t+n12 * n23 * n31\n\t\t\t)\n\n\t\t);\n\n\t},\n\n\ttranspose: function () {\n\n\t\tvar te = this.elements;\n\t\tvar tmp;\n\n\t\ttmp = te[1]; te[1] = te[4]; te[4] = tmp;\n\t\ttmp = te[2]; te[2] = te[8]; te[8] = tmp;\n\t\ttmp = te[6]; te[6] = te[9]; te[9] = tmp;\n\n\t\ttmp = te[3]; te[3] = te[12]; te[12] = tmp;\n\t\ttmp = te[7]; te[7] = te[13]; te[13] = tmp;\n\t\ttmp = te[11]; te[11] = te[14]; te[14] = tmp;\n\n\t\treturn this;\n\n\t},\n\n\tflattenToArray: function ( flat ) {\n\n\t\tvar te = this.elements;\n\t\tflat[ 0 ] = te[0]; flat[ 1 ] = te[1]; flat[ 2 ] = te[2]; flat[ 3 ] = te[3];\n\t\tflat[ 4 ] = te[4]; flat[ 5 ] = te[5]; flat[ 6 ] = te[6]; flat[ 7 ] = te[7];\n\t\tflat[ 8 ] = te[8]; flat[ 9 ] = te[9]; flat[ 10 ] = te[10]; flat[ 11 ] = te[11];\n\t\tflat[ 12 ] = te[12]; flat[ 13 ] = te[13]; flat[ 14 ] = te[14]; flat[ 15 ] = te[15];\n\n\t\treturn flat;\n\n\t},\n\n\tflattenToArrayOffset: function( flat, offset ) {\n\n\t\tvar te = this.elements;\n\t\tflat[ offset ] = te[0];\n\t\tflat[ offset + 1 ] = te[1];\n\t\tflat[ offset + 2 ] = te[2];\n\t\tflat[ offset + 3 ] = te[3];\n\n\t\tflat[ offset + 4 ] = te[4];\n\t\tflat[ offset + 5 ] = te[5];\n\t\tflat[ offset + 6 ] = te[6];\n\t\tflat[ offset + 7 ] = te[7];\n\n\t\tflat[ offset + 8 ]  = te[8];\n\t\tflat[ offset + 9 ]  = te[9];\n\t\tflat[ offset + 10 ] = te[10];\n\t\tflat[ offset + 11 ] = te[11];\n\n\t\tflat[ offset + 12 ] = te[12];\n\t\tflat[ offset + 13 ] = te[13];\n\t\tflat[ offset + 14 ] = te[14];\n\t\tflat[ offset + 15 ] = te[15];\n\n\t\treturn flat;\n\n\t},\n\n\tgetPosition: function() {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function () {\n\n\t\t\tconsole.warn( 'DEPRECATED: Matrix4\\'s .getPosition() has been removed. Use Vector3.getPositionFromMatrix( matrix ) instead.' );\n\n\t\t\tvar te = this.elements;\n\t\t\treturn v1.set( te[12], te[13], te[14] );\n\n\t\t};\n\n\t}(),\n\n\tsetPosition: function ( v ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[12] = v.x;\n\t\tte[13] = v.y;\n\t\tte[14] = v.z;\n\n\t\treturn this;\n\n\t},\n\n\tgetInverse: function ( m, throwOnInvertible ) {\n\n\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n\t\tvar te = this.elements;\n\t\tvar me = m.elements;\n\n\t\tvar n11 = me[0], n12 = me[4], n13 = me[8], n14 = me[12];\n\t\tvar n21 = me[1], n22 = me[5], n23 = me[9], n24 = me[13];\n\t\tvar n31 = me[2], n32 = me[6], n33 = me[10], n34 = me[14];\n\t\tvar n41 = me[3], n42 = me[7], n43 = me[11], n44 = me[15];\n\n\t\tte[0] = n23*n34*n42 - n24*n33*n42 + n24*n32*n43 - n22*n34*n43 - n23*n32*n44 + n22*n33*n44;\n\t\tte[4] = n14*n33*n42 - n13*n34*n42 - n14*n32*n43 + n12*n34*n43 + n13*n32*n44 - n12*n33*n44;\n\t\tte[8] = n13*n24*n42 - n14*n23*n42 + n14*n22*n43 - n12*n24*n43 - n13*n22*n44 + n12*n23*n44;\n\t\tte[12] = n14*n23*n32 - n13*n24*n32 - n14*n22*n33 + n12*n24*n33 + n13*n22*n34 - n12*n23*n34;\n\t\tte[1] = n24*n33*n41 - n23*n34*n41 - n24*n31*n43 + n21*n34*n43 + n23*n31*n44 - n21*n33*n44;\n\t\tte[5] = n13*n34*n41 - n14*n33*n41 + n14*n31*n43 - n11*n34*n43 - n13*n31*n44 + n11*n33*n44;\n\t\tte[9] = n14*n23*n41 - n13*n24*n41 - n14*n21*n43 + n11*n24*n43 + n13*n21*n44 - n11*n23*n44;\n\t\tte[13] = n13*n24*n31 - n14*n23*n31 + n14*n21*n33 - n11*n24*n33 - n13*n21*n34 + n11*n23*n34;\n\t\tte[2] = n22*n34*n41 - n24*n32*n41 + n24*n31*n42 - n21*n34*n42 - n22*n31*n44 + n21*n32*n44;\n\t\tte[6] = n14*n32*n41 - n12*n34*n41 - n14*n31*n42 + n11*n34*n42 + n12*n31*n44 - n11*n32*n44;\n\t\tte[10] = n12*n24*n41 - n14*n22*n41 + n14*n21*n42 - n11*n24*n42 - n12*n21*n44 + n11*n22*n44;\n\t\tte[14] = n14*n22*n31 - n12*n24*n31 - n14*n21*n32 + n11*n24*n32 + n12*n21*n34 - n11*n22*n34;\n\t\tte[3] = n23*n32*n41 - n22*n33*n41 - n23*n31*n42 + n21*n33*n42 + n22*n31*n43 - n21*n32*n43;\n\t\tte[7] = n12*n33*n41 - n13*n32*n41 + n13*n31*n42 - n11*n33*n42 - n12*n31*n43 + n11*n32*n43;\n\t\tte[11] = n13*n22*n41 - n12*n23*n41 - n13*n21*n42 + n11*n23*n42 + n12*n21*n43 - n11*n22*n43;\n\t\tte[15] = n12*n23*n31 - n13*n22*n31 + n13*n21*n32 - n11*n23*n32 - n12*n21*n33 + n11*n22*n33;\n\n\t\tvar det = me[ 0 ] * te[ 0 ] + me[ 1 ] * te[ 4 ] + me[ 2 ] * te[ 8 ] + me[ 3 ] * te[ 12 ];\n\n\t\tif ( det == 0 ) {\n\n\t\t\tvar msg = \"Matrix4.getInverse(): can't invert matrix, determinant is 0\";\n\n\t\t\tif ( throwOnInvertible || false ) {\n\n\t\t\t\tthrow new Error( msg ); \n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( msg );\n\n\t\t\t}\n\n\t\t\tthis.identity();\n\n\t\t\treturn this;\n\t\t}\n\n\t\tthis.multiplyScalar( 1 / det );\n\n\t\treturn this;\n\n\t},\n\n\tcompose: function() {\n\n\t\tvar mRotation = new THREE.Matrix4(),\n\t\t\tmScale = new THREE.Matrix4();\n\t\t\n\t\treturn function ( translation, rotation, scale ) {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tmRotation.identity();\n\t\t\tmRotation.setRotationFromQuaternion( rotation );\n\n\t\t\tmScale.makeScale( scale.x, scale.y, scale.z );\n\n\t\t\tthis.multiplyMatrices( mRotation, mScale );\n\n\t\t\tte[12] = translation.x;\n\t\t\tte[13] = translation.y;\n\t\t\tte[14] = translation.z;\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tdecompose: function() {\n\n\t\tvar x = new THREE.Vector3(),\n\t\t\ty = new THREE.Vector3(),\n\t\t\tz = new THREE.Vector3(),\n\t\t\tmatrix = new THREE.Matrix4();\n\n\t\treturn function ( translation, rotation, scale ) {\n\n\t\t\tvar te = this.elements;\n\n\t\t\t// grab the axis vectors\n\t\t\tx.set( te[0], te[1], te[2] );\n\t\t\ty.set( te[4], te[5], te[6] );\n\t\t\tz.set( te[8], te[9], te[10] );\n\n\t\t\ttranslation = ( translation instanceof THREE.Vector3 ) ? translation : new THREE.Vector3();\n\t\t\trotation = ( rotation instanceof THREE.Quaternion ) ? rotation : new THREE.Quaternion();\n\t\t\tscale = ( scale instanceof THREE.Vector3 ) ? scale : new THREE.Vector3();\n\n\t\t\tscale.x = x.length();\n\t\t\tscale.y = y.length();\n\t\t\tscale.z = z.length();\n\n\t\t\ttranslation.x = te[12];\n\t\t\ttranslation.y = te[13];\n\t\t\ttranslation.z = te[14];\n\n\t\t\t// scale the rotation part\n\n\t\t\tmatrix.copy( this );\n\n\t\t\tmatrix.elements[0] /= scale.x;\n\t\t\tmatrix.elements[1] /= scale.x;\n\t\t\tmatrix.elements[2] /= scale.x;\n\n\t\t\tmatrix.elements[4] /= scale.y;\n\t\t\tmatrix.elements[5] /= scale.y;\n\t\t\tmatrix.elements[6] /= scale.y;\n\n\t\t\tmatrix.elements[8] /= scale.z;\n\t\t\tmatrix.elements[9] /= scale.z;\n\t\t\tmatrix.elements[10] /= scale.z;\n\n\t\t\trotation.setFromRotationMatrix( matrix );\n\n\t\t\treturn [ translation, rotation, scale ];\n\n\t\t};\n\n\t}(),\n\n\textractPosition: function ( m ) {\n\n\t\tvar te = this.elements;\n\t\tvar me = m.elements;\n\n\t\tte[12] = me[12];\n\t\tte[13] = me[13];\n\t\tte[14] = me[14];\n\n\t\treturn this;\n\n\t},\n\n\textractRotation: function() {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function ( m ) {\n\n\t\t\tvar te = this.elements;\n\t\t\tvar me = m.elements;\n\n\t\t\tvar scaleX = 1 / v1.set( me[0], me[1], me[2] ).length();\n\t\t\tvar scaleY = 1 / v1.set( me[4], me[5], me[6] ).length();\n\t\t\tvar scaleZ = 1 / v1.set( me[8], me[9], me[10] ).length();\n\n\t\t\tte[0] = me[0] * scaleX;\n\t\t\tte[1] = me[1] * scaleX;\n\t\t\tte[2] = me[2] * scaleX;\n\n\t\t\tte[4] = me[4] * scaleY;\n\t\t\tte[5] = me[5] * scaleY;\n\t\t\tte[6] = me[6] * scaleY;\n\n\t\t\tte[8] = me[8] * scaleZ;\n\t\t\tte[9] = me[9] * scaleZ;\n\t\t\tte[10] = me[10] * scaleZ;\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\ttranslate: function ( v ) {\n\n\t\tvar te = this.elements;\n\t\tvar x = v.x, y = v.y, z = v.z;\n\n\t\tte[12] = te[0] * x + te[4] * y + te[8] * z + te[12];\n\t\tte[13] = te[1] * x + te[5] * y + te[9] * z + te[13];\n\t\tte[14] = te[2] * x + te[6] * y + te[10] * z + te[14];\n\t\tte[15] = te[3] * x + te[7] * y + te[11] * z + te[15];\n\n\t\treturn this;\n\n\t},\n\n\trotateX: function ( angle ) {\n\n\t\tvar te = this.elements;\n\t\tvar m12 = te[4];\n\t\tvar m22 = te[5];\n\t\tvar m32 = te[6];\n\t\tvar m42 = te[7];\n\t\tvar m13 = te[8];\n\t\tvar m23 = te[9];\n\t\tvar m33 = te[10];\n\t\tvar m43 = te[11];\n\t\tvar c = Math.cos( angle );\n\t\tvar s = Math.sin( angle );\n\n\t\tte[4] = c * m12 + s * m13;\n\t\tte[5] = c * m22 + s * m23;\n\t\tte[6] = c * m32 + s * m33;\n\t\tte[7] = c * m42 + s * m43;\n\n\t\tte[8] = c * m13 - s * m12;\n\t\tte[9] = c * m23 - s * m22;\n\t\tte[10] = c * m33 - s * m32;\n\t\tte[11] = c * m43 - s * m42;\n\n\t\treturn this;\n\n\t},\n\n\trotateY: function ( angle ) {\n\n\t\tvar te = this.elements;\n\t\tvar m11 = te[0];\n\t\tvar m21 = te[1];\n\t\tvar m31 = te[2];\n\t\tvar m41 = te[3];\n\t\tvar m13 = te[8];\n\t\tvar m23 = te[9];\n\t\tvar m33 = te[10];\n\t\tvar m43 = te[11];\n\t\tvar c = Math.cos( angle );\n\t\tvar s = Math.sin( angle );\n\n\t\tte[0] = c * m11 - s * m13;\n\t\tte[1] = c * m21 - s * m23;\n\t\tte[2] = c * m31 - s * m33;\n\t\tte[3] = c * m41 - s * m43;\n\n\t\tte[8] = c * m13 + s * m11;\n\t\tte[9] = c * m23 + s * m21;\n\t\tte[10] = c * m33 + s * m31;\n\t\tte[11] = c * m43 + s * m41;\n\n\t\treturn this;\n\n\t},\n\n\trotateZ: function ( angle ) {\n\n\t\tvar te = this.elements;\n\t\tvar m11 = te[0];\n\t\tvar m21 = te[1];\n\t\tvar m31 = te[2];\n\t\tvar m41 = te[3];\n\t\tvar m12 = te[4];\n\t\tvar m22 = te[5];\n\t\tvar m32 = te[6];\n\t\tvar m42 = te[7];\n\t\tvar c = Math.cos( angle );\n\t\tvar s = Math.sin( angle );\n\n\t\tte[0] = c * m11 + s * m12;\n\t\tte[1] = c * m21 + s * m22;\n\t\tte[2] = c * m31 + s * m32;\n\t\tte[3] = c * m41 + s * m42;\n\n\t\tte[4] = c * m12 - s * m11;\n\t\tte[5] = c * m22 - s * m21;\n\t\tte[6] = c * m32 - s * m31;\n\t\tte[7] = c * m42 - s * m41;\n\n\t\treturn this;\n\n\t},\n\n\trotateByAxis: function ( axis, angle ) {\n\n\t\tvar te = this.elements;\n\n\t\t// optimize by checking axis\n\n\t\tif ( axis.x === 1 && axis.y === 0 && axis.z === 0 ) {\n\n\t\t\treturn this.rotateX( angle );\n\n\t\t} else if ( axis.x === 0 && axis.y === 1 && axis.z === 0 ) {\n\n\t\t\treturn this.rotateY( angle );\n\n\t\t} else if ( axis.x === 0 && axis.y === 0 && axis.z === 1 ) {\n\n\t\t\treturn this.rotateZ( angle );\n\n\t\t}\n\n\t\tvar x = axis.x, y = axis.y, z = axis.z;\n\t\tvar n = Math.sqrt(x * x + y * y + z * z);\n\n\t\tx /= n;\n\t\ty /= n;\n\t\tz /= n;\n\n\t\tvar xx = x * x, yy = y * y, zz = z * z;\n\t\tvar c = Math.cos( angle );\n\t\tvar s = Math.sin( angle );\n\t\tvar oneMinusCosine = 1 - c;\n\t\tvar xy = x * y * oneMinusCosine;\n\t\tvar xz = x * z * oneMinusCosine;\n\t\tvar yz = y * z * oneMinusCosine;\n\t\tvar xs = x * s;\n\t\tvar ys = y * s;\n\t\tvar zs = z * s;\n\n\t\tvar r11 = xx + (1 - xx) * c;\n\t\tvar r21 = xy + zs;\n\t\tvar r31 = xz - ys;\n\t\tvar r12 = xy - zs;\n\t\tvar r22 = yy + (1 - yy) * c;\n\t\tvar r32 = yz + xs;\n\t\tvar r13 = xz + ys;\n\t\tvar r23 = yz - xs;\n\t\tvar r33 = zz + (1 - zz) * c;\n\n\t\tvar m11 = te[0], m21 = te[1], m31 = te[2], m41 = te[3];\n\t\tvar m12 = te[4], m22 = te[5], m32 = te[6], m42 = te[7];\n\t\tvar m13 = te[8], m23 = te[9], m33 = te[10], m43 = te[11];\n\n\t\tte[0] = r11 * m11 + r21 * m12 + r31 * m13;\n\t\tte[1] = r11 * m21 + r21 * m22 + r31 * m23;\n\t\tte[2] = r11 * m31 + r21 * m32 + r31 * m33;\n\t\tte[3] = r11 * m41 + r21 * m42 + r31 * m43;\n\n\t\tte[4] = r12 * m11 + r22 * m12 + r32 * m13;\n\t\tte[5] = r12 * m21 + r22 * m22 + r32 * m23;\n\t\tte[6] = r12 * m31 + r22 * m32 + r32 * m33;\n\t\tte[7] = r12 * m41 + r22 * m42 + r32 * m43;\n\n\t\tte[8] = r13 * m11 + r23 * m12 + r33 * m13;\n\t\tte[9] = r13 * m21 + r23 * m22 + r33 * m23;\n\t\tte[10] = r13 * m31 + r23 * m32 + r33 * m33;\n\t\tte[11] = r13 * m41 + r23 * m42 + r33 * m43;\n\n\t\treturn this;\n\n\t},\n\n\tscale: function ( v ) {\n\n\t\tvar te = this.elements;\n\t\tvar x = v.x, y = v.y, z = v.z;\n\n\t\tte[0] *= x; te[4] *= y; te[8] *= z;\n\t\tte[1] *= x; te[5] *= y; te[9] *= z;\n\t\tte[2] *= x; te[6] *= y; te[10] *= z;\n\t\tte[3] *= x; te[7] *= y; te[11] *= z;\n\n\t\treturn this;\n\n\t},\n\n\tgetMaxScaleOnAxis: function () {\n\n\t\tvar te = this.elements;\n\n\t\tvar scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];\n\t\tvar scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];\n\t\tvar scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];\n\n\t\treturn Math.sqrt( Math.max( scaleXSq, Math.max( scaleYSq, scaleZSq ) ) );\n\n\t},\n\n\tmakeTranslation: function ( x, y, z ) {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0, x,\n\t\t\t0, 1, 0, y,\n\t\t\t0, 0, 1, z,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tmakeRotationX: function ( theta ) {\n\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\t1, 0,  0, 0,\n\t\t\t0, c, -s, 0,\n\t\t\t0, s,  c, 0,\n\t\t\t0, 0,  0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tmakeRotationY: function ( theta ) {\n\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\t c, 0, s, 0,\n\t\t\t 0, 1, 0, 0,\n\t\t\t-s, 0, c, 0,\n\t\t\t 0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tmakeRotationZ: function ( theta ) {\n\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\tc, -s, 0, 0,\n\t\t\ts,  c, 0, 0,\n\t\t\t0,  0, 1, 0,\n\t\t\t0,  0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tmakeRotationAxis: function ( axis, angle ) {\n\n\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\n\n\t\tvar c = Math.cos( angle );\n\t\tvar s = Math.sin( angle );\n\t\tvar t = 1 - c;\n\t\tvar x = axis.x, y = axis.y, z = axis.z;\n\t\tvar tx = t * x, ty = t * y;\n\n\t\tthis.set(\n\n\t\t\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\n\t\t\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\n\t\t\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\t return this;\n\n\t},\n\n\tmakeScale: function ( x, y, z ) {\n\n\t\tthis.set(\n\n\t\t\tx, 0, 0, 0,\n\t\t\t0, y, 0, 0,\n\t\t\t0, 0, z, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tmakeFrustum: function ( left, right, bottom, top, near, far ) {\n\n\t\tvar te = this.elements;\n\t\tvar x = 2 * near / ( right - left );\n\t\tvar y = 2 * near / ( top - bottom );\n\n\t\tvar a = ( right + left ) / ( right - left );\n\t\tvar b = ( top + bottom ) / ( top - bottom );\n\t\tvar c = - ( far + near ) / ( far - near );\n\t\tvar d = - 2 * far * near / ( far - near );\n\n\t\tte[0] = x;\tte[4] = 0;\tte[8] = a;\tte[12] = 0;\n\t\tte[1] = 0;\tte[5] = y;\tte[9] = b;\tte[13] = 0;\n\t\tte[2] = 0;\tte[6] = 0;\tte[10] = c;\tte[14] = d;\n\t\tte[3] = 0;\tte[7] = 0;\tte[11] = - 1;\tte[15] = 0;\n\n\t\treturn this;\n\n\t},\n\n\tmakePerspective: function ( fov, aspect, near, far ) {\n\n\t\tvar ymax = near * Math.tan( THREE.Math.degToRad( fov * 0.5 ) );\n\t\tvar ymin = - ymax;\n\t\tvar xmin = ymin * aspect;\n\t\tvar xmax = ymax * aspect;\n\n\t\treturn this.makeFrustum( xmin, xmax, ymin, ymax, near, far );\n\n\t},\n\n\tmakeOrthographic: function ( left, right, top, bottom, near, far ) {\n\n\t\tvar te = this.elements;\n\t\tvar w = right - left;\n\t\tvar h = top - bottom;\n\t\tvar p = far - near;\n\n\t\tvar x = ( right + left ) / w;\n\t\tvar y = ( top + bottom ) / h;\n\t\tvar z = ( far + near ) / p;\n\n\t\tte[0] = 2 / w;\tte[4] = 0;\tte[8] = 0;\tte[12] = -x;\n\t\tte[1] = 0;\tte[5] = 2 / h;\tte[9] = 0;\tte[13] = -y;\n\t\tte[2] = 0;\tte[6] = 0;\tte[10] = -2/p;\tte[14] = -z;\n\t\tte[3] = 0;\tte[7] = 0;\tte[11] = 0;\tte[15] = 1;\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\tvar te = this.elements;\n\n\t\treturn new THREE.Matrix4(\n\n\t\t\tte[0], te[4], te[8], te[12],\n\t\t\tte[1], te[5], te[9], te[13],\n\t\t\tte[2], te[6], te[10], te[14],\n\t\t\tte[3], te[7], te[11], te[15]\n\n\t\t);\n\n\t}\n\n} );\n/**\n * @author bhouston / http://exocortex.com\n */\n\nTHREE.Ray = function ( origin, direction ) {\n\n\tthis.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();\n\tthis.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();\n\n};\n\nTHREE.extend( THREE.Ray.prototype, {\n\n\tset: function ( origin, direction ) {\n\n\t\tthis.origin.copy( origin );\n\t\tthis.direction.copy( direction );\n\n\t\treturn this;\n\n\t},\n\n\tcopy: function ( ray ) {\n\n\t\tthis.origin.copy( ray.origin );\n\t\tthis.direction.copy( ray.direction );\n\n\t\treturn this;\n\n\t},\n\n\tat: function( t, optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\treturn result.copy( this.direction ).multiplyScalar( t ).add( this.origin );\n\n\t},\n\n\trecast: function() {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function ( t ) {\n\n\t\t\tthis.origin.copy( this.at( t, v1 ) );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tclosestPointToPoint: function ( point, optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\tresult.subVectors( point, this.origin );\n\t\tvar directionDistance = result.dot( this.direction );\n\n\t\treturn result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\n\t},\n\n\tdistanceToPoint: function() {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function ( point ) {\n\n\t\t\tvar directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );\n\t\t\tv1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\n\t\t\treturn v1.distanceTo( point );\n\n\t\t};\n\n\t}(),\n\n\tisIntersectionSphere: function( sphere ) {\n\n\t\treturn ( this.distanceToPoint( sphere.center ) <= sphere.radius );\n\n\t},\n\n\tisIntersectionPlane: function ( plane ) {\n\n\t\t// check if the line and plane are non-perpendicular, if they\n\t\t// eventually they will intersect.\n\t\tvar denominator = plane.normal.dot( this.direction );\n\t\tif ( denominator != 0 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\t// line is coplanar, return origin\n\t\tif( plane.distanceToPoint( this.origin ) == 0 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t},\n\n\tdistanceToPlane: function ( plane ) {\n\n\t\tvar denominator = plane.normal.dot( this.direction );\n\t\tif ( denominator == 0 ) {\n\n\t\t\t// line is coplanar, return origin\n\t\t\tif( plane.distanceToPoint( this.origin ) == 0 ) {\n\n\t\t\t\treturn 0;\n\n\t\t\t}\n\n\t\t\t// Unsure if this is the correct method to handle this case.\n\t\t\treturn undefined;\n\n\t\t}\n\n\t\tvar t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\n\n\t\treturn t;\n\n\t},\n\n\tintersectPlane: function ( plane, optionalTarget ) {\n\n\t\tvar t = this.distanceToPlane( plane );\n\n\t\tif ( t === undefined ) {\n\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn this.at( t, optionalTarget );\n\n\t},\n\n\tapplyMatrix4: function ( matrix4 ) {\n\n\t\tthis.direction.add( this.origin ).applyMatrix4( matrix4 );\n\t\tthis.origin.applyMatrix4( matrix4 );\n\t\tthis.direction.sub( this.origin );\n\n\t\treturn this;\n\t},\n\n\tequals: function ( ray ) {\n\n\t\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new THREE.Ray().copy( this );\n\n\t}\n\n} );\n/**\n * @author bhouston / http://exocortex.com\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Sphere = function ( center, radius ) {\n\n\tthis.center = ( center !== undefined ) ? center : new THREE.Vector3();\n\tthis.radius = ( radius !== undefined ) ? radius : 0;\n\n};\n\nTHREE.extend( THREE.Sphere.prototype, {\n\n\tset: function ( center, radius ) {\n\n\t\tthis.center.copy( center );\n\t\tthis.radius = radius;\n\n\t\treturn this;\n\t},\n\n\tsetFromCenterAndPoints: function ( center, points ) {\n\n\t\tvar maxRadiusSq = 0;\n\n\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\tvar radiusSq = center.distanceToSquared( points[ i ] );\n\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, radiusSq );\n\n\t\t}\n\n\t\tthis.center = center;\n\t\tthis.radius = Math.sqrt( maxRadiusSq );\n\n\t\treturn this;\n\n\t},\n\n\tcopy: function ( sphere ) {\n\n\t\tthis.center.copy( sphere.center );\n\t\tthis.radius = sphere.radius;\n\n\t\treturn this;\n\n\t},\n\n\tempty: function () {\n\n\t\treturn ( this.radius <= 0 );\n\n\t},\n\n\tcontainsPoint: function ( point ) {\n\n\t\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\n\n\t},\n\n\tdistanceToPoint: function ( point ) {\n\n\t\treturn ( point.distanceTo( this.center ) - this.radius );\n\n\t},\n\n\tintersectsSphere: function ( sphere ) {\n\n\t\tvar radiusSum = this.radius + sphere.radius;\n\n\t\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\n\n\t},\n\n\tclampPoint: function ( point, optionalTarget ) {\n\n\t\tvar deltaLengthSq = this.center.distanceToSquared( point );\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\tresult.copy( point );\n\n\t\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\n\n\t\t\tresult.sub( this.center ).normalize();\n\t\t\tresult.multiplyScalar( this.radius ).add( this.center );\n\n\t\t}\n\n\t\treturn result;\n\n\t},\n\n\tgetBoundingBox: function ( optionalTarget ) {\n\n\t\tvar box = optionalTarget || new THREE.Box3();\n\n\t\tbox.set( this.center, this.center );\n\t\tbox.expandByScalar( this.radius );\n\n\t\treturn box;\n\n\t},\n\n\tapplyMatrix4: function ( matrix ) {\n\n\t\tthis.center.applyMatrix4( matrix );\n\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\n\n\t\treturn this;\n\n\t},\n\n\ttranslate: function ( offset ) {\n\n\t\tthis.center.add( offset );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( sphere ) {\n\n\t\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new THREE.Sphere().copy( this );\n\n\t}\n\n} );\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author bhouston / http://exocortex.com\n */\n\nTHREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {\n\n\tthis.planes = [\n\n\t\t( p0 !== undefined ) ? p0 : new THREE.Plane(),\n\t\t( p1 !== undefined ) ? p1 : new THREE.Plane(),\n\t\t( p2 !== undefined ) ? p2 : new THREE.Plane(),\n\t\t( p3 !== undefined ) ? p3 : new THREE.Plane(),\n\t\t( p4 !== undefined ) ? p4 : new THREE.Plane(),\n\t\t( p5 !== undefined ) ? p5 : new THREE.Plane()\n\n\t];\n\n};\n\nTHREE.extend( THREE.Frustum.prototype, {\n\n\tset: function ( p0, p1, p2, p3, p4, p5 ) {\n\n\t\tvar planes = this.planes;\n\n\t\tplanes[0].copy( p0 );\n\t\tplanes[1].copy( p1 );\n\t\tplanes[2].copy( p2 );\n\t\tplanes[3].copy( p3 );\n\t\tplanes[4].copy( p4 );\n\t\tplanes[5].copy( p5 );\n\n\t\treturn this;\n\n\t},\n\n\tcopy: function ( frustum ) {\n\n\t\tvar planes = this.planes;\n\n\t\tfor( var i = 0; i < 6; i ++ ) {\n\n\t\t\tplanes[i].copy( frustum.planes[i] );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetFromMatrix: function ( m ) {\n\n\t\tvar planes = this.planes;\n\t\tvar me = m.elements;\n\t\tvar me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];\n\t\tvar me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];\n\t\tvar me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];\n\t\tvar me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];\n\n\t\tplanes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();\n\t\tplanes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();\n\t\tplanes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();\n\t\tplanes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();\n\t\tplanes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();\n\t\tplanes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();\n\n\t\treturn this;\n\n\t},\n\n\tintersectsObject: function () {\n\n\t\tvar center = new THREE.Vector3();\n\n\t\treturn function ( object ) {\n\n\t\t\t// this method is expanded inlined for performance reasons.\n\n\t\t\tvar matrix = object.matrixWorld;\n\t\t\tvar planes = this.planes;\n\t\t\tvar negRadius = - object.geometry.boundingSphere.radius * matrix.getMaxScaleOnAxis();\n\n\t\t\tcenter.getPositionFromMatrix( matrix );\n\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\tvar distance = planes[ i ].distanceToPoint( center );\n\n\t\t\t\tif ( distance < negRadius ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t};\n\n\t}(),\n\n\tintersectsSphere: function ( sphere ) {\n\n\t\tvar planes = this.planes;\n\t\tvar center = sphere.center;\n\t\tvar negRadius = -sphere.radius;\n\n\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\tvar distance = planes[ i ].distanceToPoint( center );\n\n\t\t\tif ( distance < negRadius ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tcontainsPoint: function ( point ) {\n\n\t\tvar planes = this.planes;\n\n\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\tif ( planes[ i ].distanceToPoint( point ) < 0 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new THREE.Frustum().copy( this );\n\n\t}\n\n} );\n/**\n * @author bhouston / http://exocortex.com\n */\n\nTHREE.Plane = function ( normal, constant ) {\n\n\tthis.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );\n\tthis.constant = ( constant !== undefined ) ? constant : 0;\n\n};\n\nTHREE.extend( THREE.Plane.prototype, {\n\n\tset: function ( normal, constant ) {\n\n\t\tthis.normal.copy( normal );\n\t\tthis.constant = constant;\n\n\t\treturn this;\n\n\t},\n\n\tsetComponents: function ( x, y, z, w ) {\n\n\t\tthis.normal.set( x, y, z );\n\t\tthis.constant = w;\n\n\t\treturn this;\n\n\t},\n\n\tsetFromNormalAndCoplanarPoint: function ( normal, point ) {\n\n\t\tthis.normal.copy( normal );\n\t\tthis.constant = - point.dot( this.normal );\t// must be this.normal, not normal, as this.normal is normalized\n\n\t\treturn this;\n\n\t},\n\n\tsetFromCoplanarPoints: function() {\n\n\t\tvar v1 = new THREE.Vector3();\n\t\tvar v2 = new THREE.Vector3();\n\n\t\treturn function ( a, b, c ) {\n\n\t\t\tvar normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();\n\n\t\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\n\t\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\n\tcopy: function ( plane ) {\n\n\t\tthis.normal.copy( plane.normal );\n\t\tthis.constant = plane.constant;\n\n\t\treturn this;\n\n\t},\n\n\tnormalize: function () {\n\n\t\t// Note: will lead to a divide by zero if the plane is invalid.\n\n\t\tvar inverseNormalLength = 1.0 / this.normal.length();\n\t\tthis.normal.multiplyScalar( inverseNormalLength );\n\t\tthis.constant *= inverseNormalLength;\n\n\t\treturn this;\n\n\t},\n\n\tnegate: function () {\n\n\t\tthis.constant *= -1;\n\t\tthis.normal.negate();\n\n\t\treturn this;\n\n\t},\n\n\tdistanceToPoint: function ( point ) {\n\n\t\treturn this.normal.dot( point ) + this.constant;\n\n\t},\n\n\tdistanceToSphere: function ( sphere ) {\n\n\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\n\n\t},\n\n\tprojectPoint: function ( point, optionalTarget ) {\n\n\t\treturn this.orthoPoint( point, optionalTarget ).sub( point ).negate();\n\n\t},\n\n\torthoPoint: function ( point, optionalTarget ) {\n\n\t\tvar perpendicularMagnitude = this.distanceToPoint( point );\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );\n\n\t},\n\n\tisIntersectionLine: function ( line ) {\n\n\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n\n\t\tvar startSign = this.distanceToPoint( line.start );\n\t\tvar endSign = this.distanceToPoint( line.end );\n\n\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\n\n\t},\n\n\tintersectLine: function() {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function ( line, optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\t\tvar direction = line.delta( v1 );\n\n\t\t\tvar denominator = this.normal.dot( direction );\n\n\t\t\tif ( denominator == 0 ) {\n\n\t\t\t\t// line is coplanar, return origin\n\t\t\t\tif( this.distanceToPoint( line.start ) == 0 ) {\n\n\t\t\t\t\treturn result.copy( line.start );\n\n\t\t\t\t}\n\n\t\t\t\t// Unsure if this is the correct method to handle this case.\n\t\t\t\treturn undefined;\n\n\t\t\t}\n\n\t\t\tvar t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\n\n\t\t\tif( t < 0 || t > 1 ) {\n\n\t\t\t\treturn undefined;\n\n\t\t\t}\n\n\t\t\treturn result.copy( direction ).multiplyScalar( t ).add( line.start );\n\n\t\t};\n\n\t}(),\n\n\n\tcoplanarPoint: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.copy( this.normal ).multiplyScalar( - this.constant );\n\n\t},\n\n\tapplyMatrix4: function() {\n\n\t\tvar v1 = new THREE.Vector3();\n\t\tvar v2 = new THREE.Vector3();\n\n\t\treturn function ( matrix, optionalNormalMatrix ) {\n\n\t\t\t// compute new normal based on theory here:\n\t\t\t// http://www.songho.ca/opengl/gl_normaltransform.html\n\t\t\toptionalNormalMatrix = optionalNormalMatrix || new THREE.Matrix3().getInverse( matrix ).transpose();\n\t\t\tvar newNormal = v1.copy( this.normal ).applyMatrix3( optionalNormalMatrix );\n\n\t\t\tvar newCoplanarPoint = this.coplanarPoint( v2 );\n\t\t\tnewCoplanarPoint.applyMatrix4( matrix );\n\n\t\t\tthis.setFromNormalAndCoplanarPoint( newNormal, newCoplanarPoint );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\ttranslate: function ( offset ) {\n\n\t\tthis.constant = this.constant - offset.dot( this.normal );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( plane ) {\n\n\t\treturn plane.normal.equals( this.normal ) && ( plane.constant == this.constant );\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new THREE.Plane().copy( this );\n\n\t}\n\n} );\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Math = {\n\n\t// Clamp value to range <a, b>\n\n\tclamp: function ( x, a, b ) {\n\n\t\treturn ( x < a ) ? a : ( ( x > b ) ? b : x );\n\n\t},\n\n\t// Clamp value to range <a, inf)\n\n\tclampBottom: function ( x, a ) {\n\n\t\treturn x < a ? a : x;\n\n\t},\n\n\t// Linear mapping from range <a1, a2> to range <b1, b2>\n\n\tmapLinear: function ( x, a1, a2, b1, b2 ) {\n\n\t\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\n\n\t},\n\n\t// http://en.wikipedia.org/wiki/Smoothstep\n\n\tsmoothstep: function ( x, min, max ) {\n\n\t\tif ( x <= min ) return 0;\n\t\tif ( x >= max ) return 1;\n\n\t\tx = ( x - min )/( max - min );\n\n\t\treturn x*x*(3 - 2*x);\n\n\t},\n\n\tsmootherstep: function ( x, min, max ) {\n\n\t\tif ( x <= min ) return 0;\n\t\tif ( x >= max ) return 1;\n\n\t\tx = ( x - min )/( max - min );\n\n\t\treturn x*x*x*(x*(x*6 - 15) + 10);\n\n\t},\n\n\t// Random float from <0, 1> with 16 bits of randomness\n\t// (standard Math.random() creates repetitive patterns when applied over larger space)\n\n\trandom16: function () {\n\n\t\treturn ( 65280 * Math.random() + 255 * Math.random() ) / 65535;\n\n\t},\n\n\t// Random integer from <low, high> interval\n\n\trandInt: function ( low, high ) {\n\n\t\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\n\n\t},\n\n\t// Random float from <low, high> interval\n\n\trandFloat: function ( low, high ) {\n\n\t\treturn low + Math.random() * ( high - low );\n\n\t},\n\n\t// Random float from <-range/2, range/2> interval\n\n\trandFloatSpread: function ( range ) {\n\n\t\treturn range * ( 0.5 - Math.random() );\n\n\t},\n\n\tsign: function ( x ) {\n\n\t\treturn ( x < 0 ) ? -1 : ( ( x > 0 ) ? 1 : 0 );\n\n\t},\n\n\tdegToRad: function() {\n\n\t\tvar degreeToRadiansFactor = Math.PI / 180;\n\n\t\treturn function ( degrees ) {\n\n\t\t\treturn degrees * degreeToRadiansFactor;\n\n\t\t};\n\n\t}(),\n\n\tradToDeg: function() {\n\n\t\tvar radianToDegreesFactor = 180 / Math.PI;\n\n\t\treturn function ( radians ) {\n\n\t\t\treturn radians * radianToDegreesFactor;\n\n\t\t};\n\n\t}()\n\n};\n/**\n * Spline from Tween.js, slightly optimized (and trashed)\n * http://sole.github.com/tween.js/examples/05_spline.html\n *\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Spline = function ( points ) {\n\n\tthis.points = points;\n\n\tvar c = [], v3 = { x: 0, y: 0, z: 0 },\n\tpoint, intPoint, weight, w2, w3,\n\tpa, pb, pc, pd;\n\n\tthis.initFromArray = function( a ) {\n\n\t\tthis.points = [];\n\n\t\tfor ( var i = 0; i < a.length; i++ ) {\n\n\t\t\tthis.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };\n\n\t\t}\n\n\t};\n\n\tthis.getPoint = function ( k ) {\n\n\t\tpoint = ( this.points.length - 1 ) * k;\n\t\tintPoint = Math.floor( point );\n\t\tweight = point - intPoint;\n\n\t\tc[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;\n\t\tc[ 1 ] = intPoint;\n\t\tc[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;\n\t\tc[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;\n\n\t\tpa = this.points[ c[ 0 ] ];\n\t\tpb = this.points[ c[ 1 ] ];\n\t\tpc = this.points[ c[ 2 ] ];\n\t\tpd = this.points[ c[ 3 ] ];\n\n\t\tw2 = weight * weight;\n\t\tw3 = weight * w2;\n\n\t\tv3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );\n\t\tv3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );\n\t\tv3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );\n\n\t\treturn v3;\n\n\t};\n\n\tthis.getControlPointsArray = function () {\n\n\t\tvar i, p, l = this.points.length,\n\t\t\tcoords = [];\n\n\t\tfor ( i = 0; i < l; i ++ ) {\n\n\t\t\tp = this.points[ i ];\n\t\t\tcoords[ i ] = [ p.x, p.y, p.z ];\n\n\t\t}\n\n\t\treturn coords;\n\n\t};\n\n\t// approximate length by summing linear segments\n\n\tthis.getLength = function ( nSubDivisions ) {\n\n\t\tvar i, index, nSamples, position,\n\t\t\tpoint = 0, intPoint = 0, oldIntPoint = 0,\n\t\t\toldPosition = new THREE.Vector3(),\n\t\t\ttmpVec = new THREE.Vector3(),\n\t\t\tchunkLengths = [],\n\t\t\ttotalLength = 0;\n\n\t\t// first point has 0 length\n\n\t\tchunkLengths[ 0 ] = 0;\n\n\t\tif ( !nSubDivisions ) nSubDivisions = 100;\n\n\t\tnSamples = this.points.length * nSubDivisions;\n\n\t\toldPosition.copy( this.points[ 0 ] );\n\n\t\tfor ( i = 1; i < nSamples; i ++ ) {\n\n\t\t\tindex = i / nSamples;\n\n\t\t\tposition = this.getPoint( index );\n\t\t\ttmpVec.copy( position );\n\n\t\t\ttotalLength += tmpVec.distanceTo( oldPosition );\n\n\t\t\toldPosition.copy( position );\n\n\t\t\tpoint = ( this.points.length - 1 ) * index;\n\t\t\tintPoint = Math.floor( point );\n\n\t\t\tif ( intPoint != oldIntPoint ) {\n\n\t\t\t\tchunkLengths[ intPoint ] = totalLength;\n\t\t\t\toldIntPoint = intPoint;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// last point ends with total length\n\n\t\tchunkLengths[ chunkLengths.length ] = totalLength;\n\n\t\treturn { chunks: chunkLengths, total: totalLength };\n\n\t};\n\n\tthis.reparametrizeByArcLength = function ( samplingCoef ) {\n\n\t\tvar i, j,\n\t\t\tindex, indexCurrent, indexNext,\n\t\t\tlinearDistance, realDistance,\n\t\t\tsampling, position,\n\t\t\tnewpoints = [],\n\t\t\ttmpVec = new THREE.Vector3(),\n\t\t\tsl = this.getLength();\n\n\t\tnewpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );\n\n\t\tfor ( i = 1; i < this.points.length; i++ ) {\n\n\t\t\t//tmpVec.copy( this.points[ i - 1 ] );\n\t\t\t//linearDistance = tmpVec.distanceTo( this.points[ i ] );\n\n\t\t\trealDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];\n\n\t\t\tsampling = Math.ceil( samplingCoef * realDistance / sl.total );\n\n\t\t\tindexCurrent = ( i - 1 ) / ( this.points.length - 1 );\n\t\t\tindexNext = i / ( this.points.length - 1 );\n\n\t\t\tfor ( j = 1; j < sampling - 1; j++ ) {\n\n\t\t\t\tindex = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );\n\n\t\t\t\tposition = this.getPoint( index );\n\t\t\t\tnewpoints.push( tmpVec.copy( position ).clone() );\n\n\t\t\t}\n\n\t\t\tnewpoints.push( tmpVec.copy( this.points[ i ] ).clone() );\n\n\t\t}\n\n\t\tthis.points = newpoints;\n\n\t};\n\n\t// Catmull-Rom\n\n\tfunction interpolate( p0, p1, p2, p3, t, t2, t3 ) {\n\n\t\tvar v0 = ( p2 - p0 ) * 0.5,\n\t\t\tv1 = ( p3 - p1 ) * 0.5;\n\n\t\treturn ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\n\t};\n\n};\n/**\n * @author bhouston / http://exocortex.com\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Triangle = function ( a, b, c ) {\n\n\tthis.a = ( a !== undefined ) ? a : new THREE.Vector3();\n\tthis.b = ( b !== undefined ) ? b : new THREE.Vector3();\n\tthis.c = ( c !== undefined ) ? c : new THREE.Vector3();\n\n};\n\nTHREE.Triangle.normal = function() {\n\n\tvar v0 = new THREE.Vector3();\n\n\treturn function( a, b, c, optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\tresult.subVectors( c, b );\n\t\tv0.subVectors( a, b );\n\t\tresult.cross( v0 );\n\n\t\tvar resultLengthSq = result.lengthSq();\n\t\tif( resultLengthSq > 0 ) {\n\n\t\t\treturn result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );\n\n\t\t}\n\n\t\treturn result.set( 0, 0, 0 );\n\n\t};\n\n}();\n\n// static/instance method to calculate barycoordinates\n// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\nTHREE.Triangle.barycoordFromPoint = function() {\n\n\tvar v0 = new THREE.Vector3(),\n\t\tv1 = new THREE.Vector3(),\n\t\tv2 = new THREE.Vector3();\n\n\treturn function ( point, a, b, c, optionalTarget ) {\n\n\t\tv0.subVectors( c, a );\n\t\tv1.subVectors( b, a );\n\t\tv2.subVectors( point, a );\n\n\t\tvar dot00 = v0.dot( v0 );\n\t\tvar dot01 = v0.dot( v1 );\n\t\tvar dot02 = v0.dot( v2 );\n\t\tvar dot11 = v1.dot( v1 );\n\t\tvar dot12 = v1.dot( v2 );\n\n\t\tvar denom = ( dot00 * dot11 - dot01 * dot01 );\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\t// colinear or singular triangle\n\t\tif( denom == 0 ) {\n\t\t\t// arbitrary location outside of triangle?\n\t\t\t// not sure if this is the best idea, maybe should be returning undefined\n\t\t\treturn result.set( -2, -1, -1 );\n\t\t}\n\n\t\tvar invDenom = 1 / denom;\n\t\tvar u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\n\t\tvar v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\n\n\t\t// barycoordinates must always sum to 1\n\t\treturn result.set( 1 - u - v, v, u );\n\n\t};\n\n}();\n\nTHREE.Triangle.containsPoint = function() {\n\n\tvar v1 = new THREE.Vector3();\n\n\treturn function ( point, a, b, c ) {\n\n\t\tvar result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );\n\n\t\treturn ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );\n\n\t};\n\n}();\n\nTHREE.extend( THREE.Triangle.prototype, {\n\n\tconstructor: THREE.Triangle,\n\n\tset: function ( a, b, c ) {\n\n\t\tthis.a.copy( a );\n\t\tthis.b.copy( b );\n\t\tthis.c.copy( c );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromPointsAndIndices: function ( points, i0, i1, i2 ) {\n\n\t\tthis.a.copy( points[i0] );\n\t\tthis.b.copy( points[i1] );\n\t\tthis.c.copy( points[i2] );\n\n\t\treturn this;\n\n\t},\n\n\tcopy: function ( triangle ) {\n\n\t\tthis.a.copy( triangle.a );\n\t\tthis.b.copy( triangle.b );\n\t\tthis.c.copy( triangle.c );\n\n\t\treturn this;\n\n\t},\n\n\tarea: function() {\n\n\t\tvar v0 = new THREE.Vector3();\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function () {\n\n\t\t\tv0.subVectors( this.c, this.b );\n\t\t\tv1.subVectors( this.a, this.b );\n\n\t\t\treturn v0.cross( v1 ).length() * 0.5;\n\n\t\t};\n\n\t}(),\n\n\tmidpoint: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\n\n\t},\n\n\tnormal: function ( optionalTarget ) {\n\n\t\treturn THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );\n\n\t},\n\n\tplane: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Plane();\n\n\t\treturn result.setFromCoplanarPoints( this.a, this.b, this.c );\n\n\t},\n\n\tbarycoordFromPoint: function ( point, optionalTarget ) {\n\n\t\treturn THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );\n\n\t},\n\n\tcontainsPoint: function ( point ) {\n\n\t\treturn THREE.Triangle.containsPoint( point, this.a, this.b, this.c );\n\n\t},\n\n\tequals: function ( triangle ) {\n\n\t\treturn triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new THREE.Triangle().copy( this );\n\n\t}\n\n} );\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Vertex = function ( v ) {\n\n\tconsole.warn( 'THREE.Vertex has been DEPRECATED. Use THREE.Vector3 instead.')\n\treturn v;\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.UV = function ( u, v ) {\n\n\tconsole.warn( 'THREE.UV has been DEPRECATED. Use THREE.Vector2 instead.')\n\treturn new THREE.Vector2( u, v );\n\n};\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Clock = function ( autoStart ) {\n\n\tthis.autoStart = ( autoStart !== undefined ) ? autoStart : true;\n\n\tthis.startTime = 0;\n\tthis.oldTime = 0;\n\tthis.elapsedTime = 0;\n\n\tthis.running = false;\n\n};\n\nTHREE.extend( THREE.Clock.prototype, {\n\n\tstart: function () {\n\n\t\tthis.startTime = window.performance !== undefined && window.performance.now !== undefined\n\t\t\t\t\t? window.performance.now()\n\t\t\t\t\t: Date.now();\n\n\t\tthis.oldTime = this.startTime;\n\t\tthis.running = true;\n\t},\n\n\tstop: function () {\n\n\t\tthis.getElapsedTime();\n\t\tthis.running = false;\n\n\t},\n\n\tgetElapsedTime: function () {\n\n\t\tthis.getDelta();\n\t\treturn this.elapsedTime;\n\n\t},\n\n\tgetDelta: function () {\n\n\t\tvar diff = 0;\n\n\t\tif ( this.autoStart && ! this.running ) {\n\n\t\t\tthis.start();\n\n\t\t}\n\n\t\tif ( this.running ) {\n\n\t\t\tvar newTime = window.performance !== undefined && window.performance.now !== undefined\n\t\t\t\t\t? window.performance.now()\n\t\t\t\t\t: Date.now();\n\n\t\t\tdiff = 0.001 * ( newTime - this.oldTime );\n\t\t\tthis.oldTime = newTime;\n\n\t\t\tthis.elapsedTime += diff;\n\n\t\t}\n\n\t\treturn diff;\n\n\t}\n\n} );\n/**\n * https://github.com/mrdoob/eventdispatcher.js/\n */\n\nTHREE.EventDispatcher = function () {\n\n\tvar listeners = {};\n\n\tthis.addEventListener = function ( type, listener ) {\n\n\t\tif ( listeners[ type ] === undefined ) {\n\n\t\t\tlisteners[ type ] = [];\n\n\t\t}\n\n\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\n\n\t\t\tlisteners[ type ].push( listener );\n\n\t\t}\n\n\t};\n\n\tthis.removeEventListener = function ( type, listener ) {\n\n\t\tvar index = listeners[ type ].indexOf( listener );\n\n\t\tif ( index !== - 1 ) {\n\n\t\t\tlisteners[ type ].splice( index, 1 );\n\n\t\t}\n\n\t};\n\n\tthis.dispatchEvent = function ( event ) {\n\n\t\tvar listenerArray = listeners[ event.type ];\n\n\t\tif ( listenerArray !== undefined ) {\n\n\t\t\tevent.target = this;\n\n\t\t\tfor ( var i = 0, l = listenerArray.length; i < l; i ++ ) {\n\n\t\t\t\tlistenerArray[ i ].call( this, event );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author bhouston / http://exocortex.com/\n */\n\n( function ( THREE ) {\n\n\tTHREE.Raycaster = function ( origin, direction, near, far ) {\n\n\t\tthis.ray = new THREE.Ray( origin, direction );\n\n\t\t// normalized ray.direction required for accurate distance calculations\n\t\tif( this.ray.direction.lengthSq() > 0 ) {\n\n\t\t\tthis.ray.direction.normalize();\n\n\t\t}\n\n\t\tthis.near = near || 0;\n\t\tthis.far = far || Infinity;\n\n\t};\n\n\tvar sphere = new THREE.Sphere();\n\tvar localRay = new THREE.Ray();\n\tvar facePlane = new THREE.Plane();\n\tvar intersectPoint = new THREE.Vector3();\n\tvar matrixPosition = new THREE.Vector3();\n\n\tvar inverseMatrix = new THREE.Matrix4();\n\n\tvar descSort = function ( a, b ) {\n\n\t\treturn a.distance - b.distance;\n\n\t};\n\n\tvar intersectObject = function ( object, raycaster, intersects ) {\n\n\t\tif ( object instanceof THREE.Particle ) {\n\n\t\t\tmatrixPosition.getPositionFromMatrix( object.matrixWorld );\n\t\t\tvar distance = raycaster.ray.distanceToPoint( matrixPosition );\n\n\t\t\tif ( distance > object.scale.x ) {\n\n\t\t\t\treturn intersects;\n\n\t\t\t}\n\n\t\t\tintersects.push( {\n\n\t\t\t\tdistance: distance,\n\t\t\t\tpoint: object.position,\n\t\t\t\tface: null,\n\t\t\t\tobject: object\n\n\t\t\t} );\n\n\t\t} else if ( object instanceof THREE.Mesh ) {\n\n\t\t\t// Checking boundingSphere distance to ray\n\t\t\tmatrixPosition.getPositionFromMatrix( object.matrixWorld );\n\t\t\tsphere.set(\n\t\t\t\tmatrixPosition,\n\t\t\t\tobject.geometry.boundingSphere.radius * object.matrixWorld.getMaxScaleOnAxis() );\n\n\t\t\tif ( ! raycaster.ray.isIntersectionSphere( sphere ) ) {\n\n\t\t\t\treturn intersects;\n\n\t\t\t}\n\n\t\t\t// Checking faces\n\n\t\t\tvar geometry = object.geometry;\n\t\t\tvar vertices = geometry.vertices;\n\n\t\t\tvar isFaceMaterial = object.material instanceof THREE.MeshFaceMaterial;\n\t\t\tvar objectMaterials = isFaceMaterial === true ? object.material.materials : null;\n\n\t\t\tvar side = object.material.side;\n\n\t\t\tvar a, b, c, d;\n\t\t\tvar precision = raycaster.precision;\n\n\t\t\tobject.matrixRotationWorld.extractRotation( object.matrixWorld );\n\n\t\t\tinverseMatrix.getInverse( object.matrixWorld );\n\n\t\t\tlocalRay.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\n\t\t\tfor ( var f = 0, fl = geometry.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tvar face = geometry.faces[ f ];\n\n\t\t\t\tvar material = isFaceMaterial === true ? objectMaterials[ face.materialIndex ] : object.material;\n\n\t\t\t\tif ( material === undefined ) continue;\n\n\t\t\t\tfacePlane.setFromNormalAndCoplanarPoint( face.normal, vertices[face.a] );\n\n\t\t\t\tvar planeDistance = localRay.distanceToPlane( facePlane );\n\n\t\t\t\t// bail if raycaster and plane are parallel\n\t\t\t\tif ( Math.abs( planeDistance ) < precision ) continue;\n\n\t\t\t\t// if negative distance, then plane is behind raycaster\n\t\t\t\tif ( planeDistance < 0 ) continue;\n\n\t\t\t\t// check if we hit the wrong side of a single sided face\n\t\t\t\tside = material.side;\n\t\t\t\tif( side !== THREE.DoubleSide ) {\n\n\t\t\t\t\tvar planeSign = localRay.direction.dot( facePlane.normal );\n\n\t\t\t\t\tif( ! ( side === THREE.FrontSide ? planeSign < 0 : planeSign > 0 ) ) continue;\n\n\t\t\t\t}\n\n\t\t\t\t// this can be done using the planeDistance from localRay because localRay wasn't normalized, but ray was\n\t\t\t\tif ( planeDistance < raycaster.near || planeDistance > raycaster.far ) continue;\n\n\t\t\t\tintersectPoint = localRay.at( planeDistance, intersectPoint ); // passing in intersectPoint avoids a copy\n\n\t\t\t\tif ( face instanceof THREE.Face3 ) {\n\n\t\t\t\t\ta = vertices[ face.a ];\n\t\t\t\t\tb = vertices[ face.b ];\n\t\t\t\t\tc = vertices[ face.c ];\n\n\t\t\t\t\tif ( ! THREE.Triangle.containsPoint( intersectPoint, a, b, c ) ) continue;\n\n\t\t\t\t} else if ( face instanceof THREE.Face4 ) {\n\n\t\t\t\t\ta = vertices[ face.a ];\n\t\t\t\t\tb = vertices[ face.b ];\n\t\t\t\t\tc = vertices[ face.c ];\n\t\t\t\t\td = vertices[ face.d ];\n\n\t\t\t\t\tif ( ( ! THREE.Triangle.containsPoint( intersectPoint, a, b, d ) ) &&\n\t\t\t\t\t\t ( ! THREE.Triangle.containsPoint( intersectPoint, b, c, d ) ) ) continue;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// This is added because if we call out of this if/else group when none of the cases\n\t\t\t\t\t//    match it will add a point to the intersection list erroneously.\n\t\t\t\t\tthrow Error( \"face type not supported\" );\n\n\t\t\t\t}\n\n\t\t\t\tintersects.push( {\n\n\t\t\t\t\tdistance: planeDistance,\t// this works because the original ray was normalized, and the transformed localRay wasn't\n\t\t\t\t\tpoint: raycaster.ray.at( planeDistance ),\n\t\t\t\t\tface: face,\n\t\t\t\t\tfaceIndex: f,\n\t\t\t\t\tobject: object\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tvar intersectDescendants = function ( object, raycaster, intersects ) {\n\n\t\tvar descendants = object.getDescendants();\n\n\t\tfor ( var i = 0, l = descendants.length; i < l; i ++ ) {\n\n\t\t\tintersectObject( descendants[ i ], raycaster, intersects );\n\n\t\t}\n\t};\n\n\t//\n\n\tTHREE.Raycaster.prototype.precision = 0.0001;\n\n\tTHREE.Raycaster.prototype.set = function ( origin, direction ) {\n\n\t\tthis.ray.set( origin, direction );\n\n\t\t// normalized ray.direction required for accurate distance calculations\n\t\tif( this.ray.direction.length() > 0 ) {\n\n\t\t\tthis.ray.direction.normalize();\n\n\t\t}\n\n\t};\n\n\tTHREE.Raycaster.prototype.intersectObject = function ( object, recursive ) {\n\n\t\tvar intersects = [];\n\n\t\tif ( recursive === true ) {\n\n\t\t\tintersectDescendants( object, this, intersects );\n\n\t\t}\n\n\t\tintersectObject( object, this, intersects );\n\n\t\tintersects.sort( descSort );\n\n\t\treturn intersects;\n\n\t};\n\n\tTHREE.Raycaster.prototype.intersectObjects = function ( objects, recursive ) {\n\n\t\tvar intersects = [];\n\n\t\tfor ( var i = 0, l = objects.length; i < l; i ++ ) {\n\n\t\t\tintersectObject( objects[ i ], this, intersects );\n\n\t\t\tif ( recursive === true ) {\n\n\t\t\t\tintersectDescendants( objects[ i ], this, intersects );\n\n\t\t\t}\n\t\t}\n\n\t\tintersects.sort( descSort );\n\n\t\treturn intersects;\n\n\t};\n\n}( THREE ) );\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Object3D = function () {\n\n\tthis.id = THREE.Object3DIdCount ++;\n\n\tthis.name = '';\n\tthis.properties = {};\n\n\tthis.parent = undefined;\n\tthis.children = [];\n\n\tthis.up = new THREE.Vector3( 0, 1, 0 );\n\n\tthis.position = new THREE.Vector3();\n\tthis.rotation = new THREE.Vector3();\n\tthis.eulerOrder = THREE.Object3D.defaultEulerOrder;\n\tthis.scale = new THREE.Vector3( 1, 1, 1 );\n\n\tthis.renderDepth = null;\n\n\tthis.rotationAutoUpdate = true;\n\n\tthis.matrix = new THREE.Matrix4();\n\tthis.matrixWorld = new THREE.Matrix4();\n\tthis.matrixRotationWorld = new THREE.Matrix4();\n\n\tthis.matrixAutoUpdate = true;\n\tthis.matrixWorldNeedsUpdate = true;\n\n\tthis.quaternion = new THREE.Quaternion();\n\tthis.useQuaternion = false;\n\n\tthis.visible = true;\n\n\tthis.castShadow = false;\n\tthis.receiveShadow = false;\n\n\tthis.frustumCulled = true;\n\n\tthis._vector = new THREE.Vector3();\n\n};\n\n\nTHREE.Object3D.prototype = {\n\n\tconstructor: THREE.Object3D,\n\n\tapplyMatrix: function ( matrix ) {\n\n\t\tthis.matrix.multiplyMatrices( matrix, this.matrix );\n\n\t\tthis.scale.getScaleFromMatrix( this.matrix );\n\n\t\tvar mat = new THREE.Matrix4().extractRotation( this.matrix );\n\t\tthis.rotation.setEulerFromRotationMatrix( mat, this.eulerOrder );\n\n\t\tthis.position.getPositionFromMatrix( this.matrix );\n\n\t},\n\n\ttranslate: function ( distance, axis ) {\n\n\t\tthis.matrix.rotateAxis( axis );\n\t\tthis.position.add( axis.multiplyScalar( distance ) );\n\n\t},\n\n\ttranslateX: function ( distance ) {\n\n\t\tthis.translate( distance, this._vector.set( 1, 0, 0 ) );\n\n\t},\n\n\ttranslateY: function ( distance ) {\n\n\t\tthis.translate( distance, this._vector.set( 0, 1, 0 ) );\n\n\t},\n\n\ttranslateZ: function ( distance ) {\n\n\t\tthis.translate( distance, this._vector.set( 0, 0, 1 ) );\n\n\t},\n\n\tlocalToWorld: function ( vector ) {\n\n\t\treturn vector.applyMatrix4( this.matrixWorld );\n\n\t},\n\n\tworldToLocal: function ( vector ) {\n\n\t\treturn vector.applyMatrix4( THREE.Object3D.__m1.getInverse( this.matrixWorld ) );\n\n\t},\n\n\tlookAt: function ( vector ) {\n\n\t\t// TODO: Add hierarchy support.\n\n\t\tthis.matrix.lookAt( vector, this.position, this.up );\n\n\t\tif ( this.rotationAutoUpdate ) {\n\n\t\t\tif ( this.useQuaternion === false )  {\n\n\t\t\t\tthis.rotation.setEulerFromRotationMatrix( this.matrix, this.eulerOrder );\n\n\t\t\t} else {\n\n\t\t\t\tthis.quaternion.copy( this.matrix.decompose()[ 1 ] );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tadd: function ( object ) {\n\n\t\tif ( object === this ) {\n\n\t\t\tconsole.warn( 'THREE.Object3D.add: An object can\\'t be added as a child of itself.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( object instanceof THREE.Object3D ) {\n\n\t\t\tif ( object.parent !== undefined ) {\n\n\t\t\t\tobject.parent.remove( object );\n\n\t\t\t}\n\n\t\t\tobject.parent = this;\n\t\t\tthis.children.push( object );\n\n\t\t\t// add to scene\n\n\t\t\tvar scene = this;\n\n\t\t\twhile ( scene.parent !== undefined ) {\n\n\t\t\t\tscene = scene.parent;\n\n\t\t\t}\n\n\t\t\tif ( scene !== undefined && scene instanceof THREE.Scene )  {\n\n\t\t\t\tscene.__addObject( object );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tremove: function ( object ) {\n\n\t\tvar index = this.children.indexOf( object );\n\n\t\tif ( index !== - 1 ) {\n\n\t\t\tobject.parent = undefined;\n\t\t\tthis.children.splice( index, 1 );\n\n\t\t\t// remove from scene\n\n\t\t\tvar scene = this;\n\n\t\t\twhile ( scene.parent !== undefined ) {\n\n\t\t\t\tscene = scene.parent;\n\n\t\t\t}\n\n\t\t\tif ( scene !== undefined && scene instanceof THREE.Scene ) {\n\n\t\t\t\tscene.__removeObject( object );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\ttraverse: function ( callback ) {\n\n\t\tcallback( this );\n\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\n\t\t\tthis.children[ i ].traverse( callback );\n\n\t\t}\n\n\t},\n\n\tgetChildByName: function ( name, recursive ) {\n\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\n\t\t\tvar child = this.children[ i ];\n\n\t\t\tif ( child.name === name ) {\n\n\t\t\t\treturn child;\n\n\t\t\t}\n\n\t\t\tif ( recursive === true ) {\n\n\t\t\t\tchild = child.getChildByName( name, recursive );\n\n\t\t\t\tif ( child !== undefined ) {\n\n\t\t\t\t\treturn child;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn undefined;\n\n\t},\n\n\tgetDescendants: function ( array ) {\n\n\t\tif ( array === undefined ) array = [];\n\n\t\tArray.prototype.push.apply( array, this.children );\n\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\n\t\t\tthis.children[ i ].getDescendants( array );\n\n\t\t}\n\n\t\treturn array;\n\n\t},\n\n\tupdateMatrix: function () {\n\n\t\tthis.matrix.setPosition( this.position );\n\n\t\tif ( this.useQuaternion === false )  {\n\n\t\t\tthis.matrix.setRotationFromEuler( this.rotation, this.eulerOrder );\n\n\t\t} else {\n\n\t\t\tthis.matrix.setRotationFromQuaternion( this.quaternion );\n\n\t\t}\n\n\t\tif ( this.scale.x !== 1 || this.scale.y !== 1 || this.scale.z !== 1 ) {\n\n\t\t\tthis.matrix.scale( this.scale );\n\n\t\t}\n\n\t\tthis.matrixWorldNeedsUpdate = true;\n\n\t},\n\n\tupdateMatrixWorld: function ( force ) {\n\n\t\tif ( this.matrixAutoUpdate === true ) this.updateMatrix();\n\n\t\tif ( this.matrixWorldNeedsUpdate === true || force === true ) {\n\n\t\t\tif ( this.parent === undefined ) {\n\n\t\t\t\tthis.matrixWorld.copy( this.matrix );\n\n\t\t\t} else {\n\n\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\n\t\t\t}\n\n\t\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\t\tforce = true;\n\n\t\t}\n\n\t\t// update children\n\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\n\t\t\tthis.children[ i ].updateMatrixWorld( force );\n\n\t\t}\n\n\t},\n\n\tclone: function ( object ) {\n\n\t\tif ( object === undefined ) object = new THREE.Object3D();\n\n\t\tobject.name = this.name;\n\n\t\tobject.up.copy( this.up );\n\n\t\tobject.position.copy( this.position );\n\t\tif ( object.rotation instanceof THREE.Vector3 ) object.rotation.copy( this.rotation ); // because of Sprite madness\n\t\tobject.eulerOrder = this.eulerOrder;\n\t\tobject.scale.copy( this.scale );\n\n\t\tobject.renderDepth = this.renderDepth;\n\n\t\tobject.rotationAutoUpdate = this.rotationAutoUpdate;\n\n\t\tobject.matrix.copy( this.matrix );\n\t\tobject.matrixWorld.copy( this.matrixWorld );\n\t\tobject.matrixRotationWorld.copy( this.matrixRotationWorld );\n\n\t\tobject.matrixAutoUpdate = this.matrixAutoUpdate;\n\t\tobject.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate;\n\n\t\tobject.quaternion.copy( this.quaternion );\n\t\tobject.useQuaternion = this.useQuaternion;\n\n\t\tobject.visible = this.visible;\n\n\t\tobject.castShadow = this.castShadow;\n\t\tobject.receiveShadow = this.receiveShadow;\n\n\t\tobject.frustumCulled = this.frustumCulled;\n\n\t\tfor ( var i = 0; i < this.children.length; i ++ ) {\n\n\t\t\tvar child = this.children[ i ];\n\t\t\tobject.add( child.clone() );\n\n\t\t}\n\n\t\treturn object;\n\n\t}\n\n};\n\nTHREE.Object3D.__m1 = new THREE.Matrix4();\nTHREE.Object3D.defaultEulerOrder = 'XYZ',\n\nTHREE.Object3DIdCount = 0;\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author supereggbert / http://www.paulbrunt.co.uk/\n * @author julianwa / https://github.com/julianwa\n */\n\nTHREE.Projector = function () {\n\n\tvar _object, _objectCount, _objectPool = [], _objectPoolLength = 0,\n\t_vertex, _vertexCount, _vertexPool = [], _vertexPoolLength = 0,\n\t_face, _face3Count, _face3Pool = [], _face3PoolLength = 0,\n\t_face4Count, _face4Pool = [], _face4PoolLength = 0,\n\t_line, _lineCount, _linePool = [], _linePoolLength = 0,\n\t_particle, _particleCount, _particlePool = [], _particlePoolLength = 0,\n\n\t_renderData = { objects: [], sprites: [], lights: [], elements: [] },\n\n\t_vector3 = new THREE.Vector3(),\n\t_vector4 = new THREE.Vector4(),\n\n\t_clipBox = new THREE.Box3( new THREE.Vector3( -1, -1, -1 ), new THREE.Vector3( 1, 1, 1 ) ),\n\t_boundingBox = new THREE.Box3(),\n\t_points3 = new Array( 3 ),\n\t_points4 = new Array( 4 ),\n\n\t_viewMatrix = new THREE.Matrix4(),\n\t_viewProjectionMatrix = new THREE.Matrix4(),\n\n\t_modelMatrix,\n\t_modelViewProjectionMatrix = new THREE.Matrix4(),\n\n\t_normalMatrix = new THREE.Matrix3(),\n\t_normalViewMatrix = new THREE.Matrix3(),\n\n\t_centroid = new THREE.Vector3(),\n\n\t_frustum = new THREE.Frustum(),\n\n\t_clippedVertex1PositionScreen = new THREE.Vector4(),\n\t_clippedVertex2PositionScreen = new THREE.Vector4();\n\n\tthis.projectVector = function ( vector, camera ) {\n\n\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\n\n\t\t_viewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\n\t\treturn vector.applyProjection( _viewProjectionMatrix );\n\n\t};\n\n\tthis.unprojectVector = function ( vector, camera ) {\n\n\t\tcamera.projectionMatrixInverse.getInverse( camera.projectionMatrix );\n\n\t\t_viewProjectionMatrix.multiplyMatrices( camera.matrixWorld, camera.projectionMatrixInverse );\n\n\t\treturn vector.applyProjection( _viewProjectionMatrix );\n\n\t};\n\n\tthis.pickingRay = function ( vector, camera ) {\n\n\t\t// set two vectors with opposing z values\n\t\tvector.z = -1.0;\n\t\tvar end = new THREE.Vector3( vector.x, vector.y, 1.0 );\n\n\t\tthis.unprojectVector( vector, camera );\n\t\tthis.unprojectVector( end, camera );\n\n\t\t// find direction from vector to end\n\t\tend.sub( vector ).normalize();\n\n\t\treturn new THREE.Raycaster( vector, end );\n\n\t};\n\n\tvar projectGraph = function ( root, sortObjects ) {\n\n\t\t_objectCount = 0;\n\n\t\t_renderData.objects.length = 0;\n\t\t_renderData.sprites.length = 0;\n\t\t_renderData.lights.length = 0;\n\n\t\tvar projectObject = function ( parent ) {\n\n\t\t\tfor ( var c = 0, cl = parent.children.length; c < cl; c ++ ) {\n\n\t\t\t\tvar object = parent.children[ c ];\n\n\t\t\t\tif ( object.visible === false ) continue;\n\n\t\t\t\tif ( object instanceof THREE.Light ) {\n\n\t\t\t\t\t_renderData.lights.push( object );\n\n\t\t\t\t} else if ( object instanceof THREE.Mesh || object instanceof THREE.Line ) {\n\n\t\t\t\t\tif ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) {\n\n\t\t\t\t\t\t_object = getNextObjectInPool();\n\t\t\t\t\t\t_object.object = object;\n\n\t\t\t\t\t\tif ( object.renderDepth !== null ) {\n\n\t\t\t\t\t\t\t_object.z = object.renderDepth;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t_vector3.getPositionFromMatrix( object.matrixWorld );\n\t\t\t\t\t\t\t_vector3.applyProjection( _viewProjectionMatrix );\n\t\t\t\t\t\t\t_object.z = _vector3.z;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_renderData.objects.push( _object );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( object instanceof THREE.Sprite || object instanceof THREE.Particle ) {\n\n\t\t\t\t\t_object = getNextObjectInPool();\n\t\t\t\t\t_object.object = object;\n\n\t\t\t\t\t// TODO: Find an elegant and performant solution and remove this dupe code.\n\n\t\t\t\t\tif ( object.renderDepth !== null ) {\n\n\t\t\t\t\t\t_object.z = object.renderDepth;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_vector3.getPositionFromMatrix( object.matrixWorld );\n\t\t\t\t\t\t_vector3.applyProjection( _viewProjectionMatrix );\n\t\t\t\t\t\t_object.z = _vector3.z;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_renderData.sprites.push( _object );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_object = getNextObjectInPool();\n\t\t\t\t\t_object.object = object;\n\n\t\t\t\t\tif ( object.renderDepth !== null ) {\n\n\t\t\t\t\t\t_object.z = object.renderDepth;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_vector3.getPositionFromMatrix( object.matrixWorld );\n\t\t\t\t\t\t_vector3.applyProjection( _viewProjectionMatrix );\n\t\t\t\t\t\t_object.z = _vector3.z;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_renderData.objects.push( _object );\n\n\t\t\t\t}\n\n\t\t\t\tprojectObject( object );\n\n\t\t\t}\n\n\t\t};\n\n\t\tprojectObject( root );\n\n\t\tif ( sortObjects === true ) _renderData.objects.sort( painterSort );\n\n\t\treturn _renderData;\n\n\t};\n\n\tthis.projectScene = function ( scene, camera, sortObjects, sortElements ) {\n\n\t\tvar visible = false,\n\t\to, ol, v, vl, f, fl, n, nl, c, cl, u, ul, object,\n\t\tgeometry, vertices, faces, face, faceVertexNormals, faceVertexUvs, uvs,\n\t\tv1, v2, v3, v4, isFaceMaterial, objectMaterials;\n\n\t\t_face3Count = 0;\n\t\t_face4Count = 0;\n\t\t_lineCount = 0;\n\t\t_particleCount = 0;\n\n\t\t_renderData.elements.length = 0;\n\n\t\tscene.updateMatrixWorld();\n\n\t\tif ( camera.parent === undefined ) camera.updateMatrixWorld();\n\n\t\t_viewMatrix.copy( camera.matrixWorldInverse.getInverse( camera.matrixWorld ) );\n\t\t_viewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, _viewMatrix );\n\n\t\t_normalViewMatrix.getInverse( _viewMatrix );\n\t\t_normalViewMatrix.transpose();\n\n\t\t_frustum.setFromMatrix( _viewProjectionMatrix );\n\n\t\t_renderData = projectGraph( scene, sortObjects );\n\n\t\tfor ( o = 0, ol = _renderData.objects.length; o < ol; o ++ ) {\n\n\t\t\tobject = _renderData.objects[ o ].object;\n\n\t\t\t_modelMatrix = object.matrixWorld;\n\n\t\t\t_vertexCount = 0;\n\n\t\t\tif ( object instanceof THREE.Mesh ) {\n\n\t\t\t\tgeometry = object.geometry;\n\n\t\t\t\tvertices = geometry.vertices;\n\t\t\t\tfaces = geometry.faces;\n\t\t\t\tfaceVertexUvs = geometry.faceVertexUvs;\n\n\t\t\t\t_normalMatrix.getInverse( _modelMatrix );\n\t\t\t\t_normalMatrix.transpose();\n\n\t\t\t\tisFaceMaterial = object.material instanceof THREE.MeshFaceMaterial;\n\t\t\t\tobjectMaterials = isFaceMaterial === true ? object.material : null;\n\n\t\t\t\tfor ( v = 0, vl = vertices.length; v < vl; v ++ ) {\n\n\t\t\t\t\t_vertex = getNextVertexInPool();\n\n\t\t\t\t\t_vertex.positionWorld.copy( vertices[ v ] ).applyMatrix4( _modelMatrix );\n\t\t\t\t\t_vertex.positionScreen.copy( _vertex.positionWorld ).applyMatrix4( _viewProjectionMatrix );\n\n\t\t\t\t\t_vertex.positionScreen.x /= _vertex.positionScreen.w;\n\t\t\t\t\t_vertex.positionScreen.y /= _vertex.positionScreen.w;\n\t\t\t\t\t_vertex.positionScreen.z /= _vertex.positionScreen.w;\n\n\t\t\t\t\t_vertex.visible = ! ( _vertex.positionScreen.x < -1 || _vertex.positionScreen.x > 1 ||\n\t\t\t\t\t\t\t      _vertex.positionScreen.y < -1 || _vertex.positionScreen.y > 1 ||\n\t\t\t\t\t\t\t      _vertex.positionScreen.z < -1 || _vertex.positionScreen.z > 1 );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( f = 0, fl = faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\tface = faces[ f ];\n\n\t\t\t\t\tvar material = isFaceMaterial === true\n\t\t\t\t\t\t? objectMaterials.materials[ face.materialIndex ]\n\t\t\t\t\t\t: object.material;\n\n\t\t\t\t\tif ( material === undefined ) continue;\n\n\t\t\t\t\tvar side = material.side;\n\n\t\t\t\t\tif ( face instanceof THREE.Face3 ) {\n\n\t\t\t\t\t\tv1 = _vertexPool[ face.a ];\n\t\t\t\t\t\tv2 = _vertexPool[ face.b ];\n\t\t\t\t\t\tv3 = _vertexPool[ face.c ];\n\n\t\t\t\t\t\t_points3[ 0 ] = v1.positionScreen;\n\t\t\t\t\t\t_points3[ 1 ] = v2.positionScreen;\n\t\t\t\t\t\t_points3[ 2 ] = v3.positionScreen;\n\n\t\t\t\t\t\tif ( v1.visible === true || v2.visible === true || v3.visible === true ||\n\t\t\t\t\t\t\t_clipBox.isIntersectionBox( _boundingBox.setFromPoints( _points3 ) ) ) {\n\n\t\t\t\t\t\t\tvisible = ( ( v3.positionScreen.x - v1.positionScreen.x ) * ( v2.positionScreen.y - v1.positionScreen.y ) -\n\t\t\t\t\t\t\t\t( v3.positionScreen.y - v1.positionScreen.y ) * ( v2.positionScreen.x - v1.positionScreen.x ) ) < 0;\n\n\t\t\t\t\t\t\tif ( side === THREE.DoubleSide || visible === ( side === THREE.FrontSide ) ) {\n\n\t\t\t\t\t\t\t\t_face = getNextFace3InPool();\n\n\t\t\t\t\t\t\t\t_face.v1.copy( v1 );\n\t\t\t\t\t\t\t\t_face.v2.copy( v2 );\n\t\t\t\t\t\t\t\t_face.v3.copy( v3 );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( face instanceof THREE.Face4 ) {\n\n\t\t\t\t\t\tv1 = _vertexPool[ face.a ];\n\t\t\t\t\t\tv2 = _vertexPool[ face.b ];\n\t\t\t\t\t\tv3 = _vertexPool[ face.c ];\n\t\t\t\t\t\tv4 = _vertexPool[ face.d ];\n\n\t\t\t\t\t\t_points4[ 0 ] = v1.positionScreen;\n\t\t\t\t\t\t_points4[ 1 ] = v2.positionScreen;\n\t\t\t\t\t\t_points4[ 2 ] = v3.positionScreen;\n\t\t\t\t\t\t_points4[ 3 ] = v4.positionScreen;\n\n\t\t\t\t\t\tif ( v1.visible === true || v2.visible === true || v3.visible === true || v4.visible === true ||\n\t\t\t\t\t\t\t_clipBox.isIntersectionBox( _boundingBox.setFromPoints( _points4 ) ) ) {\n\n\t\t\t\t\t\t\tvisible = ( v4.positionScreen.x - v1.positionScreen.x ) * ( v2.positionScreen.y - v1.positionScreen.y ) -\n\t\t\t\t\t\t\t\t( v4.positionScreen.y - v1.positionScreen.y ) * ( v2.positionScreen.x - v1.positionScreen.x ) < 0 ||\n\t\t\t\t\t\t\t\t( v2.positionScreen.x - v3.positionScreen.x ) * ( v4.positionScreen.y - v3.positionScreen.y ) -\n\t\t\t\t\t\t\t\t( v2.positionScreen.y - v3.positionScreen.y ) * ( v4.positionScreen.x - v3.positionScreen.x ) < 0;\n\n\n\t\t\t\t\t\t\tif ( side === THREE.DoubleSide || visible === ( side === THREE.FrontSide ) ) {\n\n\t\t\t\t\t\t\t\t_face = getNextFace4InPool();\n\n\t\t\t\t\t\t\t\t_face.v1.copy( v1 );\n\t\t\t\t\t\t\t\t_face.v2.copy( v2 );\n\t\t\t\t\t\t\t\t_face.v3.copy( v3 );\n\t\t\t\t\t\t\t\t_face.v4.copy( v4 );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_face.normalModel.copy( face.normal );\n\n\t\t\t\t\tif ( visible === false && ( side === THREE.BackSide || side === THREE.DoubleSide ) ) {\n\n\t\t\t\t\t\t_face.normalModel.negate();\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_face.normalModel.applyMatrix3( _normalMatrix ).normalize();\n\n\t\t\t\t\t_face.normalModelView.copy( _face.normalModel ).applyMatrix3( _normalViewMatrix );\n\n\t\t\t\t\t_face.centroidModel.copy( face.centroid ).applyMatrix4( _modelMatrix );\n\n\t\t\t\t\tfaceVertexNormals = face.vertexNormals;\n\n\t\t\t\t\tfor ( n = 0, nl = faceVertexNormals.length; n < nl; n ++ ) {\n\n\t\t\t\t\t\tvar normalModel = _face.vertexNormalsModel[ n ];\n\t\t\t\t\t\tnormalModel.copy( faceVertexNormals[ n ] );\n\n\t\t\t\t\t\tif ( visible === false && ( side === THREE.BackSide || side === THREE.DoubleSide ) ) {\n\n\t\t\t\t\t\t\tnormalModel.negate();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnormalModel.applyMatrix3( _normalMatrix ).normalize();\n\n\t\t\t\t\t\tvar normalModelView = _face.vertexNormalsModelView[ n ];\n\t\t\t\t\t\tnormalModelView.copy( normalModel ).applyMatrix3( _normalViewMatrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_face.vertexNormalsLength = faceVertexNormals.length;\n\n\t\t\t\t\tfor ( c = 0, cl = faceVertexUvs.length; c < cl; c ++ ) {\n\n\t\t\t\t\t\tuvs = faceVertexUvs[ c ][ f ];\n\n\t\t\t\t\t\tif ( uvs === undefined ) continue;\n\n\t\t\t\t\t\tfor ( u = 0, ul = uvs.length; u < ul; u ++ ) {\n\n\t\t\t\t\t\t\t_face.uvs[ c ][ u ] = uvs[ u ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_face.color = face.color;\n\t\t\t\t\t_face.material = material;\n\n\t\t\t\t\t_centroid.copy( _face.centroidModel ).applyProjection( _viewProjectionMatrix );\n\n\t\t\t\t\t_face.z = _centroid.z;\n\n\t\t\t\t\t_renderData.elements.push( _face );\n\n\t\t\t\t}\n\n\t\t\t} else if ( object instanceof THREE.Line ) {\n\n\t\t\t\t_modelViewProjectionMatrix.multiplyMatrices( _viewProjectionMatrix, _modelMatrix );\n\n\t\t\t\tvertices = object.geometry.vertices;\n\n\t\t\t\tv1 = getNextVertexInPool();\n\t\t\t\tv1.positionScreen.copy( vertices[ 0 ] ).applyMatrix4( _modelViewProjectionMatrix );\n\n\t\t\t\t// Handle LineStrip and LinePieces\n\t\t\t\tvar step = object.type === THREE.LinePieces ? 2 : 1;\n\n\t\t\t\tfor ( v = 1, vl = vertices.length; v < vl; v ++ ) {\n\n\t\t\t\t\tv1 = getNextVertexInPool();\n\t\t\t\t\tv1.positionScreen.copy( vertices[ v ] ).applyMatrix4( _modelViewProjectionMatrix );\n\n\t\t\t\t\tif ( ( v + 1 ) % step > 0 ) continue;\n\n\t\t\t\t\tv2 = _vertexPool[ _vertexCount - 2 ];\n\n\t\t\t\t\t_clippedVertex1PositionScreen.copy( v1.positionScreen );\n\t\t\t\t\t_clippedVertex2PositionScreen.copy( v2.positionScreen );\n\n\t\t\t\t\tif ( clipLine( _clippedVertex1PositionScreen, _clippedVertex2PositionScreen ) === true ) {\n\n\t\t\t\t\t\t// Perform the perspective divide\n\t\t\t\t\t\t_clippedVertex1PositionScreen.multiplyScalar( 1 / _clippedVertex1PositionScreen.w );\n\t\t\t\t\t\t_clippedVertex2PositionScreen.multiplyScalar( 1 / _clippedVertex2PositionScreen.w );\n\n\t\t\t\t\t\t_line = getNextLineInPool();\n\t\t\t\t\t\t_line.v1.positionScreen.copy( _clippedVertex1PositionScreen );\n\t\t\t\t\t\t_line.v2.positionScreen.copy( _clippedVertex2PositionScreen );\n\n\t\t\t\t\t\t_line.z = Math.max( _clippedVertex1PositionScreen.z, _clippedVertex2PositionScreen.z );\n\n\t\t\t\t\t\t_line.material = object.material;\n\n\t\t\t\t\t\t_renderData.elements.push( _line );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( o = 0, ol = _renderData.sprites.length; o < ol; o++ ) {\n\n\t\t\tobject = _renderData.sprites[ o ].object;\n\n\t\t\t_modelMatrix = object.matrixWorld;\n\n\t\t\tif ( object instanceof THREE.Particle ) {\n\n\t\t\t\t_vector4.set( _modelMatrix.elements[12], _modelMatrix.elements[13], _modelMatrix.elements[14], 1 );\n\t\t\t\t_vector4.applyMatrix4( _viewProjectionMatrix );\n\n\t\t\t\t_vector4.z /= _vector4.w;\n\n\t\t\t\tif ( _vector4.z > 0 && _vector4.z < 1 ) {\n\n\t\t\t\t\t_particle = getNextParticleInPool();\n\t\t\t\t\t_particle.object = object;\n\t\t\t\t\t_particle.x = _vector4.x / _vector4.w;\n\t\t\t\t\t_particle.y = _vector4.y / _vector4.w;\n\t\t\t\t\t_particle.z = _vector4.z;\n\n\t\t\t\t\t_particle.rotation = object.rotation.z;\n\n\t\t\t\t\t_particle.scale.x = object.scale.x * Math.abs( _particle.x - ( _vector4.x + camera.projectionMatrix.elements[0] ) / ( _vector4.w + camera.projectionMatrix.elements[12] ) );\n\t\t\t\t\t_particle.scale.y = object.scale.y * Math.abs( _particle.y - ( _vector4.y + camera.projectionMatrix.elements[5] ) / ( _vector4.w + camera.projectionMatrix.elements[13] ) );\n\n\t\t\t\t\t_particle.material = object.material;\n\n\t\t\t\t\t_renderData.elements.push( _particle );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( sortElements === true ) _renderData.elements.sort( painterSort );\n\n\t\treturn _renderData;\n\n\t};\n\n\t// Pools\n\n\tfunction getNextObjectInPool() {\n\n\t\tif ( _objectCount === _objectPoolLength ) {\n\n\t\t\tvar object = new THREE.RenderableObject();\n\t\t\t_objectPool.push( object );\n\t\t\t_objectPoolLength ++;\n\t\t\t_objectCount ++;\n\t\t\treturn object;\n\n\t\t}\n\n\t\treturn _objectPool[ _objectCount ++ ];\n\n\t}\n\n\tfunction getNextVertexInPool() {\n\n\t\tif ( _vertexCount === _vertexPoolLength ) {\n\n\t\t\tvar vertex = new THREE.RenderableVertex();\n\t\t\t_vertexPool.push( vertex );\n\t\t\t_vertexPoolLength ++;\n\t\t\t_vertexCount ++;\n\t\t\treturn vertex;\n\n\t\t}\n\n\t\treturn _vertexPool[ _vertexCount ++ ];\n\n\t}\n\n\tfunction getNextFace3InPool() {\n\n\t\tif ( _face3Count === _face3PoolLength ) {\n\n\t\t\tvar face = new THREE.RenderableFace3();\n\t\t\t_face3Pool.push( face );\n\t\t\t_face3PoolLength ++;\n\t\t\t_face3Count ++;\n\t\t\treturn face;\n\n\t\t}\n\n\t\treturn _face3Pool[ _face3Count ++ ];\n\n\n\t}\n\n\tfunction getNextFace4InPool() {\n\n\t\tif ( _face4Count === _face4PoolLength ) {\n\n\t\t\tvar face = new THREE.RenderableFace4();\n\t\t\t_face4Pool.push( face );\n\t\t\t_face4PoolLength ++;\n\t\t\t_face4Count ++;\n\t\t\treturn face;\n\n\t\t}\n\n\t\treturn _face4Pool[ _face4Count ++ ];\n\n\t}\n\n\tfunction getNextLineInPool() {\n\n\t\tif ( _lineCount === _linePoolLength ) {\n\n\t\t\tvar line = new THREE.RenderableLine();\n\t\t\t_linePool.push( line );\n\t\t\t_linePoolLength ++;\n\t\t\t_lineCount ++\n\t\t\treturn line;\n\n\t\t}\n\n\t\treturn _linePool[ _lineCount ++ ];\n\n\t}\n\n\tfunction getNextParticleInPool() {\n\n\t\tif ( _particleCount === _particlePoolLength ) {\n\n\t\t\tvar particle = new THREE.RenderableParticle();\n\t\t\t_particlePool.push( particle );\n\t\t\t_particlePoolLength ++;\n\t\t\t_particleCount ++\n\t\t\treturn particle;\n\n\t\t}\n\n\t\treturn _particlePool[ _particleCount ++ ];\n\n\t}\n\n\t//\n\n\tfunction painterSort( a, b ) {\n\n\t\treturn b.z - a.z;\n\n\t}\n\n\tfunction clipLine( s1, s2 ) {\n\n\t\tvar alpha1 = 0, alpha2 = 1,\n\n\t\t// Calculate the boundary coordinate of each vertex for the near and far clip planes,\n\t\t// Z = -1 and Z = +1, respectively.\n\t\tbc1near =  s1.z + s1.w,\n\t\tbc2near =  s2.z + s2.w,\n\t\tbc1far =  - s1.z + s1.w,\n\t\tbc2far =  - s2.z + s2.w;\n\n\t\tif ( bc1near >= 0 && bc2near >= 0 && bc1far >= 0 && bc2far >= 0 ) {\n\n\t\t\t// Both vertices lie entirely within all clip planes.\n\t\t\treturn true;\n\n\t\t} else if ( ( bc1near < 0 && bc2near < 0) || (bc1far < 0 && bc2far < 0 ) ) {\n\n\t\t\t// Both vertices lie entirely outside one of the clip planes.\n\t\t\treturn false;\n\n\t\t} else {\n\n\t\t\t// The line segment spans at least one clip plane.\n\n\t\t\tif ( bc1near < 0 ) {\n\n\t\t\t\t// v1 lies outside the near plane, v2 inside\n\t\t\t\talpha1 = Math.max( alpha1, bc1near / ( bc1near - bc2near ) );\n\n\t\t\t} else if ( bc2near < 0 ) {\n\n\t\t\t\t// v2 lies outside the near plane, v1 inside\n\t\t\t\talpha2 = Math.min( alpha2, bc1near / ( bc1near - bc2near ) );\n\n\t\t\t}\n\n\t\t\tif ( bc1far < 0 ) {\n\n\t\t\t\t// v1 lies outside the far plane, v2 inside\n\t\t\t\talpha1 = Math.max( alpha1, bc1far / ( bc1far - bc2far ) );\n\n\t\t\t} else if ( bc2far < 0 ) {\n\n\t\t\t\t// v2 lies outside the far plane, v2 inside\n\t\t\t\talpha2 = Math.min( alpha2, bc1far / ( bc1far - bc2far ) );\n\n\t\t\t}\n\n\t\t\tif ( alpha2 < alpha1 ) {\n\n\t\t\t\t// The line segment spans two boundaries, but is outside both of them.\n\t\t\t\t// (This can't happen when we're only clipping against just near/far but good\n\t\t\t\t//  to leave the check here for future usage if other clip planes are added.)\n\t\t\t\treturn false;\n\n\t\t\t} else {\n\n\t\t\t\t// Update the s1 and s2 vertices to match the clipped line segment.\n\t\t\t\ts1.lerp( s2, alpha1 );\n\t\t\t\ts2.lerp( s1, 1 - alpha2 );\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {\n\n\tthis.a = a;\n\tthis.b = b;\n\tthis.c = c;\n\n\tthis.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();\n\tthis.vertexNormals = normal instanceof Array ? normal : [ ];\n\n\tthis.color = color instanceof THREE.Color ? color : new THREE.Color();\n\tthis.vertexColors = color instanceof Array ? color : [];\n\n\tthis.vertexTangents = [];\n\n\tthis.materialIndex = materialIndex !== undefined ? materialIndex : 0;\n\n\tthis.centroid = new THREE.Vector3();\n\n};\n\nTHREE.Face3.prototype = {\n\n\tconstructor: THREE.Face3,\n\n\tclone: function () {\n\n\t\tvar face = new THREE.Face3( this.a, this.b, this.c );\n\n\t\tface.normal.copy( this.normal );\n\t\tface.color.copy( this.color );\n\t\tface.centroid.copy( this.centroid );\n\n\t\tface.materialIndex = this.materialIndex;\n\n\t\tvar i, il;\n\t\tfor ( i = 0, il = this.vertexNormals.length; i < il; i ++ ) face.vertexNormals[ i ] = this.vertexNormals[ i ].clone();\n\t\tfor ( i = 0, il = this.vertexColors.length; i < il; i ++ ) face.vertexColors[ i ] = this.vertexColors[ i ].clone();\n\t\tfor ( i = 0, il = this.vertexTangents.length; i < il; i ++ ) face.vertexTangents[ i ] = this.vertexTangents[ i ].clone();\n\n\t\treturn face;\n\n\t}\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Face4 = function ( a, b, c, d, normal, color, materialIndex ) {\n\n\tthis.a = a;\n\tthis.b = b;\n\tthis.c = c;\n\tthis.d = d;\n\n\tthis.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();\n\tthis.vertexNormals = normal instanceof Array ? normal : [ ];\n\n\tthis.color = color instanceof THREE.Color ? color : new THREE.Color();\n\tthis.vertexColors = color instanceof Array ? color : [];\n\n\tthis.vertexTangents = [];\n\n\tthis.materialIndex = materialIndex !== undefined ? materialIndex : 0;\n\n\tthis.centroid = new THREE.Vector3();\n\n};\n\nTHREE.Face4.prototype = {\n\n\tconstructor: THREE.Face4,\n\n\tclone: function () {\n\n\t\tvar face = new THREE.Face4( this.a, this.b, this.c, this.d );\n\n\t\tface.normal.copy( this.normal );\n\t\tface.color.copy( this.color );\n\t\tface.centroid.copy( this.centroid );\n\n\t\tface.materialIndex = this.materialIndex;\n\n\t\tvar i, il;\n\t\tfor ( i = 0, il = this.vertexNormals.length; i < il; i ++ ) face.vertexNormals[ i ] = this.vertexNormals[ i ].clone();\n\t\tfor ( i = 0, il = this.vertexColors.length; i < il; i ++ ) face.vertexColors[ i ] = this.vertexColors[ i ].clone();\n\t\tfor ( i = 0, il = this.vertexTangents.length; i < il; i ++ ) face.vertexTangents[ i ] = this.vertexTangents[ i ].clone();\n\n\t\treturn face;\n\n\t}\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author kile / http://kile.stravaganza.org/\n * @author alteredq / http://alteredqualia.com/\n * @author mikael emtinger / http://gomo.se/\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * @author bhouston / http://exocortex.com\n */\n\nTHREE.Geometry = function () {\n\n\tTHREE.EventDispatcher.call( this );\n\n\tthis.id = THREE.GeometryIdCount ++;\n\n\tthis.name = '';\n\n\tthis.vertices = [];\n\tthis.colors = [];  // one-to-one vertex colors, used in ParticleSystem, Line and Ribbon\n\tthis.normals = []; // one-to-one vertex normals, used in Ribbon\n\n\tthis.faces = [];\n\n\tthis.faceUvs = [[]];\n\tthis.faceVertexUvs = [[]];\n\n\tthis.morphTargets = [];\n\tthis.morphColors = [];\n\tthis.morphNormals = [];\n\n\tthis.skinWeights = [];\n\tthis.skinIndices = [];\n\n\tthis.lineDistances = [];\n\n\tthis.boundingBox = null;\n\tthis.boundingSphere = null;\n\n\tthis.hasTangents = false;\n\n\tthis.dynamic = true; // the intermediate typed arrays will be deleted when set to false\n\n\t// update flags\n\n\tthis.verticesNeedUpdate = false;\n\tthis.elementsNeedUpdate = false;\n\tthis.uvsNeedUpdate = false;\n\tthis.normalsNeedUpdate = false;\n\tthis.tangentsNeedUpdate = false;\n\tthis.colorsNeedUpdate = false;\n\tthis.lineDistancesNeedUpdate = false;\n\n\tthis.buffersNeedUpdate = false;\n\n};\n\nTHREE.Geometry.prototype = {\n\n\tconstructor: THREE.Geometry,\n\n\tapplyMatrix: function ( matrix ) {\n\n\t\tvar normalMatrix = new THREE.Matrix3().getInverse( matrix ).transpose();\n\n\t\tfor ( var i = 0, il = this.vertices.length; i < il; i ++ ) {\n\n\t\t\tvar vertex = this.vertices[ i ];\n\t\t\tvertex.applyMatrix4( matrix );\n\n\t\t}\n\n\t\tfor ( var i = 0, il = this.faces.length; i < il; i ++ ) {\n\n\t\t\tvar face = this.faces[ i ];\n\t\t\tface.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\tface.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t}\n\n\t\t\tface.centroid.applyMatrix4( matrix );\n\n\t\t}\n\n\t},\n\n\tcomputeCentroids: function () {\n\n\t\tvar f, fl, face;\n\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = this.faces[ f ];\n\t\t\tface.centroid.set( 0, 0, 0 );\n\n\t\t\tif ( face instanceof THREE.Face3 ) {\n\n\t\t\t\tface.centroid.add( this.vertices[ face.a ] );\n\t\t\t\tface.centroid.add( this.vertices[ face.b ] );\n\t\t\t\tface.centroid.add( this.vertices[ face.c ] );\n\t\t\t\tface.centroid.divideScalar( 3 );\n\n\t\t\t} else if ( face instanceof THREE.Face4 ) {\n\n\t\t\t\tface.centroid.add( this.vertices[ face.a ] );\n\t\t\t\tface.centroid.add( this.vertices[ face.b ] );\n\t\t\t\tface.centroid.add( this.vertices[ face.c ] );\n\t\t\t\tface.centroid.add( this.vertices[ face.d ] );\n\t\t\t\tface.centroid.divideScalar( 4 );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tcomputeFaceNormals: function () {\n\n\t\tvar cb = new THREE.Vector3(), ab = new THREE.Vector3();\n\n\t\tfor ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tvar face = this.faces[ f ];\n\n\t\t\tvar vA = this.vertices[ face.a ];\n\t\t\tvar vB = this.vertices[ face.b ];\n\t\t\tvar vC = this.vertices[ face.c ];\n\n\t\t\tcb.subVectors( vC, vB );\n\t\t\tab.subVectors( vA, vB );\n\t\t\tcb.cross( ab );\n\n\t\t\tcb.normalize();\n\n\t\t\tface.normal.copy( cb );\n\n\t\t}\n\n\t},\n\n\tcomputeVertexNormals: function ( areaWeighted ) {\n\n\t\tvar v, vl, f, fl, face, vertices;\n\n\t\t// create internal buffers for reuse when calling this method repeatedly\n\t\t// (otherwise memory allocation / deallocation every frame is big resource hog)\n\n\t\tif ( this.__tmpVertices === undefined ) {\n\n\t\t\tthis.__tmpVertices = new Array( this.vertices.length );\n\t\t\tvertices = this.__tmpVertices;\n\n\t\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\n\t\t\t\tvertices[ v ] = new THREE.Vector3();\n\n\t\t\t}\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tif ( face instanceof THREE.Face3 ) {\n\n\t\t\t\t\tface.vertexNormals = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];\n\n\t\t\t\t} else if ( face instanceof THREE.Face4 ) {\n\n\t\t\t\t\tface.vertexNormals = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tvertices = this.__tmpVertices;\n\n\t\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\n\t\t\t\tvertices[ v ].set( 0, 0, 0 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( areaWeighted ) {\n\n\t\t\t// vertex normals weighted by triangle areas\n\t\t\t// http://www.iquilezles.org/www/articles/normals/normals.htm\n\n\t\t\tvar vA, vB, vC, vD;\n\t\t\tvar cb = new THREE.Vector3(), ab = new THREE.Vector3(),\n\t\t\t\tdb = new THREE.Vector3(), dc = new THREE.Vector3(), bc = new THREE.Vector3();\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tif ( face instanceof THREE.Face3 ) {\n\n\t\t\t\t\tvA = this.vertices[ face.a ];\n\t\t\t\t\tvB = this.vertices[ face.b ];\n\t\t\t\t\tvC = this.vertices[ face.c ];\n\n\t\t\t\t\tcb.subVectors( vC, vB );\n\t\t\t\t\tab.subVectors( vA, vB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tvertices[ face.a ].add( cb );\n\t\t\t\t\tvertices[ face.b ].add( cb );\n\t\t\t\t\tvertices[ face.c ].add( cb );\n\n\t\t\t\t} else if ( face instanceof THREE.Face4 ) {\n\n\t\t\t\t\tvA = this.vertices[ face.a ];\n\t\t\t\t\tvB = this.vertices[ face.b ];\n\t\t\t\t\tvC = this.vertices[ face.c ];\n\t\t\t\t\tvD = this.vertices[ face.d ];\n\n\t\t\t\t\t// abd\n\n\t\t\t\t\tdb.subVectors( vD, vB );\n\t\t\t\t\tab.subVectors( vA, vB );\n\t\t\t\t\tdb.cross( ab );\n\n\t\t\t\t\tvertices[ face.a ].add( db );\n\t\t\t\t\tvertices[ face.b ].add( db );\n\t\t\t\t\tvertices[ face.d ].add( db );\n\n\t\t\t\t\t// bcd\n\n\t\t\t\t\tdc.subVectors( vD, vC );\n\t\t\t\t\tbc.subVectors( vB, vC );\n\t\t\t\t\tdc.cross( bc );\n\n\t\t\t\t\tvertices[ face.b ].add( dc );\n\t\t\t\t\tvertices[ face.c ].add( dc );\n\t\t\t\t\tvertices[ face.d ].add( dc );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tif ( face instanceof THREE.Face3 ) {\n\n\t\t\t\t\tvertices[ face.a ].add( face.normal );\n\t\t\t\t\tvertices[ face.b ].add( face.normal );\n\t\t\t\t\tvertices[ face.c ].add( face.normal );\n\n\t\t\t\t} else if ( face instanceof THREE.Face4 ) {\n\n\t\t\t\t\tvertices[ face.a ].add( face.normal );\n\t\t\t\t\tvertices[ face.b ].add( face.normal );\n\t\t\t\t\tvertices[ face.c ].add( face.normal );\n\t\t\t\t\tvertices[ face.d ].add( face.normal );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\n\t\t\tvertices[ v ].normalize();\n\n\t\t}\n\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = this.faces[ f ];\n\n\t\t\tif ( face instanceof THREE.Face3 ) {\n\n\t\t\t\tface.vertexNormals[ 0 ].copy( vertices[ face.a ] );\n\t\t\t\tface.vertexNormals[ 1 ].copy( vertices[ face.b ] );\n\t\t\t\tface.vertexNormals[ 2 ].copy( vertices[ face.c ] );\n\n\t\t\t} else if ( face instanceof THREE.Face4 ) {\n\n\t\t\t\tface.vertexNormals[ 0 ].copy( vertices[ face.a ] );\n\t\t\t\tface.vertexNormals[ 1 ].copy( vertices[ face.b ] );\n\t\t\t\tface.vertexNormals[ 2 ].copy( vertices[ face.c ] );\n\t\t\t\tface.vertexNormals[ 3 ].copy( vertices[ face.d ] );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tcomputeMorphNormals: function () {\n\n\t\tvar i, il, f, fl, face;\n\n\t\t// save original normals\n\t\t// - create temp variables on first access\n\t\t//   otherwise just copy (for faster repeated calls)\n\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = this.faces[ f ];\n\n\t\t\tif ( ! face.__originalFaceNormal ) {\n\n\t\t\t\tface.__originalFaceNormal = face.normal.clone();\n\n\t\t\t} else {\n\n\t\t\t\tface.__originalFaceNormal.copy( face.normal );\n\n\t\t\t}\n\n\t\t\tif ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];\n\n\t\t\tfor ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {\n\n\t\t\t\tif ( ! face.__originalVertexNormals[ i ] ) {\n\n\t\t\t\t\tface.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tface.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// use temp geometry to compute face and vertex normals for each morph\n\n\t\tvar tmpGeo = new THREE.Geometry();\n\t\ttmpGeo.faces = this.faces;\n\n\t\tfor ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {\n\n\t\t\t// create on first access\n\n\t\t\tif ( ! this.morphNormals[ i ] ) {\n\n\t\t\t\tthis.morphNormals[ i ] = {};\n\t\t\t\tthis.morphNormals[ i ].faceNormals = [];\n\t\t\t\tthis.morphNormals[ i ].vertexNormals = [];\n\n\t\t\t\tvar dstNormalsFace = this.morphNormals[ i ].faceNormals;\n\t\t\t\tvar dstNormalsVertex = this.morphNormals[ i ].vertexNormals;\n\n\t\t\t\tvar faceNormal, vertexNormals;\n\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\t\tfaceNormal = new THREE.Vector3();\n\n\t\t\t\t\tif ( face instanceof THREE.Face3 ) {\n\n\t\t\t\t\t\tvertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3(), d: new THREE.Vector3() };\n\n\t\t\t\t\t}\n\n\t\t\t\t\tdstNormalsFace.push( faceNormal );\n\t\t\t\t\tdstNormalsVertex.push( vertexNormals );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar morphNormals = this.morphNormals[ i ];\n\n\t\t\t// set vertices to morph target\n\n\t\t\ttmpGeo.vertices = this.morphTargets[ i ].vertices;\n\n\t\t\t// compute morph normals\n\n\t\t\ttmpGeo.computeFaceNormals();\n\t\t\ttmpGeo.computeVertexNormals();\n\n\t\t\t// store morph normals\n\n\t\t\tvar faceNormal, vertexNormals;\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tfaceNormal = morphNormals.faceNormals[ f ];\n\t\t\t\tvertexNormals = morphNormals.vertexNormals[ f ];\n\n\t\t\t\tfaceNormal.copy( face.normal );\n\n\t\t\t\tif ( face instanceof THREE.Face3 ) {\n\n\t\t\t\t\tvertexNormals.a.copy( face.vertexNormals[ 0 ] );\n\t\t\t\t\tvertexNormals.b.copy( face.vertexNormals[ 1 ] );\n\t\t\t\t\tvertexNormals.c.copy( face.vertexNormals[ 2 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvertexNormals.a.copy( face.vertexNormals[ 0 ] );\n\t\t\t\t\tvertexNormals.b.copy( face.vertexNormals[ 1 ] );\n\t\t\t\t\tvertexNormals.c.copy( face.vertexNormals[ 2 ] );\n\t\t\t\t\tvertexNormals.d.copy( face.vertexNormals[ 3 ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// restore original normals\n\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = this.faces[ f ];\n\n\t\t\tface.normal = face.__originalFaceNormal;\n\t\t\tface.vertexNormals = face.__originalVertexNormals;\n\n\t\t}\n\n\t},\n\n\tcomputeTangents: function () {\n\n\t\t// based on http://www.terathon.com/code/tangent.html\n\t\t// tangents go to vertices\n\n\t\tvar f, fl, v, vl, i, il, vertexIndex,\n\t\t\tface, uv, vA, vB, vC, uvA, uvB, uvC,\n\t\t\tx1, x2, y1, y2, z1, z2,\n\t\t\ts1, s2, t1, t2, r, t, test,\n\t\t\ttan1 = [], tan2 = [],\n\t\t\tsdir = new THREE.Vector3(), tdir = new THREE.Vector3(),\n\t\t\ttmp = new THREE.Vector3(), tmp2 = new THREE.Vector3(),\n\t\t\tn = new THREE.Vector3(), w;\n\n\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\n\t\t\ttan1[ v ] = new THREE.Vector3();\n\t\t\ttan2[ v ] = new THREE.Vector3();\n\n\t\t}\n\n\t\tfunction handleTriangle( context, a, b, c, ua, ub, uc ) {\n\n\t\t\tvA = context.vertices[ a ];\n\t\t\tvB = context.vertices[ b ];\n\t\t\tvC = context.vertices[ c ];\n\n\t\t\tuvA = uv[ ua ];\n\t\t\tuvB = uv[ ub ];\n\t\t\tuvC = uv[ uc ];\n\n\t\t\tx1 = vB.x - vA.x;\n\t\t\tx2 = vC.x - vA.x;\n\t\t\ty1 = vB.y - vA.y;\n\t\t\ty2 = vC.y - vA.y;\n\t\t\tz1 = vB.z - vA.z;\n\t\t\tz2 = vC.z - vA.z;\n\n\t\t\ts1 = uvB.x - uvA.x;\n\t\t\ts2 = uvC.x - uvA.x;\n\t\t\tt1 = uvB.y - uvA.y;\n\t\t\tt2 = uvC.y - uvA.y;\n\n\t\t\tr = 1.0 / ( s1 * t2 - s2 * t1 );\n\t\t\tsdir.set( ( t2 * x1 - t1 * x2 ) * r,\n\t\t\t\t\t  ( t2 * y1 - t1 * y2 ) * r,\n\t\t\t\t\t  ( t2 * z1 - t1 * z2 ) * r );\n\t\t\ttdir.set( ( s1 * x2 - s2 * x1 ) * r,\n\t\t\t\t\t  ( s1 * y2 - s2 * y1 ) * r,\n\t\t\t\t\t  ( s1 * z2 - s2 * z1 ) * r );\n\n\t\t\ttan1[ a ].add( sdir );\n\t\t\ttan1[ b ].add( sdir );\n\t\t\ttan1[ c ].add( sdir );\n\n\t\t\ttan2[ a ].add( tdir );\n\t\t\ttan2[ b ].add( tdir );\n\t\t\ttan2[ c ].add( tdir );\n\n\t\t}\n\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = this.faces[ f ];\n\t\t\tuv = this.faceVertexUvs[ 0 ][ f ]; // use UV layer 0 for tangents\n\n\t\t\tif ( face instanceof THREE.Face3 ) {\n\n\t\t\t\thandleTriangle( this, face.a, face.b, face.c, 0, 1, 2 );\n\n\t\t\t} else if ( face instanceof THREE.Face4 ) {\n\n\t\t\t\thandleTriangle( this, face.a, face.b, face.d, 0, 1, 3 );\n\t\t\t\thandleTriangle( this, face.b, face.c, face.d, 1, 2, 3 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar faceIndex = [ 'a', 'b', 'c', 'd' ];\n\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = this.faces[ f ];\n\n\t\t\tfor ( i = 0; i < face.vertexNormals.length; i++ ) {\n\n\t\t\t\tn.copy( face.vertexNormals[ i ] );\n\n\t\t\t\tvertexIndex = face[ faceIndex[ i ] ];\n\n\t\t\t\tt = tan1[ vertexIndex ];\n\n\t\t\t\t// Gram-Schmidt orthogonalize\n\n\t\t\t\ttmp.copy( t );\n\t\t\t\ttmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();\n\n\t\t\t\t// Calculate handedness\n\n\t\t\t\ttmp2.crossVectors( face.vertexNormals[ i ], t );\n\t\t\t\ttest = tmp2.dot( tan2[ vertexIndex ] );\n\t\t\t\tw = (test < 0.0) ? -1.0 : 1.0;\n\n\t\t\t\tface.vertexTangents[ i ] = new THREE.Vector4( tmp.x, tmp.y, tmp.z, w );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.hasTangents = true;\n\n\t},\n\n\tcomputeLineDistances: function ( ) {\n\n\t\tvar d = 0;\n\t\tvar vertices = this.vertices;\n\n\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\tif ( i > 0 ) {\n\n\t\t\t\td += vertices[ i ].distanceTo( vertices[ i - 1 ] );\n\n\t\t\t}\n\n\t\t\tthis.lineDistances[ i ] = d;\n\n\t\t}\n\n\t},\n\n\tcomputeBoundingBox: function () {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new THREE.Box3();\n\n\t\t}\n\n\t\tthis.boundingBox.setFromPoints( this.vertices );\n\n\t},\n\n\tcomputeBoundingSphere: function () {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new THREE.Sphere();\n\n\t\t}\n\n\t\tthis.boundingSphere.setFromCenterAndPoints( this.boundingSphere.center, this.vertices );\n\n\t},\n\n\t/*\n\t * Checks for duplicate vertices with hashmap.\n\t * Duplicated vertices are removed\n\t * and faces' vertices are updated.\n\t */\n\n\tmergeVertices: function () {\n\n\t\tvar verticesMap = {}; // Hashmap for looking up vertice by position coordinates (and making sure they are unique)\n\t\tvar unique = [], changes = [];\n\n\t\tvar v, key;\n\t\tvar precisionPoints = 4; // number of decimal points, eg. 4 for epsilon of 0.0001\n\t\tvar precision = Math.pow( 10, precisionPoints );\n\t\tvar i,il, face;\n\t\tvar indices, k, j, jl, u;\n\n\t\t// reset cache of vertices as it now will be changing.\n\t\tthis.__tmpVertices = undefined;\n\n\t\tfor ( i = 0, il = this.vertices.length; i < il; i ++ ) {\n\n\t\t\tv = this.vertices[ i ];\n\t\t\tkey = [ Math.round( v.x * precision ), Math.round( v.y * precision ), Math.round( v.z * precision ) ].join( '_' );\n\n\t\t\tif ( verticesMap[ key ] === undefined ) {\n\n\t\t\t\tverticesMap[ key ] = i;\n\t\t\t\tunique.push( this.vertices[ i ] );\n\t\t\t\tchanges[ i ] = unique.length - 1;\n\n\t\t\t} else {\n\n\t\t\t\t//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\n\t\t\t\tchanges[ i ] = changes[ verticesMap[ key ] ];\n\n\t\t\t}\n\n\t\t};\n\n\n\t\t// if faces are completely degenerate after merging vertices, we\n\t\t// have to remove them from the geometry.\n\t\tvar faceIndicesToRemove = [];\n\n\t\tfor( i = 0, il = this.faces.length; i < il; i ++ ) {\n\n\t\t\tface = this.faces[ i ];\n\n\t\t\tif ( face instanceof THREE.Face3 ) {\n\n\t\t\t\tface.a = changes[ face.a ];\n\t\t\t\tface.b = changes[ face.b ];\n\t\t\t\tface.c = changes[ face.c ];\n\n\t\t\t\tindices = [ face.a, face.b, face.c ];\n\n\t\t\t\tvar dupIndex = -1;\n\n\t\t\t\t// if any duplicate vertices are found in a Face3\n\t\t\t\t// we have to remove the face as nothing can be saved\n\t\t\t\tfor ( var n = 0; n < 3; n ++ ) {\n\t\t\t\t\tif ( indices[ n ] == indices[ ( n + 1 ) % 3 ] ) {\n\n\t\t\t\t\t\tdupIndex = n;\n\t\t\t\t\t\tfaceIndicesToRemove.push( i );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else if ( face instanceof THREE.Face4 ) {\n\n\t\t\t\tface.a = changes[ face.a ];\n\t\t\t\tface.b = changes[ face.b ];\n\t\t\t\tface.c = changes[ face.c ];\n\t\t\t\tface.d = changes[ face.d ];\n\n\t\t\t\t// check dups in (a, b, c, d) and convert to -> face3\n\n\t\t\t\tindices = [ face.a, face.b, face.c, face.d ];\n\n\t\t\t\tvar dupIndex = -1;\n\n\t\t\t\tfor ( var n = 0; n < 4; n ++ ) {\n\n\t\t\t\t\tif ( indices[ n ] == indices[ ( n + 1 ) % 4 ] ) {\n\n\t\t\t\t\t\t// if more than one duplicated vertex is found\n\t\t\t\t\t\t// we can't generate any valid Face3's, thus\n\t\t\t\t\t\t// we need to remove this face complete.\n\t\t\t\t\t\tif ( dupIndex >= 0 ) {\n\n\t\t\t\t\t\t\tfaceIndicesToRemove.push( i );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdupIndex = n;\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( dupIndex >= 0 ) {\n\n\t\t\t\t\tindices.splice( dupIndex, 1 );\n\n\t\t\t\t\tvar newFace = new THREE.Face3( indices[0], indices[1], indices[2], face.normal, face.color, face.materialIndex );\n\n\t\t\t\t\tfor ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tu = this.faceVertexUvs[ j ][ i ];\n\n\t\t\t\t\t\tif ( u ) {\n\t\t\t\t\t\t\tu.splice( dupIndex, 1 );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif( face.vertexNormals && face.vertexNormals.length > 0) {\n\n\t\t\t\t\t\tnewFace.vertexNormals = face.vertexNormals;\n\t\t\t\t\t\tnewFace.vertexNormals.splice( dupIndex, 1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif( face.vertexColors && face.vertexColors.length > 0 ) {\n\n\t\t\t\t\t\tnewFace.vertexColors = face.vertexColors;\n\t\t\t\t\t\tnewFace.vertexColors.splice( dupIndex, 1 );\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.faces[ i ] = newFace;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {\n\n\t\t\tthis.faces.splice( i, 1 );\n\n\t\t\tfor ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\n\n\t\t\t\tthis.faceVertexUvs[ j ].splice( i, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Use unique set of vertices\n\n\t\tvar diff = this.vertices.length - unique.length;\n\t\tthis.vertices = unique;\n\t\treturn diff;\n\n\t},\n\n\tclone: function () {\n\n\t\tvar geometry = new THREE.Geometry();\n\n\t\tvar vertices = this.vertices;\n\n\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\tgeometry.vertices.push( vertices[ i ].clone() );\n\n\t\t}\n\n\t\tvar faces = this.faces;\n\n\t\tfor ( var i = 0, il = faces.length; i < il; i ++ ) {\n\n\t\t\tgeometry.faces.push( faces[ i ].clone() );\n\n\t\t}\n\n\t\tvar uvs = this.faceVertexUvs[ 0 ];\n\n\t\tfor ( var i = 0, il = uvs.length; i < il; i ++ ) {\n\n\t\t\tvar uv = uvs[ i ], uvCopy = [];\n\n\t\t\tfor ( var j = 0, jl = uv.length; j < jl; j ++ ) {\n\n\t\t\t\tuvCopy.push( new THREE.Vector2( uv[ j ].x, uv[ j ].y ) );\n\n\t\t\t}\n\n\t\t\tgeometry.faceVertexUvs[ 0 ].push( uvCopy );\n\n\t\t}\n\n\t\treturn geometry;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n};\n\nTHREE.GeometryIdCount = 0;\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.BufferGeometry = function () {\n\n\tTHREE.EventDispatcher.call( this );\n\n\tthis.id = THREE.GeometryIdCount ++;\n\n\t// attributes\n\n\tthis.attributes = {};\n\n\t// attributes typed arrays are kept only if dynamic flag is set\n\n\tthis.dynamic = false;\n\n\t// offsets for chunks when using indexed elements\n\n\tthis.offsets = [];\n\n\t// boundings\n\n\tthis.boundingBox = null;\n\tthis.boundingSphere = null;\n\n\tthis.hasTangents = false;\n\n\t// for compatibility\n\n\tthis.morphTargets = [];\n\n};\n\nTHREE.BufferGeometry.prototype = {\n\n\tconstructor : THREE.BufferGeometry,\n\n\tapplyMatrix: function ( matrix ) {\n\n\t\tvar positionArray;\n\t\tvar normalArray;\n\n\t\tif ( this.attributes[ \"position\" ] ) positionArray = this.attributes[ \"position\" ].array;\n\t\tif ( this.attributes[ \"normal\" ] ) normalArray = this.attributes[ \"normal\" ].array;\n\n\t\tif ( positionArray !== undefined ) {\n\n\t\t\tmatrix.multiplyVector3Array( positionArray );\n\t\t\tthis.verticesNeedUpdate = true;\n\n\t\t}\n\n\t\tif ( normalArray !== undefined ) {\n\n\t\t\tvar normalMatrix = new THREE.Matrix3();\n\t\t\tnormalMatrix.getInverse( matrix ).transpose();\n\n\t\t\tnormalMatrix.multiplyVector3Array( normalArray );\n\n\t\t\tthis.normalizeNormals();\n\n\t\t\tthis.normalsNeedUpdate = true;\n\n\t\t}\n\n\t},\n\n\tcomputeBoundingBox: function () {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new THREE.Box3();\n\n\t\t}\n\n\t\tvar positions = this.attributes[ \"position\" ].array;\n\n\t\tif ( positions ) {\n\n\t\t\tvar bb = this.boundingBox;\n\t\t\tvar x, y, z;\n\n\t\t\tif( positions.length >= 3 ) {\n\t\t\t\tbb.min.x = bb.max.x = positions[ 0 ];\n\t\t\t\tbb.min.y = bb.max.y = positions[ 1 ];\n\t\t\t\tbb.min.z = bb.max.z = positions[ 2 ];\n\t\t\t}\n\n\t\t\tfor ( var i = 3, il = positions.length; i < il; i += 3 ) {\n\n\t\t\t\tx = positions[ i ];\n\t\t\t\ty = positions[ i + 1 ];\n\t\t\t\tz = positions[ i + 2 ];\n\n\t\t\t\t// bounding box\n\n\t\t\t\tif ( x < bb.min.x ) {\n\n\t\t\t\t\tbb.min.x = x;\n\n\t\t\t\t} else if ( x > bb.max.x ) {\n\n\t\t\t\t\tbb.max.x = x;\n\n\t\t\t\t}\n\n\t\t\t\tif ( y < bb.min.y ) {\n\n\t\t\t\t\tbb.min.y = y;\n\n\t\t\t\t} else if ( y > bb.max.y ) {\n\n\t\t\t\t\tbb.max.y = y;\n\n\t\t\t\t}\n\n\t\t\t\tif ( z < bb.min.z ) {\n\n\t\t\t\t\tbb.min.z = z;\n\n\t\t\t\t} else if ( z > bb.max.z ) {\n\n\t\t\t\t\tbb.max.z = z;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( positions === undefined || positions.length === 0 ) {\n\n\t\t\tthis.boundingBox.min.set( 0, 0, 0 );\n\t\t\tthis.boundingBox.max.set( 0, 0, 0 );\n\n\t\t}\n\n\t},\n\n\tcomputeBoundingSphere: function () {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new THREE.Sphere();\n\n\t\t}\n\n\t\tvar positions = this.attributes[ \"position\" ].array;\n\n\t\tif ( positions ) {\n\n\t\t\tvar radiusSq, maxRadiusSq = 0;\n\t\t\tvar x, y, z;\n\n\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 3 ) {\n\n\t\t\t\tx = positions[ i ];\n\t\t\t\ty = positions[ i + 1 ];\n\t\t\t\tz = positions[ i + 2 ];\n\n\t\t\t\tradiusSq =  x * x + y * y + z * z;\n\t\t\t\tif ( radiusSq > maxRadiusSq ) maxRadiusSq = radiusSq;\n\n\t\t\t}\n\n\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t}\n\n\t},\n\n\tcomputeVertexNormals: function () {\n\n\t\tif ( this.attributes[ \"position\" ] ) {\n\n\t\t\tvar i, il;\n\t\t\tvar j, jl;\n\n\t\t\tvar nVertexElements = this.attributes[ \"position\" ].array.length;\n\n\t\t\tif ( this.attributes[ \"normal\" ] === undefined ) {\n\n\t\t\t\tthis.attributes[ \"normal\" ] = {\n\n\t\t\t\t\titemSize: 3,\n\t\t\t\t\tarray: new Float32Array( nVertexElements ),\n\t\t\t\t\tnumItems: nVertexElements\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\t// reset existing normals to zero\n\n\t\t\t\tfor ( i = 0, il = this.attributes[ \"normal\" ].array.length; i < il; i ++ ) {\n\n\t\t\t\t\tthis.attributes[ \"normal\" ].array[ i ] = 0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar positions = this.attributes[ \"position\" ].array;\n\t\t\tvar normals = this.attributes[ \"normal\" ].array;\n\n\t\t\tvar vA, vB, vC, x, y, z,\n\n\t\t\tpA = new THREE.Vector3(),\n\t\t\tpB = new THREE.Vector3(),\n\t\t\tpC = new THREE.Vector3(),\n\n\t\t\tcb = new THREE.Vector3(),\n\t\t\tab = new THREE.Vector3();\n\n\t\t\t// indexed elements\n\n\t\t\tif ( this.attributes[ \"index\" ] ) {\n\n\t\t\t\tvar indices = this.attributes[ \"index\" ].array;\n\n\t\t\t\tvar offsets = this.offsets;\n\n\t\t\t\tfor ( j = 0, jl = offsets.length; j < jl; ++ j ) {\n\n\t\t\t\t\tvar start = offsets[ j ].start;\n\t\t\t\t\tvar count = offsets[ j ].count;\n\t\t\t\t\tvar index = offsets[ j ].index;\n\n\t\t\t\t\tfor ( i = start, il = start + count; i < il; i += 3 ) {\n\n\t\t\t\t\t\tvA = index + indices[ i ];\n\t\t\t\t\t\tvB = index + indices[ i + 1 ];\n\t\t\t\t\t\tvC = index + indices[ i + 2 ];\n\n\t\t\t\t\t\tx = positions[ vA * 3 ];\n\t\t\t\t\t\ty = positions[ vA * 3 + 1 ];\n\t\t\t\t\t\tz = positions[ vA * 3 + 2 ];\n\t\t\t\t\t\tpA.set( x, y, z );\n\n\t\t\t\t\t\tx = positions[ vB * 3 ];\n\t\t\t\t\t\ty = positions[ vB * 3 + 1 ];\n\t\t\t\t\t\tz = positions[ vB * 3 + 2 ];\n\t\t\t\t\t\tpB.set( x, y, z );\n\n\t\t\t\t\t\tx = positions[ vC * 3 ];\n\t\t\t\t\t\ty = positions[ vC * 3 + 1 ];\n\t\t\t\t\t\tz = positions[ vC * 3 + 2 ];\n\t\t\t\t\t\tpC.set( x, y, z );\n\n\t\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\t\tnormals[ vA * 3 ]     += cb.x;\n\t\t\t\t\t\tnormals[ vA * 3 + 1 ] += cb.y;\n\t\t\t\t\t\tnormals[ vA * 3 + 2 ] += cb.z;\n\n\t\t\t\t\t\tnormals[ vB * 3 ]     += cb.x;\n\t\t\t\t\t\tnormals[ vB * 3 + 1 ] += cb.y;\n\t\t\t\t\t\tnormals[ vB * 3 + 2 ] += cb.z;\n\n\t\t\t\t\t\tnormals[ vC * 3 ]     += cb.x;\n\t\t\t\t\t\tnormals[ vC * 3 + 1 ] += cb.y;\n\t\t\t\t\t\tnormals[ vC * 3 + 2 ] += cb.z;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t// non-indexed elements (unconnected triangle soup)\n\n\t\t\t} else {\n\n\t\t\t\tfor ( i = 0, il = positions.length; i < il; i += 9 ) {\n\n\t\t\t\t\tx = positions[ i ];\n\t\t\t\t\ty = positions[ i + 1 ];\n\t\t\t\t\tz = positions[ i + 2 ];\n\t\t\t\t\tpA.set( x, y, z );\n\n\t\t\t\t\tx = positions[ i + 3 ];\n\t\t\t\t\ty = positions[ i + 4 ];\n\t\t\t\t\tz = positions[ i + 5 ];\n\t\t\t\t\tpB.set( x, y, z );\n\n\t\t\t\t\tx = positions[ i + 6 ];\n\t\t\t\t\ty = positions[ i + 7 ];\n\t\t\t\t\tz = positions[ i + 8 ];\n\t\t\t\t\tpC.set( x, y, z );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnormals[ i ] \t = cb.x;\n\t\t\t\t\tnormals[ i + 1 ] = cb.y;\n\t\t\t\t\tnormals[ i + 2 ] = cb.z;\n\n\t\t\t\t\tnormals[ i + 3 ] = cb.x;\n\t\t\t\t\tnormals[ i + 4 ] = cb.y;\n\t\t\t\t\tnormals[ i + 5 ] = cb.z;\n\n\t\t\t\t\tnormals[ i + 6 ] = cb.x;\n\t\t\t\t\tnormals[ i + 7 ] = cb.y;\n\t\t\t\t\tnormals[ i + 8 ] = cb.z;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.normalizeNormals();\n\n\t\t\tthis.normalsNeedUpdate = true;\n\n\t\t}\n\n\t},\n\n\tnormalizeNormals: function () {\n\n\t\tvar normals = this.attributes[ \"normal\" ].array;\n\n\t\tvar x, y, z, n;\n\n\t\tfor ( var i = 0, il = normals.length; i < il; i += 3 ) {\n\n\t\t\tx = normals[ i ];\n\t\t\ty = normals[ i + 1 ];\n\t\t\tz = normals[ i + 2 ];\n\n\t\t\tn = 1.0 / Math.sqrt( x * x + y * y + z * z );\n\n\t\t\tnormals[ i ] \t *= n;\n\t\t\tnormals[ i + 1 ] *= n;\n\t\t\tnormals[ i + 2 ] *= n;\n\n\t\t}\n\n\t},\n\n\tcomputeTangents: function () {\n\n\t\t// based on http://www.terathon.com/code/tangent.html\n\t\t// (per vertex tangents)\n\n\t\tif ( this.attributes[ \"index\" ] === undefined ||\n\t\t\t this.attributes[ \"position\" ] === undefined ||\n\t\t\t this.attributes[ \"normal\" ] === undefined ||\n\t\t\t this.attributes[ \"uv\" ] === undefined ) {\n\n\t\t\tconsole.warn( \"Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()\" );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar indices = this.attributes[ \"index\" ].array;\n\t\tvar positions = this.attributes[ \"position\" ].array;\n\t\tvar normals = this.attributes[ \"normal\" ].array;\n\t\tvar uvs = this.attributes[ \"uv\" ].array;\n\n\t\tvar nVertices = positions.length / 3;\n\n\t\tif ( this.attributes[ \"tangent\" ] === undefined ) {\n\n\t\t\tvar nTangentElements = 4 * nVertices;\n\n\t\t\tthis.attributes[ \"tangent\" ] = {\n\n\t\t\t\titemSize: 4,\n\t\t\t\tarray: new Float32Array( nTangentElements ),\n\t\t\t\tnumItems: nTangentElements\n\n\t\t\t};\n\n\t\t}\n\n\t\tvar tangents = this.attributes[ \"tangent\" ].array;\n\n\t\tvar tan1 = [], tan2 = [];\n\n\t\tfor ( var k = 0; k < nVertices; k ++ ) {\n\n\t\t\ttan1[ k ] = new THREE.Vector3();\n\t\t\ttan2[ k ] = new THREE.Vector3();\n\n\t\t}\n\n\t\tvar xA, yA, zA,\n\t\t\txB, yB, zB,\n\t\t\txC, yC, zC,\n\n\t\t\tuA, vA,\n\t\t\tuB, vB,\n\t\t\tuC, vC,\n\n\t\t\tx1, x2, y1, y2, z1, z2,\n\t\t\ts1, s2, t1, t2, r;\n\n\t\tvar sdir = new THREE.Vector3(), tdir = new THREE.Vector3();\n\n\t\tfunction handleTriangle( a, b, c ) {\n\n\t\t\txA = positions[ a * 3 ];\n\t\t\tyA = positions[ a * 3 + 1 ];\n\t\t\tzA = positions[ a * 3 + 2 ];\n\n\t\t\txB = positions[ b * 3 ];\n\t\t\tyB = positions[ b * 3 + 1 ];\n\t\t\tzB = positions[ b * 3 + 2 ];\n\n\t\t\txC = positions[ c * 3 ];\n\t\t\tyC = positions[ c * 3 + 1 ];\n\t\t\tzC = positions[ c * 3 + 2 ];\n\n\t\t\tuA = uvs[ a * 2 ];\n\t\t\tvA = uvs[ a * 2 + 1 ];\n\n\t\t\tuB = uvs[ b * 2 ];\n\t\t\tvB = uvs[ b * 2 + 1 ];\n\n\t\t\tuC = uvs[ c * 2 ];\n\t\t\tvC = uvs[ c * 2 + 1 ];\n\n\t\t\tx1 = xB - xA;\n\t\t\tx2 = xC - xA;\n\n\t\t\ty1 = yB - yA;\n\t\t\ty2 = yC - yA;\n\n\t\t\tz1 = zB - zA;\n\t\t\tz2 = zC - zA;\n\n\t\t\ts1 = uB - uA;\n\t\t\ts2 = uC - uA;\n\n\t\t\tt1 = vB - vA;\n\t\t\tt2 = vC - vA;\n\n\t\t\tr = 1.0 / ( s1 * t2 - s2 * t1 );\n\n\t\t\tsdir.set(\n\t\t\t\t( t2 * x1 - t1 * x2 ) * r,\n\t\t\t\t( t2 * y1 - t1 * y2 ) * r,\n\t\t\t\t( t2 * z1 - t1 * z2 ) * r\n\t\t\t);\n\n\t\t\ttdir.set(\n\t\t\t\t( s1 * x2 - s2 * x1 ) * r,\n\t\t\t\t( s1 * y2 - s2 * y1 ) * r,\n\t\t\t\t( s1 * z2 - s2 * z1 ) * r\n\t\t\t);\n\n\t\t\ttan1[ a ].add( sdir );\n\t\t\ttan1[ b ].add( sdir );\n\t\t\ttan1[ c ].add( sdir );\n\n\t\t\ttan2[ a ].add( tdir );\n\t\t\ttan2[ b ].add( tdir );\n\t\t\ttan2[ c ].add( tdir );\n\n\t\t}\n\n\t\tvar i, il;\n\t\tvar j, jl;\n\t\tvar iA, iB, iC;\n\n\t\tvar offsets = this.offsets;\n\n\t\tfor ( j = 0, jl = offsets.length; j < jl; ++ j ) {\n\n\t\t\tvar start = offsets[ j ].start;\n\t\t\tvar count = offsets[ j ].count;\n\t\t\tvar index = offsets[ j ].index;\n\n\t\t\tfor ( i = start, il = start + count; i < il; i += 3 ) {\n\n\t\t\t\tiA = index + indices[ i ];\n\t\t\t\tiB = index + indices[ i + 1 ];\n\t\t\t\tiC = index + indices[ i + 2 ];\n\n\t\t\t\thandleTriangle( iA, iB, iC );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3();\n\t\tvar n = new THREE.Vector3(), n2 = new THREE.Vector3();\n\t\tvar w, t, test;\n\n\t\tfunction handleVertex( v ) {\n\n\t\t\tn.x = normals[ v * 3 ];\n\t\t\tn.y = normals[ v * 3 + 1 ];\n\t\t\tn.z = normals[ v * 3 + 2 ];\n\n\t\t\tn2.copy( n );\n\n\t\t\tt = tan1[ v ];\n\n\t\t\t// Gram-Schmidt orthogonalize\n\n\t\t\ttmp.copy( t );\n\t\t\ttmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();\n\n\t\t\t// Calculate handedness\n\n\t\t\ttmp2.crossVectors( n2, t );\n\t\t\ttest = tmp2.dot( tan2[ v ] );\n\t\t\tw = ( test < 0.0 ) ? -1.0 : 1.0;\n\n\t\t\ttangents[ v * 4 ] \t  = tmp.x;\n\t\t\ttangents[ v * 4 + 1 ] = tmp.y;\n\t\t\ttangents[ v * 4 + 2 ] = tmp.z;\n\t\t\ttangents[ v * 4 + 3 ] = w;\n\n\t\t}\n\n\t\tfor ( j = 0, jl = offsets.length; j < jl; ++ j ) {\n\n\t\t\tvar start = offsets[ j ].start;\n\t\t\tvar count = offsets[ j ].count;\n\t\t\tvar index = offsets[ j ].index;\n\n\t\t\tfor ( i = start, il = start + count; i < il; i += 3 ) {\n\n\t\t\t\tiA = index + indices[ i ];\n\t\t\t\tiB = index + indices[ i + 1 ];\n\t\t\t\tiC = index + indices[ i + 2 ];\n\n\t\t\t\thandleVertex( iA );\n\t\t\t\thandleVertex( iB );\n\t\t\t\thandleVertex( iC );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.hasTangents = true;\n\t\tthis.tangentsNeedUpdate = true;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author mikael emtinger / http://gomo.se/\n */\n\nTHREE.Camera = function () {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.matrixWorldInverse = new THREE.Matrix4();\n\n\tthis.projectionMatrix = new THREE.Matrix4();\n\tthis.projectionMatrixInverse = new THREE.Matrix4();\n\n};\n\nTHREE.Camera.prototype = Object.create( THREE.Object3D.prototype );\n\nTHREE.Camera.prototype.lookAt = function ( vector ) {\n\n\t// TODO: Add hierarchy support.\n\n\tthis.matrix.lookAt( this.position, vector, this.up );\n\n\tif ( this.rotationAutoUpdate === true ) {\n\n\t\tif ( this.useQuaternion === false )  {\n\n\t\t\tthis.rotation.setEulerFromRotationMatrix( this.matrix, this.eulerOrder );\n\n\t\t} else {\n\n\t\t\tthis.quaternion.copy( this.matrix.decompose()[ 1 ] );\n\n\t\t}\n\n\t}\n\n};\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {\n\n\tTHREE.Camera.call( this );\n\n\tthis.left = left;\n\tthis.right = right;\n\tthis.top = top;\n\tthis.bottom = bottom;\n\n\tthis.near = ( near !== undefined ) ? near : 0.1;\n\tthis.far = ( far !== undefined ) ? far : 2000;\n\n\tthis.updateProjectionMatrix();\n\n};\n\nTHREE.OrthographicCamera.prototype = Object.create( THREE.Camera.prototype );\n\nTHREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {\n\n\tthis.projectionMatrix.makeOrthographic( this.left, this.right, this.top, this.bottom, this.near, this.far );\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author greggman / http://games.greggman.com/\n * @author zz85 / http://www.lab4games.net/zz85/blog\n */\n\nTHREE.PerspectiveCamera = function ( fov, aspect, near, far ) {\n\n\tTHREE.Camera.call( this );\n\n\tthis.fov = fov !== undefined ? fov : 50;\n\tthis.aspect = aspect !== undefined ? aspect : 1;\n\tthis.near = near !== undefined ? near : 0.1;\n\tthis.far = far !== undefined ? far : 2000;\n\n\tthis.updateProjectionMatrix();\n\n};\n\nTHREE.PerspectiveCamera.prototype = Object.create( THREE.Camera.prototype );\n\n\n/**\n * Uses Focal Length (in mm) to estimate and set FOV\n * 35mm (fullframe) camera is used if frame size is not specified;\n * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html\n */\n\nTHREE.PerspectiveCamera.prototype.setLens = function ( focalLength, frameHeight ) {\n\n\tif ( frameHeight === undefined ) frameHeight = 24;\n\n\tthis.fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );\n\tthis.updateProjectionMatrix();\n\n}\n\n\n/**\n * Sets an offset in a larger frustum. This is useful for multi-window or\n * multi-monitor/multi-machine setups.\n *\n * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\n * the monitors are in grid like this\n *\n *   +---+---+---+\n *   | A | B | C |\n *   +---+---+---+\n *   | D | E | F |\n *   +---+---+---+\n *\n * then for each monitor you would call it like this\n *\n *   var w = 1920;\n *   var h = 1080;\n *   var fullWidth = w * 3;\n *   var fullHeight = h * 2;\n *\n *   --A--\n *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n *   --B--\n *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n *   --C--\n *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n *   --D--\n *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n *   --E--\n *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n *   --F--\n *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n *\n *   Note there is no reason monitors have to be the same size or in a grid.\n */\n\nTHREE.PerspectiveCamera.prototype.setViewOffset = function ( fullWidth, fullHeight, x, y, width, height ) {\n\n\tthis.fullWidth = fullWidth;\n\tthis.fullHeight = fullHeight;\n\tthis.x = x;\n\tthis.y = y;\n\tthis.width = width;\n\tthis.height = height;\n\n\tthis.updateProjectionMatrix();\n\n};\n\n\nTHREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {\n\n\tif ( this.fullWidth ) {\n\n\t\tvar aspect = this.fullWidth / this.fullHeight;\n\t\tvar top = Math.tan( THREE.Math.degToRad( this.fov * 0.5 ) ) * this.near;\n\t\tvar bottom = -top;\n\t\tvar left = aspect * bottom;\n\t\tvar right = aspect * top;\n\t\tvar width = Math.abs( right - left );\n\t\tvar height = Math.abs( top - bottom );\n\n\t\tthis.projectionMatrix.makeFrustum(\n\t\t\tleft + this.x * width / this.fullWidth,\n\t\t\tleft + ( this.x + this.width ) * width / this.fullWidth,\n\t\t\ttop - ( this.y + this.height ) * height / this.fullHeight,\n\t\t\ttop - this.y * height / this.fullHeight,\n\t\t\tthis.near,\n\t\t\tthis.far\n\t\t);\n\n\t} else {\n\n\t\tthis.projectionMatrix.makePerspective( this.fov, this.aspect, this.near, this.far );\n\n\t}\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n \nTHREE.Light = function ( hex ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.color = new THREE.Color( hex );\n\n};\n\nTHREE.Light.prototype = Object.create( THREE.Object3D.prototype );\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.AmbientLight = function ( hex ) {\n\n\tTHREE.Light.call( this, hex );\n\n};\n\nTHREE.AmbientLight.prototype = Object.create( THREE.Light.prototype );\n/**\n * @author MPanknin / http://www.redplant.de/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.AreaLight = function ( hex, intensity ) {\n\n\tTHREE.Light.call( this, hex );\n\n\tthis.normal = new THREE.Vector3( 0, -1, 0 );\n\tthis.right = new THREE.Vector3( 1, 0, 0 );\n\n\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\n\n\tthis.width = 1.0;\n\tthis.height = 1.0;\n\n\tthis.constantAttenuation = 1.5;\n\tthis.linearAttenuation = 0.5;\n\tthis.quadraticAttenuation = 0.1;\n\n};\n\nTHREE.AreaLight.prototype = Object.create( THREE.Light.prototype );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.DirectionalLight = function ( hex, intensity ) {\n\n\tTHREE.Light.call( this, hex );\n\n\tthis.position = new THREE.Vector3( 0, 1, 0 );\n\tthis.target = new THREE.Object3D();\n\n\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\n\n\tthis.castShadow = false;\n\tthis.onlyShadow = false;\n\n\t//\n\n\tthis.shadowCameraNear = 50;\n\tthis.shadowCameraFar = 5000;\n\n\tthis.shadowCameraLeft = -500;\n\tthis.shadowCameraRight = 500;\n\tthis.shadowCameraTop = 500;\n\tthis.shadowCameraBottom = -500;\n\n\tthis.shadowCameraVisible = false;\n\n\tthis.shadowBias = 0;\n\tthis.shadowDarkness = 0.5;\n\n\tthis.shadowMapWidth = 512;\n\tthis.shadowMapHeight = 512;\n\n\t//\n\n\tthis.shadowCascade = false;\n\n\tthis.shadowCascadeOffset = new THREE.Vector3( 0, 0, -1000 );\n\tthis.shadowCascadeCount = 2;\n\n\tthis.shadowCascadeBias = [ 0, 0, 0 ];\n\tthis.shadowCascadeWidth = [ 512, 512, 512 ];\n\tthis.shadowCascadeHeight = [ 512, 512, 512 ];\n\n\tthis.shadowCascadeNearZ = [ -1.000, 0.990, 0.998 ];\n\tthis.shadowCascadeFarZ  = [  0.990, 0.998, 1.000 ];\n\n\tthis.shadowCascadeArray = [];\n\n\t//\n\n\tthis.shadowMap = null;\n\tthis.shadowMapSize = null;\n\tthis.shadowCamera = null;\n\tthis.shadowMatrix = null;\n\n};\n\nTHREE.DirectionalLight.prototype = Object.create( THREE.Light.prototype );\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.HemisphereLight = function ( skyColorHex, groundColorHex, intensity ) {\n\n\tTHREE.Light.call( this, skyColorHex );\n\n\tthis.groundColor = new THREE.Color( groundColorHex );\n\n\tthis.position = new THREE.Vector3( 0, 100, 0 );\n\n\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\n\n};\n\nTHREE.HemisphereLight.prototype = Object.create( THREE.Light.prototype );\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.PointLight = function ( hex, intensity, distance ) {\n\n\tTHREE.Light.call( this, hex );\n\n\tthis.position = new THREE.Vector3( 0, 0, 0 );\n\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\n\tthis.distance = ( distance !== undefined ) ? distance : 0;\n\n};\n\nTHREE.PointLight.prototype = Object.create( THREE.Light.prototype );\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.SpotLight = function ( hex, intensity, distance, angle, exponent ) {\n\n\tTHREE.Light.call( this, hex );\n\n\tthis.position = new THREE.Vector3( 0, 1, 0 );\n\tthis.target = new THREE.Object3D();\n\n\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\n\tthis.distance = ( distance !== undefined ) ? distance : 0;\n\tthis.angle = ( angle !== undefined ) ? angle : Math.PI / 2;\n\tthis.exponent = ( exponent !== undefined ) ? exponent : 10;\n\n\tthis.castShadow = false;\n\tthis.onlyShadow = false;\n\n\t//\n\n\tthis.shadowCameraNear = 50;\n\tthis.shadowCameraFar = 5000;\n\tthis.shadowCameraFov = 50;\n\n\tthis.shadowCameraVisible = false;\n\n\tthis.shadowBias = 0;\n\tthis.shadowDarkness = 0.5;\n\n\tthis.shadowMapWidth = 512;\n\tthis.shadowMapHeight = 512;\n\n\t//\n\n\tthis.shadowMap = null;\n\tthis.shadowMapSize = null;\n\tthis.shadowCamera = null;\n\tthis.shadowMatrix = null;\n\n};\n\nTHREE.SpotLight.prototype = Object.create( THREE.Light.prototype );\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Loader = function ( showStatus ) {\n\n\tthis.showStatus = showStatus;\n\tthis.statusDomElement = showStatus ? THREE.Loader.prototype.addStatusElement() : null;\n\n\tthis.onLoadStart = function () {};\n\tthis.onLoadProgress = function () {};\n\tthis.onLoadComplete = function () {};\n\n};\n\nTHREE.Loader.prototype = {\n\n\tconstructor: THREE.Loader,\n\n\tcrossOrigin: 'anonymous',\n\n\taddStatusElement: function () {\n\n\t\tvar e = document.createElement( \"div\" );\n\n\t\te.style.position = \"absolute\";\n\t\te.style.right = \"0px\";\n\t\te.style.top = \"0px\";\n\t\te.style.fontSize = \"0.8em\";\n\t\te.style.textAlign = \"left\";\n\t\te.style.background = \"rgba(0,0,0,0.25)\";\n\t\te.style.color = \"#fff\";\n\t\te.style.width = \"120px\";\n\t\te.style.padding = \"0.5em 0.5em 0.5em 0.5em\";\n\t\te.style.zIndex = 1000;\n\n\t\te.innerHTML = \"Loading ...\";\n\n\t\treturn e;\n\n\t},\n\n\tupdateProgress: function ( progress ) {\n\n\t\tvar message = \"Loaded \";\n\n\t\tif ( progress.total ) {\n\n\t\t\tmessage += ( 100 * progress.loaded / progress.total ).toFixed(0) + \"%\";\n\n\n\t\t} else {\n\n\t\t\tmessage += ( progress.loaded / 1000 ).toFixed(2) + \" KB\";\n\n\t\t}\n\n\t\tthis.statusDomElement.innerHTML = message;\n\n\t},\n\n\textractUrlBase: function ( url ) {\n\n\t\tvar parts = url.split( '/' );\n\t\tparts.pop();\n\t\treturn ( parts.length < 1 ? '.' : parts.join( '/' ) ) + '/';\n\n\t},\n\n\tinitMaterials: function ( materials, texturePath ) {\n\n\t\tvar array = [];\n\n\t\tfor ( var i = 0; i < materials.length; ++ i ) {\n\n\t\t\tarray[ i ] = THREE.Loader.prototype.createMaterial( materials[ i ], texturePath );\n\n\t\t}\n\n\t\treturn array;\n\n\t},\n\n\tneedsTangents: function ( materials ) {\n\n\t\tfor( var i = 0, il = materials.length; i < il; i ++ ) {\n\n\t\t\tvar m = materials[ i ];\n\n\t\t\tif ( m instanceof THREE.ShaderMaterial ) return true;\n\n\t\t}\n\n\t\treturn false;\n\n\t},\n\n\tcreateMaterial: function ( m, texturePath ) {\n\n\t\tvar _this = this;\n\n\t\tfunction is_pow2( n ) {\n\n\t\t\tvar l = Math.log( n ) / Math.LN2;\n\t\t\treturn Math.floor( l ) == l;\n\n\t\t}\n\n\t\tfunction nearest_pow2( n ) {\n\n\t\t\tvar l = Math.log( n ) / Math.LN2;\n\t\t\treturn Math.pow( 2, Math.round(  l ) );\n\n\t\t}\n\n\t\tfunction load_image( where, url ) {\n\n\t\t\tvar image = new Image();\n\n\t\t\timage.onload = function () {\n\n\t\t\t\tif ( !is_pow2( this.width ) || !is_pow2( this.height ) ) {\n\n\t\t\t\t\tvar width = nearest_pow2( this.width );\n\t\t\t\t\tvar height = nearest_pow2( this.height );\n\n\t\t\t\t\twhere.image.width = width;\n\t\t\t\t\twhere.image.height = height;\n\t\t\t\t\twhere.image.getContext( '2d' ).drawImage( this, 0, 0, width, height );\n\n\t\t\t\t} else {\n\n\t\t\t\t\twhere.image = this;\n\n\t\t\t\t}\n\n\t\t\t\twhere.needsUpdate = true;\n\n\t\t\t};\n\n\t\t\timage.crossOrigin = _this.crossOrigin;\n\t\t\timage.src = url;\n\n\t\t}\n\n\t\tfunction create_texture( where, name, sourceFile, repeat, offset, wrap, anisotropy ) {\n\n\t\t\tvar isCompressed = /\\.dds$/i.test( sourceFile );\n\t\t\tvar fullPath = texturePath + \"/\" + sourceFile;\n\n\t\t\tif ( isCompressed ) {\n\n\t\t\t\tvar texture = THREE.ImageUtils.loadCompressedTexture( fullPath );\n\n\t\t\t\twhere[ name ] = texture;\n\n\t\t\t} else {\n\n\t\t\t\tvar texture = document.createElement( 'canvas' );\n\n\t\t\t\twhere[ name ] = new THREE.Texture( texture );\n\n\t\t\t}\n\n\t\t\twhere[ name ].sourceFile = sourceFile;\n\n\t\t\tif( repeat ) {\n\n\t\t\t\twhere[ name ].repeat.set( repeat[ 0 ], repeat[ 1 ] );\n\n\t\t\t\tif ( repeat[ 0 ] !== 1 ) where[ name ].wrapS = THREE.RepeatWrapping;\n\t\t\t\tif ( repeat[ 1 ] !== 1 ) where[ name ].wrapT = THREE.RepeatWrapping;\n\n\t\t\t}\n\n\t\t\tif ( offset ) {\n\n\t\t\t\twhere[ name ].offset.set( offset[ 0 ], offset[ 1 ] );\n\n\t\t\t}\n\n\t\t\tif ( wrap ) {\n\n\t\t\t\tvar wrapMap = {\n\t\t\t\t\t\"repeat\": THREE.RepeatWrapping,\n\t\t\t\t\t\"mirror\": THREE.MirroredRepeatWrapping\n\t\t\t\t}\n\n\t\t\t\tif ( wrapMap[ wrap[ 0 ] ] !== undefined ) where[ name ].wrapS = wrapMap[ wrap[ 0 ] ];\n\t\t\t\tif ( wrapMap[ wrap[ 1 ] ] !== undefined ) where[ name ].wrapT = wrapMap[ wrap[ 1 ] ];\n\n\t\t\t}\n\n\t\t\tif ( anisotropy ) {\n\n\t\t\t\twhere[ name ].anisotropy = anisotropy;\n\n\t\t\t}\n\n\t\t\tif ( ! isCompressed ) {\n\n\t\t\t\tload_image( where[ name ], fullPath );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction rgb2hex( rgb ) {\n\n\t\t\treturn ( rgb[ 0 ] * 255 << 16 ) + ( rgb[ 1 ] * 255 << 8 ) + rgb[ 2 ] * 255;\n\n\t\t}\n\n\t\t// defaults\n\n\t\tvar mtype = \"MeshLambertMaterial\";\n\t\tvar mpars = { color: 0xeeeeee, opacity: 1.0, map: null, lightMap: null, normalMap: null, bumpMap: null, wireframe: false };\n\n\t\t// parameters from model file\n\n\t\tif ( m.shading ) {\n\n\t\t\tvar shading = m.shading.toLowerCase();\n\n\t\t\tif ( shading === \"phong\" ) mtype = \"MeshPhongMaterial\";\n\t\t\telse if ( shading === \"basic\" ) mtype = \"MeshBasicMaterial\";\n\n\t\t}\n\n\t\tif ( m.blending !== undefined && THREE[ m.blending ] !== undefined ) {\n\n\t\t\tmpars.blending = THREE[ m.blending ];\n\n\t\t}\n\n\t\tif ( m.transparent !== undefined || m.opacity < 1.0 ) {\n\n\t\t\tmpars.transparent = m.transparent;\n\n\t\t}\n\n\t\tif ( m.depthTest !== undefined ) {\n\n\t\t\tmpars.depthTest = m.depthTest;\n\n\t\t}\n\n\t\tif ( m.depthWrite !== undefined ) {\n\n\t\t\tmpars.depthWrite = m.depthWrite;\n\n\t\t}\n\n\t\tif ( m.visible !== undefined ) {\n\n\t\t\tmpars.visible = m.visible;\n\n\t\t}\n\n\t\tif ( m.flipSided !== undefined ) {\n\n\t\t\tmpars.side = THREE.BackSide;\n\n\t\t}\n\n\t\tif ( m.doubleSided !== undefined ) {\n\n\t\t\tmpars.side = THREE.DoubleSide;\n\n\t\t}\n\n\t\tif ( m.wireframe !== undefined ) {\n\n\t\t\tmpars.wireframe = m.wireframe;\n\n\t\t}\n\n\t\tif ( m.vertexColors !== undefined ) {\n\n\t\t\tif ( m.vertexColors === \"face\" ) {\n\n\t\t\t\tmpars.vertexColors = THREE.FaceColors;\n\n\t\t\t} else if ( m.vertexColors ) {\n\n\t\t\t\tmpars.vertexColors = THREE.VertexColors;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// colors\n\n\t\tif ( m.colorDiffuse ) {\n\n\t\t\tmpars.color = rgb2hex( m.colorDiffuse );\n\n\t\t} else if ( m.DbgColor ) {\n\n\t\t\tmpars.color = m.DbgColor;\n\n\t\t}\n\n\t\tif ( m.colorSpecular ) {\n\n\t\t\tmpars.specular = rgb2hex( m.colorSpecular );\n\n\t\t}\n\n\t\tif ( m.colorAmbient ) {\n\n\t\t\tmpars.ambient = rgb2hex( m.colorAmbient );\n\n\t\t}\n\n\t\t// modifiers\n\n\t\tif ( m.transparency ) {\n\n\t\t\tmpars.opacity = m.transparency;\n\n\t\t}\n\n\t\tif ( m.specularCoef ) {\n\n\t\t\tmpars.shininess = m.specularCoef;\n\n\t\t}\n\n\t\t// textures\n\n\t\tif ( m.mapDiffuse && texturePath ) {\n\n\t\t\tcreate_texture( mpars, \"map\", m.mapDiffuse, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );\n\n\t\t}\n\n\t\tif ( m.mapLight && texturePath ) {\n\n\t\t\tcreate_texture( mpars, \"lightMap\", m.mapLight, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );\n\n\t\t}\n\n\t\tif ( m.mapBump && texturePath ) {\n\n\t\t\tcreate_texture( mpars, \"bumpMap\", m.mapBump, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );\n\n\t\t}\n\n\t\tif ( m.mapNormal && texturePath ) {\n\n\t\t\tcreate_texture( mpars, \"normalMap\", m.mapNormal, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );\n\n\t\t}\n\n\t\tif ( m.mapSpecular && texturePath ) {\n\n\t\t\tcreate_texture( mpars, \"specularMap\", m.mapSpecular, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( m.mapBumpScale ) {\n\n\t\t\tmpars.bumpScale = m.mapBumpScale;\n\n\t\t}\n\n\t\t// special case for normal mapped material\n\n\t\tif ( m.mapNormal ) {\n\n\t\t\tvar shader = THREE.ShaderLib[ \"normalmap\" ];\n\t\t\tvar uniforms = THREE.UniformsUtils.clone( shader.uniforms );\n\n\t\t\tuniforms[ \"tNormal\" ].value = mpars.normalMap;\n\n\t\t\tif ( m.mapNormalFactor ) {\n\n\t\t\t\tuniforms[ \"uNormalScale\" ].value.set( m.mapNormalFactor, m.mapNormalFactor );\n\n\t\t\t}\n\n\t\t\tif ( mpars.map ) {\n\n\t\t\t\tuniforms[ \"tDiffuse\" ].value = mpars.map;\n\t\t\t\tuniforms[ \"enableDiffuse\" ].value = true;\n\n\t\t\t}\n\n\t\t\tif ( mpars.specularMap ) {\n\n\t\t\t\tuniforms[ \"tSpecular\" ].value = mpars.specularMap;\n\t\t\t\tuniforms[ \"enableSpecular\" ].value = true;\n\n\t\t\t}\n\n\t\t\tif ( mpars.lightMap ) {\n\n\t\t\t\tuniforms[ \"tAO\" ].value = mpars.lightMap;\n\t\t\t\tuniforms[ \"enableAO\" ].value = true;\n\n\t\t\t}\n\n\t\t\t// for the moment don't handle displacement texture\n\n\t\t\tuniforms[ \"uDiffuseColor\" ].value.setHex( mpars.color );\n\t\t\tuniforms[ \"uSpecularColor\" ].value.setHex( mpars.specular );\n\t\t\tuniforms[ \"uAmbientColor\" ].value.setHex( mpars.ambient );\n\n\t\t\tuniforms[ \"uShininess\" ].value = mpars.shininess;\n\n\t\t\tif ( mpars.opacity !== undefined ) {\n\n\t\t\t\tuniforms[ \"uOpacity\" ].value = mpars.opacity;\n\n\t\t\t}\n\n\t\t\tvar parameters = { fragmentShader: shader.fragmentShader, vertexShader: shader.vertexShader, uniforms: uniforms, lights: true, fog: true };\n\t\t\tvar material = new THREE.ShaderMaterial( parameters );\n\n\t\t\tif ( mpars.transparent ) {\n\n\t\t\t\tmaterial.transparent = true;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tvar material = new THREE[ mtype ]( mpars );\n\n\t\t}\n\n\t\tif ( m.DbgName !== undefined ) material.name = m.DbgName;\n\n\t\treturn material;\n\n\t}\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.ImageLoader = function () {\n\n\tTHREE.EventDispatcher.call( this );\n\n\tthis.crossOrigin = null;\n\n};\n\nTHREE.ImageLoader.prototype = {\n\n\tconstructor: THREE.ImageLoader,\n\n\tload: function ( url, image ) {\n\n\t\tvar scope = this;\n\n\t\tif ( image === undefined ) image = new Image();\n\n\t\timage.addEventListener( 'load', function () {\n\n\t\t\tscope.dispatchEvent( { type: 'load', content: image } );\n\n\t\t}, false );\n\n\t\timage.addEventListener( 'error', function () {\n\n\t\t\tscope.dispatchEvent( { type: 'error', message: 'Couldn\\'t load URL [' + url + ']' } );\n\n\t\t}, false );\n\n\t\tif ( scope.crossOrigin ) image.crossOrigin = scope.crossOrigin;\n\n\t\timage.src = url;\n\n\t}\n\n}\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.JSONLoader = function ( showStatus ) {\n\n\tTHREE.Loader.call( this, showStatus );\n\n\tthis.withCredentials = false;\n\n};\n\nTHREE.JSONLoader.prototype = Object.create( THREE.Loader.prototype );\n\nTHREE.JSONLoader.prototype.load = function ( url, callback, texturePath ) {\n\n\tvar scope = this;\n\n\t// todo: unify load API to for easier SceneLoader use\n\n\ttexturePath = texturePath && ( typeof texturePath === \"string\" ) ? texturePath : this.extractUrlBase( url );\n\n\tthis.onLoadStart();\n\tthis.loadAjaxJSON( this, url, callback, texturePath );\n\n};\n\nTHREE.JSONLoader.prototype.loadAjaxJSON = function ( context, url, callback, texturePath, callbackProgress ) {\n\n\tvar xhr = new XMLHttpRequest();\n\n\tvar length = 0;\n\n\txhr.onreadystatechange = function () {\n\n\t\tif ( xhr.readyState === xhr.DONE ) {\n\n\t\t\tif ( xhr.status === 200 || xhr.status === 0 ) {\n\n\t\t\t\tif ( xhr.responseText ) {\n\n\t\t\t\t\tvar json = JSON.parse( xhr.responseText );\n\t\t\t\t\tcontext.createModel( json, callback, texturePath );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( \"THREE.JSONLoader: [\" + url + \"] seems to be unreachable or file there is empty\" );\n\n\t\t\t\t}\n\n\t\t\t\t// in context of more complex asset initialization\n\t\t\t\t// do not block on single failed file\n\t\t\t\t// maybe should go even one more level up\n\n\t\t\t\tcontext.onLoadComplete();\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( \"THREE.JSONLoader: Couldn't load [\" + url + \"] [\" + xhr.status + \"]\" );\n\n\t\t\t}\n\n\t\t} else if ( xhr.readyState === xhr.LOADING ) {\n\n\t\t\tif ( callbackProgress ) {\n\n\t\t\t\tif ( length === 0 ) {\n\n\t\t\t\t\tlength = xhr.getResponseHeader( \"Content-Length\" );\n\n\t\t\t\t}\n\n\t\t\t\tcallbackProgress( { total: length, loaded: xhr.responseText.length } );\n\n\t\t\t}\n\n\t\t} else if ( xhr.readyState === xhr.HEADERS_RECEIVED ) {\n\n\t\t\tlength = xhr.getResponseHeader( \"Content-Length\" );\n\n\t\t}\n\n\t};\n\n\txhr.open( \"GET\", url, true );\n\txhr.withCredentials = this.withCredentials;\n\txhr.send( null );\n\n};\n\nTHREE.JSONLoader.prototype.createModel = function ( json, callback, texturePath ) {\n\n\tvar scope = this,\n\tgeometry = new THREE.Geometry(),\n\tscale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;\n\n\tparseModel( scale );\n\n\tparseSkin();\n\tparseMorphing( scale );\n\n\tgeometry.computeCentroids();\n\tgeometry.computeFaceNormals();\n\n\tfunction parseModel( scale ) {\n\n\t\tfunction isBitSet( value, position ) {\n\n\t\t\treturn value & ( 1 << position );\n\n\t\t}\n\n\t\tvar i, j, fi,\n\n\t\toffset, zLength, nVertices,\n\n\t\tcolorIndex, normalIndex, uvIndex, materialIndex,\n\n\t\ttype,\n\t\tisQuad,\n\t\thasMaterial,\n\t\thasFaceUv, hasFaceVertexUv,\n\t\thasFaceNormal, hasFaceVertexNormal,\n\t\thasFaceColor, hasFaceVertexColor,\n\n\t\tvertex, face, color, normal,\n\n\t\tuvLayer, uvs, u, v,\n\n\t\tfaces = json.faces,\n\t\tvertices = json.vertices,\n\t\tnormals = json.normals,\n\t\tcolors = json.colors,\n\n\t\tnUvLayers = 0;\n\n\t\t// disregard empty arrays\n\n\t\tfor ( i = 0; i < json.uvs.length; i++ ) {\n\n\t\t\tif ( json.uvs[ i ].length ) nUvLayers ++;\n\n\t\t}\n\n\t\tfor ( i = 0; i < nUvLayers; i++ ) {\n\n\t\t\tgeometry.faceUvs[ i ] = [];\n\t\t\tgeometry.faceVertexUvs[ i ] = [];\n\n\t\t}\n\n\t\toffset = 0;\n\t\tzLength = vertices.length;\n\n\t\twhile ( offset < zLength ) {\n\n\t\t\tvertex = new THREE.Vector3();\n\n\t\t\tvertex.x = vertices[ offset ++ ] * scale;\n\t\t\tvertex.y = vertices[ offset ++ ] * scale;\n\t\t\tvertex.z = vertices[ offset ++ ] * scale;\n\n\t\t\tgeometry.vertices.push( vertex );\n\n\t\t}\n\n\t\toffset = 0;\n\t\tzLength = faces.length;\n\n\t\twhile ( offset < zLength ) {\n\n\t\t\ttype = faces[ offset ++ ];\n\n\n\t\t\tisQuad          \t= isBitSet( type, 0 );\n\t\t\thasMaterial         = isBitSet( type, 1 );\n\t\t\thasFaceUv           = isBitSet( type, 2 );\n\t\t\thasFaceVertexUv     = isBitSet( type, 3 );\n\t\t\thasFaceNormal       = isBitSet( type, 4 );\n\t\t\thasFaceVertexNormal = isBitSet( type, 5 );\n\t\t\thasFaceColor\t    = isBitSet( type, 6 );\n\t\t\thasFaceVertexColor  = isBitSet( type, 7 );\n\n\t\t\t//console.log(\"type\", type, \"bits\", isQuad, hasMaterial, hasFaceUv, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);\n\n\t\t\tif ( isQuad ) {\n\n\t\t\t\tface = new THREE.Face4();\n\n\t\t\t\tface.a = faces[ offset ++ ];\n\t\t\t\tface.b = faces[ offset ++ ];\n\t\t\t\tface.c = faces[ offset ++ ];\n\t\t\t\tface.d = faces[ offset ++ ];\n\n\t\t\t\tnVertices = 4;\n\n\t\t\t} else {\n\n\t\t\t\tface = new THREE.Face3();\n\n\t\t\t\tface.a = faces[ offset ++ ];\n\t\t\t\tface.b = faces[ offset ++ ];\n\t\t\t\tface.c = faces[ offset ++ ];\n\n\t\t\t\tnVertices = 3;\n\n\t\t\t}\n\n\t\t\tif ( hasMaterial ) {\n\n\t\t\t\tmaterialIndex = faces[ offset ++ ];\n\t\t\t\tface.materialIndex = materialIndex;\n\n\t\t\t}\n\n\t\t\t// to get face <=> uv index correspondence\n\n\t\t\tfi = geometry.faces.length;\n\n\t\t\tif ( hasFaceUv ) {\n\n\t\t\t\tfor ( i = 0; i < nUvLayers; i++ ) {\n\n\t\t\t\t\tuvLayer = json.uvs[ i ];\n\n\t\t\t\t\tuvIndex = faces[ offset ++ ];\n\n\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\n\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\n\n\t\t\t\t\tgeometry.faceUvs[ i ][ fi ] = new THREE.Vector2( u, v );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexUv ) {\n\n\t\t\t\tfor ( i = 0; i < nUvLayers; i++ ) {\n\n\t\t\t\t\tuvLayer = json.uvs[ i ];\n\n\t\t\t\t\tuvs = [];\n\n\t\t\t\t\tfor ( j = 0; j < nVertices; j ++ ) {\n\n\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\n\n\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\n\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\n\n\t\t\t\t\t\tuvs[ j ] = new THREE.Vector2( u, v );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = uvs;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( hasFaceNormal ) {\n\n\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\tnormal = new THREE.Vector3();\n\n\t\t\t\tnormal.x = normals[ normalIndex ++ ];\n\t\t\t\tnormal.y = normals[ normalIndex ++ ];\n\t\t\t\tnormal.z = normals[ normalIndex ];\n\n\t\t\t\tface.normal = normal;\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexNormal ) {\n\n\t\t\t\tfor ( i = 0; i < nVertices; i++ ) {\n\n\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\tnormal = new THREE.Vector3();\n\n\t\t\t\t\tnormal.x = normals[ normalIndex ++ ];\n\t\t\t\t\tnormal.y = normals[ normalIndex ++ ];\n\t\t\t\t\tnormal.z = normals[ normalIndex ];\n\n\t\t\t\t\tface.vertexNormals.push( normal );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tif ( hasFaceColor ) {\n\n\t\t\t\tcolorIndex = faces[ offset ++ ];\n\n\t\t\t\tcolor = new THREE.Color( colors[ colorIndex ] );\n\t\t\t\tface.color = color;\n\n\t\t\t}\n\n\n\t\t\tif ( hasFaceVertexColor ) {\n\n\t\t\t\tfor ( i = 0; i < nVertices; i++ ) {\n\n\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\n\t\t\t\t\tcolor = new THREE.Color( colors[ colorIndex ] );\n\t\t\t\t\tface.vertexColors.push( color );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tgeometry.faces.push( face );\n\n\t\t}\n\n\t};\n\n\tfunction parseSkin() {\n\n\t\tvar i, l, x, y, z, w, a, b, c, d;\n\n\t\tif ( json.skinWeights ) {\n\n\t\t\tfor ( i = 0, l = json.skinWeights.length; i < l; i += 2 ) {\n\n\t\t\t\tx = json.skinWeights[ i     ];\n\t\t\t\ty = json.skinWeights[ i + 1 ];\n\t\t\t\tz = 0;\n\t\t\t\tw = 0;\n\n\t\t\t\tgeometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( json.skinIndices ) {\n\n\t\t\tfor ( i = 0, l = json.skinIndices.length; i < l; i += 2 ) {\n\n\t\t\t\ta = json.skinIndices[ i     ];\n\t\t\t\tb = json.skinIndices[ i + 1 ];\n\t\t\t\tc = 0;\n\t\t\t\td = 0;\n\n\t\t\t\tgeometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometry.bones = json.bones;\n\t\tgeometry.animation = json.animation;\n\n\t};\n\n\tfunction parseMorphing( scale ) {\n\n\t\tif ( json.morphTargets !== undefined ) {\n\n\t\t\tvar i, l, v, vl, dstVertices, srcVertices;\n\n\t\t\tfor ( i = 0, l = json.morphTargets.length; i < l; i ++ ) {\n\n\t\t\t\tgeometry.morphTargets[ i ] = {};\n\t\t\t\tgeometry.morphTargets[ i ].name = json.morphTargets[ i ].name;\n\t\t\t\tgeometry.morphTargets[ i ].vertices = [];\n\n\t\t\t\tdstVertices = geometry.morphTargets[ i ].vertices;\n\t\t\t\tsrcVertices = json.morphTargets [ i ].vertices;\n\n\t\t\t\tfor( v = 0, vl = srcVertices.length; v < vl; v += 3 ) {\n\n\t\t\t\t\tvar vertex = new THREE.Vector3();\n\t\t\t\t\tvertex.x = srcVertices[ v ] * scale;\n\t\t\t\t\tvertex.y = srcVertices[ v + 1 ] * scale;\n\t\t\t\t\tvertex.z = srcVertices[ v + 2 ] * scale;\n\n\t\t\t\t\tdstVertices.push( vertex );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( json.morphColors !== undefined ) {\n\n\t\t\tvar i, l, c, cl, dstColors, srcColors, color;\n\n\t\t\tfor ( i = 0, l = json.morphColors.length; i < l; i++ ) {\n\n\t\t\t\tgeometry.morphColors[ i ] = {};\n\t\t\t\tgeometry.morphColors[ i ].name = json.morphColors[ i ].name;\n\t\t\t\tgeometry.morphColors[ i ].colors = [];\n\n\t\t\t\tdstColors = geometry.morphColors[ i ].colors;\n\t\t\t\tsrcColors = json.morphColors [ i ].colors;\n\n\t\t\t\tfor ( c = 0, cl = srcColors.length; c < cl; c += 3 ) {\n\n\t\t\t\t\tcolor = new THREE.Color( 0xffaa00 );\n\t\t\t\t\tcolor.setRGB( srcColors[ c ], srcColors[ c + 1 ], srcColors[ c + 2 ] );\n\t\t\t\t\tdstColors.push( color );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tvar materials = this.initMaterials( json.materials, texturePath );\n\n\tif ( this.needsTangents( materials ) ) geometry.computeTangents();\n\n\tcallback( geometry, materials );\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.LoadingMonitor = function () {\n\n\tTHREE.EventDispatcher.call( this );\n\n\tvar scope = this;\n\n\tvar loaded = 0;\n\tvar total = 0;\n\n\tvar onLoad = function ( event ) {\n\n\t\tloaded ++;\n\n\t\tscope.dispatchEvent( { type: 'progress', loaded: loaded, total: total } );\n\n\t\tif ( loaded === total ) {\n\n\t\t\tscope.dispatchEvent( { type: 'load' } );\n\n\t\t}\n\n\t};\n\n\tthis.add = function ( loader ) {\n\n\t\ttotal ++;\n\n\t\tloader.addEventListener( 'load', onLoad, false );\n\n\t};\n\n};\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.SceneLoader = function () {\n\n\tthis.onLoadStart = function () {};\n\tthis.onLoadProgress = function() {};\n\tthis.onLoadComplete = function () {};\n\n\tthis.callbackSync = function () {};\n\tthis.callbackProgress = function () {};\n\n\tthis.geometryHandlerMap = {};\n\tthis.hierarchyHandlerMap = {};\n\n\tthis.addGeometryHandler( \"ascii\", THREE.JSONLoader );\n\n};\n\nTHREE.SceneLoader.prototype.constructor = THREE.SceneLoader;\n\nTHREE.SceneLoader.prototype.load = function ( url, callbackFinished ) {\n\n\tvar scope = this;\n\n\tvar xhr = new XMLHttpRequest();\n\n\txhr.onreadystatechange = function () {\n\n\t\tif ( xhr.readyState === 4 ) {\n\n\t\t\tif ( xhr.status === 200 || xhr.status === 0 ) {\n\n\t\t\t\tvar json = JSON.parse( xhr.responseText );\n\t\t\t\tscope.parse( json, callbackFinished, url );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( \"THREE.SceneLoader: Couldn't load [\" + url + \"] [\" + xhr.status + \"]\" );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\txhr.open( \"GET\", url, true );\n\txhr.send( null );\n\n};\n\nTHREE.SceneLoader.prototype.addGeometryHandler = function ( typeID, loaderClass ) {\n\n\tthis.geometryHandlerMap[ typeID ] = { \"loaderClass\": loaderClass };\n\n};\n\nTHREE.SceneLoader.prototype.addHierarchyHandler = function ( typeID, loaderClass ) {\n\n\tthis.hierarchyHandlerMap[ typeID ] = { \"loaderClass\": loaderClass };\n\n};\n\nTHREE.SceneLoader.prototype.parse = function ( json, callbackFinished, url ) {\n\n\tvar scope = this;\n\n\tvar urlBase = THREE.Loader.prototype.extractUrlBase( url );\n\n\tvar geometry, material, camera, fog,\n\t\ttexture, images, color,\n\t\tlight, hex, intensity,\n\t\tcounter_models, counter_textures,\n\t\ttotal_models, total_textures,\n\t\tresult;\n\n\tvar target_array = [];\n\n\tvar data = json;\n\n\t// async geometry loaders\n\n\tfor ( var typeID in this.geometryHandlerMap ) {\n\n\t\tvar loaderClass = this.geometryHandlerMap[ typeID ][ \"loaderClass\" ];\n\t\tthis.geometryHandlerMap[ typeID ][ \"loaderObject\" ] = new loaderClass();\n\n\t}\n\n\t// async hierachy loaders\n\n\tfor ( var typeID in this.hierarchyHandlerMap ) {\n\n\t\tvar loaderClass = this.hierarchyHandlerMap[ typeID ][ \"loaderClass\" ];\n\t\tthis.hierarchyHandlerMap[ typeID ][ \"loaderObject\" ] = new loaderClass();\n\n\t}\n\n\tcounter_models = 0;\n\tcounter_textures = 0;\n\n\tresult = {\n\n\t\tscene: new THREE.Scene(),\n\t\tgeometries: {},\n\t\tface_materials: {},\n\t\tmaterials: {},\n\t\ttextures: {},\n\t\tobjects: {},\n\t\tcameras: {},\n\t\tlights: {},\n\t\tfogs: {},\n\t\tempties: {},\n\t\tgroups: {}\n\n\t};\n\n\tif ( data.transform ) {\n\n\t\tvar position = data.transform.position,\n\t\t\trotation = data.transform.rotation,\n\t\t\tscale = data.transform.scale;\n\n\t\tif ( position )\n\t\t\tresult.scene.position.set( position[ 0 ], position[ 1 ], position [ 2 ] );\n\n\t\tif ( rotation )\n\t\t\tresult.scene.rotation.set( rotation[ 0 ], rotation[ 1 ], rotation [ 2 ] );\n\n\t\tif ( scale )\n\t\t\tresult.scene.scale.set( scale[ 0 ], scale[ 1 ], scale [ 2 ] );\n\n\t\tif ( position || rotation || scale ) {\n\n\t\t\tresult.scene.updateMatrix();\n\t\t\tresult.scene.updateMatrixWorld();\n\n\t\t}\n\n\t}\n\n\tfunction get_url( source_url, url_type ) {\n\n\t\tif ( url_type == \"relativeToHTML\" ) {\n\n\t\t\treturn source_url;\n\n\t\t} else {\n\n\t\t\treturn urlBase + \"/\" + source_url;\n\n\t\t}\n\n\t};\n\n\t// toplevel loader function, delegates to handle_children\n\n\tfunction handle_objects() {\n\n\t\thandle_children( result.scene, data.objects );\n\n\t}\n\n\t// handle all the children from the loaded json and attach them to given parent\n\n\tfunction handle_children( parent, children ) {\n\n\t\tvar mat, dst, pos, rot, scl, quat;\n\n\t\tfor ( var objID in children ) {\n\n\t\t\t// check by id if child has already been handled,\n\t\t\t// if not, create new object\n\n\t\t\tif ( result.objects[ objID ] === undefined ) {\n\n\t\t\t\tvar objJSON = children[ objID ];\n\n\t\t\t\tvar object = null;\n\n\t\t\t\t// meshes\n\n\t\t\t\tif ( objJSON.type && ( objJSON.type in scope.hierarchyHandlerMap ) ) {\n\n\t\t\t\t\tif ( objJSON.loading === undefined ) {\n\n\t\t\t\t\t\tvar reservedTypes = { \"type\": 1, \"url\": 1, \"material\": 1,\n\t\t\t\t\t\t\t\t\t\t\t  \"position\": 1, \"rotation\": 1, \"scale\" : 1,\n\t\t\t\t\t\t\t\t\t\t\t  \"visible\": 1, \"children\": 1, \"properties\": 1,\n\t\t\t\t\t\t\t\t\t\t\t  \"skin\": 1, \"morph\": 1, \"mirroredLoop\": 1, \"duration\": 1 };\n\n\t\t\t\t\t\tvar loaderParameters = {};\n\n\t\t\t\t\t\tfor ( var parType in objJSON ) {\n\n\t\t\t\t\t\t\tif ( ! ( parType in reservedTypes ) ) {\n\n\t\t\t\t\t\t\t\tloaderParameters[ parType ] = objJSON[ parType ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmaterial = result.materials[ objJSON.material ];\n\n\t\t\t\t\t\tobjJSON.loading = true;\n\n\t\t\t\t\t\tvar loader = scope.hierarchyHandlerMap[ objJSON.type ][ \"loaderObject\" ];\n\n\t\t\t\t\t\t// ColladaLoader\n\n\t\t\t\t\t\tif ( loader.options ) {\n\n\t\t\t\t\t\t\tloader.load( get_url( objJSON.url, data.urlBaseType ), create_callback_hierachy( objID, parent, material, objJSON ) );\n\n\t\t\t\t\t\t// UTF8Loader\n\t\t\t\t\t\t// OBJLoader\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tloader.load( get_url( objJSON.url, data.urlBaseType ), create_callback_hierachy( objID, parent, material, objJSON ), loaderParameters );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( objJSON.geometry !== undefined ) {\n\n\t\t\t\t\tgeometry = result.geometries[ objJSON.geometry ];\n\n\t\t\t\t\t// geometry already loaded\n\n\t\t\t\t\tif ( geometry ) {\n\n\t\t\t\t\t\tvar needsTangents = false;\n\n\t\t\t\t\t\tmaterial = result.materials[ objJSON.material ];\n\t\t\t\t\t\tneedsTangents = material instanceof THREE.ShaderMaterial;\n\n\t\t\t\t\t\tpos = objJSON.position;\n\t\t\t\t\t\trot = objJSON.rotation;\n\t\t\t\t\t\tscl = objJSON.scale;\n\t\t\t\t\t\tmat = objJSON.matrix;\n\t\t\t\t\t\tquat = objJSON.quaternion;\n\n\t\t\t\t\t\t// use materials from the model file\n\t\t\t\t\t\t// if there is no material specified in the object\n\n\t\t\t\t\t\tif ( ! objJSON.material ) {\n\n\t\t\t\t\t\t\tmaterial = new THREE.MeshFaceMaterial( result.face_materials[ objJSON.geometry ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// use materials from the model file\n\t\t\t\t\t\t// if there is just empty face material\n\t\t\t\t\t\t// (must create new material as each model has its own face material)\n\n\t\t\t\t\t\tif ( ( material instanceof THREE.MeshFaceMaterial ) && material.materials.length === 0 ) {\n\n\t\t\t\t\t\t\tmaterial = new THREE.MeshFaceMaterial( result.face_materials[ objJSON.geometry ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( material instanceof THREE.MeshFaceMaterial ) {\n\n\t\t\t\t\t\t\tfor ( var i = 0; i < material.materials.length; i ++ ) {\n\n\t\t\t\t\t\t\t\tneedsTangents = needsTangents || ( material.materials[ i ] instanceof THREE.ShaderMaterial );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( needsTangents ) {\n\n\t\t\t\t\t\t\tgeometry.computeTangents();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( objJSON.skin ) {\n\n\t\t\t\t\t\t\tobject = new THREE.SkinnedMesh( geometry, material );\n\n\t\t\t\t\t\t} else if ( objJSON.morph ) {\n\n\t\t\t\t\t\t\tobject = new THREE.MorphAnimMesh( geometry, material );\n\n\t\t\t\t\t\t\tif ( objJSON.duration !== undefined ) {\n\n\t\t\t\t\t\t\t\tobject.duration = objJSON.duration;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( objJSON.time !== undefined ) {\n\n\t\t\t\t\t\t\t\tobject.time = objJSON.time;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( objJSON.mirroredLoop !== undefined ) {\n\n\t\t\t\t\t\t\t\tobject.mirroredLoop = objJSON.mirroredLoop;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( material.morphNormals ) {\n\n\t\t\t\t\t\t\t\tgeometry.computeMorphNormals();\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tobject = new THREE.Mesh( geometry, material );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tobject.name = objID;\n\n\t\t\t\t\t\tif ( mat ) {\n\n\t\t\t\t\t\t\tobject.matrixAutoUpdate = false;\n\t\t\t\t\t\t\tobject.matrix.set(\n\t\t\t\t\t\t\t\tmat[0],  mat[1],  mat[2],  mat[3],\n\t\t\t\t\t\t\t\tmat[4],  mat[5],  mat[6],  mat[7],\n\t\t\t\t\t\t\t\tmat[8],  mat[9],  mat[10], mat[11],\n\t\t\t\t\t\t\t\tmat[12], mat[13], mat[14], mat[15]\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tobject.position.set( pos[0], pos[1], pos[2] );\n\n\t\t\t\t\t\t\tif ( quat ) {\n\n\t\t\t\t\t\t\t\tobject.quaternion.set( quat[0], quat[1], quat[2], quat[3] );\n\t\t\t\t\t\t\t\tobject.useQuaternion = true;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tobject.rotation.set( rot[0], rot[1], rot[2] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tobject.scale.set( scl[0], scl[1], scl[2] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tobject.visible = objJSON.visible;\n\t\t\t\t\t\tobject.castShadow = objJSON.castShadow;\n\t\t\t\t\t\tobject.receiveShadow = objJSON.receiveShadow;\n\n\t\t\t\t\t\tparent.add( object );\n\n\t\t\t\t\t\tresult.objects[ objID ] = object;\n\n\t\t\t\t\t}\n\n\t\t\t\t// lights\n\n\t\t\t\t} else if ( objJSON.type === \"DirectionalLight\" || objJSON.type === \"PointLight\" || objJSON.type === \"AmbientLight\" ) {\n\n\t\t\t\t\thex = ( objJSON.color !== undefined ) ? objJSON.color : 0xffffff;\n\t\t\t\t\tintensity = ( objJSON.intensity !== undefined ) ? objJSON.intensity : 1;\n\n\t\t\t\t\tif ( objJSON.type === \"DirectionalLight\" ) {\n\n\t\t\t\t\t\tpos = objJSON.direction;\n\n\t\t\t\t\t\tlight = new THREE.DirectionalLight( hex, intensity );\n\t\t\t\t\t\tlight.position.set( pos[0], pos[1], pos[2] );\n\n\t\t\t\t\t\tif ( objJSON.target ) {\n\n\t\t\t\t\t\t\ttarget_array.push( { \"object\": light, \"targetName\" : objJSON.target } );\n\n\t\t\t\t\t\t\t// kill existing default target\n\t\t\t\t\t\t\t// otherwise it gets added to scene when parent gets added\n\n\t\t\t\t\t\t\tlight.target = null;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( objJSON.type === \"PointLight\" ) {\n\n\t\t\t\t\t\tpos = objJSON.position;\n\t\t\t\t\t\tdst = objJSON.distance;\n\n\t\t\t\t\t\tlight = new THREE.PointLight( hex, intensity, dst );\n\t\t\t\t\t\tlight.position.set( pos[0], pos[1], pos[2] );\n\n\t\t\t\t\t} else if ( objJSON.type === \"AmbientLight\" ) {\n\n\t\t\t\t\t\tlight = new THREE.AmbientLight( hex );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tparent.add( light );\n\n\t\t\t\t\tlight.name = objID;\n\t\t\t\t\tresult.lights[ objID ] = light;\n\t\t\t\t\tresult.objects[ objID ] = light;\n\n\t\t\t\t// cameras\n\n\t\t\t\t} else if ( objJSON.type === \"PerspectiveCamera\" || objJSON.type === \"OrthographicCamera\" ) {\n\n\t\t\t\t\tif ( objJSON.type === \"PerspectiveCamera\" ) {\n\n\t\t\t\t\t\tcamera = new THREE.PerspectiveCamera( objJSON.fov, objJSON.aspect, objJSON.near, objJSON.far );\n\n\t\t\t\t\t} else if ( objJSON.type === \"OrthographicCamera\" ) {\n\n\t\t\t\t\t\tcamera = new THREE.OrthographicCamera( objJSON.left, objJSON.right, objJSON.top, objJSON.bottom, objJSON.near, objJSON.far );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tpos = objJSON.position;\n\t\t\t\t\tcamera.position.set( pos[0], pos[1], pos[2] );\n\t\t\t\t\tparent.add( camera );\n\n\t\t\t\t\tcamera.name = objID;\n\t\t\t\t\tresult.cameras[ objID ] = camera;\n\t\t\t\t\tresult.objects[ objID ] = camera;\n\n\t\t\t\t// pure Object3D\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpos = objJSON.position;\n\t\t\t\t\trot = objJSON.rotation;\n\t\t\t\t\tscl = objJSON.scale;\n\t\t\t\t\tquat = objJSON.quaternion;\n\n\t\t\t\t\tobject = new THREE.Object3D();\n\t\t\t\t\tobject.name = objID;\n\t\t\t\t\tobject.position.set( pos[0], pos[1], pos[2] );\n\n\t\t\t\t\tif ( quat ) {\n\n\t\t\t\t\t\tobject.quaternion.set( quat[0], quat[1], quat[2], quat[3] );\n\t\t\t\t\t\tobject.useQuaternion = true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tobject.rotation.set( rot[0], rot[1], rot[2] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tobject.scale.set( scl[0], scl[1], scl[2] );\n\t\t\t\t\tobject.visible = ( objJSON.visible !== undefined ) ? objJSON.visible : false;\n\n\t\t\t\t\tparent.add( object );\n\n\t\t\t\t\tresult.objects[ objID ] = object;\n\t\t\t\t\tresult.empties[ objID ] = object;\n\n\t\t\t\t}\n\n\t\t\t\tif ( object ) {\n\n\t\t\t\t\tif ( objJSON.properties !== undefined )  {\n\n\t\t\t\t\t\tfor ( var key in objJSON.properties ) {\n\n\t\t\t\t\t\t\tvar value = objJSON.properties[ key ];\n\t\t\t\t\t\t\tobject.properties[ key ] = value;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( objJSON.groups !== undefined ) {\n\n\t\t\t\t\t\tfor ( var i = 0; i < objJSON.groups.length; i ++ ) {\n\n\t\t\t\t\t\t\tvar groupID = objJSON.groups[ i ];\n\n\t\t\t\t\t\t\tif ( result.groups[ groupID ] === undefined ) {\n\n\t\t\t\t\t\t\t\tresult.groups[ groupID ] = [];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tresult.groups[ groupID ].push( objID );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( objJSON.children !== undefined ) {\n\n\t\t\t\t\t\thandle_children( object, objJSON.children );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tfunction handle_mesh( geo, mat, id ) {\n\n\t\tresult.geometries[ id ] = geo;\n\t\tresult.face_materials[ id ] = mat;\n\t\thandle_objects();\n\n\t};\n\n\tfunction handle_hierarchy( node, id, parent, material, obj ) {\n\n\t\tvar p = obj.position;\n\t\tvar r = obj.rotation;\n\t\tvar q = obj.quaternion;\n\t\tvar s = obj.scale;\n\n\t\tnode.position.set( p[0], p[1], p[2] );\n\n\t\tif ( q ) {\n\n\t\t\tnode.quaternion.set( q[0], q[1], q[2], q[3] );\n\t\t\tnode.useQuaternion = true;\n\n\t\t} else {\n\n\t\t\tnode.rotation.set( r[0], r[1], r[2] );\n\n\t\t}\n\n\t\tnode.scale.set( s[0], s[1], s[2] );\n\n\t\t// override children materials\n\t\t// if object material was specified in JSON explicitly\n\n\t\tif ( material ) {\n\n\t\t\tnode.traverse( function ( child )  {\n\n\t\t\t\tchild.material = material;\n\n\t\t\t} );\n\n\t\t}\n\n\t\t// override children visibility\n\t\t// with root node visibility as specified in JSON\n\n\t\tvar visible = ( obj.visible !== undefined ) ? obj.visible : true;\n\n\t\tnode.traverse( function ( child )  {\n\n\t\t\tchild.visible = visible;\n\n\t\t} );\n\n\t\tparent.add( node );\n\n\t\tnode.name = id;\n\n\t\tresult.objects[ id ] = node;\n\t\thandle_objects();\n\n\t};\n\n\tfunction create_callback_geometry( id ) {\n\n\t\treturn function( geo, mat ) {\n\n\t\t\thandle_mesh( geo, mat, id );\n\n\t\t\tcounter_models -= 1;\n\n\t\t\tscope.onLoadComplete();\n\n\t\t\tasync_callback_gate();\n\n\t\t}\n\n\t};\n\n\tfunction create_callback_hierachy( id, parent, material, obj ) {\n\n\t\treturn function( event ) {\n\n\t\t\tvar result;\n\n\t\t\t// loaders which use EventDispatcher\n\n\t\t\tif ( event.content ) {\n\n\t\t\t\tresult = event.content;\n\n\t\t\t// ColladaLoader\n\n\t\t\t} else if ( event.dae ) {\n\n\t\t\t\tresult = event.scene;\n\n\n\t\t\t// UTF8Loader\n\n\t\t\t} else {\n\n\t\t\t\tresult = event;\n\n\t\t\t}\n\n\t\t\thandle_hierarchy( result, id, parent, material, obj );\n\n\t\t\tcounter_models -= 1;\n\n\t\t\tscope.onLoadComplete();\n\n\t\t\tasync_callback_gate();\n\n\t\t}\n\n\t};\n\n\tfunction create_callback_embed( id ) {\n\n\t\treturn function( geo, mat ) {\n\n\t\t\tresult.geometries[ id ] = geo;\n\t\t\tresult.face_materials[ id ] = mat;\n\n\t\t}\n\n\t};\n\n\tfunction async_callback_gate() {\n\n\t\tvar progress = {\n\n\t\t\ttotalModels : total_models,\n\t\t\ttotalTextures : total_textures,\n\t\t\tloadedModels : total_models - counter_models,\n\t\t\tloadedTextures : total_textures - counter_textures\n\n\t\t};\n\n\t\tscope.callbackProgress( progress, result );\n\n\t\tscope.onLoadProgress();\n\n\t\tif ( counter_models === 0 && counter_textures === 0 ) {\n\n\t\t\tfinalize();\n\t\t\tcallbackFinished( result );\n\n\t\t}\n\n\t};\n\n\tfunction finalize() {\n\n\t\t// take care of targets which could be asynchronously loaded objects\n\n\t\tfor ( var i = 0; i < target_array.length; i ++ ) {\n\n\t\t\tvar ta = target_array[ i ];\n\n\t\t\tvar target = result.objects[ ta.targetName ];\n\n\t\t\tif ( target ) {\n\n\t\t\t\tta.object.target = target;\n\n\t\t\t} else {\n\n\t\t\t\t// if there was error and target of specified name doesn't exist in the scene file\n\t\t\t\t// create instead dummy target\n\t\t\t\t// (target must be added to scene explicitly as parent is already added)\n\n\t\t\t\tta.object.target = new THREE.Object3D();\n\t\t\t\tresult.scene.add( ta.object.target );\n\n\t\t\t}\n\n\t\t\tta.object.target.properties.targetInverse = ta.object;\n\n\t\t}\n\n\t};\n\n\tvar callbackTexture = function ( count ) {\n\n\t\tcounter_textures -= count;\n\t\tasync_callback_gate();\n\n\t\tscope.onLoadComplete();\n\n\t};\n\n\t// must use this instead of just directly calling callbackTexture\n\t// because of closure in the calling context loop\n\n\tvar generateTextureCallback = function ( count ) {\n\n\t\treturn function() {\n\n\t\t\tcallbackTexture( count );\n\n\t\t};\n\n\t};\n\n\t// first go synchronous elements\n\n\t// fogs\n\n\tvar fogID, fogJSON;\n\n\tfor ( fogID in data.fogs ) {\n\n\t\tfogJSON = data.fogs[ fogID ];\n\n\t\tif ( fogJSON.type === \"linear\" ) {\n\n\t\t\tfog = new THREE.Fog( 0x000000, fogJSON.near, fogJSON.far );\n\n\t\t} else if ( fogJSON.type === \"exp2\" ) {\n\n\t\t\tfog = new THREE.FogExp2( 0x000000, fogJSON.density );\n\n\t\t}\n\n\t\tcolor = fogJSON.color;\n\t\tfog.color.setRGB( color[0], color[1], color[2] );\n\n\t\tresult.fogs[ fogID ] = fog;\n\n\t}\n\n\t// now come potentially asynchronous elements\n\n\t// geometries\n\n\t// count how many geometries will be loaded asynchronously\n\n\tvar geoID, geoJSON;\n\n\tfor ( geoID in data.geometries ) {\n\n\t\tgeoJSON = data.geometries[ geoID ];\n\n\t\tif ( geoJSON.type in this.geometryHandlerMap ) {\n\n\t\t\tcounter_models += 1;\n\n\t\t\tscope.onLoadStart();\n\n\t\t}\n\n\t}\n\n\t// count how many hierarchies will be loaded asynchronously\n\n\tvar objID, objJSON;\n\n\tfor ( objID in data.objects ) {\n\n\t\tobjJSON = data.objects[ objID ];\n\n\t\tif ( objJSON.type && ( objJSON.type in this.hierarchyHandlerMap ) ) {\n\n\t\t\tcounter_models += 1;\n\n\t\t\tscope.onLoadStart();\n\n\t\t}\n\n\t}\n\n\ttotal_models = counter_models;\n\n\tfor ( geoID in data.geometries ) {\n\n\t\tgeoJSON = data.geometries[ geoID ];\n\n\t\tif ( geoJSON.type === \"cube\" ) {\n\n\t\t\tgeometry = new THREE.CubeGeometry( geoJSON.width, geoJSON.height, geoJSON.depth, geoJSON.widthSegments, geoJSON.heightSegments, geoJSON.depthSegments );\n\t\t\tresult.geometries[ geoID ] = geometry;\n\n\t\t} else if ( geoJSON.type === \"plane\" ) {\n\n\t\t\tgeometry = new THREE.PlaneGeometry( geoJSON.width, geoJSON.height, geoJSON.widthSegments, geoJSON.heightSegments );\n\t\t\tresult.geometries[ geoID ] = geometry;\n\n\t\t} else if ( geoJSON.type === \"sphere\" ) {\n\n\t\t\tgeometry = new THREE.SphereGeometry( geoJSON.radius, geoJSON.widthSegments, geoJSON.heightSegments );\n\t\t\tresult.geometries[ geoID ] = geometry;\n\n\t\t} else if ( geoJSON.type === \"cylinder\" ) {\n\n\t\t\tgeometry = new THREE.CylinderGeometry( geoJSON.topRad, geoJSON.botRad, geoJSON.height, geoJSON.radSegs, geoJSON.heightSegs );\n\t\t\tresult.geometries[ geoID ] = geometry;\n\n\t\t} else if ( geoJSON.type === \"torus\" ) {\n\n\t\t\tgeometry = new THREE.TorusGeometry( geoJSON.radius, geoJSON.tube, geoJSON.segmentsR, geoJSON.segmentsT );\n\t\t\tresult.geometries[ geoID ] = geometry;\n\n\t\t} else if ( geoJSON.type === \"icosahedron\" ) {\n\n\t\t\tgeometry = new THREE.IcosahedronGeometry( geoJSON.radius, geoJSON.subdivisions );\n\t\t\tresult.geometries[ geoID ] = geometry;\n\n\t\t} else if ( geoJSON.type in this.geometryHandlerMap ) {\n\n\t\t\tvar loaderParameters = {};\n\n\t\t\tfor ( var parType in geoJSON ) {\n\n\t\t\t\tif ( parType !== \"type\" && parType !== \"url\" ) {\n\n\t\t\t\t\tloaderParameters[ parType ] = geoJSON[ parType ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar loader = this.geometryHandlerMap[ geoJSON.type ][ \"loaderObject\" ];\n\t\t\tloader.load( get_url( geoJSON.url, data.urlBaseType ), create_callback_geometry( geoID ), loaderParameters );\n\n\t\t} else if ( geoJSON.type === \"embedded\" ) {\n\n\t\t\tvar modelJson = data.embeds[ geoJSON.id ],\n\t\t\t\ttexture_path = \"\";\n\n\t\t\t// pass metadata along to jsonLoader so it knows the format version\n\n\t\t\tmodelJson.metadata = data.metadata;\n\n\t\t\tif ( modelJson ) {\n\n\t\t\t\tvar jsonLoader = this.geometryHandlerMap[ \"ascii\" ][ \"loaderObject\" ];\n\t\t\t\tjsonLoader.createModel( modelJson, create_callback_embed( geoID ), texture_path );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// textures\n\n\t// count how many textures will be loaded asynchronously\n\n\tvar textureID, textureJSON;\n\n\tfor ( textureID in data.textures ) {\n\n\t\ttextureJSON = data.textures[ textureID ];\n\n\t\tif ( textureJSON.url instanceof Array ) {\n\n\t\t\tcounter_textures += textureJSON.url.length;\n\n\t\t\tfor( var n = 0; n < textureJSON.url.length; n ++ ) {\n\n\t\t\t\tscope.onLoadStart();\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tcounter_textures += 1;\n\n\t\t\tscope.onLoadStart();\n\n\t\t}\n\n\t}\n\n\ttotal_textures = counter_textures;\n\n\tfor ( textureID in data.textures ) {\n\n\t\ttextureJSON = data.textures[ textureID ];\n\n\t\tif ( textureJSON.mapping !== undefined && THREE[ textureJSON.mapping ] !== undefined  ) {\n\n\t\t\ttextureJSON.mapping = new THREE[ textureJSON.mapping ]();\n\n\t\t}\n\n\t\tif ( textureJSON.url instanceof Array ) {\n\n\t\t\tvar count = textureJSON.url.length;\n\t\t\tvar url_array = [];\n\n\t\t\tfor( var i = 0; i < count; i ++ ) {\n\n\t\t\t\turl_array[ i ] = get_url( textureJSON.url[ i ], data.urlBaseType );\n\n\t\t\t}\n\n\t\t\tvar isCompressed = /\\.dds$/i.test( url_array[ 0 ] );\n\n\t\t\tif ( isCompressed ) {\n\n\t\t\t\ttexture = THREE.ImageUtils.loadCompressedTextureCube( url_array, textureJSON.mapping, generateTextureCallback( count ) );\n\n\t\t\t} else {\n\n\t\t\t\ttexture = THREE.ImageUtils.loadTextureCube( url_array, textureJSON.mapping, generateTextureCallback( count ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tvar isCompressed = /\\.dds$/i.test( textureJSON.url );\n\t\t\tvar fullUrl = get_url( textureJSON.url, data.urlBaseType );\n\t\t\tvar textureCallback = generateTextureCallback( 1 );\n\n\t\t\tif ( isCompressed ) {\n\n\t\t\t\ttexture = THREE.ImageUtils.loadCompressedTexture( fullUrl, textureJSON.mapping, textureCallback );\n\n\t\t\t} else {\n\n\t\t\t\ttexture = THREE.ImageUtils.loadTexture( fullUrl, textureJSON.mapping, textureCallback );\n\n\t\t\t}\n\n\t\t\tif ( THREE[ textureJSON.minFilter ] !== undefined )\n\t\t\t\ttexture.minFilter = THREE[ textureJSON.minFilter ];\n\n\t\t\tif ( THREE[ textureJSON.magFilter ] !== undefined )\n\t\t\t\ttexture.magFilter = THREE[ textureJSON.magFilter ];\n\n\t\t\tif ( textureJSON.anisotropy ) texture.anisotropy = textureJSON.anisotropy;\n\n\t\t\tif ( textureJSON.repeat ) {\n\n\t\t\t\ttexture.repeat.set( textureJSON.repeat[ 0 ], textureJSON.repeat[ 1 ] );\n\n\t\t\t\tif ( textureJSON.repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;\n\t\t\t\tif ( textureJSON.repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;\n\n\t\t\t}\n\n\t\t\tif ( textureJSON.offset ) {\n\n\t\t\t\ttexture.offset.set( textureJSON.offset[ 0 ], textureJSON.offset[ 1 ] );\n\n\t\t\t}\n\n\t\t\t// handle wrap after repeat so that default repeat can be overriden\n\n\t\t\tif ( textureJSON.wrap ) {\n\n\t\t\t\tvar wrapMap = {\n\t\t\t\t\"repeat\" \t: THREE.RepeatWrapping,\n\t\t\t\t\"mirror\"\t: THREE.MirroredRepeatWrapping\n\t\t\t\t}\n\n\t\t\t\tif ( wrapMap[ textureJSON.wrap[ 0 ] ] !== undefined ) texture.wrapS = wrapMap[ textureJSON.wrap[ 0 ] ];\n\t\t\t\tif ( wrapMap[ textureJSON.wrap[ 1 ] ] !== undefined ) texture.wrapT = wrapMap[ textureJSON.wrap[ 1 ] ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tresult.textures[ textureID ] = texture;\n\n\t}\n\n\t// materials\n\n\tvar matID, matJSON;\n\tvar parID;\n\n\tfor ( matID in data.materials ) {\n\n\t\tmatJSON = data.materials[ matID ];\n\n\t\tfor ( parID in matJSON.parameters ) {\n\n\t\t\tif ( parID === \"envMap\" || parID === \"map\" || parID === \"lightMap\" || parID === \"bumpMap\" ) {\n\n\t\t\t\tmatJSON.parameters[ parID ] = result.textures[ matJSON.parameters[ parID ] ];\n\n\t\t\t} else if ( parID === \"shading\" ) {\n\n\t\t\t\tmatJSON.parameters[ parID ] = ( matJSON.parameters[ parID ] === \"flat\" ) ? THREE.FlatShading : THREE.SmoothShading;\n\n\t\t\t} else if ( parID === \"side\" ) {\n\n\t\t\t\tif ( matJSON.parameters[ parID ] == \"double\" ) {\n\n\t\t\t\t\tmatJSON.parameters[ parID ] = THREE.DoubleSide;\n\n\t\t\t\t} else if ( matJSON.parameters[ parID ] == \"back\" ) {\n\n\t\t\t\t\tmatJSON.parameters[ parID ] = THREE.BackSide;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmatJSON.parameters[ parID ] = THREE.FrontSide;\n\n\t\t\t\t}\n\n\t\t\t} else if ( parID === \"blending\" ) {\n\n\t\t\t\tmatJSON.parameters[ parID ] = matJSON.parameters[ parID ] in THREE ? THREE[ matJSON.parameters[ parID ] ] : THREE.NormalBlending;\n\n\t\t\t} else if ( parID === \"combine\" ) {\n\n\t\t\t\tmatJSON.parameters[ parID ] = matJSON.parameters[ parID ] in THREE ? THREE[ matJSON.parameters[ parID ] ] : THREE.MultiplyOperation;\n\n\t\t\t} else if ( parID === \"vertexColors\" ) {\n\n\t\t\t\tif ( matJSON.parameters[ parID ] == \"face\" ) {\n\n\t\t\t\t\tmatJSON.parameters[ parID ] = THREE.FaceColors;\n\n\t\t\t\t// default to vertex colors if \"vertexColors\" is anything else face colors or 0 / null / false\n\n\t\t\t\t} else if ( matJSON.parameters[ parID ] )   {\n\n\t\t\t\t\tmatJSON.parameters[ parID ] = THREE.VertexColors;\n\n\t\t\t\t}\n\n\t\t\t} else if ( parID === \"wrapRGB\" ) {\n\n\t\t\t\tvar v3 = matJSON.parameters[ parID ];\n\t\t\t\tmatJSON.parameters[ parID ] = new THREE.Vector3( v3[ 0 ], v3[ 1 ], v3[ 2 ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( matJSON.parameters.opacity !== undefined && matJSON.parameters.opacity < 1.0 ) {\n\n\t\t\tmatJSON.parameters.transparent = true;\n\n\t\t}\n\n\t\tif ( matJSON.parameters.normalMap ) {\n\n\t\t\tvar shader = THREE.ShaderLib[ \"normalmap\" ];\n\t\t\tvar uniforms = THREE.UniformsUtils.clone( shader.uniforms );\n\n\t\t\tvar diffuse = matJSON.parameters.color;\n\t\t\tvar specular = matJSON.parameters.specular;\n\t\t\tvar ambient = matJSON.parameters.ambient;\n\t\t\tvar shininess = matJSON.parameters.shininess;\n\n\t\t\tuniforms[ \"tNormal\" ].value = result.textures[ matJSON.parameters.normalMap ];\n\n\t\t\tif ( matJSON.parameters.normalScale ) {\n\n\t\t\t\tuniforms[ \"uNormalScale\" ].value.set( matJSON.parameters.normalScale[ 0 ], matJSON.parameters.normalScale[ 1 ] );\n\n\t\t\t}\n\n\t\t\tif ( matJSON.parameters.map ) {\n\n\t\t\t\tuniforms[ \"tDiffuse\" ].value = matJSON.parameters.map;\n\t\t\t\tuniforms[ \"enableDiffuse\" ].value = true;\n\n\t\t\t}\n\n\t\t\tif ( matJSON.parameters.envMap ) {\n\n\t\t\t\tuniforms[ \"tCube\" ].value = matJSON.parameters.envMap;\n\t\t\t\tuniforms[ \"enableReflection\" ].value = true;\n\t\t\t\tuniforms[ \"uReflectivity\" ].value = matJSON.parameters.reflectivity;\n\n\t\t\t}\n\n\t\t\tif ( matJSON.parameters.lightMap ) {\n\n\t\t\t\tuniforms[ \"tAO\" ].value = matJSON.parameters.lightMap;\n\t\t\t\tuniforms[ \"enableAO\" ].value = true;\n\n\t\t\t}\n\n\t\t\tif ( matJSON.parameters.specularMap ) {\n\n\t\t\t\tuniforms[ \"tSpecular\" ].value = result.textures[ matJSON.parameters.specularMap ];\n\t\t\t\tuniforms[ \"enableSpecular\" ].value = true;\n\n\t\t\t}\n\n\t\t\tif ( matJSON.parameters.displacementMap ) {\n\n\t\t\t\tuniforms[ \"tDisplacement\" ].value = result.textures[ matJSON.parameters.displacementMap ];\n\t\t\t\tuniforms[ \"enableDisplacement\" ].value = true;\n\n\t\t\t\tuniforms[ \"uDisplacementBias\" ].value = matJSON.parameters.displacementBias;\n\t\t\t\tuniforms[ \"uDisplacementScale\" ].value = matJSON.parameters.displacementScale;\n\n\t\t\t}\n\n\t\t\tuniforms[ \"uDiffuseColor\" ].value.setHex( diffuse );\n\t\t\tuniforms[ \"uSpecularColor\" ].value.setHex( specular );\n\t\t\tuniforms[ \"uAmbientColor\" ].value.setHex( ambient );\n\n\t\t\tuniforms[ \"uShininess\" ].value = shininess;\n\n\t\t\tif ( matJSON.parameters.opacity ) {\n\n\t\t\t\tuniforms[ \"uOpacity\" ].value = matJSON.parameters.opacity;\n\n\t\t\t}\n\n\t\t\tvar parameters = { fragmentShader: shader.fragmentShader, vertexShader: shader.vertexShader, uniforms: uniforms, lights: true, fog: true };\n\n\t\t\tmaterial = new THREE.ShaderMaterial( parameters );\n\n\t\t} else {\n\n\t\t\tmaterial = new THREE[ matJSON.type ]( matJSON.parameters );\n\n\t\t}\n\n\t\tresult.materials[ matID ] = material;\n\n\t}\n\n\t// second pass through all materials to initialize MeshFaceMaterials\n\t// that could be referring to other materials out of order\n\n\tfor ( matID in data.materials ) {\n\n\t\tmatJSON = data.materials[ matID ];\n\n\t\tif ( matJSON.parameters.materials ) {\n\n\t\t\tvar materialArray = [];\n\n\t\t\tfor ( var i = 0; i < matJSON.parameters.materials.length; i ++ ) {\n\n\t\t\t\tvar label = matJSON.parameters.materials[ i ];\n\t\t\t\tmaterialArray.push( result.materials[ label ] );\n\n\t\t\t}\n\n\t\t\tresult.materials[ matID ].materials = materialArray;\n\n\t\t}\n\n\t}\n\n\t// objects ( synchronous init of procedural primitives )\n\n\thandle_objects();\n\n\t// defaults\n\n\tif ( result.cameras && data.defaults.camera ) {\n\n\t\tresult.currentCamera = result.cameras[ data.defaults.camera ];\n\n\t}\n\n\tif ( result.fogs && data.defaults.fog ) {\n\n\t\tresult.scene.fog = result.fogs[ data.defaults.fog ];\n\n\t}\n\n\t// synchronous callback\n\n\tscope.callbackSync( result );\n\n\t// just in case there are no async elements\n\n\tasync_callback_gate();\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.TextureLoader = function () {\n\n\tTHREE.EventDispatcher.call( this );\n\n\tthis.crossOrigin = null;\n\n};\n\nTHREE.TextureLoader.prototype = {\n\n\tconstructor: THREE.TextureLoader,\n\n\tload: function ( url ) {\n\n\t\tvar scope = this;\n\n\t\tvar image = new Image();\n\n\t\timage.addEventListener( 'load', function () {\n\n\t\t\tvar texture = new THREE.Texture( image );\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tscope.dispatchEvent( { type: 'load', content: texture } );\n\n\t\t}, false );\n\n\t\timage.addEventListener( 'error', function () {\n\n\t\t\tscope.dispatchEvent( { type: 'error', message: 'Couldn\\'t load URL [' + url + ']' } );\n\n\t\t}, false );\n\n\t\tif ( scope.crossOrigin ) image.crossOrigin = scope.crossOrigin;\n\n\t\timage.src = url;\n\n\t}\n\n}\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Material = function () {\n\n\tTHREE.EventDispatcher.call( this );\n\n\tthis.id = THREE.MaterialIdCount ++;\n\n\tthis.name = '';\n\n\tthis.side = THREE.FrontSide;\n\n\tthis.opacity = 1;\n\tthis.transparent = false;\n\n\tthis.blending = THREE.NormalBlending;\n\n\tthis.blendSrc = THREE.SrcAlphaFactor;\n\tthis.blendDst = THREE.OneMinusSrcAlphaFactor;\n\tthis.blendEquation = THREE.AddEquation;\n\n\tthis.depthTest = true;\n\tthis.depthWrite = true;\n\n\tthis.polygonOffset = false;\n\tthis.polygonOffsetFactor = 0;\n\tthis.polygonOffsetUnits = 0;\n\n\tthis.alphaTest = 0;\n\n\tthis.overdraw = false; // Boolean for fixing antialiasing gaps in CanvasRenderer\n\n\tthis.visible = true;\n\n\tthis.needsUpdate = true;\n\n};\n\nTHREE.Material.prototype.setValues = function ( values ) {\n\n\tif ( values === undefined ) return;\n\n\tfor ( var key in values ) {\n\n\t\tvar newValue = values[ key ];\n\n\t\tif ( newValue === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Material: \\'' + key + '\\' parameter is undefined.' );\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tif ( key in this ) {\n\n\t\t\tvar currentValue = this[ key ];\n\n\t\t\tif ( currentValue instanceof THREE.Color && newValue instanceof THREE.Color ) {\n\n\t\t\t\tcurrentValue.copy( newValue );\n\n\t\t\t} else if ( currentValue instanceof THREE.Color ) {\n\n\t\t\t\tcurrentValue.set( newValue );\n\n\t\t\t} else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {\n\n\t\t\t\tcurrentValue.copy( newValue );\n\n\t\t\t} else {\n\n\t\t\t\tthis[ key ] = newValue;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n};\n\nTHREE.Material.prototype.clone = function ( material ) {\n\n\tif ( material === undefined ) material = new THREE.Material();\n\n\tmaterial.name = this.name;\n\n\tmaterial.side = this.side;\n\n\tmaterial.opacity = this.opacity;\n\tmaterial.transparent = this.transparent;\n\n\tmaterial.blending = this.blending;\n\n\tmaterial.blendSrc = this.blendSrc;\n\tmaterial.blendDst = this.blendDst;\n\tmaterial.blendEquation = this.blendEquation;\n\n\tmaterial.depthTest = this.depthTest;\n\tmaterial.depthWrite = this.depthWrite;\n\n\tmaterial.polygonOffset = this.polygonOffset;\n\tmaterial.polygonOffsetFactor = this.polygonOffsetFactor;\n\tmaterial.polygonOffsetUnits = this.polygonOffsetUnits;\n\n\tmaterial.alphaTest = this.alphaTest;\n\n\tmaterial.overdraw = this.overdraw;\n\n\tmaterial.visible = this.visible;\n\n\treturn material;\n\n};\n\nTHREE.Material.prototype.dispose = function () {\n\n\tthis.dispatchEvent( { type: 'dispose' } );\n\n};\n\nTHREE.MaterialIdCount = 0;\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *\n *  blending: THREE.NormalBlending,\n *  depthTest: <bool>,\n *  depthWrite: <bool>,\n *\n *  linewidth: <float>,\n *  linecap: \"round\",\n *  linejoin: \"round\",\n *\n *  vertexColors: <bool>\n *\n *  fog: <bool>\n * }\n */\n\nTHREE.LineBasicMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.color = new THREE.Color( 0xffffff );\n\n\tthis.linewidth = 1;\n\tthis.linecap = 'round';\n\tthis.linejoin = 'round';\n\n\tthis.vertexColors = false;\n\n\tthis.fog = true;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );\n\nTHREE.LineBasicMaterial.prototype.clone = function () {\n\n\tvar material = new THREE.LineBasicMaterial();\n\n\tTHREE.Material.prototype.clone.call( this, material );\n\n\tmaterial.color.copy( this.color );\n\n\tmaterial.linewidth = this.linewidth;\n\tmaterial.linecap = this.linecap;\n\tmaterial.linejoin = this.linejoin;\n\n\tmaterial.vertexColors = this.vertexColors;\n\n\tmaterial.fog = this.fog;\n\n\treturn material;\n\n};\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *\n *  blending: THREE.NormalBlending,\n *  depthTest: <bool>,\n *  depthWrite: <bool>,\n *\n *  linewidth: <float>,\n *\n *  scale: <float>,\n *  dashSize: <float>,\n *  gapSize: <float>,\n *\n *  vertexColors: <bool>\n *\n *  fog: <bool>\n * }\n */\n\nTHREE.LineDashedMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.color = new THREE.Color( 0xffffff );\n\n\tthis.linewidth = 1;\n\n\tthis.scale = 1;\n\tthis.dashSize = 3;\n\tthis.gapSize = 1;\n\n\tthis.vertexColors = false;\n\n\tthis.fog = true;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );\n\nTHREE.LineDashedMaterial.prototype.clone = function () {\n\n\tvar material = new THREE.LineDashedMaterial();\n\n\tTHREE.Material.prototype.clone.call( this, material );\n\n\tmaterial.color.copy( this.color );\n\n\tmaterial.linewidth = this.linewidth;\n\n\tmaterial.scale = this.scale;\n\tmaterial.dashSize = this.dashSize;\n\tmaterial.gapSize = this.gapSize;\n\n\tmaterial.vertexColors = this.vertexColors;\n\n\tmaterial.fog = this.fog;\n\n\treturn material;\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *\n *  specularMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n *  combine: THREE.Multiply,\n *  reflectivity: <float>,\n *  refractionRatio: <float>,\n *\n *  shading: THREE.SmoothShading,\n *  blending: THREE.NormalBlending,\n *  depthTest: <bool>,\n *  depthWrite: <bool>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *\n *  fog: <bool>\n * }\n */\n\nTHREE.MeshBasicMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.color = new THREE.Color( 0xffffff ); // emissive\n\n\tthis.map = null;\n\n\tthis.lightMap = null;\n\n\tthis.specularMap = null;\n\n\tthis.envMap = null;\n\tthis.combine = THREE.MultiplyOperation;\n\tthis.reflectivity = 1;\n\tthis.refractionRatio = 0.98;\n\n\tthis.fog = true;\n\n\tthis.shading = THREE.SmoothShading;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\tthis.wireframeLinecap = 'round';\n\tthis.wireframeLinejoin = 'round';\n\n\tthis.vertexColors = THREE.NoColors;\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );\n\nTHREE.MeshBasicMaterial.prototype.clone = function () {\n\n\tvar material = new THREE.MeshBasicMaterial();\n\n\tTHREE.Material.prototype.clone.call( this, material );\n\n\tmaterial.color.copy( this.color );\n\n\tmaterial.map = this.map;\n\n\tmaterial.lightMap = this.lightMap;\n\n\tmaterial.specularMap = this.specularMap;\n\n\tmaterial.envMap = this.envMap;\n\tmaterial.combine = this.combine;\n\tmaterial.reflectivity = this.reflectivity;\n\tmaterial.refractionRatio = this.refractionRatio;\n\n\tmaterial.fog = this.fog;\n\n\tmaterial.shading = this.shading;\n\n\tmaterial.wireframe = this.wireframe;\n\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\n\tmaterial.wireframeLinecap = this.wireframeLinecap;\n\tmaterial.wireframeLinejoin = this.wireframeLinejoin;\n\n\tmaterial.vertexColors = this.vertexColors;\n\n\tmaterial.skinning = this.skinning;\n\tmaterial.morphTargets = this.morphTargets;\n\n\treturn material;\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  ambient: <hex>,\n *  emissive: <hex>,\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *\n *  specularMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n *  combine: THREE.Multiply,\n *  reflectivity: <float>,\n *  refractionRatio: <float>,\n *\n *  shading: THREE.SmoothShading,\n *  blending: THREE.NormalBlending,\n *  depthTest: <bool>,\n *  depthWrite: <bool>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>,\n *\n *\tfog: <bool>\n * }\n */\n\nTHREE.MeshLambertMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.color = new THREE.Color( 0xffffff ); // diffuse\n\tthis.ambient = new THREE.Color( 0xffffff );\n\tthis.emissive = new THREE.Color( 0x000000 );\n\n\tthis.wrapAround = false;\n\tthis.wrapRGB = new THREE.Vector3( 1, 1, 1 );\n\n\tthis.map = null;\n\n\tthis.lightMap = null;\n\n\tthis.specularMap = null;\n\n\tthis.envMap = null;\n\tthis.combine = THREE.MultiplyOperation;\n\tthis.reflectivity = 1;\n\tthis.refractionRatio = 0.98;\n\n\tthis.fog = true;\n\n\tthis.shading = THREE.SmoothShading;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\tthis.wireframeLinecap = 'round';\n\tthis.wireframeLinejoin = 'round';\n\n\tthis.vertexColors = THREE.NoColors;\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\tthis.morphNormals = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );\n\nTHREE.MeshLambertMaterial.prototype.clone = function () {\n\n\tvar material = new THREE.MeshLambertMaterial();\n\n\tTHREE.Material.prototype.clone.call( this, material );\n\n\tmaterial.color.copy( this.color );\n\tmaterial.ambient.copy( this.ambient );\n\tmaterial.emissive.copy( this.emissive );\n\n\tmaterial.wrapAround = this.wrapAround;\n\tmaterial.wrapRGB.copy( this.wrapRGB );\n\n\tmaterial.map = this.map;\n\n\tmaterial.lightMap = this.lightMap;\n\n\tmaterial.specularMap = this.specularMap;\n\n\tmaterial.envMap = this.envMap;\n\tmaterial.combine = this.combine;\n\tmaterial.reflectivity = this.reflectivity;\n\tmaterial.refractionRatio = this.refractionRatio;\n\n\tmaterial.fog = this.fog;\n\n\tmaterial.shading = this.shading;\n\n\tmaterial.wireframe = this.wireframe;\n\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\n\tmaterial.wireframeLinecap = this.wireframeLinecap;\n\tmaterial.wireframeLinejoin = this.wireframeLinejoin;\n\n\tmaterial.vertexColors = this.vertexColors;\n\n\tmaterial.skinning = this.skinning;\n\tmaterial.morphTargets = this.morphTargets;\n\tmaterial.morphNormals = this.morphNormals;\n\n\treturn material;\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  ambient: <hex>,\n *  emissive: <hex>,\n *  specular: <hex>,\n *  shininess: <float>,\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *\n *  bumpMap: new THREE.Texture( <Image> ),\n *  bumpScale: <float>,\n *\n *  normalMap: new THREE.Texture( <Image> ),\n *  normalScale: <Vector2>,\n *\n *  specularMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n *  combine: THREE.Multiply,\n *  reflectivity: <float>,\n *  refractionRatio: <float>,\n *\n *  shading: THREE.SmoothShading,\n *  blending: THREE.NormalBlending,\n *  depthTest: <bool>,\n *  depthWrite: <bool>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>,\n *\n *\tfog: <bool>\n * }\n */\n\nTHREE.MeshPhongMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.color = new THREE.Color( 0xffffff ); // diffuse\n\tthis.ambient = new THREE.Color( 0xffffff );\n\tthis.emissive = new THREE.Color( 0x000000 );\n\tthis.specular = new THREE.Color( 0x111111 );\n\tthis.shininess = 30;\n\n\tthis.metal = false;\n\tthis.perPixel = true;\n\n\tthis.wrapAround = false;\n\tthis.wrapRGB = new THREE.Vector3( 1, 1, 1 );\n\n\tthis.map = null;\n\n\tthis.lightMap = null;\n\n\tthis.bumpMap = null;\n\tthis.bumpScale = 1;\n\n\tthis.normalMap = null;\n\tthis.normalScale = new THREE.Vector2( 1, 1 );\n\n\tthis.specularMap = null;\n\n\tthis.envMap = null;\n\tthis.combine = THREE.MultiplyOperation;\n\tthis.reflectivity = 1;\n\tthis.refractionRatio = 0.98;\n\n\tthis.fog = true;\n\n\tthis.shading = THREE.SmoothShading;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\tthis.wireframeLinecap = 'round';\n\tthis.wireframeLinejoin = 'round';\n\n\tthis.vertexColors = THREE.NoColors;\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\tthis.morphNormals = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );\n\nTHREE.MeshPhongMaterial.prototype.clone = function () {\n\n\tvar material = new THREE.MeshPhongMaterial();\n\n\tTHREE.Material.prototype.clone.call( this, material );\n\n\tmaterial.color.copy( this.color );\n\tmaterial.ambient.copy( this.ambient );\n\tmaterial.emissive.copy( this.emissive );\n\tmaterial.specular.copy( this.specular );\n\tmaterial.shininess = this.shininess;\n\n\tmaterial.metal = this.metal;\n\tmaterial.perPixel = this.perPixel;\n\n\tmaterial.wrapAround = this.wrapAround;\n\tmaterial.wrapRGB.copy( this.wrapRGB );\n\n\tmaterial.map = this.map;\n\n\tmaterial.lightMap = this.lightMap;\n\n\tmaterial.bumpMap = this.bumpMap;\n\tmaterial.bumpScale = this.bumpScale;\n\n\tmaterial.normalMap = this.normalMap;\n\tmaterial.normalScale.copy( this.normalScale );\n\n\tmaterial.specularMap = this.specularMap;\n\n\tmaterial.envMap = this.envMap;\n\tmaterial.combine = this.combine;\n\tmaterial.reflectivity = this.reflectivity;\n\tmaterial.refractionRatio = this.refractionRatio;\n\n\tmaterial.fog = this.fog;\n\n\tmaterial.shading = this.shading;\n\n\tmaterial.wireframe = this.wireframe;\n\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\n\tmaterial.wireframeLinecap = this.wireframeLinecap;\n\tmaterial.wireframeLinejoin = this.wireframeLinejoin;\n\n\tmaterial.vertexColors = this.vertexColors;\n\n\tmaterial.skinning = this.skinning;\n\tmaterial.morphTargets = this.morphTargets;\n\tmaterial.morphNormals = this.morphNormals;\n\n\treturn material;\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  opacity: <float>,\n *\n *  blending: THREE.NormalBlending,\n *  depthTest: <bool>,\n *  depthWrite: <bool>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>\n * }\n */\n\nTHREE.MeshDepthMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );\n\nTHREE.MeshDepthMaterial.prototype.clone = function () {\n\n\tvar material = new THREE.LineBasicMaterial();\n\n\tTHREE.Material.prototype.clone.call( this, material );\n\n\tmaterial.wireframe = this.wireframe;\n\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\n\n\treturn material;\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n *\n * parameters = {\n *  opacity: <float>,\n *\n *  shading: THREE.FlatShading,\n *  blending: THREE.NormalBlending,\n *  depthTest: <bool>,\n *  depthWrite: <bool>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>\n * }\n */\n\nTHREE.MeshNormalMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this, parameters );\n\n\tthis.shading = THREE.FlatShading;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );\n\nTHREE.MeshNormalMaterial.prototype.clone = function () {\n\n\tvar material = new THREE.MeshNormalMaterial();\n\n\tTHREE.Material.prototype.clone.call( this, material );\n\n\tmaterial.shading = this.shading;\n\n\tmaterial.wireframe = this.wireframe;\n\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\n\n\treturn material;\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.MeshFaceMaterial = function ( materials ) {\n\n\tthis.materials = materials instanceof Array ? materials : [];\n\n};\n\nTHREE.MeshFaceMaterial.prototype.clone = function () {\n\n\treturn new THREE.MeshFaceMaterial( this.materials.slice( 0 ) );\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *  map: new THREE.Texture( <Image> ),\n *\n *  size: <float>,\n *\n *  blending: THREE.NormalBlending,\n *  depthTest: <bool>,\n *  depthWrite: <bool>,\n *\n *  vertexColors: <bool>,\n *\n *  fog: <bool>\n * }\n */\n\nTHREE.ParticleBasicMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.color = new THREE.Color( 0xffffff );\n\n\tthis.map = null;\n\n\tthis.size = 1;\n\tthis.sizeAttenuation = true;\n\n\tthis.vertexColors = false;\n\n\tthis.fog = true;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.ParticleBasicMaterial.prototype = Object.create( THREE.Material.prototype );\n\nTHREE.ParticleBasicMaterial.prototype.clone = function () {\n\n\tvar material = new THREE.ParticleBasicMaterial();\n\n\tTHREE.Material.prototype.clone.call( this, material );\n\n\tmaterial.color.copy( this.color );\n\n\tmaterial.map = this.map;\n\n\tmaterial.size = this.size;\n\tmaterial.sizeAttenuation = this.sizeAttenuation;\n\n\tmaterial.vertexColors = this.vertexColors;\n\n\tmaterial.fog = this.fog;\n\n\treturn material;\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n *\n * parameters = {\n *  color: <hex>,\n *  program: <function>,\n *  opacity: <float>,\n *  blending: THREE.NormalBlending\n * }\n */\n\nTHREE.ParticleCanvasMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.color = new THREE.Color( 0xffffff );\n\tthis.program = function ( context, color ) {};\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.ParticleCanvasMaterial.prototype = Object.create( THREE.Material.prototype );\n\nTHREE.ParticleCanvasMaterial.prototype.clone = function () {\n\n\tvar material = new THREE.ParticleCanvasMaterial();\n\n\tTHREE.Material.prototype.clone.call( this, material );\n\n\tmaterial.color.copy( this.color );\n\tmaterial.program = this.program;\n\n\treturn material;\n\n};\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  fragmentShader: <string>,\n *  vertexShader: <string>,\n *\n *  uniforms: { \"parameter1\": { type: \"f\", value: 1.0 }, \"parameter2\": { type: \"i\" value2: 2 } },\n *\n *  defines: { \"label\" : \"value\" },\n *\n *  shading: THREE.SmoothShading,\n *  blending: THREE.NormalBlending,\n *  depthTest: <bool>,\n *  depthWrite: <bool>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  lights: <bool>,\n *\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>,\n *\n *\tfog: <bool>\n * }\n */\n\nTHREE.ShaderMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.fragmentShader = \"void main() {}\";\n\tthis.vertexShader = \"void main() {}\";\n\tthis.uniforms = {};\n\tthis.defines = {};\n\tthis.attributes = null;\n\n\tthis.shading = THREE.SmoothShading;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\n\tthis.fog = false; // set to use scene fog\n\n\tthis.lights = false; // set to use scene lights\n\n\tthis.vertexColors = THREE.NoColors; // set to use \"color\" attribute stream\n\n\tthis.skinning = false; // set to use skinning attribute streams\n\n\tthis.morphTargets = false; // set to use morph targets\n\tthis.morphNormals = false; // set to use morph normals\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );\n\nTHREE.ShaderMaterial.prototype.clone = function () {\n\n\tvar material = new THREE.ShaderMaterial();\n\n\tTHREE.Material.prototype.clone.call( this, material );\n\n\tmaterial.fragmentShader = this.fragmentShader;\n\tmaterial.vertexShader = this.vertexShader;\n\n\tmaterial.uniforms = THREE.UniformsUtils.clone( this.uniforms );\n\n\tmaterial.attributes = this.attributes;\n\tmaterial.defines = this.defines;\n\n\tmaterial.shading = this.shading;\n\n\tmaterial.wireframe = this.wireframe;\n\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\n\n\tmaterial.fog = this.fog;\n\n\tmaterial.lights = this.lights;\n\n\tmaterial.vertexColors = this.vertexColors;\n\n\tmaterial.skinning = this.skinning;\n\n\tmaterial.morphTargets = this.morphTargets;\n\tmaterial.morphNormals = this.morphNormals;\n\n\treturn material;\n\n};\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *  map: new THREE.Texture( <Image> ),\n *\n *  blending: THREE.NormalBlending,\n *  depthTest: <bool>,\n *  depthWrite: <bool>,\n *\n *  useScreenCoordinates: <bool>,\n *  sizeAttenuation: <bool>,\n *  scaleByViewport: <bool>,\n *  alignment: THREE.SpriteAlignment.center,\n *\n *\tuvOffset: new THREE.Vector2(),\n *\tuvScale: new THREE.Vector2(),\n *\n *  fog: <bool>\n * }\n */\n\nTHREE.SpriteMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\t// defaults\n\n\tthis.color = new THREE.Color( 0xffffff );\n\tthis.map = new THREE.Texture();\n\n\tthis.useScreenCoordinates = true;\n\tthis.depthTest = !this.useScreenCoordinates;\n\tthis.sizeAttenuation = !this.useScreenCoordinates;\n\tthis.scaleByViewport = !this.sizeAttenuation;\n\tthis.alignment = THREE.SpriteAlignment.center.clone();\n\n\tthis.fog = false;\n\n\tthis.uvOffset = new THREE.Vector2( 0, 0 );\n\tthis.uvScale  = new THREE.Vector2( 1, 1 );\n\n\t// set parameters\n\n\tthis.setValues( parameters );\n\n\t// override coupled defaults if not specified explicitly by parameters\n\n\tparameters = parameters || {};\n\n\tif ( parameters.depthTest === undefined ) this.depthTest = !this.useScreenCoordinates;\n\tif ( parameters.sizeAttenuation === undefined ) this.sizeAttenuation = !this.useScreenCoordinates;\n\tif ( parameters.scaleByViewport === undefined ) this.scaleByViewport = !this.sizeAttenuation;\n\n};\n\nTHREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );\n\nTHREE.SpriteMaterial.prototype.clone = function () {\n\n\tvar material = new THREE.SpriteMaterial();\n\n\tTHREE.Material.prototype.clone.call( this, material );\n\n\tmaterial.color.copy( this.color );\n\tmaterial.map = this.map;\n\n\tmaterial.useScreenCoordinates = this.useScreenCoordinates;\n\tmaterial.sizeAttenuation = this.sizeAttenuation;\n\tmaterial.scaleByViewport = this.scaleByViewport;\n\tmaterial.alignment.copy( this.alignment );\n\n\tmaterial.uvOffset.copy( this.uvOffset );\n\tmaterial.uvScale.copy( this.uvScale );\n\n\tmaterial.fog = this.fog;\n\n\treturn material;\n\n};\n\n// Alignment enums\n\nTHREE.SpriteAlignment = {};\nTHREE.SpriteAlignment.topLeft = new THREE.Vector2( 1, -1 );\nTHREE.SpriteAlignment.topCenter = new THREE.Vector2( 0, -1 );\nTHREE.SpriteAlignment.topRight = new THREE.Vector2( -1, -1 );\nTHREE.SpriteAlignment.centerLeft = new THREE.Vector2( 1, 0 );\nTHREE.SpriteAlignment.center = new THREE.Vector2( 0, 0 );\nTHREE.SpriteAlignment.centerRight = new THREE.Vector2( -1, 0 );\nTHREE.SpriteAlignment.bottomLeft = new THREE.Vector2( 1, 1 );\nTHREE.SpriteAlignment.bottomCenter = new THREE.Vector2( 0, 1 );\nTHREE.SpriteAlignment.bottomRight = new THREE.Vector2( -1, 1 );\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author szimek / https://github.com/szimek/\n */\n\nTHREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\n\tTHREE.EventDispatcher.call( this );\n\n\tthis.id = THREE.TextureIdCount ++;\n\n\tthis.name = '';\n\n\tthis.image = image;\n\tthis.mipmaps = [];\n\n\tthis.mapping = mapping !== undefined ? mapping : new THREE.UVMapping();\n\n\tthis.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;\n\tthis.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;\n\n\tthis.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;\n\tthis.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;\n\n\tthis.anisotropy = anisotropy !== undefined ? anisotropy : 1;\n\n\tthis.format = format !== undefined ? format : THREE.RGBAFormat;\n\tthis.type = type !== undefined ? type : THREE.UnsignedByteType;\n\n\tthis.offset = new THREE.Vector2( 0, 0 );\n\tthis.repeat = new THREE.Vector2( 1, 1 );\n\n\tthis.generateMipmaps = true;\n\tthis.premultiplyAlpha = false;\n\tthis.flipY = true;\n\tthis.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\n\n\tthis.needsUpdate = false;\n\tthis.onUpdate = null;\n\n};\n\nTHREE.Texture.prototype = {\n\n\tconstructor: THREE.Texture,\n\n\tclone: function ( texture ) {\n\n\t\tif ( texture === undefined ) texture = new THREE.Texture();\n\n\t\ttexture.image = this.image;\n\t\ttexture.mipmaps = this.mipmaps.slice(0);\n\n\t\ttexture.mapping = this.mapping;\n\n\t\ttexture.wrapS = this.wrapS;\n\t\ttexture.wrapT = this.wrapT;\n\n\t\ttexture.magFilter = this.magFilter;\n\t\ttexture.minFilter = this.minFilter;\n\n\t\ttexture.anisotropy = this.anisotropy;\n\n\t\ttexture.format = this.format;\n\t\ttexture.type = this.type;\n\n\t\ttexture.offset.copy( this.offset );\n\t\ttexture.repeat.copy( this.repeat );\n\n\t\ttexture.generateMipmaps = this.generateMipmaps;\n\t\ttexture.premultiplyAlpha = this.premultiplyAlpha;\n\t\ttexture.flipY = this.flipY;\n\t\ttexture.unpackAlignment = this.unpackAlignment;\n\n\t\treturn texture;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n};\n\nTHREE.TextureIdCount = 0;\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {\n\n\tTHREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\tthis.image = { width: width, height: height };\n\tthis.mipmaps = mipmaps;\n\n\tthis.generateMipmaps = false; // WebGL currently can't generate mipmaps for compressed textures, they must be embedded in DDS file\n\n};\n\nTHREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );\n\nTHREE.CompressedTexture.prototype.clone = function () {\n\n\tvar texture = new THREE.CompressedTexture();\n\n\tTHREE.Texture.prototype.clone.call( this, texture );\n\n\treturn texture;\n\n};\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {\n\n\tTHREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\tthis.image = { data: data, width: width, height: height };\n\n};\n\nTHREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );\n\nTHREE.DataTexture.prototype.clone = function () {\n\n\tvar texture = new THREE.DataTexture();\n\n\tTHREE.Texture.prototype.clone.call( this, texture );\n\n\treturn texture;\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Particle = function ( material ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.material = material;\n\n};\n\nTHREE.Particle.prototype = Object.create( THREE.Object3D.prototype );\n\nTHREE.Particle.prototype.clone = function ( object ) {\n\n\tif ( object === undefined ) object = new THREE.Particle( this.material );\n\n\tTHREE.Object3D.prototype.clone.call( this, object );\n\n\treturn object;\n\n};\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.ParticleSystem = function ( geometry, material ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.geometry = geometry;\n\tthis.material = ( material !== undefined ) ? material : new THREE.ParticleBasicMaterial( { color: Math.random() * 0xffffff } );\n\n\tthis.sortParticles = false;\n\n\tif ( this.geometry ) {\n\n\t\t// calc bound radius\n\n\t\tif( this.geometry.boundingSphere === null ) {\n\n\t\t\tthis.geometry.computeBoundingSphere();\n\n\t\t}\n\n\t}\n\n\tthis.frustumCulled = false;\n\n};\n\nTHREE.ParticleSystem.prototype = Object.create( THREE.Object3D.prototype );\n\nTHREE.ParticleSystem.prototype.clone = function ( object ) {\n\n\tif ( object === undefined ) object = new THREE.ParticleSystem( this.geometry, this.material );\n\tobject.sortParticles = this.sortParticles;\n\n\tTHREE.Object3D.prototype.clone.call( this, object );\n\n\treturn object;\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Line = function ( geometry, material, type ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.geometry = geometry;\n\tthis.material = ( material !== undefined ) ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );\n\tthis.type = ( type !== undefined ) ? type : THREE.LineStrip;\n\n\tif ( this.geometry ) {\n\n\t\tif ( ! this.geometry.boundingSphere ) {\n\n\t\t\tthis.geometry.computeBoundingSphere();\n\n\t\t}\n\n\t}\n\n};\n\nTHREE.LineStrip = 0;\nTHREE.LinePieces = 1;\n\nTHREE.Line.prototype = Object.create( THREE.Object3D.prototype );\n\nTHREE.Line.prototype.clone = function ( object ) {\n\n\tif ( object === undefined ) object = new THREE.Line( this.geometry, this.material, this.type );\n\n\tTHREE.Object3D.prototype.clone.call( this, object );\n\n\treturn object;\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author mikael emtinger / http://gomo.se/\n * @author jonobr1 / http://jonobr1.com/\n */\n\nTHREE.Mesh = function ( geometry, material ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.geometry = geometry;\n\tthis.material = ( material !== undefined ) ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff, wireframe: true } );\n\n\tif ( this.geometry !== undefined ) {\n\n\t\tif ( this.geometry.boundingSphere === null ) {\n\n\t\t\tthis.geometry.computeBoundingSphere();\n\n\t\t}\n\n\t\tthis.updateMorphTargets();\n\n\t}\n\n};\n\nTHREE.Mesh.prototype = Object.create( THREE.Object3D.prototype );\n\nTHREE.Mesh.prototype.updateMorphTargets = function () {\n\n\tif ( this.geometry.morphTargets.length > 0 ) {\n\n\t\tthis.morphTargetBase = -1;\n\t\tthis.morphTargetForcedOrder = [];\n\t\tthis.morphTargetInfluences = [];\n\t\tthis.morphTargetDictionary = {};\n\n\t\tfor ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {\n\n\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\tthis.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;\n\n\t\t}\n\n\t}\n\n};\n\nTHREE.Mesh.prototype.getMorphTargetIndexByName = function ( name ) {\n\n\tif ( this.morphTargetDictionary[ name ] !== undefined ) {\n\n\t\treturn this.morphTargetDictionary[ name ];\n\n\t}\n\n\tconsole.log( \"THREE.Mesh.getMorphTargetIndexByName: morph target \" + name + \" does not exist. Returning 0.\" );\n\n\treturn 0;\n\n};\n\nTHREE.Mesh.prototype.clone = function ( object ) {\n\n\tif ( object === undefined ) object = new THREE.Mesh( this.geometry, this.material );\n\n\tTHREE.Object3D.prototype.clone.call( this, object );\n\n\treturn object;\n\n};\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Bone = function( belongsToSkin ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.skin = belongsToSkin;\n\tthis.skinMatrix = new THREE.Matrix4();\n\n};\n\nTHREE.Bone.prototype = Object.create( THREE.Object3D.prototype );\n\nTHREE.Bone.prototype.update = function ( parentSkinMatrix, forceUpdate ) {\n\n\t// update local\n\n\tif ( this.matrixAutoUpdate ) {\n\n\t\tforceUpdate |= this.updateMatrix();\n\n\t}\n\n\t// update skin matrix\n\n\tif ( forceUpdate || this.matrixWorldNeedsUpdate ) {\n\n\t\tif( parentSkinMatrix ) {\n\n\t\t\tthis.skinMatrix.multiplyMatrices( parentSkinMatrix, this.matrix );\n\n\t\t} else {\n\n\t\t\tthis.skinMatrix.copy( this.matrix );\n\n\t\t}\n\n\t\tthis.matrixWorldNeedsUpdate = false;\n\t\tforceUpdate = true;\n\n\t}\n\n\t// update children\n\n\tvar child, i, l = this.children.length;\n\n\tfor ( i = 0; i < l; i ++ ) {\n\n\t\tthis.children[ i ].update( this.skinMatrix, forceUpdate );\n\n\t}\n\n};\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {\n\n\tTHREE.Mesh.call( this, geometry, material );\n\n\t//\n\n\tthis.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;\n\n\t// init bones\n\n\tthis.identityMatrix = new THREE.Matrix4();\n\n\tthis.bones = [];\n\tthis.boneMatrices = [];\n\n\tvar b, bone, gbone, p, q, s;\n\n\tif ( this.geometry && this.geometry.bones !== undefined ) {\n\n\t\tfor ( b = 0; b < this.geometry.bones.length; b ++ ) {\n\n\t\t\tgbone = this.geometry.bones[ b ];\n\n\t\t\tp = gbone.pos;\n\t\t\tq = gbone.rotq;\n\t\t\ts = gbone.scl;\n\n\t\t\tbone = this.addBone();\n\n\t\t\tbone.name = gbone.name;\n\t\t\tbone.position.set( p[0], p[1], p[2] );\n\t\t\tbone.quaternion.set( q[0], q[1], q[2], q[3] );\n\t\t\tbone.useQuaternion = true;\n\n\t\t\tif ( s !== undefined ) {\n\n\t\t\t\tbone.scale.set( s[0], s[1], s[2] );\n\n\t\t\t} else {\n\n\t\t\t\tbone.scale.set( 1, 1, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( b = 0; b < this.bones.length; b ++ ) {\n\n\t\t\tgbone = this.geometry.bones[ b ];\n\t\t\tbone = this.bones[ b ];\n\n\t\t\tif ( gbone.parent === -1 ) {\n\n\t\t\t\tthis.add( bone );\n\n\t\t\t} else {\n\n\t\t\t\tthis.bones[ gbone.parent ].add( bone );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tvar nBones = this.bones.length;\n\n\t\tif ( this.useVertexTexture ) {\n\n\t\t\t// layout (1 matrix = 4 pixels)\n\t\t\t//\tRGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n\t\t\t//  with  8x8  pixel texture max   16 bones  (8 * 8  / 4)\n\t\t\t//  \t 16x16 pixel texture max   64 bones (16 * 16 / 4)\n\t\t\t//  \t 32x32 pixel texture max  256 bones (32 * 32 / 4)\n\t\t\t//  \t 64x64 pixel texture max 1024 bones (64 * 64 / 4)\n\n\t\t\tvar size;\n\n\t\t\tif ( nBones > 256 )\n\t\t\t\tsize = 64;\n\t\t\telse if ( nBones > 64 )\n\t\t\t\tsize = 32;\n\t\t\telse if ( nBones > 16 )\n\t\t\t\tsize = 16;\n\t\t\telse\n\t\t\t\tsize = 8;\n\n\t\t\tthis.boneTextureWidth = size;\n\t\t\tthis.boneTextureHeight = size;\n\n\t\t\tthis.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel\n\t\t\tthis.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );\n\t\t\tthis.boneTexture.minFilter = THREE.NearestFilter;\n\t\t\tthis.boneTexture.magFilter = THREE.NearestFilter;\n\t\t\tthis.boneTexture.generateMipmaps = false;\n\t\t\tthis.boneTexture.flipY = false;\n\n\t\t} else {\n\n\t\t\tthis.boneMatrices = new Float32Array( 16 * nBones );\n\n\t\t}\n\n\t\tthis.pose();\n\n\t}\n\n};\n\nTHREE.SkinnedMesh.prototype = Object.create( THREE.Mesh.prototype );\n\nTHREE.SkinnedMesh.prototype.addBone = function( bone ) {\n\n\tif ( bone === undefined ) {\n\n\t\tbone = new THREE.Bone( this );\n\n\t}\n\n\tthis.bones.push( bone );\n\n\treturn bone;\n\n};\n\nTHREE.SkinnedMesh.prototype.updateMatrixWorld = function ( force ) {\n\n\tthis.matrixAutoUpdate && this.updateMatrix();\n\n\t// update matrixWorld\n\n\tif ( this.matrixWorldNeedsUpdate || force ) {\n\n\t\tif ( this.parent ) {\n\n\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\n\t\t} else {\n\n\t\t\tthis.matrixWorld.copy( this.matrix );\n\n\t\t}\n\n\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\tforce = true;\n\n\t}\n\n\t// update children\n\n\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\n\t\tvar child = this.children[ i ];\n\n\t\tif ( child instanceof THREE.Bone ) {\n\n\t\t\tchild.update( this.identityMatrix, false );\n\n\t\t} else {\n\n\t\t\tchild.updateMatrixWorld( true );\n\n\t\t}\n\n\t}\n\n\t// make a snapshot of the bones' rest position\n\n\tif ( this.boneInverses == undefined ) {\n\n\t\tthis.boneInverses = [];\n\n\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\tvar inverse = new THREE.Matrix4();\n\n\t\t\tinverse.getInverse( this.bones[ b ].skinMatrix );\n\n\t\t\tthis.boneInverses.push( inverse );\n\n\t\t}\n\n\t}\n\n\t// flatten bone matrices to array\n\n\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t// compute the offset between the current and the original transform;\n\n\t\t//TODO: we could get rid of this multiplication step if the skinMatrix\n\t\t// was already representing the offset; however, this requires some\n\t\t// major changes to the animation system\n\n\t\tTHREE.SkinnedMesh.offsetMatrix.multiplyMatrices( this.bones[ b ].skinMatrix, this.boneInverses[ b ] );\n\n\t\tTHREE.SkinnedMesh.offsetMatrix.flattenToArrayOffset( this.boneMatrices, b * 16 );\n\n\t}\n\n\tif ( this.useVertexTexture ) {\n\n\t\tthis.boneTexture.needsUpdate = true;\n\n\t}\n\n};\n\nTHREE.SkinnedMesh.prototype.pose = function () {\n\n\tthis.updateMatrixWorld( true );\n\n\tfor ( var i = 0; i < this.geometry.skinIndices.length; i ++ ) {\n\n\t\t// normalize weights\n\n\t\tvar sw = this.geometry.skinWeights[ i ];\n\n\t\tvar scale = 1.0 / sw.lengthManhattan();\n\n\t\tif ( scale !== Infinity ) {\n\n\t\t\tsw.multiplyScalar( scale );\n\n\t\t} else {\n\n\t\t\tsw.set( 1 ); // this will be normalized by the shader anyway\n\n\t\t}\n\n\t}\n\n};\n\nTHREE.SkinnedMesh.prototype.clone = function ( object ) {\n\n\tif ( object === undefined ) object = new THREE.SkinnedMesh( this.geometry, this.material, this.useVertexTexture );\n\n\tTHREE.Mesh.prototype.clone.call( this, object );\n\n\treturn object;\n\n};\n\nTHREE.SkinnedMesh.offsetMatrix = new THREE.Matrix4();\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.MorphAnimMesh = function ( geometry, material ) {\n\n\tTHREE.Mesh.call( this, geometry, material );\n\n\t// API\n\n\tthis.duration = 1000; // milliseconds\n\tthis.mirroredLoop = false;\n\tthis.time = 0;\n\n\t// internals\n\n\tthis.lastKeyframe = 0;\n\tthis.currentKeyframe = 0;\n\n\tthis.direction = 1;\n\tthis.directionBackwards = false;\n\n\tthis.setFrameRange( 0, this.geometry.morphTargets.length - 1 );\n\n};\n\nTHREE.MorphAnimMesh.prototype = Object.create( THREE.Mesh.prototype );\n\nTHREE.MorphAnimMesh.prototype.setFrameRange = function ( start, end ) {\n\n\tthis.startKeyframe = start;\n\tthis.endKeyframe = end;\n\n\tthis.length = this.endKeyframe - this.startKeyframe + 1;\n\n};\n\nTHREE.MorphAnimMesh.prototype.setDirectionForward = function () {\n\n\tthis.direction = 1;\n\tthis.directionBackwards = false;\n\n};\n\nTHREE.MorphAnimMesh.prototype.setDirectionBackward = function () {\n\n\tthis.direction = -1;\n\tthis.directionBackwards = true;\n\n};\n\nTHREE.MorphAnimMesh.prototype.parseAnimations = function () {\n\n\tvar geometry = this.geometry;\n\n\tif ( ! geometry.animations ) geometry.animations = {};\n\n\tvar firstAnimation, animations = geometry.animations;\n\n\tvar pattern = /([a-z]+)(\\d+)/;\n\n\tfor ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {\n\n\t\tvar morph = geometry.morphTargets[ i ];\n\t\tvar parts = morph.name.match( pattern );\n\n\t\tif ( parts && parts.length > 1 ) {\n\n\t\t\tvar label = parts[ 1 ];\n\t\t\tvar num = parts[ 2 ];\n\n\t\t\tif ( ! animations[ label ] ) animations[ label ] = { start: Infinity, end: -Infinity };\n\n\t\t\tvar animation = animations[ label ];\n\n\t\t\tif ( i < animation.start ) animation.start = i;\n\t\t\tif ( i > animation.end ) animation.end = i;\n\n\t\t\tif ( ! firstAnimation ) firstAnimation = label;\n\n\t\t}\n\n\t}\n\n\tgeometry.firstAnimation = firstAnimation;\n\n};\n\nTHREE.MorphAnimMesh.prototype.setAnimationLabel = function ( label, start, end ) {\n\n\tif ( ! this.geometry.animations ) this.geometry.animations = {};\n\n\tthis.geometry.animations[ label ] = { start: start, end: end };\n\n};\n\nTHREE.MorphAnimMesh.prototype.playAnimation = function ( label, fps ) {\n\n\tvar animation = this.geometry.animations[ label ];\n\n\tif ( animation ) {\n\n\t\tthis.setFrameRange( animation.start, animation.end );\n\t\tthis.duration = 1000 * ( ( animation.end - animation.start ) / fps );\n\t\tthis.time = 0;\n\n\t} else {\n\n\t\tconsole.warn( \"animation[\" + label + \"] undefined\" );\n\n\t}\n\n};\n\nTHREE.MorphAnimMesh.prototype.updateAnimation = function ( delta ) {\n\n\tvar frameTime = this.duration / this.length;\n\n\tthis.time += this.direction * delta;\n\n\tif ( this.mirroredLoop ) {\n\n\t\tif ( this.time > this.duration || this.time < 0 ) {\n\n\t\t\tthis.direction *= -1;\n\n\t\t\tif ( this.time > this.duration ) {\n\n\t\t\t\tthis.time = this.duration;\n\t\t\t\tthis.directionBackwards = true;\n\n\t\t\t}\n\n\t\t\tif ( this.time < 0 ) {\n\n\t\t\t\tthis.time = 0;\n\t\t\t\tthis.directionBackwards = false;\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\tthis.time = this.time % this.duration;\n\n\t\tif ( this.time < 0 ) this.time += this.duration;\n\n\t}\n\n\tvar keyframe = this.startKeyframe + THREE.Math.clamp( Math.floor( this.time / frameTime ), 0, this.length - 1 );\n\n\tif ( keyframe !== this.currentKeyframe ) {\n\n\t\tthis.morphTargetInfluences[ this.lastKeyframe ] = 0;\n\t\tthis.morphTargetInfluences[ this.currentKeyframe ] = 1;\n\n\t\tthis.morphTargetInfluences[ keyframe ] = 0;\n\n\t\tthis.lastKeyframe = this.currentKeyframe;\n\t\tthis.currentKeyframe = keyframe;\n\n\t}\n\n\tvar mix = ( this.time % frameTime ) / frameTime;\n\n\tif ( this.directionBackwards ) {\n\n\t\tmix = 1 - mix;\n\n\t}\n\n\tthis.morphTargetInfluences[ this.currentKeyframe ] = mix;\n\tthis.morphTargetInfluences[ this.lastKeyframe ] = 1 - mix;\n\n};\n\nTHREE.MorphAnimMesh.prototype.clone = function ( object ) {\n\n\tif ( object === undefined ) object = new THREE.MorphAnimMesh( this.geometry, this.material );\n\n\tobject.duration = this.duration;\n\tobject.mirroredLoop = this.mirroredLoop;\n\tobject.time = this.time;\n\n\tobject.lastKeyframe = this.lastKeyframe;\n\tobject.currentKeyframe = this.currentKeyframe;\n\n\tobject.direction = this.direction;\n\tobject.directionBackwards = this.directionBackwards;\n\n\tTHREE.Mesh.prototype.clone.call( this, object );\n\n\treturn object;\n\n};\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Ribbon = function ( geometry, material ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.geometry = geometry;\n\tthis.material = material;\n\n};\n\nTHREE.Ribbon.prototype = Object.create( THREE.Object3D.prototype );\n\nTHREE.Ribbon.prototype.clone = function ( object ) {\n\n\tif ( object === undefined ) object = new THREE.Ribbon( this.geometry, this.material );\n\n\tTHREE.Object3D.prototype.clone.call( this, object );\n\n\treturn object;\n\n};\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.LOD = function () {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.LODs = [];\n\n};\n\n\nTHREE.LOD.prototype = Object.create( THREE.Object3D.prototype );\n\nTHREE.LOD.prototype.addLevel = function ( object3D, visibleAtDistance ) {\n\n\tif ( visibleAtDistance === undefined ) {\n\n\t\tvisibleAtDistance = 0;\n\n\t}\n\n\tvisibleAtDistance = Math.abs( visibleAtDistance );\n\n\tfor ( var l = 0; l < this.LODs.length; l ++ ) {\n\n\t\tif ( visibleAtDistance < this.LODs[ l ].visibleAtDistance ) {\n\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\tthis.LODs.splice( l, 0, { visibleAtDistance: visibleAtDistance, object3D: object3D } );\n\tthis.add( object3D );\n\n};\n\nTHREE.LOD.prototype.update = function ( camera ) {\n\n\tif ( this.LODs.length > 1 ) {\n\n\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\n\n\t\tvar inverse  = camera.matrixWorldInverse;\n\t\tvar distance = -( inverse.elements[2] * this.matrixWorld.elements[12] + inverse.elements[6] * this.matrixWorld.elements[13] + inverse.elements[10] * this.matrixWorld.elements[14] + inverse.elements[14] );\n\n\t\tthis.LODs[ 0 ].object3D.visible = true;\n\n\t\tfor ( var l = 1; l < this.LODs.length; l ++ ) {\n\n\t\t\tif( distance >= this.LODs[ l ].visibleAtDistance ) {\n\n\t\t\t\tthis.LODs[ l - 1 ].object3D.visible = false;\n\t\t\t\tthis.LODs[ l     ].object3D.visible = true;\n\n\t\t\t} else {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor( ; l < this.LODs.length; l ++ ) {\n\n\t\t\tthis.LODs[ l ].object3D.visible = false;\n\n\t\t}\n\n\t}\n\n};\n\nTHREE.LOD.prototype.clone = function () {\n\n\t// TODO\n\n};\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Sprite = function ( material ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();\n\n\tthis.rotation3d = this.rotation;\n\tthis.rotation = 0;\n\n};\n\nTHREE.Sprite.prototype = Object.create( THREE.Object3D.prototype );\n\n/*\n * Custom update matrix\n */\n\nTHREE.Sprite.prototype.updateMatrix = function () {\n\n\tthis.matrix.setPosition( this.position );\n\n\tthis.rotation3d.set( 0, 0, this.rotation );\n\tthis.matrix.setRotationFromEuler( this.rotation3d );\n\n\tif ( this.scale.x !== 1 || this.scale.y !== 1 ) {\n\n\t\tthis.matrix.scale( this.scale );\n\n\t}\n\n\tthis.matrixWorldNeedsUpdate = true;\n\n};\n\nTHREE.Sprite.prototype.clone = function ( object ) {\n\n\tif ( object === undefined ) object = new THREE.Sprite( this.material );\n\n\tTHREE.Object3D.prototype.clone.call( this, object );\n\n\treturn object;\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Scene = function () {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.fog = null;\n\tthis.overrideMaterial = null;\n\n\tthis.matrixAutoUpdate = false;\n\n\tthis.__objects = [];\n\tthis.__lights = [];\n\n\tthis.__objectsAdded = [];\n\tthis.__objectsRemoved = [];\n\n};\n\nTHREE.Scene.prototype = Object.create( THREE.Object3D.prototype );\n\nTHREE.Scene.prototype.__addObject = function ( object ) {\n\n\tif ( object instanceof THREE.Light ) {\n\n\t\tif ( this.__lights.indexOf( object ) === - 1 ) {\n\n\t\t\tthis.__lights.push( object );\n\n\t\t}\n\n\t\tif ( object.target && object.target.parent === undefined ) {\n\n\t\t\tthis.add( object.target );\n\n\t\t}\n\n\t} else if ( !( object instanceof THREE.Camera || object instanceof THREE.Bone ) ) {\n\n\t\tif ( this.__objects.indexOf( object ) === - 1 ) {\n\n\t\t\tthis.__objects.push( object );\n\t\t\tthis.__objectsAdded.push( object );\n\n\t\t\t// check if previously removed\n\n\t\t\tvar i = this.__objectsRemoved.indexOf( object );\n\n\t\t\tif ( i !== -1 ) {\n\n\t\t\t\tthis.__objectsRemoved.splice( i, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfor ( var c = 0; c < object.children.length; c ++ ) {\n\n\t\tthis.__addObject( object.children[ c ] );\n\n\t}\n\n};\n\nTHREE.Scene.prototype.__removeObject = function ( object ) {\n\n\tif ( object instanceof THREE.Light ) {\n\n\t\tvar i = this.__lights.indexOf( object );\n\n\t\tif ( i !== -1 ) {\n\n\t\t\tthis.__lights.splice( i, 1 );\n\n\t\t}\n\n\t} else if ( !( object instanceof THREE.Camera ) ) {\n\n\t\tvar i = this.__objects.indexOf( object );\n\n\t\tif( i !== -1 ) {\n\n\t\t\tthis.__objects.splice( i, 1 );\n\t\t\tthis.__objectsRemoved.push( object );\n\n\t\t\t// check if previously added\n\n\t\t\tvar ai = this.__objectsAdded.indexOf( object );\n\n\t\t\tif ( ai !== -1 ) {\n\n\t\t\t\tthis.__objectsAdded.splice( ai, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfor ( var c = 0; c < object.children.length; c ++ ) {\n\n\t\tthis.__removeObject( object.children[ c ] );\n\n\t}\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Fog = function ( hex, near, far ) {\n\n\tthis.name = '';\n\n\tthis.color = new THREE.Color( hex );\n\n\tthis.near = ( near !== undefined ) ? near : 1;\n\tthis.far = ( far !== undefined ) ? far : 1000;\n\n};\n\nTHREE.Fog.prototype.clone = function () {\n\n\treturn new THREE.Fog( this.color.getHex(), this.near, this.far );\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.FogExp2 = function ( hex, density ) {\n\n\tthis.name = '';\n\tthis.color = new THREE.Color( hex );\n\tthis.density = ( density !== undefined ) ? density : 0.00025;\n\n};\n\nTHREE.FogExp2.prototype.clone = function () {\n\n\treturn new THREE.FogExp2( this.color.getHex(), this.density );\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.CanvasRenderer = function ( parameters ) {\n\n\tconsole.log( 'THREE.CanvasRenderer', THREE.REVISION );\n\n\tvar smoothstep = THREE.Math.smoothstep;\n\n\tparameters = parameters || {};\n\n\tvar _this = this,\n\t_renderData, _elements, _lights,\n\t_projector = new THREE.Projector(),\n\n\t_canvas = parameters.canvas !== undefined\n\t\t\t? parameters.canvas\n\t\t\t: document.createElement( 'canvas' ),\n\n\t_canvasWidth, _canvasHeight, _canvasWidthHalf, _canvasHeightHalf,\n\t_context = _canvas.getContext( '2d' ),\n\n\t_clearColor = new THREE.Color( 0x000000 ),\n\t_clearOpacity = 0,\n\n\t_contextGlobalAlpha = 1,\n\t_contextGlobalCompositeOperation = 0,\n\t_contextStrokeStyle = null,\n\t_contextFillStyle = null,\n\t_contextLineWidth = null,\n\t_contextLineCap = null,\n\t_contextLineJoin = null,\n\t_contextDashSize = null,\n\t_contextGapSize = 0,\n\n\t_v1, _v2, _v3, _v4,\n\t_v5 = new THREE.RenderableVertex(),\n\t_v6 = new THREE.RenderableVertex(),\n\n\t_v1x, _v1y, _v2x, _v2y, _v3x, _v3y,\n\t_v4x, _v4y, _v5x, _v5y, _v6x, _v6y,\n\n\t_color = new THREE.Color(),\n\t_color1 = new THREE.Color(),\n\t_color2 = new THREE.Color(),\n\t_color3 = new THREE.Color(),\n\t_color4 = new THREE.Color(),\n\n\t_diffuseColor = new THREE.Color(),\n\t_emissiveColor = new THREE.Color(),\n\n\t_lightColor = new THREE.Color(),\n\n\t_patterns = {}, _imagedatas = {},\n\n\t_near, _far,\n\n\t_image, _uvs,\n\t_uv1x, _uv1y, _uv2x, _uv2y, _uv3x, _uv3y,\n\n\t_clipBox = new THREE.Box2(),\n\t_clearBox = new THREE.Box2(),\n\t_elemBox = new THREE.Box2(),\n\n\t_enableLighting = false,\n\t_ambientLight = new THREE.Color(),\n\t_directionalLights = new THREE.Color(),\n\t_pointLights = new THREE.Color(),\n\n\t_vector3 = new THREE.Vector3(), // Needed for PointLight\n\n\t_pixelMap, _pixelMapContext, _pixelMapImage, _pixelMapData,\n\t_gradientMap, _gradientMapContext, _gradientMapQuality = 16;\n\n\t_pixelMap = document.createElement( 'canvas' );\n\t_pixelMap.width = _pixelMap.height = 2;\n\n\t_pixelMapContext = _pixelMap.getContext( '2d' );\n\t_pixelMapContext.fillStyle = 'rgba(0,0,0,1)';\n\t_pixelMapContext.fillRect( 0, 0, 2, 2 );\n\n\t_pixelMapImage = _pixelMapContext.getImageData( 0, 0, 2, 2 );\n\t_pixelMapData = _pixelMapImage.data;\n\n\t_gradientMap = document.createElement( 'canvas' );\n\t_gradientMap.width = _gradientMap.height = _gradientMapQuality;\n\n\t_gradientMapContext = _gradientMap.getContext( '2d' );\n\t_gradientMapContext.translate( - _gradientMapQuality / 2, - _gradientMapQuality / 2 );\n\t_gradientMapContext.scale( _gradientMapQuality, _gradientMapQuality );\n\n\t_gradientMapQuality --; // Fix UVs\n\n\t// dash+gap fallbacks for Firefox and everything else\n\n\tif ( _context.setLineDash === undefined ) {\n\n\t\tif ( _context.mozDash !== undefined ) {\n\n\t\t\t_context.setLineDash = function ( values ) {\n\n\t\t\t\t_context.mozDash = values[ 0 ] !== null ? values : null;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t_context.setLineDash = function () {}\n\n\t\t}\n\n\t}\n\n\tthis.domElement = _canvas;\n\n\tthis.devicePixelRatio = parameters.devicePixelRatio !== undefined\n\t\t\t\t? parameters.devicePixelRatio\n\t\t\t\t: window.devicePixelRatio !== undefined\n\t\t\t\t\t? window.devicePixelRatio\n\t\t\t\t\t: 1;\n\n\tthis.autoClear = true;\n\tthis.sortObjects = true;\n\tthis.sortElements = true;\n\n\tthis.info = {\n\n\t\trender: {\n\n\t\t\tvertices: 0,\n\t\t\tfaces: 0\n\n\t\t}\n\n\t}\n\n\t// WebGLRenderer compatibility\n\n\tthis.supportsVertexTextures = function () {};\n\tthis.setFaceCulling = function () {};\n\n\tthis.setSize = function ( width, height ) {\n\n\t\t_canvasWidth = width * this.devicePixelRatio;\n\t\t_canvasHeight = height * this.devicePixelRatio;\n\n\t\t_canvasWidthHalf = Math.floor( _canvasWidth / 2 );\n\t\t_canvasHeightHalf = Math.floor( _canvasHeight / 2 );\n\n\t\t_canvas.width = _canvasWidth;\n\t\t_canvas.height = _canvasHeight;\n\n\t\t_canvas.style.width = width + 'px';\n\t\t_canvas.style.height = height + 'px';\n\n\t\t_clipBox.set(\n\t\t\tnew THREE.Vector2( - _canvasWidthHalf, - _canvasHeightHalf ),\n\t\t\tnew THREE.Vector2( _canvasWidthHalf, _canvasHeightHalf )\n\t\t);\n\n\t\t_clearBox.set(\n\t\t\tnew THREE.Vector2( - _canvasWidthHalf, - _canvasHeightHalf ),\n\t\t\tnew THREE.Vector2( _canvasWidthHalf, _canvasHeightHalf )\n\t\t);\n\n\t\t_contextGlobalAlpha = 1;\n\t\t_contextGlobalCompositeOperation = 0;\n\t\t_contextStrokeStyle = null;\n\t\t_contextFillStyle = null;\n\t\t_contextLineWidth = null;\n\t\t_contextLineCap = null;\n\t\t_contextLineJoin = null;\n\n\t};\n\n\tthis.setClearColor = function ( color, opacity ) {\n\n\t\t_clearColor.copy( color );\n\t\t_clearOpacity = opacity !== undefined ? opacity : 1;\n\n\t\t_clearBox.set(\n\t\t\tnew THREE.Vector2( - _canvasWidthHalf, - _canvasHeightHalf ),\n\t\t\tnew THREE.Vector2( _canvasWidthHalf, _canvasHeightHalf )\n\t\t);\n\n\t};\n\n\tthis.setClearColorHex = function ( hex, opacity ) {\n\n\t\t_clearColor.setHex( hex );\n\t\t_clearOpacity = opacity !== undefined ? opacity : 1;\n\n\t\t_clearBox.set(\n\t\t\tnew THREE.Vector2( - _canvasWidthHalf, - _canvasHeightHalf ),\n\t\t\tnew THREE.Vector2( _canvasWidthHalf, _canvasHeightHalf )\n\t\t);\n\n\t};\n\n\tthis.getMaxAnisotropy  = function () {\n\n\t\treturn 0;\n\n\t};\n\n\tthis.clear = function () {\n\n\t\t_context.setTransform( 1, 0, 0, - 1, _canvasWidthHalf, _canvasHeightHalf );\n\n\t\tif ( _clearBox.empty() === false ) {\n\n\t\t\t_clearBox.intersect( _clipBox );\n\t\t\t_clearBox.expandByScalar( 2 );\n\n\t\t\tif ( _clearOpacity < 1 ) {\n\n\t\t\t\t_context.clearRect(\n\t\t\t\t\t_clearBox.min.x | 0,\n\t\t\t\t\t_clearBox.min.y | 0,\n\t\t\t\t\t( _clearBox.max.x - _clearBox.min.x ) | 0,\n\t\t\t\t\t( _clearBox.max.y - _clearBox.min.y ) | 0\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tif ( _clearOpacity > 0 ) {\n\n\t\t\t\tsetBlending( THREE.NormalBlending );\n\t\t\t\tsetOpacity( 1 );\n\n\t\t\t\tsetFillStyle( 'rgba(' + Math.floor( _clearColor.r * 255 ) + ',' + Math.floor( _clearColor.g * 255 ) + ',' + Math.floor( _clearColor.b * 255 ) + ',' + _clearOpacity + ')' );\n\n\t\t\t\t_context.fillRect(\n\t\t\t\t\t_clearBox.min.x | 0,\n\t\t\t\t\t_clearBox.min.y | 0,\n\t\t\t\t\t( _clearBox.max.x - _clearBox.min.x ) | 0,\n\t\t\t\t\t( _clearBox.max.y - _clearBox.min.y ) | 0\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\t_clearBox.makeEmpty();\n\n\t\t}\n\n\n\t};\n\n\tthis.render = function ( scene, camera ) {\n\n\t\tif ( camera instanceof THREE.Camera === false ) {\n\n\t\t\tconsole.error( 'THREE.CanvasRenderer.render: camera is not an instance of THREE.Camera.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( this.autoClear === true ) {\n\n\t\t\tthis.clear();\n\n\t\t}\n\n\t\t_context.setTransform( 1, 0, 0, - 1, _canvasWidthHalf, _canvasHeightHalf );\n\n\t\t_this.info.render.vertices = 0;\n\t\t_this.info.render.faces = 0;\n\n\t\t_renderData = _projector.projectScene( scene, camera, this.sortObjects, this.sortElements );\n\t\t_elements = _renderData.elements;\n\t\t_lights = _renderData.lights;\n\n\t\t/* DEBUG\n\t\tsetFillStyle( 'rgba( 0, 255, 255, 0.5 )' );\n\t\t_context.fillRect( _clipBox.min.x, _clipBox.min.y, _clipBox.max.x - _clipBox.min.x, _clipBox.max.y - _clipBox.min.y );\n\t\t*/\n\n\t\t_enableLighting = _lights.length > 0;\n\n\t\tif ( _enableLighting === true ) {\n\n\t\t\t calculateLights();\n\n\t\t}\n\n\t\tfor ( var e = 0, el = _elements.length; e < el; e++ ) {\n\n\t\t\tvar element = _elements[ e ];\n\n\t\t\tvar material = element.material;\n\n\t\t\tif ( material === undefined || material.visible === false ) continue;\n\n\t\t\t_elemBox.makeEmpty();\n\n\t\t\tif ( element instanceof THREE.RenderableParticle ) {\n\n\t\t\t\t_v1 = element;\n\t\t\t\t_v1.x *= _canvasWidthHalf; _v1.y *= _canvasHeightHalf;\n\n\t\t\t\trenderParticle( _v1, element, material );\n\n\t\t\t} else if ( element instanceof THREE.RenderableLine ) {\n\n\t\t\t\t_v1 = element.v1; _v2 = element.v2;\n\n\t\t\t\t_v1.positionScreen.x *= _canvasWidthHalf; _v1.positionScreen.y *= _canvasHeightHalf;\n\t\t\t\t_v2.positionScreen.x *= _canvasWidthHalf; _v2.positionScreen.y *= _canvasHeightHalf;\n\n\t\t\t\t_elemBox.setFromPoints( [ _v1.positionScreen, _v2.positionScreen ] );\n\n\t\t\t\tif ( _clipBox.isIntersectionBox( _elemBox ) === true ) {\n\n\t\t\t\t\trenderLine( _v1, _v2, element, material );\n\n\t\t\t\t}\n\n\t\t\t} else if ( element instanceof THREE.RenderableFace3 ) {\n\n\t\t\t\t_v1 = element.v1; _v2 = element.v2; _v3 = element.v3;\n\n\t\t\t\tif ( _v1.positionScreen.z < -1 || _v1.positionScreen.z > 1 ) continue;\n\t\t\t\tif ( _v2.positionScreen.z < -1 || _v2.positionScreen.z > 1 ) continue;\n\t\t\t\tif ( _v3.positionScreen.z < -1 || _v3.positionScreen.z > 1 ) continue;\n\n\t\t\t\t_v1.positionScreen.x *= _canvasWidthHalf; _v1.positionScreen.y *= _canvasHeightHalf;\n\t\t\t\t_v2.positionScreen.x *= _canvasWidthHalf; _v2.positionScreen.y *= _canvasHeightHalf;\n\t\t\t\t_v3.positionScreen.x *= _canvasWidthHalf; _v3.positionScreen.y *= _canvasHeightHalf;\n\n\t\t\t\tif ( material.overdraw === true ) {\n\n\t\t\t\t\texpand( _v1.positionScreen, _v2.positionScreen );\n\t\t\t\t\texpand( _v2.positionScreen, _v3.positionScreen );\n\t\t\t\t\texpand( _v3.positionScreen, _v1.positionScreen );\n\n\t\t\t\t}\n\n\t\t\t\t_elemBox.setFromPoints( [ _v1.positionScreen, _v2.positionScreen, _v3.positionScreen ] );\n\n\t\t\t\trenderFace3( _v1, _v2, _v3, 0, 1, 2, element, material );\n\n\t\t\t} else if ( element instanceof THREE.RenderableFace4 ) {\n\n\t\t\t\t_v1 = element.v1; _v2 = element.v2; _v3 = element.v3; _v4 = element.v4;\n\n\t\t\t\tif ( _v1.positionScreen.z < -1 || _v1.positionScreen.z > 1 ) continue;\n\t\t\t\tif ( _v2.positionScreen.z < -1 || _v2.positionScreen.z > 1 ) continue;\n\t\t\t\tif ( _v3.positionScreen.z < -1 || _v3.positionScreen.z > 1 ) continue;\n\t\t\t\tif ( _v4.positionScreen.z < -1 || _v4.positionScreen.z > 1 ) continue;\n\n\t\t\t\t_v1.positionScreen.x *= _canvasWidthHalf; _v1.positionScreen.y *= _canvasHeightHalf;\n\t\t\t\t_v2.positionScreen.x *= _canvasWidthHalf; _v2.positionScreen.y *= _canvasHeightHalf;\n\t\t\t\t_v3.positionScreen.x *= _canvasWidthHalf; _v3.positionScreen.y *= _canvasHeightHalf;\n\t\t\t\t_v4.positionScreen.x *= _canvasWidthHalf; _v4.positionScreen.y *= _canvasHeightHalf;\n\n\t\t\t\t_v5.positionScreen.copy( _v2.positionScreen );\n\t\t\t\t_v6.positionScreen.copy( _v4.positionScreen );\n\n\t\t\t\tif ( material.overdraw === true ) {\n\n\t\t\t\t\texpand( _v1.positionScreen, _v2.positionScreen );\n\t\t\t\t\texpand( _v2.positionScreen, _v4.positionScreen );\n\t\t\t\t\texpand( _v4.positionScreen, _v1.positionScreen );\n\n\t\t\t\t\texpand( _v3.positionScreen, _v5.positionScreen );\n\t\t\t\t\texpand( _v3.positionScreen, _v6.positionScreen );\n\n\t\t\t\t}\n\n\t\t\t\t_elemBox.setFromPoints( [ _v1.positionScreen, _v2.positionScreen, _v3.positionScreen, _v4.positionScreen ] );\n\n\t\t\t\trenderFace4( _v1, _v2, _v3, _v4, _v5, _v6, element, material, scene );\n\n\t\t\t}\n\n\t\t\t/* DEBUG\n\t\t\tsetLineWidth( 1 );\n\t\t\tsetStrokeStyle( 'rgba( 0, 255, 0, 0.5 )' );\n\t\t\t_context.strokeRect( _elemBox.min.x, _elemBox.min.y, _elemBox.max.x - _elemBox.min.x, _elemBox.max.y - _elemBox.min.y );\n\t\t\t*/\n\n\t\t\t_clearBox.union( _elemBox );\n\n\t\t}\n\n\t\t/* DEBUG\n\t\tsetLineWidth( 1 );\n\t\tsetStrokeStyle( 'rgba( 255, 0, 0, 0.5 )' );\n\t\t_context.strokeRect( _clearBox.min.x, _clearBox.min.y, _clearBox.max.x - _clearBox.min.x, _clearBox.max.y - _clearBox.min.y );\n\t\t*/\n\n\t\t_context.setTransform( 1, 0, 0, 1, 0, 0 );\n\n\t\t//\n\n\t\tfunction calculateLights() {\n\n\t\t\t_ambientLight.setRGB( 0, 0, 0 );\n\t\t\t_directionalLights.setRGB( 0, 0, 0 );\n\t\t\t_pointLights.setRGB( 0, 0, 0 );\n\n\t\t\tfor ( var l = 0, ll = _lights.length; l < ll; l ++ ) {\n\n\t\t\t\tvar light = _lights[ l ];\n\t\t\t\tvar lightColor = light.color;\n\n\t\t\t\tif ( light instanceof THREE.AmbientLight ) {\n\n\t\t\t\t\t_ambientLight.add( lightColor );\n\n\t\t\t\t} else if ( light instanceof THREE.DirectionalLight ) {\n\n\t\t\t\t\t// for particles\n\n\t\t\t\t\t_directionalLights.add( lightColor );\n\n\t\t\t\t} else if ( light instanceof THREE.PointLight ) {\n\n\t\t\t\t\t// for particles\n\n\t\t\t\t\t_pointLights.add( lightColor );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction calculateLight( position, normal, color ) {\n\n\t\t\tfor ( var l = 0, ll = _lights.length; l < ll; l ++ ) {\n\n\t\t\t\tvar light = _lights[ l ];\n\n\t\t\t\t_lightColor.copy( light.color );\n\n\t\t\t\tif ( light instanceof THREE.DirectionalLight ) {\n\n\t\t\t\t\tvar lightPosition = _vector3.getPositionFromMatrix( light.matrixWorld ).normalize();\n\n\t\t\t\t\tvar amount = normal.dot( lightPosition );\n\n\t\t\t\t\tif ( amount <= 0 ) continue;\n\n\t\t\t\t\tamount *= light.intensity;\n\n\t\t\t\t\tcolor.add( _lightColor.multiplyScalar( amount ) );\n\n\t\t\t\t} else if ( light instanceof THREE.PointLight ) {\n\n\t\t\t\t\tvar lightPosition = _vector3.getPositionFromMatrix( light.matrixWorld );\n\n\t\t\t\t\tvar amount = normal.dot( _vector3.subVectors( lightPosition, position ).normalize() );\n\n\t\t\t\t\tif ( amount <= 0 ) continue;\n\n\t\t\t\t\tamount *= light.distance == 0 ? 1 : 1 - Math.min( position.distanceTo( lightPosition ) / light.distance, 1 );\n\n\t\t\t\t\tif ( amount == 0 ) continue;\n\n\t\t\t\t\tamount *= light.intensity;\n\n\t\t\t\t\tcolor.add( _lightColor.multiplyScalar( amount ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction renderParticle( v1, element, material ) {\n\n\t\t\tsetOpacity( material.opacity );\n\t\t\tsetBlending( material.blending );\n\n\t\t\tvar width, height, scaleX, scaleY,\n\t\t\tbitmap, bitmapWidth, bitmapHeight;\n\n\t\t\tif ( material instanceof THREE.ParticleBasicMaterial ) {\n\n\t\t\t\tif ( material.map === null ) {\n\n\t\t\t\t\tscaleX = element.object.scale.x;\n\t\t\t\t\tscaleY = element.object.scale.y;\n\n\t\t\t\t\t// TODO: Be able to disable this\n\n\t\t\t\t\tscaleX *= element.scale.x * _canvasWidthHalf;\n\t\t\t\t\tscaleY *= element.scale.y * _canvasHeightHalf;\n\n\t\t\t\t\t_elemBox.min.set( v1.x - scaleX, v1.y - scaleY );\n\t\t\t\t\t_elemBox.max.set( v1.x + scaleX, v1.y + scaleY );\n\n\t\t\t\t\tif ( _clipBox.isIntersectionBox( _elemBox ) === false ) {\n\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tsetFillStyle( material.color.getStyle() );\n\n\t\t\t\t\t_context.save();\n\t\t\t\t\t_context.translate( v1.x, v1.y );\n\t\t\t\t\t_context.rotate( - element.rotation );\n\t\t\t\t\t_context.scale( scaleX, scaleY );\n\t\t\t\t\t_context.fillRect( -1, -1, 2, 2 );\n\t\t\t\t\t_context.restore();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbitmap = material.map.image;\n\t\t\t\t\tbitmapWidth = bitmap.width >> 1;\n\t\t\t\t\tbitmapHeight = bitmap.height >> 1;\n\n\t\t\t\t\tscaleX = element.scale.x * _canvasWidthHalf;\n\t\t\t\t\tscaleY = element.scale.y * _canvasHeightHalf;\n\n\t\t\t\t\twidth = scaleX * bitmapWidth;\n\t\t\t\t\theight = scaleY * bitmapHeight;\n\n\t\t\t\t\t// TODO: Rotations break this...\n\n\t\t\t\t\t_elemBox.min.set( v1.x - width, v1.y - height );\n\t\t\t\t\t_elemBox.max.set( v1.x + width, v1.y + height );\n\n\t\t\t\t\tif ( _clipBox.isIntersectionBox( _elemBox ) === false ) {\n\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_context.save();\n\t\t\t\t\t_context.translate( v1.x, v1.y );\n\t\t\t\t\t_context.rotate( - element.rotation );\n\t\t\t\t\t_context.scale( scaleX, - scaleY );\n\n\t\t\t\t\t_context.translate( - bitmapWidth, - bitmapHeight );\n\t\t\t\t\t_context.drawImage( bitmap, 0, 0 );\n\t\t\t\t\t_context.restore();\n\n\t\t\t\t}\n\n\t\t\t\t/* DEBUG\n\t\t\t\tsetStrokeStyle( 'rgb(255,255,0)' );\n\t\t\t\t_context.beginPath();\n\t\t\t\t_context.moveTo( v1.x - 10, v1.y );\n\t\t\t\t_context.lineTo( v1.x + 10, v1.y );\n\t\t\t\t_context.moveTo( v1.x, v1.y - 10 );\n\t\t\t\t_context.lineTo( v1.x, v1.y + 10 );\n\t\t\t\t_context.stroke();\n\t\t\t\t*/\n\n\t\t\t} else if ( material instanceof THREE.ParticleCanvasMaterial ) {\n\n\t\t\t\twidth = element.scale.x * _canvasWidthHalf;\n\t\t\t\theight = element.scale.y * _canvasHeightHalf;\n\n\t\t\t\t_elemBox.min.set( v1.x - width, v1.y - height );\n\t\t\t\t_elemBox.max.set( v1.x + width, v1.y + height );\n\n\t\t\t\tif ( _clipBox.isIntersectionBox( _elemBox ) === false ) {\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tsetStrokeStyle( material.color.getStyle() );\n\t\t\t\tsetFillStyle( material.color.getStyle() );\n\n\t\t\t\t_context.save();\n\t\t\t\t_context.translate( v1.x, v1.y );\n\t\t\t\t_context.rotate( - element.rotation );\n\t\t\t\t_context.scale( width, height );\n\n\t\t\t\tmaterial.program( _context );\n\n\t\t\t\t_context.restore();\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction renderLine( v1, v2, element, material ) {\n\n\t\t\tsetOpacity( material.opacity );\n\t\t\tsetBlending( material.blending );\n\n\t\t\t_context.beginPath();\n\t\t\t_context.moveTo( v1.positionScreen.x, v1.positionScreen.y );\n\t\t\t_context.lineTo( v2.positionScreen.x, v2.positionScreen.y );\n\n\t\t\tif ( material instanceof THREE.LineBasicMaterial ) {\n\n\t\t\t\tsetLineWidth( material.linewidth );\n\t\t\t\tsetLineCap( material.linecap );\n\t\t\t\tsetLineJoin( material.linejoin );\n\t\t\t\tsetStrokeStyle( material.color.getStyle() );\n\t\t\t\tsetDashAndGap( null, null );\n\n\t\t\t\t_context.stroke();\n\t\t\t\t_elemBox.expandByScalar( material.linewidth * 2 );\n\n\t\t\t} else if ( material instanceof THREE.LineDashedMaterial ) {\n\n\t\t\t\tsetLineWidth( material.linewidth );\n\t\t\t\tsetLineCap( material.linecap );\n\t\t\t\tsetLineJoin( material.linejoin );\n\t\t\t\tsetStrokeStyle( material.color.getStyle() );\n\t\t\t\tsetDashAndGap( material.dashSize, material.gapSize );\n\n\t\t\t\t_context.stroke();\n\t\t\t\t_elemBox.expandByScalar( material.linewidth * 2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction renderFace3( v1, v2, v3, uv1, uv2, uv3, element, material ) {\n\n\t\t\t_this.info.render.vertices += 3;\n\t\t\t_this.info.render.faces ++;\n\n\t\t\tsetOpacity( material.opacity );\n\t\t\tsetBlending( material.blending );\n\n\t\t\t_v1x = v1.positionScreen.x; _v1y = v1.positionScreen.y;\n\t\t\t_v2x = v2.positionScreen.x; _v2y = v2.positionScreen.y;\n\t\t\t_v3x = v3.positionScreen.x; _v3y = v3.positionScreen.y;\n\n\t\t\tdrawTriangle( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y );\n\n\t\t\tif ( ( material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial ) && material.map === null ) {\n\n\t\t\t\t_diffuseColor.copy( material.color );\n\t\t\t\t_emissiveColor.copy( material.emissive );\n\n\t\t\t\tif ( material.vertexColors === THREE.FaceColors ) {\n\n\t\t\t\t\t_diffuseColor.multiply( element.color );\n\n\t\t\t\t}\n\n\t\t\t\tif ( _enableLighting === true ) {\n\n\t\t\t\t\tif ( material.wireframe === false && material.shading == THREE.SmoothShading && element.vertexNormalsLength == 3 ) {\n\n\t\t\t\t\t\t_color1.copy( _ambientLight );\n\t\t\t\t\t\t_color2.copy( _ambientLight );\n\t\t\t\t\t\t_color3.copy( _ambientLight );\n\n\t\t\t\t\t\tcalculateLight( element.v1.positionWorld, element.vertexNormalsModel[ 0 ], _color1 );\n\t\t\t\t\t\tcalculateLight( element.v2.positionWorld, element.vertexNormalsModel[ 1 ], _color2 );\n\t\t\t\t\t\tcalculateLight( element.v3.positionWorld, element.vertexNormalsModel[ 2 ], _color3 );\n\n\t\t\t\t\t\t_color1.multiply( _diffuseColor ).add( _emissiveColor );\n\t\t\t\t\t\t_color2.multiply( _diffuseColor ).add( _emissiveColor );\n\t\t\t\t\t\t_color3.multiply( _diffuseColor ).add( _emissiveColor );\n\t\t\t\t\t\t_color4.addColors( _color2, _color3 ).multiplyScalar( 0.5 );\n\n\t\t\t\t\t\t_image = getGradientTexture( _color1, _color2, _color3, _color4 );\n\n\t\t\t\t\t\tclipImage( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, 0, 0, 1, 0, 0, 1, _image );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_color.copy( _ambientLight );\n\n\t\t\t\t\t\tcalculateLight( element.centroidModel, element.normalModel, _color );\n\n\t\t\t\t\t\t_color.multiply( _diffuseColor ).add( _emissiveColor );\n\n\t\t\t\t\t\tmaterial.wireframe === true\n\t\t\t\t\t\t\t? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )\n\t\t\t\t\t\t\t: fillPath( _color );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmaterial.wireframe === true\n\t\t\t\t\t\t? strokePath( material.color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )\n\t\t\t\t\t\t: fillPath( material.color );\n\n\t\t\t\t}\n\n\t\t\t} else if ( material instanceof THREE.MeshBasicMaterial || material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial ) {\n\n\t\t\t\tif ( material.map !== null ) {\n\n\t\t\t\t\tif ( material.map.mapping instanceof THREE.UVMapping ) {\n\n\t\t\t\t\t\t_uvs = element.uvs[ 0 ];\n\t\t\t\t\t\tpatternPath( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _uvs[ uv1 ].x, _uvs[ uv1 ].y, _uvs[ uv2 ].x, _uvs[ uv2 ].y, _uvs[ uv3 ].x, _uvs[ uv3 ].y, material.map );\n\n\t\t\t\t\t}\n\n\n\t\t\t\t} else if ( material.envMap !== null ) {\n\n\t\t\t\t\tif ( material.envMap.mapping instanceof THREE.SphericalReflectionMapping ) {\n\n\t\t\t\t\t\t_vector3.copy( element.vertexNormalsModelView[ uv1 ] );\n\t\t\t\t\t\t_uv1x = 0.5 * _vector3.x + 0.5;\n\t\t\t\t\t\t_uv1y = 0.5 * _vector3.y + 0.5;\n\n\t\t\t\t\t\t_vector3.copy( element.vertexNormalsModelView[ uv2 ] );\n\t\t\t\t\t\t_uv2x = 0.5 * _vector3.x + 0.5;\n\t\t\t\t\t\t_uv2y = 0.5 * _vector3.y + 0.5;\n\n\t\t\t\t\t\t_vector3.copy( element.vertexNormalsModelView[ uv3 ] );\n\t\t\t\t\t\t_uv3x = 0.5 * _vector3.x + 0.5;\n\t\t\t\t\t\t_uv3y = 0.5 * _vector3.y + 0.5;\n\n\t\t\t\t\t\tpatternPath( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _uv1x, _uv1y, _uv2x, _uv2y, _uv3x, _uv3y, material.envMap );\n\n\t\t\t\t\t}/* else if ( material.envMap.mapping == THREE.SphericalRefractionMapping ) {\n\n\n\n\t\t\t\t\t}*/\n\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_color.copy( material.color );\n\n\t\t\t\t\tif ( material.vertexColors === THREE.FaceColors ) {\n\n\t\t\t\t\t\t_color.multiply( element.color );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmaterial.wireframe === true\n\t\t\t\t\t\t? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )\n\t\t\t\t\t\t: fillPath( _color );\n\n\t\t\t\t}\n\n\t\t\t} else if ( material instanceof THREE.MeshDepthMaterial ) {\n\n\t\t\t\t_near = camera.near;\n\t\t\t\t_far = camera.far;\n\n\t\t\t\t_color1.r = _color1.g = _color1.b = 1 - smoothstep( v1.positionScreen.z * v1.positionScreen.w, _near, _far );\n\t\t\t\t_color2.r = _color2.g = _color2.b = 1 - smoothstep( v2.positionScreen.z * v2.positionScreen.w, _near, _far );\n\t\t\t\t_color3.r = _color3.g = _color3.b = 1 - smoothstep( v3.positionScreen.z * v3.positionScreen.w, _near, _far );\n\t\t\t\t_color4.addColors( _color2, _color3 ).multiplyScalar( 0.5 );\n\n\t\t\t\t_image = getGradientTexture( _color1, _color2, _color3, _color4 );\n\n\t\t\t\tclipImage( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, 0, 0, 1, 0, 0, 1, _image );\n\n\t\t\t} else if ( material instanceof THREE.MeshNormalMaterial ) {\n\n\t\t\t\tvar normal;\n\n\t\t\t\tif ( material.shading == THREE.FlatShading ) {\n\n\t\t\t\t\tnormal = element.normalModelView;\n\n\t\t\t\t\t_color.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );\n\n\t\t\t\t\tmaterial.wireframe === true\n\t\t\t\t\t\t? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )\n\t\t\t\t\t\t: fillPath( _color );\n\n\t\t\t\t} else if ( material.shading == THREE.SmoothShading ) {\n\n\t\t\t\t\tnormal = element.vertexNormalsModelView[ uv1 ];\n\t\t\t\t\t_color1.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );\n\n\t\t\t\t\tnormal = element.vertexNormalsModelView[ uv2 ];\n\t\t\t\t\t_color2.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );\n\n\t\t\t\t\tnormal = element.vertexNormalsModelView[ uv3 ];\n\t\t\t\t\t_color3.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );\n\n\t\t\t\t\t_color4.addColors( _color2, _color3 ).multiplyScalar( 0.5 );\n\n\t\t\t\t\t_image = getGradientTexture( _color1, _color2, _color3, _color4 );\n\n\t\t\t\t\tclipImage( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, 0, 0, 1, 0, 0, 1, _image );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction renderFace4( v1, v2, v3, v4, v5, v6, element, material ) {\n\n\t\t\t_this.info.render.vertices += 4;\n\t\t\t_this.info.render.faces ++;\n\n\t\t\tsetOpacity( material.opacity );\n\t\t\tsetBlending( material.blending );\n\n\t\t\tif ( ( material.map !== undefined && material.map !== null ) || ( material.envMap !== undefined && material.envMap !== null ) ) {\n\n\t\t\t\t// Let renderFace3() handle this\n\n\t\t\t\trenderFace3( v1, v2, v4, 0, 1, 3, element, material );\n\t\t\t\trenderFace3( v5, v3, v6, 1, 2, 3, element, material );\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\t_v1x = v1.positionScreen.x; _v1y = v1.positionScreen.y;\n\t\t\t_v2x = v2.positionScreen.x; _v2y = v2.positionScreen.y;\n\t\t\t_v3x = v3.positionScreen.x; _v3y = v3.positionScreen.y;\n\t\t\t_v4x = v4.positionScreen.x; _v4y = v4.positionScreen.y;\n\t\t\t_v5x = v5.positionScreen.x; _v5y = v5.positionScreen.y;\n\t\t\t_v6x = v6.positionScreen.x; _v6y = v6.positionScreen.y;\n\n\t\t\tif ( material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial ) {\n\n\t\t\t\t_diffuseColor.copy( material.color );\n\t\t\t\t_emissiveColor.copy( material.emissive );\n\n\t\t\t\tif ( material.vertexColors === THREE.FaceColors ) {\n\n\t\t\t\t\t_diffuseColor.multiply( element.color );\n\n\t\t\t\t}\n\n\t\t\t\tif ( _enableLighting === true ) {\n\n\t\t\t\t\tif ( material.wireframe === false && material.shading == THREE.SmoothShading && element.vertexNormalsLength == 4 ) {\n\n\t\t\t\t\t\t_color1.copy( _ambientLight );\n\t\t\t\t\t\t_color2.copy( _ambientLight );\n\t\t\t\t\t\t_color3.copy( _ambientLight );\n\t\t\t\t\t\t_color4.copy( _ambientLight );\n\n\t\t\t\t\t\tcalculateLight( element.v1.positionWorld, element.vertexNormalsModel[ 0 ], _color1 );\n\t\t\t\t\t\tcalculateLight( element.v2.positionWorld, element.vertexNormalsModel[ 1 ], _color2 );\n\t\t\t\t\t\tcalculateLight( element.v4.positionWorld, element.vertexNormalsModel[ 3 ], _color3 );\n\t\t\t\t\t\tcalculateLight( element.v3.positionWorld, element.vertexNormalsModel[ 2 ], _color4 );\n\n\t\t\t\t\t\t_color1.multiply( _diffuseColor ).add( _emissiveColor );\n\t\t\t\t\t\t_color2.multiply( _diffuseColor ).add( _emissiveColor );\n\t\t\t\t\t\t_color3.multiply( _diffuseColor ).add( _emissiveColor );\n\t\t\t\t\t\t_color4.multiply( _diffuseColor ).add( _emissiveColor );\n\n\t\t\t\t\t\t_image = getGradientTexture( _color1, _color2, _color3, _color4 );\n\n\t\t\t\t\t\t// TODO: UVs are incorrect, v4->v3?\n\n\t\t\t\t\t\tdrawTriangle( _v1x, _v1y, _v2x, _v2y, _v4x, _v4y );\n\t\t\t\t\t\tclipImage( _v1x, _v1y, _v2x, _v2y, _v4x, _v4y, 0, 0, 1, 0, 0, 1, _image );\n\n\t\t\t\t\t\tdrawTriangle( _v5x, _v5y, _v3x, _v3y, _v6x, _v6y );\n\t\t\t\t\t\tclipImage( _v5x, _v5y, _v3x, _v3y, _v6x, _v6y, 1, 0, 1, 1, 0, 1, _image );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_color.copy( _ambientLight );\n\n\t\t\t\t\t\tcalculateLight( element.centroidModel, element.normalModel, _color );\n\n\t\t\t\t\t\t_color.multiply( _diffuseColor ).add( _emissiveColor );\n\n\t\t\t\t\t\tdrawQuad( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _v4x, _v4y );\n\n\t\t\t\t\t\tmaterial.wireframe === true\n\t\t\t\t\t\t\t? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )\n\t\t\t\t\t\t\t: fillPath( _color );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_color.addColors( _diffuseColor, _emissiveColor );\n\n\t\t\t\t\tdrawQuad( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _v4x, _v4y );\n\n\t\t\t\t\tmaterial.wireframe === true\n\t\t\t\t\t\t? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )\n\t\t\t\t\t\t: fillPath( _color );\n\n\t\t\t\t}\n\n\t\t\t} else if ( material instanceof THREE.MeshBasicMaterial ) {\n\n\t\t\t\t_color.copy( material.color );\n\n\t\t\t\tif ( material.vertexColors === THREE.FaceColors ) {\n\n\t\t\t\t\t_color.multiply( element.color );\n\n\t\t\t\t}\n\n\t\t\t\tdrawQuad( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _v4x, _v4y );\n\n\t\t\t\tmaterial.wireframe === true\n\t\t\t\t\t? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )\n\t\t\t\t\t: fillPath( _color );\n\n\t\t\t} else if ( material instanceof THREE.MeshNormalMaterial ) {\n\n\t\t\t\tvar normal;\n\n\t\t\t\tif ( material.shading == THREE.FlatShading ) {\n\n\t\t\t\t\tnormal = element.normalModelView;\n\t\t\t\t\t_color.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );\n\n\t\t\t\t\tdrawQuad( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _v4x, _v4y );\n\n\t\t\t\t\tmaterial.wireframe === true\n\t\t\t\t\t\t? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )\n\t\t\t\t\t\t: fillPath( _color );\n\n\t\t\t\t} else if ( material.shading == THREE.SmoothShading ) {\n\n\t\t\t\t\tnormal = element.vertexNormalsModelView[ 0 ];\n\t\t\t\t\t_color1.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );\n\n\t\t\t\t\tnormal = element.vertexNormalsModelView[ 1 ];\n\t\t\t\t\t_color2.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );\n\n\t\t\t\t\tnormal = element.vertexNormalsModelView[ 3 ];\n\t\t\t\t\t_color3.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );\n\n\t\t\t\t\tnormal = element.vertexNormalsModelView[ 2 ];\n\t\t\t\t\t_color4.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );\n\n\t\t\t\t\t_image = getGradientTexture( _color1, _color2, _color3, _color4 );\n\n\t\t\t\t\tdrawTriangle( _v1x, _v1y, _v2x, _v2y, _v4x, _v4y );\n\t\t\t\t\tclipImage( _v1x, _v1y, _v2x, _v2y, _v4x, _v4y, 0, 0, 1, 0, 0, 1, _image );\n\n\t\t\t\t\tdrawTriangle( _v5x, _v5y, _v3x, _v3y, _v6x, _v6y );\n\t\t\t\t\tclipImage( _v5x, _v5y, _v3x, _v3y, _v6x, _v6y, 1, 0, 1, 1, 0, 1, _image );\n\n\t\t\t\t}\n\n\n\n\t\t\t} else if ( material instanceof THREE.MeshDepthMaterial ) {\n\n\t\t\t\t_near = camera.near;\n\t\t\t\t_far = camera.far;\n\n\t\t\t\t_color1.r = _color1.g = _color1.b = 1 - smoothstep( v1.positionScreen.z * v1.positionScreen.w, _near, _far );\n\t\t\t\t_color2.r = _color2.g = _color2.b = 1 - smoothstep( v2.positionScreen.z * v2.positionScreen.w, _near, _far );\n\t\t\t\t_color3.r = _color3.g = _color3.b = 1 - smoothstep( v4.positionScreen.z * v4.positionScreen.w, _near, _far );\n\t\t\t\t_color4.r = _color4.g = _color4.b = 1 - smoothstep( v3.positionScreen.z * v3.positionScreen.w, _near, _far );\n\n\t\t\t\t_image = getGradientTexture( _color1, _color2, _color3, _color4 );\n\n\t\t\t\t// TODO: UVs are incorrect, v4->v3?\n\n\t\t\t\tdrawTriangle( _v1x, _v1y, _v2x, _v2y, _v4x, _v4y );\n\t\t\t\tclipImage( _v1x, _v1y, _v2x, _v2y, _v4x, _v4y, 0, 0, 1, 0, 0, 1, _image );\n\n\t\t\t\tdrawTriangle( _v5x, _v5y, _v3x, _v3y, _v6x, _v6y );\n\t\t\t\tclipImage( _v5x, _v5y, _v3x, _v3y, _v6x, _v6y, 1, 0, 1, 1, 0, 1, _image );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tfunction drawTriangle( x0, y0, x1, y1, x2, y2 ) {\n\n\t\t\t_context.beginPath();\n\t\t\t_context.moveTo( x0, y0 );\n\t\t\t_context.lineTo( x1, y1 );\n\t\t\t_context.lineTo( x2, y2 );\n\t\t\t_context.closePath();\n\n\t\t}\n\n\t\tfunction drawQuad( x0, y0, x1, y1, x2, y2, x3, y3 ) {\n\n\t\t\t_context.beginPath();\n\t\t\t_context.moveTo( x0, y0 );\n\t\t\t_context.lineTo( x1, y1 );\n\t\t\t_context.lineTo( x2, y2 );\n\t\t\t_context.lineTo( x3, y3 );\n\t\t\t_context.closePath();\n\n\t\t}\n\n\t\tfunction strokePath( color, linewidth, linecap, linejoin ) {\n\n\t\t\tsetLineWidth( linewidth );\n\t\t\tsetLineCap( linecap );\n\t\t\tsetLineJoin( linejoin );\n\t\t\tsetStrokeStyle( color.getStyle() );\n\n\t\t\t_context.stroke();\n\n\t\t\t_elemBox.expandByScalar( linewidth * 2 );\n\n\t\t}\n\n\t\tfunction fillPath( color ) {\n\n\t\t\tsetFillStyle( color.getStyle() );\n\t\t\t_context.fill();\n\n\t\t}\n\n\t\tfunction patternPath( x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, u2, v2, texture ) {\n\n\t\t\tif ( texture instanceof THREE.DataTexture || texture.image === undefined || texture.image.width == 0 ) return;\n\n\t\t\tif ( texture.needsUpdate === true ) {\n\n\t\t\t\tvar repeatX = texture.wrapS == THREE.RepeatWrapping;\n\t\t\t\tvar repeatY = texture.wrapT == THREE.RepeatWrapping;\n\n\t\t\t\t_patterns[ texture.id ] = _context.createPattern(\n\t\t\t\t\ttexture.image, repeatX === true && repeatY === true\n\t\t\t\t\t\t? 'repeat'\n\t\t\t\t\t\t: repeatX === true && repeatY === false\n\t\t\t\t\t\t\t? 'repeat-x'\n\t\t\t\t\t\t\t: repeatX === false && repeatY === true\n\t\t\t\t\t\t\t\t? 'repeat-y'\n\t\t\t\t\t\t\t\t: 'no-repeat'\n\t\t\t\t);\n\n\t\t\t\ttexture.needsUpdate = false;\n\n\t\t\t}\n\n\t\t\t_patterns[ texture.id ] === undefined\n\t\t\t\t? setFillStyle( 'rgba(0,0,0,1)' )\n\t\t\t\t: setFillStyle( _patterns[ texture.id ] );\n\n\t\t\t// http://extremelysatisfactorytotalitarianism.com/blog/?p=2120\n\n\t\t\tvar a, b, c, d, e, f, det, idet,\n\t\t\toffsetX = texture.offset.x / texture.repeat.x,\n\t\t\toffsetY = texture.offset.y / texture.repeat.y,\n\t\t\twidth = texture.image.width * texture.repeat.x,\n\t\t\theight = texture.image.height * texture.repeat.y;\n\n\t\t\tu0 = ( u0 + offsetX ) * width;\n\t\t\tv0 = ( 1.0 - v0 + offsetY ) * height;\n\n\t\t\tu1 = ( u1 + offsetX ) * width;\n\t\t\tv1 = ( 1.0 - v1 + offsetY ) * height;\n\n\t\t\tu2 = ( u2 + offsetX ) * width;\n\t\t\tv2 = ( 1.0 - v2 + offsetY ) * height;\n\n\t\t\tx1 -= x0; y1 -= y0;\n\t\t\tx2 -= x0; y2 -= y0;\n\n\t\t\tu1 -= u0; v1 -= v0;\n\t\t\tu2 -= u0; v2 -= v0;\n\n\t\t\tdet = u1 * v2 - u2 * v1;\n\n\t\t\tif ( det === 0 ) {\n\n\t\t\t\tif ( _imagedatas[ texture.id ] === undefined ) {\n\n\t\t\t\t\tvar canvas = document.createElement( 'canvas' )\n\t\t\t\t\tcanvas.width = texture.image.width;\n\t\t\t\t\tcanvas.height = texture.image.height;\n\n\t\t\t\t\tvar context = canvas.getContext( '2d' );\n\t\t\t\t\tcontext.drawImage( texture.image, 0, 0 );\n\n\t\t\t\t\t_imagedatas[ texture.id ] = context.getImageData( 0, 0, texture.image.width, texture.image.height ).data;\n\n\t\t\t\t}\n\n\t\t\t\tvar data = _imagedatas[ texture.id ];\n\t\t\t\tvar index = ( Math.floor( u0 ) + Math.floor( v0 ) * texture.image.width ) * 4;\n\n\t\t\t\t_color.setRGB( data[ index ] / 255, data[ index + 1 ] / 255, data[ index + 2 ] / 255 );\n\t\t\t\tfillPath( _color );\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tidet = 1 / det;\n\n\t\t\ta = ( v2 * x1 - v1 * x2 ) * idet;\n\t\t\tb = ( v2 * y1 - v1 * y2 ) * idet;\n\t\t\tc = ( u1 * x2 - u2 * x1 ) * idet;\n\t\t\td = ( u1 * y2 - u2 * y1 ) * idet;\n\n\t\t\te = x0 - a * u0 - c * v0;\n\t\t\tf = y0 - b * u0 - d * v0;\n\n\t\t\t_context.save();\n\t\t\t_context.transform( a, b, c, d, e, f );\n\t\t\t_context.fill();\n\t\t\t_context.restore();\n\n\t\t}\n\n\t\tfunction clipImage( x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, u2, v2, image ) {\n\n\t\t\t// http://extremelysatisfactorytotalitarianism.com/blog/?p=2120\n\n\t\t\tvar a, b, c, d, e, f, det, idet,\n\t\t\twidth = image.width - 1,\n\t\t\theight = image.height - 1;\n\n\t\t\tu0 *= width; v0 *= height;\n\t\t\tu1 *= width; v1 *= height;\n\t\t\tu2 *= width; v2 *= height;\n\n\t\t\tx1 -= x0; y1 -= y0;\n\t\t\tx2 -= x0; y2 -= y0;\n\n\t\t\tu1 -= u0; v1 -= v0;\n\t\t\tu2 -= u0; v2 -= v0;\n\n\t\t\tdet = u1 * v2 - u2 * v1;\n\n\t\t\tidet = 1 / det;\n\n\t\t\ta = ( v2 * x1 - v1 * x2 ) * idet;\n\t\t\tb = ( v2 * y1 - v1 * y2 ) * idet;\n\t\t\tc = ( u1 * x2 - u2 * x1 ) * idet;\n\t\t\td = ( u1 * y2 - u2 * y1 ) * idet;\n\n\t\t\te = x0 - a * u0 - c * v0;\n\t\t\tf = y0 - b * u0 - d * v0;\n\n\t\t\t_context.save();\n\t\t\t_context.transform( a, b, c, d, e, f );\n\t\t\t_context.clip();\n\t\t\t_context.drawImage( image, 0, 0 );\n\t\t\t_context.restore();\n\n\t\t}\n\n\t\tfunction getGradientTexture( color1, color2, color3, color4 ) {\n\n\t\t\t// http://mrdoob.com/blog/post/710\n\n\t\t\t_pixelMapData[ 0 ] = ( color1.r * 255 ) | 0;\n\t\t\t_pixelMapData[ 1 ] = ( color1.g * 255 ) | 0;\n\t\t\t_pixelMapData[ 2 ] = ( color1.b * 255 ) | 0;\n\n\t\t\t_pixelMapData[ 4 ] = ( color2.r * 255 ) | 0;\n\t\t\t_pixelMapData[ 5 ] = ( color2.g * 255 ) | 0;\n\t\t\t_pixelMapData[ 6 ] = ( color2.b * 255 ) | 0;\n\n\t\t\t_pixelMapData[ 8 ] = ( color3.r * 255 ) | 0;\n\t\t\t_pixelMapData[ 9 ] = ( color3.g * 255 ) | 0;\n\t\t\t_pixelMapData[ 10 ] = ( color3.b * 255 ) | 0;\n\n\t\t\t_pixelMapData[ 12 ] = ( color4.r * 255 ) | 0;\n\t\t\t_pixelMapData[ 13 ] = ( color4.g * 255 ) | 0;\n\t\t\t_pixelMapData[ 14 ] = ( color4.b * 255 ) | 0;\n\n\t\t\t_pixelMapContext.putImageData( _pixelMapImage, 0, 0 );\n\t\t\t_gradientMapContext.drawImage( _pixelMap, 0, 0 );\n\n\t\t\treturn _gradientMap;\n\n\t\t}\n\n\t\t// Hide anti-alias gaps\n\n\t\tfunction expand( v1, v2 ) {\n\n\t\t\tvar x = v2.x - v1.x, y =  v2.y - v1.y,\n\t\t\tdet = x * x + y * y, idet;\n\n\t\t\tif ( det === 0 ) return;\n\n\t\t\tidet = 1 / Math.sqrt( det );\n\n\t\t\tx *= idet; y *= idet;\n\n\t\t\tv2.x += x; v2.y += y;\n\t\t\tv1.x -= x; v1.y -= y;\n\n\t\t}\n\t};\n\n\t// Context cached methods.\n\n\tfunction setOpacity( value ) {\n\n\t\tif ( _contextGlobalAlpha !== value ) {\n\n\t\t\t_context.globalAlpha = value;\n\t\t\t_contextGlobalAlpha = value;\n\n\t\t}\n\n\t}\n\n\tfunction setBlending( value ) {\n\n\t\tif ( _contextGlobalCompositeOperation !== value ) {\n\n\t\t\tif ( value === THREE.NormalBlending ) {\n\n\t\t\t\t_context.globalCompositeOperation = 'source-over';\n\n\t\t\t} else if ( value === THREE.AdditiveBlending ) {\n\n\t\t\t\t_context.globalCompositeOperation = 'lighter';\n\n\t\t\t} else if ( value === THREE.SubtractiveBlending ) {\n\n\t\t\t\t_context.globalCompositeOperation = 'darker';\n\n\t\t\t}\n\n\t\t\t_contextGlobalCompositeOperation = value;\n\n\t\t}\n\n\t}\n\n\tfunction setLineWidth( value ) {\n\n\t\tif ( _contextLineWidth !== value ) {\n\n\t\t\t_context.lineWidth = value;\n\t\t\t_contextLineWidth = value;\n\n\t\t}\n\n\t}\n\n\tfunction setLineCap( value ) {\n\n\t\t// \"butt\", \"round\", \"square\"\n\n\t\tif ( _contextLineCap !== value ) {\n\n\t\t\t_context.lineCap = value;\n\t\t\t_contextLineCap = value;\n\n\t\t}\n\n\t}\n\n\tfunction setLineJoin( value ) {\n\n\t\t// \"round\", \"bevel\", \"miter\"\n\n\t\tif ( _contextLineJoin !== value ) {\n\n\t\t\t_context.lineJoin = value;\n\t\t\t_contextLineJoin = value;\n\n\t\t}\n\n\t}\n\n\tfunction setStrokeStyle( value ) {\n\n\t\tif ( _contextStrokeStyle !== value ) {\n\n\t\t\t_context.strokeStyle = value;\n\t\t\t_contextStrokeStyle = value;\n\n\t\t}\n\n\t}\n\n\tfunction setFillStyle( value ) {\n\n\t\tif ( _contextFillStyle !== value ) {\n\n\t\t\t_context.fillStyle = value;\n\t\t\t_contextFillStyle = value;\n\n\t\t}\n\n\t}\n\n\tfunction setDashAndGap( dashSizeValue, gapSizeValue ) {\n\n\t\tif ( _contextDashSize !== dashSizeValue || _contextGapSize !== gapSizeValue ) {\n\n\t\t\t_context.setLineDash( [ dashSizeValue, gapSizeValue ] );\n\t\t\t_contextDashSize = dashSizeValue;\n\t\t\t_contextGapSize = gapSizeValue;\n\n\t\t}\n\n\t}\n\n};\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n * @author mikael emtinger / http://gomo.se/\n */\n\nTHREE.ShaderChunk = {\n\n\t// FOG\n\n\tfog_pars_fragment: [\n\n\t\t\"#ifdef USE_FOG\",\n\n\t\t\t\"uniform vec3 fogColor;\",\n\n\t\t\t\"#ifdef FOG_EXP2\",\n\n\t\t\t\t\"uniform float fogDensity;\",\n\n\t\t\t\"#else\",\n\n\t\t\t\t\"uniform float fogNear;\",\n\t\t\t\t\"uniform float fogFar;\",\n\n\t\t\t\"#endif\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tfog_fragment: [\n\n\t\t\"#ifdef USE_FOG\",\n\n\t\t\t\"float depth = gl_FragCoord.z / gl_FragCoord.w;\",\n\n\t\t\t\"#ifdef FOG_EXP2\",\n\n\t\t\t\t\"const float LOG2 = 1.442695;\",\n\t\t\t\t\"float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\",\n\t\t\t\t\"fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\",\n\n\t\t\t\"#else\",\n\n\t\t\t\t\"float fogFactor = smoothstep( fogNear, fogFar, depth );\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\t// ENVIRONMENT MAP\n\n\tenvmap_pars_fragment: [\n\n\t\t\"#ifdef USE_ENVMAP\",\n\n\t\t\t\"uniform float reflectivity;\",\n\t\t\t\"uniform samplerCube envMap;\",\n\t\t\t\"uniform float flipEnvMap;\",\n\t\t\t\"uniform int combine;\",\n\n\t\t\t\"#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\",\n\n\t\t\t\t\"uniform bool useRefract;\",\n\t\t\t\t\"uniform float refractionRatio;\",\n\n\t\t\t\"#else\",\n\n\t\t\t\t\"varying vec3 vReflect;\",\n\n\t\t\t\"#endif\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tenvmap_fragment: [\n\n\t\t\"#ifdef USE_ENVMAP\",\n\n\t\t\t\"vec3 reflectVec;\",\n\n\t\t\t\"#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\",\n\n\t\t\t\t\"vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\",\n\n\t\t\t\t\"if ( useRefract ) {\",\n\n\t\t\t\t\t\"reflectVec = refract( cameraToVertex, normal, refractionRatio );\",\n\n\t\t\t\t\"} else { \",\n\n\t\t\t\t\t\"reflectVec = reflect( cameraToVertex, normal );\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\"#else\",\n\n\t\t\t\t\"reflectVec = vReflect;\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\t\"float flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\",\n\t\t\t\t\"vec4 cubeColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\",\n\n\t\t\t\"#else\",\n\n\t\t\t\t\"vec4 cubeColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"#ifdef GAMMA_INPUT\",\n\n\t\t\t\t\"cubeColor.xyz *= cubeColor.xyz;\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"if ( combine == 1 ) {\",\n\n\t\t\t\t\"gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularStrength * reflectivity );\",\n\n\t\t\t\"} else if ( combine == 2 ) {\",\n\n\t\t\t\t\"gl_FragColor.xyz += cubeColor.xyz * specularStrength * reflectivity;\",\n\n\t\t\t\"} else {\",\n\n\t\t\t\t\"gl_FragColor.xyz = mix( gl_FragColor.xyz, gl_FragColor.xyz * cubeColor.xyz, specularStrength * reflectivity );\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tenvmap_pars_vertex: [\n\n\t\t\"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\",\n\n\t\t\t\"varying vec3 vReflect;\",\n\n\t\t\t\"uniform float refractionRatio;\",\n\t\t\t\"uniform bool useRefract;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tworldpos_vertex : [\n\n\t\t\"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\",\n\n\t\t\t\"#ifdef USE_SKINNING\",\n\n\t\t\t\t\"vec4 worldPosition = modelMatrix * skinned;\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"#if defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\",\n\n\t\t\t\t\"vec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"#if ! defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\",\n\n\t\t\t\t\"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"#endif\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tenvmap_vertex : [\n\n\t\t\"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\",\n\n\t\t\t\"vec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;\",\n\t\t\t\"worldNormal = normalize( worldNormal );\",\n\n\t\t\t\"vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\",\n\n\t\t\t\"if ( useRefract ) {\",\n\n\t\t\t\t\"vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\",\n\n\t\t\t\"} else {\",\n\n\t\t\t\t\"vReflect = reflect( cameraToVertex, worldNormal );\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\t// COLOR MAP (particles)\n\n\tmap_particle_pars_fragment: [\n\n\t\t\"#ifdef USE_MAP\",\n\n\t\t\t\"uniform sampler2D map;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\n\tmap_particle_fragment: [\n\n\t\t\"#ifdef USE_MAP\",\n\n\t\t\t\"gl_FragColor = gl_FragColor * texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\t// COLOR MAP (triangles)\n\n\tmap_pars_vertex: [\n\n\t\t\"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\",\n\n\t\t\t\"varying vec2 vUv;\",\n\t\t\t\"uniform vec4 offsetRepeat;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tmap_pars_fragment: [\n\n\t\t\"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\",\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\"#endif\",\n\n\t\t\"#ifdef USE_MAP\",\n\n\t\t\t\"uniform sampler2D map;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tmap_vertex: [\n\n\t\t\"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\",\n\n\t\t\t\"vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tmap_fragment: [\n\n\t\t\"#ifdef USE_MAP\",\n\n\t\t\t\"vec4 texelColor = texture2D( map, vUv );\",\n\n\t\t\t\"#ifdef GAMMA_INPUT\",\n\n\t\t\t\t\"texelColor.xyz *= texelColor.xyz;\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"gl_FragColor = gl_FragColor * texelColor;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\t// LIGHT MAP\n\n\tlightmap_pars_fragment: [\n\n\t\t\"#ifdef USE_LIGHTMAP\",\n\n\t\t\t\"varying vec2 vUv2;\",\n\t\t\t\"uniform sampler2D lightMap;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tlightmap_pars_vertex: [\n\n\t\t\"#ifdef USE_LIGHTMAP\",\n\n\t\t\t\"varying vec2 vUv2;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tlightmap_fragment: [\n\n\t\t\"#ifdef USE_LIGHTMAP\",\n\n\t\t\t\"gl_FragColor = gl_FragColor * texture2D( lightMap, vUv2 );\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tlightmap_vertex: [\n\n\t\t\"#ifdef USE_LIGHTMAP\",\n\n\t\t\t\"vUv2 = uv2;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\t// BUMP MAP\n\n\tbumpmap_pars_fragment: [\n\n\t\t\"#ifdef USE_BUMPMAP\",\n\n\t\t\t\"uniform sampler2D bumpMap;\",\n\t\t\t\"uniform float bumpScale;\",\n\n\t\t\t// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\n\t\t\t//\thttp://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\n\n\t\t\t// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n\t\t\t\"vec2 dHdxy_fwd() {\",\n\n\t\t\t\t\"vec2 dSTdx = dFdx( vUv );\",\n\t\t\t\t\"vec2 dSTdy = dFdy( vUv );\",\n\n\t\t\t\t\"float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\",\n\t\t\t\t\"float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\",\n\t\t\t\t\"float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\",\n\n\t\t\t\t\"return vec2( dBx, dBy );\",\n\n\t\t\t\"}\",\n\n\t\t\t\"vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\",\n\n\t\t\t\t\"vec3 vSigmaX = dFdx( surf_pos );\",\n\t\t\t\t\"vec3 vSigmaY = dFdy( surf_pos );\",\n\t\t\t\t\"vec3 vN = surf_norm;\",\t\t// normalized\n\n\t\t\t\t\"vec3 R1 = cross( vSigmaY, vN );\",\n\t\t\t\t\"vec3 R2 = cross( vN, vSigmaX );\",\n\n\t\t\t\t\"float fDet = dot( vSigmaX, R1 );\",\n\n\t\t\t\t\"vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\",\n\t\t\t\t\"return normalize( abs( fDet ) * surf_norm - vGrad );\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\t// NORMAL MAP\n\n\tnormalmap_pars_fragment: [\n\n\t\t\"#ifdef USE_NORMALMAP\",\n\n\t\t\t\"uniform sampler2D normalMap;\",\n\t\t\t\"uniform vec2 normalScale;\",\n\n\t\t\t// Per-Pixel Tangent Space Normal Mapping\n\t\t\t// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n\t\t\t\"vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\",\n\n\t\t\t\t\"vec3 q0 = dFdx( eye_pos.xyz );\",\n\t\t\t\t\"vec3 q1 = dFdy( eye_pos.xyz );\",\n\t\t\t\t\"vec2 st0 = dFdx( vUv.st );\",\n\t\t\t\t\"vec2 st1 = dFdy( vUv.st );\",\n\n\t\t\t\t\"vec3 S = normalize(  q0 * st1.t - q1 * st0.t );\",\n\t\t\t\t\"vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\",\n\t\t\t\t\"vec3 N = normalize( surf_norm );\",\n\n\t\t\t\t\"vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\",\n\t\t\t\t\"mapN.xy = normalScale * mapN.xy;\",\n\t\t\t\t\"mat3 tsn = mat3( S, T, N );\",\n\t\t\t\t\"return normalize( tsn * mapN );\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\t// SPECULAR MAP\n\n\tspecularmap_pars_fragment: [\n\n\t\t\"#ifdef USE_SPECULARMAP\",\n\n\t\t\t\"uniform sampler2D specularMap;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tspecularmap_fragment: [\n\n\t\t\"float specularStrength;\",\n\n\t\t\"#ifdef USE_SPECULARMAP\",\n\n\t\t\t\"vec4 texelSpecular = texture2D( specularMap, vUv );\",\n\t\t\t\"specularStrength = texelSpecular.r;\",\n\n\t\t\"#else\",\n\n\t\t\t\"specularStrength = 1.0;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\t// LIGHTS LAMBERT\n\n\tlights_lambert_pars_vertex: [\n\n\t\t\"uniform vec3 ambient;\",\n\t\t\"uniform vec3 diffuse;\",\n\t\t\"uniform vec3 emissive;\",\n\n\t\t\"uniform vec3 ambientLightColor;\",\n\n\t\t\"#if MAX_DIR_LIGHTS > 0\",\n\n\t\t\t\"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\",\n\t\t\t\"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_HEMI_LIGHTS > 0\",\n\n\t\t\t\"uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\",\n\t\t\t\"uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\",\n\t\t\t\"uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_POINT_LIGHTS > 0\",\n\n\t\t\t\"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\",\n\t\t\t\"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\",\n\t\t\t\"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_SPOT_LIGHTS > 0\",\n\n\t\t\t\"uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\"uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\"uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\"uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\",\n\n\t\t\"#endif\",\n\n\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\"uniform vec3 wrapRGB;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tlights_lambert_vertex: [\n\n\t\t\"vLightFront = vec3( 0.0 );\",\n\n\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\"vLightBack = vec3( 0.0 );\",\n\n\t\t\"#endif\",\n\n\t\t\"transformedNormal = normalize( transformedNormal );\",\n\n\t\t\"#if MAX_DIR_LIGHTS > 0\",\n\n\t\t\"for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\",\n\n\t\t\t\"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\",\n\t\t\t\"vec3 dirVector = normalize( lDirection.xyz );\",\n\n\t\t\t\"float dotProduct = dot( transformedNormal, dirVector );\",\n\t\t\t\"vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\",\n\n\t\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\t\"vec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\",\n\n\t\t\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\t\t\"vec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\t\"vec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\",\n\t\t\t\t\"directionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );\",\n\n\t\t\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\t\t\"directionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"vLightFront += directionalLightColor[ i ] * directionalLightWeighting;\",\n\n\t\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\t\"vLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;\",\n\n\t\t\t\"#endif\",\n\n\t\t\"}\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_POINT_LIGHTS > 0\",\n\n\t\t\t\"for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\",\n\n\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\",\n\t\t\t\t\"vec3 lVector = lPosition.xyz - mvPosition.xyz;\",\n\n\t\t\t\t\"float lDistance = 1.0;\",\n\t\t\t\t\"if ( pointLightDistance[ i ] > 0.0 )\",\n\t\t\t\t\t\"lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\",\n\n\t\t\t\t\"lVector = normalize( lVector );\",\n\t\t\t\t\"float dotProduct = dot( transformedNormal, lVector );\",\n\n\t\t\t\t\"vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );\",\n\n\t\t\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\t\t\"vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\",\n\n\t\t\t\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\t\t\t\"vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\t\t\"vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\",\n\t\t\t\t\t\"pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );\",\n\n\t\t\t\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\t\t\t\"pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;\",\n\n\t\t\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\t\t\"vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_SPOT_LIGHTS > 0\",\n\n\t\t\t\"for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\",\n\n\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\",\n\t\t\t\t\"vec3 lVector = lPosition.xyz - mvPosition.xyz;\",\n\n\t\t\t\t\"float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );\",\n\n\t\t\t\t\"if ( spotEffect > spotLightAngleCos[ i ] ) {\",\n\n\t\t\t\t\t\"spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\",\n\n\t\t\t\t\t\"float lDistance = 1.0;\",\n\t\t\t\t\t\"if ( spotLightDistance[ i ] > 0.0 )\",\n\t\t\t\t\t\t\"lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\",\n\n\t\t\t\t\t\"lVector = normalize( lVector );\",\n\n\t\t\t\t\t\"float dotProduct = dot( transformedNormal, lVector );\",\n\t\t\t\t\t\"vec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );\",\n\n\t\t\t\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\t\t\t\"vec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\",\n\n\t\t\t\t\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\t\t\t\t\"vec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\",\n\n\t\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\t\t\t\"vec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\",\n\t\t\t\t\t\t\"spotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );\",\n\n\t\t\t\t\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\t\t\t\t\"spotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );\",\n\n\t\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\"vLightFront += spotLightColor[ i ] * spotLightWeighting * lDistance * spotEffect;\",\n\n\t\t\t\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\t\t\t\"vLightBack += spotLightColor[ i ] * spotLightWeightingBack * lDistance * spotEffect;\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_HEMI_LIGHTS > 0\",\n\n\t\t\t\"for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\",\n\n\t\t\t\t\"vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\",\n\t\t\t\t\"vec3 lVector = normalize( lDirection.xyz );\",\n\n\t\t\t\t\"float dotProduct = dot( transformedNormal, lVector );\",\n\n\t\t\t\t\"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\",\n\t\t\t\t\"float hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;\",\n\n\t\t\t\t\"vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\",\n\n\t\t\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\t\t\"vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\",\n\n\t\t\"vLightFront = vLightFront * diffuse + ambient * ambientLightColor + emissive;\",\n\n\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\"vLightBack = vLightBack * diffuse + ambient * ambientLightColor + emissive;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\t// LIGHTS PHONG\n\n\tlights_phong_pars_vertex: [\n\n\t\t\"#ifndef PHONG_PER_PIXEL\",\n\n\t\t\"#if MAX_POINT_LIGHTS > 0\",\n\n\t\t\t\"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\",\n\t\t\t\"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\",\n\n\t\t\t\"varying vec4 vPointLight[ MAX_POINT_LIGHTS ];\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_SPOT_LIGHTS > 0\",\n\n\t\t\t\"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\",\n\n\t\t\t\"varying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];\",\n\n\t\t\"#endif\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )\",\n\n\t\t\t\"varying vec3 vWorldPosition;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\n\tlights_phong_vertex: [\n\n\t\t\"#ifndef PHONG_PER_PIXEL\",\n\n\t\t\"#if MAX_POINT_LIGHTS > 0\",\n\n\t\t\t\"for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\",\n\n\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\",\n\t\t\t\t\"vec3 lVector = lPosition.xyz - mvPosition.xyz;\",\n\n\t\t\t\t\"float lDistance = 1.0;\",\n\t\t\t\t\"if ( pointLightDistance[ i ] > 0.0 )\",\n\t\t\t\t\t\"lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\",\n\n\t\t\t\t\"vPointLight[ i ] = vec4( lVector, lDistance );\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_SPOT_LIGHTS > 0\",\n\n\t\t\t\"for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\",\n\n\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\",\n\t\t\t\t\"vec3 lVector = lPosition.xyz - mvPosition.xyz;\",\n\n\t\t\t\t\"float lDistance = 1.0;\",\n\t\t\t\t\"if ( spotLightDistance[ i ] > 0.0 )\",\n\t\t\t\t\t\"lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\",\n\n\t\t\t\t\"vSpotLight[ i ] = vec4( lVector, lDistance );\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )\",\n\n\t\t\t\"vWorldPosition = worldPosition.xyz;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tlights_phong_pars_fragment: [\n\n\t\t\"uniform vec3 ambientLightColor;\",\n\n\t\t\"#if MAX_DIR_LIGHTS > 0\",\n\n\t\t\t\"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\",\n\t\t\t\"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_HEMI_LIGHTS > 0\",\n\n\t\t\t\"uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\",\n\t\t\t\"uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\",\n\t\t\t\"uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_POINT_LIGHTS > 0\",\n\n\t\t\t\"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\",\n\n\t\t\t\"#ifdef PHONG_PER_PIXEL\",\n\n\t\t\t\t\"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\",\n\t\t\t\t\"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\",\n\n\t\t\t\"#else\",\n\n\t\t\t\t\"varying vec4 vPointLight[ MAX_POINT_LIGHTS ];\",\n\n\t\t\t\"#endif\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_SPOT_LIGHTS > 0\",\n\n\t\t\t\"uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\"uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\"uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\"uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\",\n\n\t\t\t\"#ifdef PHONG_PER_PIXEL\",\n\n\t\t\t\t\"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\",\n\n\t\t\t\"#else\",\n\n\t\t\t\t\"varying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];\",\n\n\t\t\t\"#endif\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )\",\n\n\t\t\t\"varying vec3 vWorldPosition;\",\n\n\t\t\"#endif\",\n\n\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\"uniform vec3 wrapRGB;\",\n\n\t\t\"#endif\",\n\n\t\t\"varying vec3 vViewPosition;\",\n\t\t\"varying vec3 vNormal;\"\n\n\t].join(\"\\n\"),\n\n\tlights_phong_fragment: [\n\n\t\t\"vec3 normal = normalize( vNormal );\",\n\t\t\"vec3 viewPosition = normalize( vViewPosition );\",\n\n\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\"normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\",\n\n\t\t\"#endif\",\n\n\t\t\"#ifdef USE_NORMALMAP\",\n\n\t\t\t\"normal = perturbNormal2Arb( -viewPosition, normal );\",\n\n\t\t\"#elif defined( USE_BUMPMAP )\",\n\n\t\t\t\"normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_POINT_LIGHTS > 0\",\n\n\t\t\t\"vec3 pointDiffuse  = vec3( 0.0 );\",\n\t\t\t\"vec3 pointSpecular = vec3( 0.0 );\",\n\n\t\t\t\"for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\",\n\n\t\t\t\t\"#ifdef PHONG_PER_PIXEL\",\n\n\t\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\",\n\t\t\t\t\t\"vec3 lVector = lPosition.xyz + vViewPosition.xyz;\",\n\n\t\t\t\t\t\"float lDistance = 1.0;\",\n\t\t\t\t\t\"if ( pointLightDistance[ i ] > 0.0 )\",\n\t\t\t\t\t\t\"lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\",\n\n\t\t\t\t\t\"lVector = normalize( lVector );\",\n\n\t\t\t\t\"#else\",\n\n\t\t\t\t\t\"vec3 lVector = normalize( vPointLight[ i ].xyz );\",\n\t\t\t\t\t\"float lDistance = vPointLight[ i ].w;\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t// diffuse\n\n\t\t\t\t\"float dotProduct = dot( normal, lVector );\",\n\n\t\t\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\t\t\"float pointDiffuseWeightFull = max( dotProduct, 0.0 );\",\n\t\t\t\t\t\"float pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\",\n\n\t\t\t\t\t\"vec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\",\n\n\t\t\t\t\"#else\",\n\n\t\t\t\t\t\"float pointDiffuseWeight = max( dotProduct, 0.0 );\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"pointDiffuse  += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;\",\n\n\t\t\t\t// specular\n\n\t\t\t\t\"vec3 pointHalfVector = normalize( lVector + viewPosition );\",\n\t\t\t\t\"float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\",\n\t\t\t\t\"float pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\",\n\n\t\t\t\t\"#ifdef PHYSICALLY_BASED_SHADING\",\n\n\t\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\n\n\t\t\t\t\t\"float specularNormalization = ( shininess + 2.0001 ) / 8.0;\",\n\n\t\t\t\t\t\"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, pointHalfVector ), 5.0 );\",\n\t\t\t\t\t\"pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;\",\n\n\t\t\t\t\"#else\",\n\n\t\t\t\t\t\"pointSpecular += specular * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance;\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_SPOT_LIGHTS > 0\",\n\n\t\t\t\"vec3 spotDiffuse  = vec3( 0.0 );\",\n\t\t\t\"vec3 spotSpecular = vec3( 0.0 );\",\n\n\t\t\t\"for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\",\n\n\t\t\t\t\"#ifdef PHONG_PER_PIXEL\",\n\n\t\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\",\n\t\t\t\t\t\"vec3 lVector = lPosition.xyz + vViewPosition.xyz;\",\n\n\t\t\t\t\t\"float lDistance = 1.0;\",\n\t\t\t\t\t\"if ( spotLightDistance[ i ] > 0.0 )\",\n\t\t\t\t\t\t\"lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\",\n\n\t\t\t\t\t\"lVector = normalize( lVector );\",\n\n\t\t\t\t\"#else\",\n\n\t\t\t\t\t\"vec3 lVector = normalize( vSpotLight[ i ].xyz );\",\n\t\t\t\t\t\"float lDistance = vSpotLight[ i ].w;\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\",\n\n\t\t\t\t\"if ( spotEffect > spotLightAngleCos[ i ] ) {\",\n\n\t\t\t\t\t\"spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\",\n\n\t\t\t\t\t// diffuse\n\n\t\t\t\t\t\"float dotProduct = dot( normal, lVector );\",\n\n\t\t\t\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\t\t\t\"float spotDiffuseWeightFull = max( dotProduct, 0.0 );\",\n\t\t\t\t\t\t\"float spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\",\n\n\t\t\t\t\t\t\"vec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\",\n\n\t\t\t\t\t\"#else\",\n\n\t\t\t\t\t\t\"float spotDiffuseWeight = max( dotProduct, 0.0 );\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\"spotDiffuse += diffuse * spotLightColor[ i ] * spotDiffuseWeight * lDistance * spotEffect;\",\n\n\t\t\t\t\t// specular\n\n\t\t\t\t\t\"vec3 spotHalfVector = normalize( lVector + viewPosition );\",\n\t\t\t\t\t\"float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\",\n\t\t\t\t\t\"float spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );\",\n\n\t\t\t\t\t\"#ifdef PHYSICALLY_BASED_SHADING\",\n\n\t\t\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\n\n\t\t\t\t\t\t\"float specularNormalization = ( shininess + 2.0001 ) / 8.0;\",\n\n\t\t\t\t\t\t\"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, spotHalfVector ), 5.0 );\",\n\t\t\t\t\t\t\"spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;\",\n\n\t\t\t\t\t\"#else\",\n\n\t\t\t\t\t\t\"spotSpecular += specular * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * spotEffect;\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_DIR_LIGHTS > 0\",\n\n\t\t\t\"vec3 dirDiffuse  = vec3( 0.0 );\",\n\t\t\t\"vec3 dirSpecular = vec3( 0.0 );\" ,\n\n\t\t\t\"for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\",\n\n\t\t\t\t\"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\",\n\t\t\t\t\"vec3 dirVector = normalize( lDirection.xyz );\",\n\n\t\t\t\t// diffuse\n\n\t\t\t\t\"float dotProduct = dot( normal, dirVector );\",\n\n\t\t\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\t\t\"float dirDiffuseWeightFull = max( dotProduct, 0.0 );\",\n\t\t\t\t\t\"float dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\",\n\n\t\t\t\t\t\"vec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\",\n\n\t\t\t\t\"#else\",\n\n\t\t\t\t\t\"float dirDiffuseWeight = max( dotProduct, 0.0 );\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"dirDiffuse  += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;\",\n\n\t\t\t\t// specular\n\n\t\t\t\t\"vec3 dirHalfVector = normalize( dirVector + viewPosition );\",\n\t\t\t\t\"float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\",\n\t\t\t\t\"float dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\",\n\n\t\t\t\t\"#ifdef PHYSICALLY_BASED_SHADING\",\n\n\t\t\t\t\t/*\n\t\t\t\t\t// fresnel term from skin shader\n\t\t\t\t\t\"const float F0 = 0.128;\",\n\n\t\t\t\t\t\"float base = 1.0 - dot( viewPosition, dirHalfVector );\",\n\t\t\t\t\t\"float exponential = pow( base, 5.0 );\",\n\n\t\t\t\t\t\"float fresnel = exponential + F0 * ( 1.0 - exponential );\",\n\t\t\t\t\t*/\n\n\t\t\t\t\t/*\n\t\t\t\t\t// fresnel term from fresnel shader\n\t\t\t\t\t\"const float mFresnelBias = 0.08;\",\n\t\t\t\t\t\"const float mFresnelScale = 0.3;\",\n\t\t\t\t\t\"const float mFresnelPower = 5.0;\",\n\n\t\t\t\t\t\"float fresnel = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( -viewPosition ), normal ), mFresnelPower );\",\n\t\t\t\t\t*/\n\n\t\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\n\n\t\t\t\t\t\"float specularNormalization = ( shininess + 2.0001 ) / 8.0;\",\n\n\t\t\t\t\t//\"dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization * fresnel;\",\n\n\t\t\t\t\t\"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );\",\n\t\t\t\t\t\"dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\",\n\n\t\t\t\t\"#else\",\n\n\t\t\t\t\t\"dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight;\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_HEMI_LIGHTS > 0\",\n\n\t\t\t\"vec3 hemiDiffuse  = vec3( 0.0 );\",\n\t\t\t\"vec3 hemiSpecular = vec3( 0.0 );\" ,\n\n\t\t\t\"for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\",\n\n\t\t\t\t\"vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\",\n\t\t\t\t\"vec3 lVector = normalize( lDirection.xyz );\",\n\n\t\t\t\t// diffuse\n\n\t\t\t\t\"float dotProduct = dot( normal, lVector );\",\n\t\t\t\t\"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\",\n\n\t\t\t\t\"vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\",\n\n\t\t\t\t\"hemiDiffuse += diffuse * hemiColor;\",\n\n\t\t\t\t// specular (sky light)\n\n\t\t\t\t\"vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\",\n\t\t\t\t\"float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\",\n\t\t\t\t\"float hemiSpecularWeightSky = specularStrength * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );\",\n\n\t\t\t\t// specular (ground light)\n\n\t\t\t\t\"vec3 lVectorGround = -lVector;\",\n\n\t\t\t\t\"vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\",\n\t\t\t\t\"float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\",\n\t\t\t\t\"float hemiSpecularWeightGround = specularStrength * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );\",\n\n\t\t\t\t\"#ifdef PHYSICALLY_BASED_SHADING\",\n\n\t\t\t\t\t\"float dotProductGround = dot( normal, lVectorGround );\",\n\n\t\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\n\n\t\t\t\t\t\"float specularNormalization = ( shininess + 2.0001 ) / 8.0;\",\n\n\t\t\t\t\t\"vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );\",\n\t\t\t\t\t\"vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );\",\n\t\t\t\t\t\"hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\",\n\n\t\t\t\t\"#else\",\n\n\t\t\t\t\t\"hemiSpecular += specular * hemiColor * ( hemiSpecularWeightSky + hemiSpecularWeightGround ) * hemiDiffuseWeight;\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\",\n\n\t\t\"vec3 totalDiffuse = vec3( 0.0 );\",\n\t\t\"vec3 totalSpecular = vec3( 0.0 );\",\n\n\t\t\"#if MAX_DIR_LIGHTS > 0\",\n\n\t\t\t\"totalDiffuse += dirDiffuse;\",\n\t\t\t\"totalSpecular += dirSpecular;\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_HEMI_LIGHTS > 0\",\n\n\t\t\t\"totalDiffuse += hemiDiffuse;\",\n\t\t\t\"totalSpecular += hemiSpecular;\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_POINT_LIGHTS > 0\",\n\n\t\t\t\"totalDiffuse += pointDiffuse;\",\n\t\t\t\"totalSpecular += pointSpecular;\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_SPOT_LIGHTS > 0\",\n\n\t\t\t\"totalDiffuse += spotDiffuse;\",\n\t\t\t\"totalSpecular += spotSpecular;\",\n\n\t\t\"#endif\",\n\n\t\t\"#ifdef METAL\",\n\n\t\t\t\"gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient + totalSpecular );\",\n\n\t\t\"#else\",\n\n\t\t\t\"gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\t// VERTEX COLORS\n\n\tcolor_pars_fragment: [\n\n\t\t\"#ifdef USE_COLOR\",\n\n\t\t\t\"varying vec3 vColor;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\n\tcolor_fragment: [\n\n\t\t\"#ifdef USE_COLOR\",\n\n\t\t\t\"gl_FragColor = gl_FragColor * vec4( vColor, opacity );\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tcolor_pars_vertex: [\n\n\t\t\"#ifdef USE_COLOR\",\n\n\t\t\t\"varying vec3 vColor;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\n\tcolor_vertex: [\n\n\t\t\"#ifdef USE_COLOR\",\n\n\t\t\t\"#ifdef GAMMA_INPUT\",\n\n\t\t\t\t\"vColor = color * color;\",\n\n\t\t\t\"#else\",\n\n\t\t\t\t\"vColor = color;\",\n\n\t\t\t\"#endif\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\t// SKINNING\n\n\tskinning_pars_vertex: [\n\n\t\t\"#ifdef USE_SKINNING\",\n\n\t\t\t\"#ifdef BONE_TEXTURE\",\n\n\t\t\t\t\"uniform sampler2D boneTexture;\",\n\n\t\t\t\t\"mat4 getBoneMatrix( const in float i ) {\",\n\n\t\t\t\t\t\"float j = i * 4.0;\",\n\t\t\t\t\t\"float x = mod( j, N_BONE_PIXEL_X );\",\n\t\t\t\t\t\"float y = floor( j / N_BONE_PIXEL_X );\",\n\n\t\t\t\t\t\"const float dx = 1.0 / N_BONE_PIXEL_X;\",\n\t\t\t\t\t\"const float dy = 1.0 / N_BONE_PIXEL_Y;\",\n\n\t\t\t\t\t\"y = dy * ( y + 0.5 );\",\n\n\t\t\t\t\t\"vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\",\n\t\t\t\t\t\"vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\",\n\t\t\t\t\t\"vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\",\n\t\t\t\t\t\"vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\",\n\n\t\t\t\t\t\"mat4 bone = mat4( v1, v2, v3, v4 );\",\n\n\t\t\t\t\t\"return bone;\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\"#else\",\n\n\t\t\t\t\"uniform mat4 boneGlobalMatrices[ MAX_BONES ];\",\n\n\t\t\t\t\"mat4 getBoneMatrix( const in float i ) {\",\n\n\t\t\t\t\t\"mat4 bone = boneGlobalMatrices[ int(i) ];\",\n\t\t\t\t\t\"return bone;\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\"#endif\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tskinbase_vertex: [\n\n\t\t\"#ifdef USE_SKINNING\",\n\n\t\t\t\"mat4 boneMatX = getBoneMatrix( skinIndex.x );\",\n\t\t\t\"mat4 boneMatY = getBoneMatrix( skinIndex.y );\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tskinning_vertex: [\n\n\t\t\"#ifdef USE_SKINNING\",\n\n\t\t\t\"#ifdef USE_MORPHTARGETS\",\n\n\t\t\t\"vec4 skinVertex = vec4( morphed, 1.0 );\",\n\n\t\t\t\"#else\",\n\n\t\t\t\"vec4 skinVertex = vec4( position, 1.0 );\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"vec4 skinned  = boneMatX * skinVertex * skinWeight.x;\",\n\t\t\t\"skinned \t  += boneMatY * skinVertex * skinWeight.y;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\t// MORPHING\n\n\tmorphtarget_pars_vertex: [\n\n\t\t\"#ifdef USE_MORPHTARGETS\",\n\n\t\t\t\"#ifndef USE_MORPHNORMALS\",\n\n\t\t\t\"uniform float morphTargetInfluences[ 8 ];\",\n\n\t\t\t\"#else\",\n\n\t\t\t\"uniform float morphTargetInfluences[ 4 ];\",\n\n\t\t\t\"#endif\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tmorphtarget_vertex: [\n\n\t\t\"#ifdef USE_MORPHTARGETS\",\n\n\t\t\t\"vec3 morphed = vec3( 0.0 );\",\n\t\t\t\"morphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\",\n\t\t\t\"morphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\",\n\t\t\t\"morphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\",\n\t\t\t\"morphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\",\n\n\t\t\t\"#ifndef USE_MORPHNORMALS\",\n\n\t\t\t\"morphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\",\n\t\t\t\"morphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\",\n\t\t\t\"morphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\",\n\t\t\t\"morphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"morphed += position;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tdefault_vertex : [\n\n\t\t\"vec4 mvPosition;\",\n\n\t\t\"#ifdef USE_SKINNING\",\n\n\t\t\t\"mvPosition = modelViewMatrix * skinned;\",\n\n\t\t\"#endif\",\n\n\t\t\"#if !defined( USE_SKINNING ) && defined( USE_MORPHTARGETS )\",\n\n\t\t\t\"mvPosition = modelViewMatrix * vec4( morphed, 1.0 );\",\n\n\t\t\"#endif\",\n\n\t\t\"#if !defined( USE_SKINNING ) && ! defined( USE_MORPHTARGETS )\",\n\n\t\t\t\"mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"#endif\",\n\n\t\t\"gl_Position = projectionMatrix * mvPosition;\"\n\n\t].join(\"\\n\"),\n\n\tmorphnormal_vertex: [\n\n\t\t\"#ifdef USE_MORPHNORMALS\",\n\n\t\t\t\"vec3 morphedNormal = vec3( 0.0 );\",\n\n\t\t\t\"morphedNormal +=  ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\",\n\t\t\t\"morphedNormal +=  ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\",\n\t\t\t\"morphedNormal +=  ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\",\n\t\t\t\"morphedNormal +=  ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\",\n\n\t\t\t\"morphedNormal += normal;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tskinnormal_vertex: [\n\n\t\t\"#ifdef USE_SKINNING\",\n\n\t\t\t\"mat4 skinMatrix = skinWeight.x * boneMatX;\",\n\t\t\t\"skinMatrix \t+= skinWeight.y * boneMatY;\",\n\n\t\t\t\"#ifdef USE_MORPHNORMALS\",\n\n\t\t\t\"vec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\",\n\n\t\t\t\"#else\",\n\n\t\t\t\"vec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\",\n\n\t\t\t\"#endif\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tdefaultnormal_vertex: [\n\n\t\t\"vec3 objectNormal;\",\n\n\t\t\"#ifdef USE_SKINNING\",\n\n\t\t\t\"objectNormal = skinnedNormal.xyz;\",\n\n\t\t\"#endif\",\n\n\t\t\"#if !defined( USE_SKINNING ) && defined( USE_MORPHNORMALS )\",\n\n\t\t\t\"objectNormal = morphedNormal;\",\n\n\t\t\"#endif\",\n\n\t\t\"#if !defined( USE_SKINNING ) && ! defined( USE_MORPHNORMALS )\",\n\n\t\t\t\"objectNormal = normal;\",\n\n\t\t\"#endif\",\n\n\t\t\"#ifdef FLIP_SIDED\",\n\n\t\t\t\"objectNormal = -objectNormal;\",\n\n\t\t\"#endif\",\n\n\t\t\"vec3 transformedNormal = normalMatrix * objectNormal;\"\n\n\t].join(\"\\n\"),\n\n\t// SHADOW MAP\n\n\t// based on SpiderGL shadow map and Fabien Sanglard's GLSL shadow mapping examples\n\t//  http://spidergl.org/example.php?id=6\n\t// \thttp://fabiensanglard.net/shadowmapping\n\n\tshadowmap_pars_fragment: [\n\n\t\t\"#ifdef USE_SHADOWMAP\",\n\n\t\t\t\"uniform sampler2D shadowMap[ MAX_SHADOWS ];\",\n\t\t\t\"uniform vec2 shadowMapSize[ MAX_SHADOWS ];\",\n\n\t\t\t\"uniform float shadowDarkness[ MAX_SHADOWS ];\",\n\t\t\t\"uniform float shadowBias[ MAX_SHADOWS ];\",\n\n\t\t\t\"varying vec4 vShadowCoord[ MAX_SHADOWS ];\",\n\n\t\t\t\"float unpackDepth( const in vec4 rgba_depth ) {\",\n\n\t\t\t\t\"const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\",\n\t\t\t\t\"float depth = dot( rgba_depth, bit_shift );\",\n\t\t\t\t\"return depth;\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tshadowmap_fragment: [\n\n\t\t\"#ifdef USE_SHADOWMAP\",\n\n\t\t\t\"#ifdef SHADOWMAP_DEBUG\",\n\n\t\t\t\t\"vec3 frustumColors[3];\",\n\t\t\t\t\"frustumColors[0] = vec3( 1.0, 0.5, 0.0 );\",\n\t\t\t\t\"frustumColors[1] = vec3( 0.0, 1.0, 0.8 );\",\n\t\t\t\t\"frustumColors[2] = vec3( 0.0, 0.5, 1.0 );\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"#ifdef SHADOWMAP_CASCADE\",\n\n\t\t\t\t\"int inFrustumCount = 0;\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"float fDepth;\",\n\t\t\t\"vec3 shadowColor = vec3( 1.0 );\",\n\n\t\t\t\"for( int i = 0; i < MAX_SHADOWS; i ++ ) {\",\n\n\t\t\t\t\"vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\",\n\n\t\t\t\t// \"if ( something && something )\" \t\t breaks ATI OpenGL shader compiler\n\t\t\t\t// \"if ( all( something, something ) )\"  using this instead\n\n\t\t\t\t\"bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\",\n\t\t\t\t\"bool inFrustum = all( inFrustumVec );\",\n\n\t\t\t\t// don't shadow pixels outside of light frustum\n\t\t\t\t// use just first frustum (for cascades)\n\t\t\t\t// don't shadow pixels behind far plane of light frustum\n\n\t\t\t\t\"#ifdef SHADOWMAP_CASCADE\",\n\n\t\t\t\t\t\"inFrustumCount += int( inFrustum );\",\n\t\t\t\t\t\"bvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\",\n\n\t\t\t\t\"#else\",\n\n\t\t\t\t\t\"bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"bool frustumTest = all( frustumTestVec );\",\n\n\t\t\t\t\"if ( frustumTest ) {\",\n\n\t\t\t\t\t\"shadowCoord.z += shadowBias[ i ];\",\n\n\t\t\t\t\t\"#if defined( SHADOWMAP_TYPE_PCF )\",\n\n\t\t\t\t\t\t// Percentage-close filtering\n\t\t\t\t\t\t// (9 pixel kernel)\n\t\t\t\t\t\t// http://fabiensanglard.net/shadowmappingPCF/\n\n\t\t\t\t\t\t\"float shadow = 0.0;\",\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t// nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\n\t\t\t\t\t\t// must enroll loop manually\n\n\t\t\t\t\t\t\"for ( float y = -1.25; y <= 1.25; y += 1.25 )\",\n\t\t\t\t\t\t\t\"for ( float x = -1.25; x <= 1.25; x += 1.25 ) {\",\n\n\t\t\t\t\t\t\t\t\"vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\",\n\n\t\t\t\t\t\t\t\t// doesn't seem to produce any noticeable visual difference compared to simple \"texture2D\" lookup\n\t\t\t\t\t\t\t\t//\"vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\",\n\n\t\t\t\t\t\t\t\t\"float fDepth = unpackDepth( rgbaDepth );\",\n\n\t\t\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z )\",\n\t\t\t\t\t\t\t\t\t\"shadow += 1.0;\",\n\n\t\t\t\t\t\t\"}\",\n\n\t\t\t\t\t\t\"shadow /= 9.0;\",\n\n\t\t\t\t\t\t*/\n\n\t\t\t\t\t\t\"const float shadowDelta = 1.0 / 9.0;\",\n\n\t\t\t\t\t\t\"float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\",\n\t\t\t\t\t\t\"float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\",\n\n\t\t\t\t\t\t\"float dx0 = -1.25 * xPixelOffset;\",\n\t\t\t\t\t\t\"float dy0 = -1.25 * yPixelOffset;\",\n\t\t\t\t\t\t\"float dx1 = 1.25 * xPixelOffset;\",\n\t\t\t\t\t\t\"float dy1 = 1.25 * yPixelOffset;\",\n\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\",\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\n\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\",\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\n\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\",\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\n\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\",\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\n\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\",\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\n\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\",\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\n\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\",\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\n\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\",\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\n\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\",\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\n\n\t\t\t\t\t\t\"shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\",\n\n\t\t\t\t\t\"#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\",\n\n\t\t\t\t\t\t// Percentage-close filtering\n\t\t\t\t\t\t// (9 pixel kernel)\n\t\t\t\t\t\t// http://fabiensanglard.net/shadowmappingPCF/\n\n\t\t\t\t\t\t\"float shadow = 0.0;\",\n\n\t\t\t\t\t\t\"float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\",\n\t\t\t\t\t\t\"float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\",\n\n\t\t\t\t\t\t\"float dx0 = -1.0 * xPixelOffset;\",\n\t\t\t\t\t\t\"float dy0 = -1.0 * yPixelOffset;\",\n\t\t\t\t\t\t\"float dx1 = 1.0 * xPixelOffset;\",\n\t\t\t\t\t\t\"float dy1 = 1.0 * yPixelOffset;\",\n\n\t\t\t\t\t\t\"mat3 shadowKernel;\",\n\t\t\t\t\t\t\"mat3 depthKernel;\",\n\n\t\t\t\t\t\t\"depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\",\n\t\t\t\t\t\t\"if ( depthKernel[0][0] < shadowCoord.z ) shadowKernel[0][0] = 0.25;\",\n\t\t\t\t\t\t\"else shadowKernel[0][0] = 0.0;\",\n\n\t\t\t\t\t\t\"depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\",\n\t\t\t\t\t\t\"if ( depthKernel[0][1] < shadowCoord.z ) shadowKernel[0][1] = 0.25;\",\n\t\t\t\t\t\t\"else shadowKernel[0][1] = 0.0;\",\n\n\t\t\t\t\t\t\"depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i], shadowCoord.xy + vec2( dx0, dy1 ) ) );\",\n\t\t\t\t\t\t\"if ( depthKernel[0][2] < shadowCoord.z ) shadowKernel[0][2] = 0.25;\",\n\t\t\t\t\t\t\"else shadowKernel[0][2] = 0.0;\",\n\n\t\t\t\t\t\t\"depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\",\n\t\t\t\t\t\t\"if ( depthKernel[1][0] < shadowCoord.z ) shadowKernel[1][0] = 0.25;\",\n\t\t\t\t\t\t\"else shadowKernel[1][0] = 0.0;\",\n\n\t\t\t\t\t\t\"depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\",\n\t\t\t\t\t\t\"if ( depthKernel[1][1] < shadowCoord.z ) shadowKernel[1][1] = 0.25;\",\n\t\t\t\t\t\t\"else shadowKernel[1][1] = 0.0;\",\n\n\t\t\t\t\t\t\"depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\",\n\t\t\t\t\t\t\"if ( depthKernel[1][2] < shadowCoord.z ) shadowKernel[1][2] = 0.25;\",\n\t\t\t\t\t\t\"else shadowKernel[1][2] = 0.0;\",\n\n\t\t\t\t\t\t\"depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\",\n\t\t\t\t\t\t\"if ( depthKernel[2][0] < shadowCoord.z ) shadowKernel[2][0] = 0.25;\",\n\t\t\t\t\t\t\"else shadowKernel[2][0] = 0.0;\",\n\n\t\t\t\t\t\t\"depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\",\n\t\t\t\t\t\t\"if ( depthKernel[2][1] < shadowCoord.z ) shadowKernel[2][1] = 0.25;\",\n\t\t\t\t\t\t\"else shadowKernel[2][1] = 0.0;\",\n\n\t\t\t\t\t\t\"depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\",\n\t\t\t\t\t\t\"if ( depthKernel[2][2] < shadowCoord.z ) shadowKernel[2][2] = 0.25;\",\n\t\t\t\t\t\t\"else shadowKernel[2][2] = 0.0;\",\n\n\t\t\t\t\t\t\"vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\",\n\n\t\t\t\t\t\t\"shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\",\n\t\t\t\t\t\t\"shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\",\n\n\t\t\t\t\t\t\"vec4 shadowValues;\",\n\t\t\t\t\t\t\"shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\",\n\t\t\t\t\t\t\"shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\",\n\t\t\t\t\t\t\"shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\",\n\t\t\t\t\t\t\"shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\",\n\n\t\t\t\t\t\t\"shadow = dot( shadowValues, vec4( 1.0 ) );\",\n\n\t\t\t\t\t\t\"shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\",\n\n\t\t\t\t\t\"#else\",\n\n\t\t\t\t\t\t\"vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\",\n\t\t\t\t\t\t\"float fDepth = unpackDepth( rgbaDepth );\",\n\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z )\",\n\n\t\t\t\t\t\t\t// spot with multiple shadows is darker\n\n\t\t\t\t\t\t\t\"shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\",\n\n\t\t\t\t\t\t\t// spot with multiple shadows has the same color as single shadow spot\n\n\t\t\t\t\t\t\t//\"shadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\"}\",\n\n\n\t\t\t\t\"#ifdef SHADOWMAP_DEBUG\",\n\n\t\t\t\t\t\"#ifdef SHADOWMAP_CASCADE\",\n\n\t\t\t\t\t\t\"if ( inFrustum && inFrustumCount == 1 ) gl_FragColor.xyz *= frustumColors[ i ];\",\n\n\t\t\t\t\t\"#else\",\n\n\t\t\t\t\t\t\"if ( inFrustum ) gl_FragColor.xyz *= frustumColors[ i ];\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\"}\",\n\n\t\t\t\"#ifdef GAMMA_OUTPUT\",\n\n\t\t\t\t\"shadowColor *= shadowColor;\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"gl_FragColor.xyz = gl_FragColor.xyz * shadowColor;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tshadowmap_pars_vertex: [\n\n\t\t\"#ifdef USE_SHADOWMAP\",\n\n\t\t\t\"varying vec4 vShadowCoord[ MAX_SHADOWS ];\",\n\t\t\t\"uniform mat4 shadowMatrix[ MAX_SHADOWS ];\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tshadowmap_vertex: [\n\n\t\t\"#ifdef USE_SHADOWMAP\",\n\n\t\t\t\"for( int i = 0; i < MAX_SHADOWS; i ++ ) {\",\n\n\t\t\t\t\"vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\t// ALPHATEST\n\n\talphatest_fragment: [\n\n\t\t\"#ifdef ALPHATEST\",\n\n\t\t\t\"if ( gl_FragColor.a < ALPHATEST ) discard;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\t// LINEAR SPACE\n\n\tlinear_to_gamma_fragment: [\n\n\t\t\"#ifdef GAMMA_OUTPUT\",\n\n\t\t\t\"gl_FragColor.xyz = sqrt( gl_FragColor.xyz );\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\")\n\n\n};\n\nTHREE.UniformsUtils = {\n\n\tmerge: function ( uniforms ) {\n\n\t\tvar u, p, tmp, merged = {};\n\n\t\tfor ( u = 0; u < uniforms.length; u ++ ) {\n\n\t\t\ttmp = this.clone( uniforms[ u ] );\n\n\t\t\tfor ( p in tmp ) {\n\n\t\t\t\tmerged[ p ] = tmp[ p ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn merged;\n\n\t},\n\n\tclone: function ( uniforms_src ) {\n\n\t\tvar u, p, parameter, parameter_src, uniforms_dst = {};\n\n\t\tfor ( u in uniforms_src ) {\n\n\t\t\tuniforms_dst[ u ] = {};\n\n\t\t\tfor ( p in uniforms_src[ u ] ) {\n\n\t\t\t\tparameter_src = uniforms_src[ u ][ p ];\n\n\t\t\t\tif ( parameter_src instanceof THREE.Color ||\n\t\t\t\t\t parameter_src instanceof THREE.Vector2 ||\n\t\t\t\t\t parameter_src instanceof THREE.Vector3 ||\n\t\t\t\t\t parameter_src instanceof THREE.Vector4 ||\n\t\t\t\t\t parameter_src instanceof THREE.Matrix4 ||\n\t\t\t\t\t parameter_src instanceof THREE.Texture ) {\n\n\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.clone();\n\n\t\t\t\t} else if ( parameter_src instanceof Array ) {\n\n\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.slice();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn uniforms_dst;\n\n\t}\n\n};\n\nTHREE.UniformsLib = {\n\n\tcommon: {\n\n\t\t\"diffuse\" : { type: \"c\", value: new THREE.Color( 0xeeeeee ) },\n\t\t\"opacity\" : { type: \"f\", value: 1.0 },\n\n\t\t\"map\" : { type: \"t\", value: null },\n\t\t\"offsetRepeat\" : { type: \"v4\", value: new THREE.Vector4( 0, 0, 1, 1 ) },\n\n\t\t\"lightMap\" : { type: \"t\", value: null },\n\t\t\"specularMap\" : { type: \"t\", value: null },\n\n\t\t\"envMap\" : { type: \"t\", value: null },\n\t\t\"flipEnvMap\" : { type: \"f\", value: -1 },\n\t\t\"useRefract\" : { type: \"i\", value: 0 },\n\t\t\"reflectivity\" : { type: \"f\", value: 1.0 },\n\t\t\"refractionRatio\" : { type: \"f\", value: 0.98 },\n\t\t\"combine\" : { type: \"i\", value: 0 },\n\n\t\t\"morphTargetInfluences\" : { type: \"f\", value: 0 }\n\n\t},\n\n\tbump: {\n\n\t\t\"bumpMap\" : { type: \"t\", value: null },\n\t\t\"bumpScale\" : { type: \"f\", value: 1 }\n\n\t},\n\n\tnormalmap: {\n\n\t\t\"normalMap\" : { type: \"t\", value: null },\n\t\t\"normalScale\" : { type: \"v2\", value: new THREE.Vector2( 1, 1 ) }\n\t},\n\n\tfog : {\n\n\t\t\"fogDensity\" : { type: \"f\", value: 0.00025 },\n\t\t\"fogNear\" : { type: \"f\", value: 1 },\n\t\t\"fogFar\" : { type: \"f\", value: 2000 },\n\t\t\"fogColor\" : { type: \"c\", value: new THREE.Color( 0xffffff ) }\n\n\t},\n\n\tlights: {\n\n\t\t\"ambientLightColor\" : { type: \"fv\", value: [] },\n\n\t\t\"directionalLightDirection\" : { type: \"fv\", value: [] },\n\t\t\"directionalLightColor\" : { type: \"fv\", value: [] },\n\n\t\t\"hemisphereLightDirection\" : { type: \"fv\", value: [] },\n\t\t\"hemisphereLightSkyColor\" : { type: \"fv\", value: [] },\n\t\t\"hemisphereLightGroundColor\" : { type: \"fv\", value: [] },\n\n\t\t\"pointLightColor\" : { type: \"fv\", value: [] },\n\t\t\"pointLightPosition\" : { type: \"fv\", value: [] },\n\t\t\"pointLightDistance\" : { type: \"fv1\", value: [] },\n\n\t\t\"spotLightColor\" : { type: \"fv\", value: [] },\n\t\t\"spotLightPosition\" : { type: \"fv\", value: [] },\n\t\t\"spotLightDirection\" : { type: \"fv\", value: [] },\n\t\t\"spotLightDistance\" : { type: \"fv1\", value: [] },\n\t\t\"spotLightAngleCos\" : { type: \"fv1\", value: [] },\n\t\t\"spotLightExponent\" : { type: \"fv1\", value: [] }\n\n\t},\n\n\tparticle: {\n\n\t\t\"psColor\" : { type: \"c\", value: new THREE.Color( 0xeeeeee ) },\n\t\t\"opacity\" : { type: \"f\", value: 1.0 },\n\t\t\"size\" : { type: \"f\", value: 1.0 },\n\t\t\"scale\" : { type: \"f\", value: 1.0 },\n\t\t\"map\" : { type: \"t\", value: null },\n\n\t\t\"fogDensity\" : { type: \"f\", value: 0.00025 },\n\t\t\"fogNear\" : { type: \"f\", value: 1 },\n\t\t\"fogFar\" : { type: \"f\", value: 2000 },\n\t\t\"fogColor\" : { type: \"c\", value: new THREE.Color( 0xffffff ) }\n\n\t},\n\n\tshadowmap: {\n\n\t\t\"shadowMap\": { type: \"tv\", value: [] },\n\t\t\"shadowMapSize\": { type: \"v2v\", value: [] },\n\n\t\t\"shadowBias\" : { type: \"fv1\", value: [] },\n\t\t\"shadowDarkness\": { type: \"fv1\", value: [] },\n\n\t\t\"shadowMatrix\" : { type: \"m4v\", value: [] }\n\n\t}\n\n};\n\nTHREE.ShaderLib = {\n\n\t'basic': {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ \"common\" ],\n\t\t\tTHREE.UniformsLib[ \"fog\" ],\n\t\t\tTHREE.UniformsLib[ \"shadowmap\" ]\n\n\t\t] ),\n\n\t\tvertexShader: [\n\n\t\t\tTHREE.ShaderChunk[ \"map_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"envmap_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"map_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\n\n\t\t\t\t\"#ifdef USE_ENVMAP\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"morphnormal_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"skinnormal_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"defaultnormal_vertex\" ],\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"skinning_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\n\n\t\t\t\tTHREE.ShaderChunk[ \"worldpos_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_vertex\" ],\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\"),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform vec3 diffuse;\",\n\t\t\t\"uniform float opacity;\",\n\n\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"map_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"envmap_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"specularmap_pars_fragment\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"gl_FragColor = vec4( diffuse, opacity );\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"map_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"alphatest_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"specularmap_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_fragment\" ],\n\n\t\t\t\tTHREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\n\n\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\")\n\n\t},\n\n\t'lambert': {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ \"common\" ],\n\t\t\tTHREE.UniformsLib[ \"fog\" ],\n\t\t\tTHREE.UniformsLib[ \"lights\" ],\n\t\t\tTHREE.UniformsLib[ \"shadowmap\" ],\n\n\t\t\t{\n\t\t\t\t\"ambient\"  : { type: \"c\", value: new THREE.Color( 0xffffff ) },\n\t\t\t\t\"emissive\" : { type: \"c\", value: new THREE.Color( 0x000000 ) },\n\t\t\t\t\"wrapRGB\"  : { type: \"v3\", value: new THREE.Vector3( 1, 1, 1 ) }\n\t\t\t}\n\n\t\t] ),\n\n\t\tvertexShader: [\n\n\t\t\t\"#define LAMBERT\",\n\n\t\t\t\"varying vec3 vLightFront;\",\n\n\t\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\t\"varying vec3 vLightBack;\",\n\n\t\t\t\"#endif\",\n\n\t\t\tTHREE.ShaderChunk[ \"map_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"envmap_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"lights_lambert_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"map_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\n\n\t\t\t\tTHREE.ShaderChunk[ \"morphnormal_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"skinnormal_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"defaultnormal_vertex\" ],\n\n\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"skinning_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\n\n\t\t\t\tTHREE.ShaderChunk[ \"worldpos_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"lights_lambert_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_vertex\" ],\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\"),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform float opacity;\",\n\n\t\t\t\"varying vec3 vLightFront;\",\n\n\t\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\t\"varying vec3 vLightBack;\",\n\n\t\t\t\"#endif\",\n\n\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"map_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"envmap_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"specularmap_pars_fragment\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"gl_FragColor = vec4( vec3 ( 1.0 ), opacity );\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"map_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"alphatest_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"specularmap_fragment\" ],\n\n\t\t\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\t\t//\"float isFront = float( gl_FrontFacing );\",\n\t\t\t\t\t//\"gl_FragColor.xyz *= isFront * vLightFront + ( 1.0 - isFront ) * vLightBack;\",\n\n\t\t\t\t\t\"if ( gl_FrontFacing )\",\n\t\t\t\t\t\t\"gl_FragColor.xyz *= vLightFront;\",\n\t\t\t\t\t\"else\",\n\t\t\t\t\t\t\"gl_FragColor.xyz *= vLightBack;\",\n\n\t\t\t\t\"#else\",\n\n\t\t\t\t\t\"gl_FragColor.xyz *= vLightFront;\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_fragment\" ],\n\n\t\t\t\tTHREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\n\n\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\")\n\n\t},\n\n\t'phong': {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ \"common\" ],\n\t\t\tTHREE.UniformsLib[ \"bump\" ],\n\t\t\tTHREE.UniformsLib[ \"normalmap\" ],\n\t\t\tTHREE.UniformsLib[ \"fog\" ],\n\t\t\tTHREE.UniformsLib[ \"lights\" ],\n\t\t\tTHREE.UniformsLib[ \"shadowmap\" ],\n\n\t\t\t{\n\t\t\t\t\"ambient\"  : { type: \"c\", value: new THREE.Color( 0xffffff ) },\n\t\t\t\t\"emissive\" : { type: \"c\", value: new THREE.Color( 0x000000 ) },\n\t\t\t\t\"specular\" : { type: \"c\", value: new THREE.Color( 0x111111 ) },\n\t\t\t\t\"shininess\": { type: \"f\", value: 30 },\n\t\t\t\t\"wrapRGB\"  : { type: \"v3\", value: new THREE.Vector3( 1, 1, 1 ) }\n\t\t\t}\n\n\t\t] ),\n\n\t\tvertexShader: [\n\n\t\t\t\"#define PHONG\",\n\n\t\t\t\"varying vec3 vViewPosition;\",\n\t\t\t\"varying vec3 vNormal;\",\n\n\t\t\tTHREE.ShaderChunk[ \"map_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"envmap_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"lights_phong_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"map_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\n\n\t\t\t\tTHREE.ShaderChunk[ \"morphnormal_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"skinnormal_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"defaultnormal_vertex\" ],\n\n\t\t\t\t\"vNormal = normalize( transformedNormal );\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"skinning_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\n\n\t\t\t\t\"vViewPosition = -mvPosition.xyz;\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"worldpos_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"lights_phong_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_vertex\" ],\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\"),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform vec3 diffuse;\",\n\t\t\t\"uniform float opacity;\",\n\n\t\t\t\"uniform vec3 ambient;\",\n\t\t\t\"uniform vec3 emissive;\",\n\t\t\t\"uniform vec3 specular;\",\n\t\t\t\"uniform float shininess;\",\n\n\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"map_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"envmap_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"lights_phong_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"bumpmap_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"normalmap_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"specularmap_pars_fragment\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"gl_FragColor = vec4( vec3 ( 1.0 ), opacity );\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"map_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"alphatest_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"specularmap_fragment\" ],\n\n\t\t\t\tTHREE.ShaderChunk[ \"lights_phong_fragment\" ],\n\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_fragment\" ],\n\n\t\t\t\tTHREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\n\n\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\")\n\n\t},\n\n\t'particle_basic': {\n\n\t\tuniforms:  THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ \"particle\" ],\n\t\t\tTHREE.UniformsLib[ \"shadowmap\" ]\n\n\t\t] ),\n\n\t\tvertexShader: [\n\n\t\t\t\"uniform float size;\",\n\t\t\t\"uniform float scale;\",\n\n\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\n\n\t\t\t\t\"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\t\"#ifdef USE_SIZEATTENUATION\",\n\t\t\t\t\t\"gl_PointSize = size * ( scale / length( mvPosition.xyz ) );\",\n\t\t\t\t\"#else\",\n\t\t\t\t\t\"gl_PointSize = size;\",\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"gl_Position = projectionMatrix * mvPosition;\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"worldpos_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_vertex\" ],\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\"),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform vec3 psColor;\",\n\t\t\t\"uniform float opacity;\",\n\n\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"map_particle_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"gl_FragColor = vec4( psColor, opacity );\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"map_particle_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"alphatest_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\")\n\n\t},\n\n\t'dashed': {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ \"common\" ],\n\t\t\tTHREE.UniformsLib[ \"fog\" ],\n\n\t\t\t{\n\t\t\t\t\"scale\":     { type: \"f\", value: 1 },\n\t\t\t\t\"dashSize\":  { type: \"f\", value: 1 },\n\t\t\t\t\"totalSize\": { type: \"f\", value: 2 }\n\t\t\t}\n\n\t\t] ),\n\n\t\tvertexShader: [\n\n\t\t\t\"uniform float scale;\",\n\t\t\t\"attribute float lineDistance;\",\n\n\t\t\t\"varying float vLineDistance;\",\n\n\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\n\n\t\t\t\t\"vLineDistance = scale * lineDistance;\",\n\n\t\t\t\t\"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\n\t\t\t\t\"gl_Position = projectionMatrix * mvPosition;\",\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\"),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform vec3 diffuse;\",\n\t\t\t\"uniform float opacity;\",\n\n\t\t\t\"uniform float dashSize;\",\n\t\t\t\"uniform float totalSize;\",\n\n\t\t\t\"varying float vLineDistance;\",\n\n\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"if ( mod( vLineDistance, totalSize ) > dashSize ) {\",\n\n\t\t\t\t\t\"discard;\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\t\"gl_FragColor = vec4( diffuse, opacity );\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\")\n\n\t},\n\n\t'depth': {\n\n\t\tuniforms: {\n\n\t\t\t\"mNear\": { type: \"f\", value: 1.0 },\n\t\t\t\"mFar\" : { type: \"f\", value: 2000.0 },\n\t\t\t\"opacity\" : { type: \"f\", value: 1.0 }\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\"),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform float mNear;\",\n\t\t\t\"uniform float mFar;\",\n\t\t\t\"uniform float opacity;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"float depth = gl_FragCoord.z / gl_FragCoord.w;\",\n\t\t\t\t\"float color = 1.0 - smoothstep( mNear, mFar, depth );\",\n\t\t\t\t\"gl_FragColor = vec4( vec3( color ), opacity );\",\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\")\n\n\t},\n\n\t'normal': {\n\n\t\tuniforms: {\n\n\t\t\t\"opacity\" : { type: \"f\", value: 1.0 }\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec3 vNormal;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\n\t\t\t\t\"vNormal = normalize( normalMatrix * normal );\",\n\n\t\t\t\t\"gl_Position = projectionMatrix * mvPosition;\",\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\"),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform float opacity;\",\n\t\t\t\"varying vec3 vNormal;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );\",\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\")\n\n\t},\n\n\t/* -------------------------------------------------------------------------\n\t//\tNormal map shader\n\t//\t\t- Blinn-Phong\n\t//\t\t- normal + diffuse + specular + AO + displacement + reflection + shadow maps\n\t//\t\t- point and directional lights (use with \"lights: true\" material option)\n\t ------------------------------------------------------------------------- */\n\n\t'normalmap' : {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ \"fog\" ],\n\t\t\tTHREE.UniformsLib[ \"lights\" ],\n\t\t\tTHREE.UniformsLib[ \"shadowmap\" ],\n\n\t\t\t{\n\n\t\t\t\"enableAO\"\t\t  : { type: \"i\", value: 0 },\n\t\t\t\"enableDiffuse\"\t  : { type: \"i\", value: 0 },\n\t\t\t\"enableSpecular\"  : { type: \"i\", value: 0 },\n\t\t\t\"enableReflection\": { type: \"i\", value: 0 },\n\t\t\t\"enableDisplacement\": { type: \"i\", value: 0 },\n\n\t\t\t\"tDisplacement\": { type: \"t\", value: null }, // must go first as this is vertex texture\n\t\t\t\"tDiffuse\"\t   : { type: \"t\", value: null },\n\t\t\t\"tCube\"\t\t   : { type: \"t\", value: null },\n\t\t\t\"tNormal\"\t   : { type: \"t\", value: null },\n\t\t\t\"tSpecular\"\t   : { type: \"t\", value: null },\n\t\t\t\"tAO\"\t\t   : { type: \"t\", value: null },\n\n\t\t\t\"uNormalScale\": { type: \"v2\", value: new THREE.Vector2( 1, 1 ) },\n\n\t\t\t\"uDisplacementBias\": { type: \"f\", value: 0.0 },\n\t\t\t\"uDisplacementScale\": { type: \"f\", value: 1.0 },\n\n\t\t\t\"uDiffuseColor\": { type: \"c\", value: new THREE.Color( 0xffffff ) },\n\t\t\t\"uSpecularColor\": { type: \"c\", value: new THREE.Color( 0x111111 ) },\n\t\t\t\"uAmbientColor\": { type: \"c\", value: new THREE.Color( 0xffffff ) },\n\t\t\t\"uShininess\": { type: \"f\", value: 30 },\n\t\t\t\"uOpacity\": { type: \"f\", value: 1 },\n\n\t\t\t\"useRefract\": { type: \"i\", value: 0 },\n\t\t\t\"uRefractionRatio\": { type: \"f\", value: 0.98 },\n\t\t\t\"uReflectivity\": { type: \"f\", value: 0.5 },\n\n\t\t\t\"uOffset\" : { type: \"v2\", value: new THREE.Vector2( 0, 0 ) },\n\t\t\t\"uRepeat\" : { type: \"v2\", value: new THREE.Vector2( 1, 1 ) },\n\n\t\t\t\"wrapRGB\"  : { type: \"v3\", value: new THREE.Vector3( 1, 1, 1 ) }\n\n\t\t\t}\n\n\t\t] ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform vec3 uAmbientColor;\",\n\t\t\t\"uniform vec3 uDiffuseColor;\",\n\t\t\t\"uniform vec3 uSpecularColor;\",\n\t\t\t\"uniform float uShininess;\",\n\t\t\t\"uniform float uOpacity;\",\n\n\t\t\t\"uniform bool enableDiffuse;\",\n\t\t\t\"uniform bool enableSpecular;\",\n\t\t\t\"uniform bool enableAO;\",\n\t\t\t\"uniform bool enableReflection;\",\n\n\t\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\t\"uniform sampler2D tNormal;\",\n\t\t\t\"uniform sampler2D tSpecular;\",\n\t\t\t\"uniform sampler2D tAO;\",\n\n\t\t\t\"uniform samplerCube tCube;\",\n\n\t\t\t\"uniform vec2 uNormalScale;\",\n\n\t\t\t\"uniform bool useRefract;\",\n\t\t\t\"uniform float uRefractionRatio;\",\n\t\t\t\"uniform float uReflectivity;\",\n\n\t\t\t\"varying vec3 vTangent;\",\n\t\t\t\"varying vec3 vBinormal;\",\n\t\t\t\"varying vec3 vNormal;\",\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"uniform vec3 ambientLightColor;\",\n\n\t\t\t\"#if MAX_DIR_LIGHTS > 0\",\n\n\t\t\t\t\"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\",\n\t\t\t\t\"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"#if MAX_HEMI_LIGHTS > 0\",\n\n\t\t\t\t\"uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\",\n\t\t\t\t\"uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\",\n\t\t\t\t\"uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"#if MAX_POINT_LIGHTS > 0\",\n\n\t\t\t\t\"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\",\n\t\t\t\t\"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\",\n\t\t\t\t\"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"#if MAX_SPOT_LIGHTS > 0\",\n\n\t\t\t\t\"uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\t\"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\t\"uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\t\"uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\t\"uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\t\"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\t\"uniform vec3 wrapRGB;\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"varying vec3 vWorldPosition;\",\n\t\t\t\"varying vec3 vViewPosition;\",\n\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"gl_FragColor = vec4( vec3( 1.0 ), uOpacity );\",\n\n\t\t\t\t\"vec3 specularTex = vec3( 1.0 );\",\n\n\t\t\t\t\"vec3 normalTex = texture2D( tNormal, vUv ).xyz * 2.0 - 1.0;\",\n\t\t\t\t\"normalTex.xy *= uNormalScale;\",\n\t\t\t\t\"normalTex = normalize( normalTex );\",\n\n\t\t\t\t\"if( enableDiffuse ) {\",\n\n\t\t\t\t\t\"#ifdef GAMMA_INPUT\",\n\n\t\t\t\t\t\t\"vec4 texelColor = texture2D( tDiffuse, vUv );\",\n\t\t\t\t\t\t\"texelColor.xyz *= texelColor.xyz;\",\n\n\t\t\t\t\t\t\"gl_FragColor = gl_FragColor * texelColor;\",\n\n\t\t\t\t\t\"#else\",\n\n\t\t\t\t\t\t\"gl_FragColor = gl_FragColor * texture2D( tDiffuse, vUv );\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\t\"if( enableAO ) {\",\n\n\t\t\t\t\t\"#ifdef GAMMA_INPUT\",\n\n\t\t\t\t\t\t\"vec4 aoColor = texture2D( tAO, vUv );\",\n\t\t\t\t\t\t\"aoColor.xyz *= aoColor.xyz;\",\n\n\t\t\t\t\t\t\"gl_FragColor.xyz = gl_FragColor.xyz * aoColor.xyz;\",\n\n\t\t\t\t\t\"#else\",\n\n\t\t\t\t\t\t\"gl_FragColor.xyz = gl_FragColor.xyz * texture2D( tAO, vUv ).xyz;\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\t\"if( enableSpecular )\",\n\t\t\t\t\t\"specularTex = texture2D( tSpecular, vUv ).xyz;\",\n\n\t\t\t\t\"mat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normalize( vNormal ) );\",\n\t\t\t\t\"vec3 finalNormal = tsb * normalTex;\",\n\n\t\t\t\t\"#ifdef FLIP_SIDED\",\n\n\t\t\t\t\t\"finalNormal = -finalNormal;\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"vec3 normal = normalize( finalNormal );\",\n\t\t\t\t\"vec3 viewPosition = normalize( vViewPosition );\",\n\n\t\t\t\t// point lights\n\n\t\t\t\t\"#if MAX_POINT_LIGHTS > 0\",\n\n\t\t\t\t\t\"vec3 pointDiffuse = vec3( 0.0 );\",\n\t\t\t\t\t\"vec3 pointSpecular = vec3( 0.0 );\",\n\n\t\t\t\t\t\"for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\",\n\n\t\t\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\",\n\t\t\t\t\t\t\"vec3 pointVector = lPosition.xyz + vViewPosition.xyz;\",\n\n\t\t\t\t\t\t\"float pointDistance = 1.0;\",\n\t\t\t\t\t\t\"if ( pointLightDistance[ i ] > 0.0 )\",\n\t\t\t\t\t\t\t\"pointDistance = 1.0 - min( ( length( pointVector ) / pointLightDistance[ i ] ), 1.0 );\",\n\n\t\t\t\t\t\t\"pointVector = normalize( pointVector );\",\n\n\t\t\t\t\t\t// diffuse\n\n\t\t\t\t\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\t\t\t\t\"float pointDiffuseWeightFull = max( dot( normal, pointVector ), 0.0 );\",\n\t\t\t\t\t\t\t\"float pointDiffuseWeightHalf = max( 0.5 * dot( normal, pointVector ) + 0.5, 0.0 );\",\n\n\t\t\t\t\t\t\t\"vec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\",\n\n\t\t\t\t\t\t\"#else\",\n\n\t\t\t\t\t\t\t\"float pointDiffuseWeight = max( dot( normal, pointVector ), 0.0 );\",\n\n\t\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\t\"pointDiffuse += pointDistance * pointLightColor[ i ] * uDiffuseColor * pointDiffuseWeight;\",\n\n\t\t\t\t\t\t// specular\n\n\t\t\t\t\t\t\"vec3 pointHalfVector = normalize( pointVector + viewPosition );\",\n\t\t\t\t\t\t\"float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\",\n\t\t\t\t\t\t\"float pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, uShininess ), 0.0 );\",\n\n\t\t\t\t\t\t\"#ifdef PHYSICALLY_BASED_SHADING\",\n\n\t\t\t\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\n\n\t\t\t\t\t\t\t\"float specularNormalization = ( uShininess + 2.0001 ) / 8.0;\",\n\n\t\t\t\t\t\t\t\"vec3 schlick = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( pointVector, pointHalfVector ), 5.0 );\",\n\t\t\t\t\t\t\t\"pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * pointDistance * specularNormalization;\",\n\n\t\t\t\t\t\t\"#else\",\n\n\t\t\t\t\t\t\t\"pointSpecular += pointDistance * pointLightColor[ i ] * uSpecularColor * pointSpecularWeight * pointDiffuseWeight;\",\n\n\t\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\"}\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t// spot lights\n\n\t\t\t\t\"#if MAX_SPOT_LIGHTS > 0\",\n\n\t\t\t\t\t\"vec3 spotDiffuse = vec3( 0.0 );\",\n\t\t\t\t\t\"vec3 spotSpecular = vec3( 0.0 );\",\n\n\t\t\t\t\t\"for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\",\n\n\t\t\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\",\n\t\t\t\t\t\t\"vec3 spotVector = lPosition.xyz + vViewPosition.xyz;\",\n\n\t\t\t\t\t\t\"float spotDistance = 1.0;\",\n\t\t\t\t\t\t\"if ( spotLightDistance[ i ] > 0.0 )\",\n\t\t\t\t\t\t\t\"spotDistance = 1.0 - min( ( length( spotVector ) / spotLightDistance[ i ] ), 1.0 );\",\n\n\t\t\t\t\t\t\"spotVector = normalize( spotVector );\",\n\n\t\t\t\t\t\t\"float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\",\n\n\t\t\t\t\t\t\"if ( spotEffect > spotLightAngleCos[ i ] ) {\",\n\n\t\t\t\t\t\t\t\"spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\",\n\n\t\t\t\t\t\t\t// diffuse\n\n\t\t\t\t\t\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\t\t\t\t\t\"float spotDiffuseWeightFull = max( dot( normal, spotVector ), 0.0 );\",\n\t\t\t\t\t\t\t\t\"float spotDiffuseWeightHalf = max( 0.5 * dot( normal, spotVector ) + 0.5, 0.0 );\",\n\n\t\t\t\t\t\t\t\t\"vec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\",\n\n\t\t\t\t\t\t\t\"#else\",\n\n\t\t\t\t\t\t\t\t\"float spotDiffuseWeight = max( dot( normal, spotVector ), 0.0 );\",\n\n\t\t\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\t\t\"spotDiffuse += spotDistance * spotLightColor[ i ] * uDiffuseColor * spotDiffuseWeight * spotEffect;\",\n\n\t\t\t\t\t\t\t// specular\n\n\t\t\t\t\t\t\t\"vec3 spotHalfVector = normalize( spotVector + viewPosition );\",\n\t\t\t\t\t\t\t\"float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\",\n\t\t\t\t\t\t\t\"float spotSpecularWeight = specularTex.r * max( pow( spotDotNormalHalf, uShininess ), 0.0 );\",\n\n\t\t\t\t\t\t\t\"#ifdef PHYSICALLY_BASED_SHADING\",\n\n\t\t\t\t\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\n\n\t\t\t\t\t\t\t\t\"float specularNormalization = ( uShininess + 2.0001 ) / 8.0;\",\n\n\t\t\t\t\t\t\t\t\"vec3 schlick = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( spotVector, spotHalfVector ), 5.0 );\",\n\t\t\t\t\t\t\t\t\"spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * spotDistance * specularNormalization * spotEffect;\",\n\n\t\t\t\t\t\t\t\"#else\",\n\n\t\t\t\t\t\t\t\t\"spotSpecular += spotDistance * spotLightColor[ i ] * uSpecularColor * spotSpecularWeight * spotDiffuseWeight * spotEffect;\",\n\n\t\t\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\t\"}\",\n\n\t\t\t\t\t\"}\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t// directional lights\n\n\t\t\t\t\"#if MAX_DIR_LIGHTS > 0\",\n\n\t\t\t\t\t\"vec3 dirDiffuse = vec3( 0.0 );\",\n\t\t\t\t\t\"vec3 dirSpecular = vec3( 0.0 );\",\n\n\t\t\t\t\t\"for( int i = 0; i < MAX_DIR_LIGHTS; i++ ) {\",\n\n\t\t\t\t\t\t\"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\",\n\t\t\t\t\t\t\"vec3 dirVector = normalize( lDirection.xyz );\",\n\n\t\t\t\t\t\t// diffuse\n\n\t\t\t\t\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\t\t\t\t\"float directionalLightWeightingFull = max( dot( normal, dirVector ), 0.0 );\",\n\t\t\t\t\t\t\t\"float directionalLightWeightingHalf = max( 0.5 * dot( normal, dirVector ) + 0.5, 0.0 );\",\n\n\t\t\t\t\t\t\t\"vec3 dirDiffuseWeight = mix( vec3( directionalLightWeightingFull ), vec3( directionalLightWeightingHalf ), wrapRGB );\",\n\n\t\t\t\t\t\t\"#else\",\n\n\t\t\t\t\t\t\t\"float dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );\",\n\n\t\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\t\"dirDiffuse += directionalLightColor[ i ] * uDiffuseColor * dirDiffuseWeight;\",\n\n\t\t\t\t\t\t// specular\n\n\t\t\t\t\t\t\"vec3 dirHalfVector = normalize( dirVector + viewPosition );\",\n\t\t\t\t\t\t\"float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\",\n\t\t\t\t\t\t\"float dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, uShininess ), 0.0 );\",\n\n\t\t\t\t\t\t\"#ifdef PHYSICALLY_BASED_SHADING\",\n\n\t\t\t\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\n\n\t\t\t\t\t\t\t\"float specularNormalization = ( uShininess + 2.0001 ) / 8.0;\",\n\n\t\t\t\t\t\t\t\"vec3 schlick = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );\",\n\t\t\t\t\t\t\t\"dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\",\n\n\t\t\t\t\t\t\"#else\",\n\n\t\t\t\t\t\t\t\"dirSpecular += directionalLightColor[ i ] * uSpecularColor * dirSpecularWeight * dirDiffuseWeight;\",\n\n\t\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\"}\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t// hemisphere lights\n\n\t\t\t\t\"#if MAX_HEMI_LIGHTS > 0\",\n\n\t\t\t\t\t\"vec3 hemiDiffuse  = vec3( 0.0 );\",\n\t\t\t\t\t\"vec3 hemiSpecular = vec3( 0.0 );\" ,\n\n\t\t\t\t\t\"for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\",\n\n\t\t\t\t\t\t\"vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\",\n\t\t\t\t\t\t\"vec3 lVector = normalize( lDirection.xyz );\",\n\n\t\t\t\t\t\t// diffuse\n\n\t\t\t\t\t\t\"float dotProduct = dot( normal, lVector );\",\n\t\t\t\t\t\t\"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\",\n\n\t\t\t\t\t\t\"vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\",\n\n\t\t\t\t\t\t\"hemiDiffuse += uDiffuseColor * hemiColor;\",\n\n\t\t\t\t\t\t// specular (sky light)\n\n\n\t\t\t\t\t\t\"vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\",\n\t\t\t\t\t\t\"float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\",\n\t\t\t\t\t\t\"float hemiSpecularWeightSky = specularTex.r * max( pow( hemiDotNormalHalfSky, uShininess ), 0.0 );\",\n\n\t\t\t\t\t\t// specular (ground light)\n\n\t\t\t\t\t\t\"vec3 lVectorGround = -lVector;\",\n\n\t\t\t\t\t\t\"vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\",\n\t\t\t\t\t\t\"float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\",\n\t\t\t\t\t\t\"float hemiSpecularWeightGround = specularTex.r * max( pow( hemiDotNormalHalfGround, uShininess ), 0.0 );\",\n\n\t\t\t\t\t\t\"#ifdef PHYSICALLY_BASED_SHADING\",\n\n\t\t\t\t\t\t\t\"float dotProductGround = dot( normal, lVectorGround );\",\n\n\t\t\t\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\n\n\t\t\t\t\t\t\t\"float specularNormalization = ( uShininess + 2.0001 ) / 8.0;\",\n\n\t\t\t\t\t\t\t\"vec3 schlickSky = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );\",\n\t\t\t\t\t\t\t\"vec3 schlickGround = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );\",\n\t\t\t\t\t\t\t\"hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\",\n\n\t\t\t\t\t\t\"#else\",\n\n\t\t\t\t\t\t\t\"hemiSpecular += uSpecularColor * hemiColor * ( hemiSpecularWeightSky + hemiSpecularWeightGround ) * hemiDiffuseWeight;\",\n\n\t\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\"}\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t// all lights contribution summation\n\n\t\t\t\t\"vec3 totalDiffuse = vec3( 0.0 );\",\n\t\t\t\t\"vec3 totalSpecular = vec3( 0.0 );\",\n\n\t\t\t\t\"#if MAX_DIR_LIGHTS > 0\",\n\n\t\t\t\t\t\"totalDiffuse += dirDiffuse;\",\n\t\t\t\t\t\"totalSpecular += dirSpecular;\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"#if MAX_HEMI_LIGHTS > 0\",\n\n\t\t\t\t\t\"totalDiffuse += hemiDiffuse;\",\n\t\t\t\t\t\"totalSpecular += hemiSpecular;\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"#if MAX_POINT_LIGHTS > 0\",\n\n\t\t\t\t\t\"totalDiffuse += pointDiffuse;\",\n\t\t\t\t\t\"totalSpecular += pointSpecular;\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"#if MAX_SPOT_LIGHTS > 0\",\n\n\t\t\t\t\t\"totalDiffuse += spotDiffuse;\",\n\t\t\t\t\t\"totalSpecular += spotSpecular;\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"#ifdef METAL\",\n\n\t\t\t\t\t\"gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * uAmbientColor + totalSpecular );\",\n\n\t\t\t\t\"#else\",\n\n\t\t\t\t\t\"gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * uAmbientColor ) + totalSpecular;\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"if ( enableReflection ) {\",\n\n\t\t\t\t\t\"vec3 vReflect;\",\n\t\t\t\t\t\"vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\",\n\n\t\t\t\t\t\"if ( useRefract ) {\",\n\n\t\t\t\t\t\t\"vReflect = refract( cameraToVertex, normal, uRefractionRatio );\",\n\n\t\t\t\t\t\"} else {\",\n\n\t\t\t\t\t\t\"vReflect = reflect( cameraToVertex, normal );\",\n\n\t\t\t\t\t\"}\",\n\n\t\t\t\t\t\"vec4 cubeColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );\",\n\n\t\t\t\t\t\"#ifdef GAMMA_INPUT\",\n\n\t\t\t\t\t\t\"cubeColor.xyz *= cubeColor.xyz;\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\"gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularTex.r * uReflectivity );\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\"),\n\n\t\tvertexShader: [\n\n\t\t\t\"attribute vec4 tangent;\",\n\n\t\t\t\"uniform vec2 uOffset;\",\n\t\t\t\"uniform vec2 uRepeat;\",\n\n\t\t\t\"uniform bool enableDisplacement;\",\n\n\t\t\t\"#ifdef VERTEX_TEXTURES\",\n\n\t\t\t\t\"uniform sampler2D tDisplacement;\",\n\t\t\t\t\"uniform float uDisplacementScale;\",\n\t\t\t\t\"uniform float uDisplacementBias;\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"varying vec3 vTangent;\",\n\t\t\t\"varying vec3 vBinormal;\",\n\t\t\t\"varying vec3 vNormal;\",\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"varying vec3 vWorldPosition;\",\n\t\t\t\"varying vec3 vViewPosition;\",\n\n\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"skinnormal_vertex\" ],\n\n\t\t\t\t// normal, tangent and binormal vectors\n\n\t\t\t\t\"#ifdef USE_SKINNING\",\n\n\t\t\t\t\t\"vNormal = normalize( normalMatrix * skinnedNormal.xyz );\",\n\n\t\t\t\t\t\"vec4 skinnedTangent = skinMatrix * vec4( tangent.xyz, 0.0 );\",\n\t\t\t\t\t\"vTangent = normalize( normalMatrix * skinnedTangent.xyz );\",\n\n\t\t\t\t\"#else\",\n\n\t\t\t\t\t\"vNormal = normalize( normalMatrix * normal );\",\n\t\t\t\t\t\"vTangent = normalize( normalMatrix * tangent.xyz );\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"vBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );\",\n\n\t\t\t\t\"vUv = uv * uRepeat + uOffset;\",\n\n\t\t\t\t// displacement mapping\n\n\t\t\t\t\"vec3 displacedPosition;\",\n\n\t\t\t\t\"#ifdef VERTEX_TEXTURES\",\n\n\t\t\t\t\t\"if ( enableDisplacement ) {\",\n\n\t\t\t\t\t\t\"vec3 dv = texture2D( tDisplacement, uv ).xyz;\",\n\t\t\t\t\t\t\"float df = uDisplacementScale * dv.x + uDisplacementBias;\",\n\t\t\t\t\t\t\"displacedPosition = position + normalize( normal ) * df;\",\n\n\t\t\t\t\t\"} else {\",\n\n\t\t\t\t\t\t\"#ifdef USE_SKINNING\",\n\n\t\t\t\t\t\t\t\"vec4 skinVertex = vec4( position, 1.0 );\",\n\n\t\t\t\t\t\t\t\"vec4 skinned  = boneMatX * skinVertex * skinWeight.x;\",\n\t\t\t\t\t\t\t\"skinned \t  += boneMatY * skinVertex * skinWeight.y;\",\n\n\t\t\t\t\t\t\t\"displacedPosition  = skinned.xyz;\",\n\n\t\t\t\t\t\t\"#else\",\n\n\t\t\t\t\t\t\t\"displacedPosition = position;\",\n\n\t\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\"}\",\n\n\t\t\t\t\"#else\",\n\n\t\t\t\t\t\"#ifdef USE_SKINNING\",\n\n\t\t\t\t\t\t\"vec4 skinVertex = vec4( position, 1.0 );\",\n\n\t\t\t\t\t\t\"vec4 skinned  = boneMatX * skinVertex * skinWeight.x;\",\n\t\t\t\t\t\t\"skinned \t  += boneMatY * skinVertex * skinWeight.y;\",\n\n\t\t\t\t\t\t\"displacedPosition  = skinned.xyz;\",\n\n\t\t\t\t\t\"#else\",\n\n\t\t\t\t\t\t\"displacedPosition = position;\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t//\n\n\t\t\t\t\"vec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );\",\n\t\t\t\t\"vec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );\",\n\n\t\t\t\t\"gl_Position = projectionMatrix * mvPosition;\",\n\n\t\t\t\t//\n\n\t\t\t\t\"vWorldPosition = worldPosition.xyz;\",\n\t\t\t\t\"vViewPosition = -mvPosition.xyz;\",\n\n\t\t\t\t// shadows\n\n\t\t\t\t\"#ifdef USE_SHADOWMAP\",\n\n\t\t\t\t\t\"for( int i = 0; i < MAX_SHADOWS; i ++ ) {\",\n\n\t\t\t\t\t\t\"vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\",\n\n\t\t\t\t\t\"}\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\")\n\n\t},\n\n\t/* -------------------------------------------------------------------------\n\t//\tCube map shader\n\t ------------------------------------------------------------------------- */\n\n\t'cube': {\n\n\t\tuniforms: { \"tCube\": { type: \"t\", value: null },\n\t\t\t\t\t\"tFlip\": { type: \"f\", value: -1 } },\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec3 vWorldPosition;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\",\n\t\t\t\t\"vWorldPosition = worldPosition.xyz;\",\n\n\t\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\"),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform samplerCube tCube;\",\n\t\t\t\"uniform float tFlip;\",\n\n\t\t\t\"varying vec3 vWorldPosition;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\",\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\")\n\n\t},\n\n\t// Depth encoding into RGBA texture\n\t// \tbased on SpiderGL shadow map example\n\t// \t\thttp://spidergl.org/example.php?id=6\n\t// \toriginally from\n\t//\t\thttp://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD\n\t// \tsee also here:\n\t//\t\thttp://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\n\n\t'depthRGBA': {\n\n\t\tuniforms: {},\n\n\t\tvertexShader: [\n\n\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"skinning_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\"),\n\n\t\tfragmentShader: [\n\n\t\t\t\"vec4 pack_depth( const in float depth ) {\",\n\n\t\t\t\t\"const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\",\n\t\t\t\t\"const vec4 bit_mask  = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\",\n\t\t\t\t\"vec4 res = fract( depth * bit_shift );\",\n\t\t\t\t\"res -= res.xxyz * bit_mask;\",\n\t\t\t\t\"return res;\",\n\n\t\t\t\"}\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );\",\n\n\t\t\t\t//\"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z / gl_FragCoord.w );\",\n\t\t\t\t//\"float z = ( ( gl_FragCoord.z / gl_FragCoord.w ) - 3.0 ) / ( 4000.0 - 3.0 );\",\n\t\t\t\t//\"gl_FragData[ 0 ] = pack_depth( z );\",\n\t\t\t\t//\"gl_FragData[ 0 ] = vec4( z, z, z, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\")\n\n\t}\n\n};\n/**\n * @author supereggbert / http://www.paulbrunt.co.uk/\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author szimek / https://github.com/szimek/\n */\n\nTHREE.WebGLRenderer = function ( parameters ) {\n\n\tconsole.log( 'THREE.WebGLRenderer', THREE.REVISION );\n\n\tparameters = parameters || {};\n\n\tvar _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),\n\n\t_precision = parameters.precision !== undefined ? parameters.precision : 'highp',\n\n\t_alpha = parameters.alpha !== undefined ? parameters.alpha : true,\n\t_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\n\t_antialias = parameters.antialias !== undefined ? parameters.antialias : false,\n\t_stencil = parameters.stencil !== undefined ? parameters.stencil : true,\n\t_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,\n\n\t_clearColor = parameters.clearColor !== undefined ? new THREE.Color( parameters.clearColor ) : new THREE.Color( 0x000000 ),\n\t_clearAlpha = parameters.clearAlpha !== undefined ? parameters.clearAlpha : 0;\n\n\t// public properties\n\n\tthis.domElement = _canvas;\n\tthis.context = null;\n\tthis.devicePixelRatio = parameters.devicePixelRatio !== undefined\n\t\t\t\t? parameters.devicePixelRatio\n\t\t\t\t: window.devicePixelRatio !== undefined\n\t\t\t\t\t? window.devicePixelRatio\n\t\t\t\t\t: 1;\n\n\t// clearing\n\n\tthis.autoClear = true;\n\tthis.autoClearColor = true;\n\tthis.autoClearDepth = true;\n\tthis.autoClearStencil = true;\n\n\t// scene graph\n\n\tthis.sortObjects = true;\n\n\tthis.autoUpdateObjects = true;\n\tthis.autoUpdateScene = true;\n\n\t// physically based shading\n\n\tthis.gammaInput = false;\n\tthis.gammaOutput = false;\n\tthis.physicallyBasedShading = false;\n\n\t// shadow map\n\n\tthis.shadowMapEnabled = false;\n\tthis.shadowMapAutoUpdate = true;\n\tthis.shadowMapType = THREE.PCFShadowMap;\n\tthis.shadowMapCullFace = THREE.CullFaceFront;\n\tthis.shadowMapDebug = false;\n\tthis.shadowMapCascade = false;\n\n\t// morphs\n\n\tthis.maxMorphTargets = 8;\n\tthis.maxMorphNormals = 4;\n\n\t// flags\n\n\tthis.autoScaleCubemaps = true;\n\n\t// custom render plugins\n\n\tthis.renderPluginsPre = [];\n\tthis.renderPluginsPost = [];\n\n\t// info\n\n\tthis.info = {\n\n\t\tmemory: {\n\n\t\t\tprograms: 0,\n\t\t\tgeometries: 0,\n\t\t\ttextures: 0\n\n\t\t},\n\n\t\trender: {\n\n\t\t\tcalls: 0,\n\t\t\tvertices: 0,\n\t\t\tfaces: 0,\n\t\t\tpoints: 0\n\n\t\t}\n\n\t};\n\n\t// internal properties\n\n\tvar _this = this,\n\n\t_programs = [],\n\t_programs_counter = 0,\n\n\t// internal state cache\n\n\t_currentProgram = null,\n\t_currentFramebuffer = null,\n\t_currentMaterialId = -1,\n\t_currentGeometryGroupHash = null,\n\t_currentCamera = null,\n\t_geometryGroupCounter = 0,\n\n\t_usedTextureUnits = 0,\n\n\t// GL state cache\n\n\t_oldDoubleSided = -1,\n\t_oldFlipSided = -1,\n\n\t_oldBlending = -1,\n\n\t_oldBlendEquation = -1,\n\t_oldBlendSrc = -1,\n\t_oldBlendDst = -1,\n\n\t_oldDepthTest = -1,\n\t_oldDepthWrite = -1,\n\n\t_oldPolygonOffset = null,\n\t_oldPolygonOffsetFactor = null,\n\t_oldPolygonOffsetUnits = null,\n\n\t_oldLineWidth = null,\n\n\t_viewportX = 0,\n\t_viewportY = 0,\n\t_viewportWidth = 0,\n\t_viewportHeight = 0,\n\t_currentWidth = 0,\n\t_currentHeight = 0,\n\n\t_enabledAttributes = {},\n\n\t// frustum\n\n\t_frustum = new THREE.Frustum(),\n\n\t // camera matrices cache\n\n\t_projScreenMatrix = new THREE.Matrix4(),\n\t_projScreenMatrixPS = new THREE.Matrix4(),\n\n\t_vector3 = new THREE.Vector3(),\n\n\t// light arrays cache\n\n\t_direction = new THREE.Vector3(),\n\n\t_lightsNeedUpdate = true,\n\n\t_lights = {\n\n\t\tambient: [ 0, 0, 0 ],\n\t\tdirectional: { length: 0, colors: new Array(), positions: new Array() },\n\t\tpoint: { length: 0, colors: new Array(), positions: new Array(), distances: new Array() },\n\t\tspot: { length: 0, colors: new Array(), positions: new Array(), distances: new Array(), directions: new Array(), anglesCos: new Array(), exponents: new Array() },\n\t\themi: { length: 0, skyColors: new Array(), groundColors: new Array(), positions: new Array() }\n\n\t};\n\n\t// initialize\n\n\tvar _gl;\n\n\tvar _glExtensionTextureFloat;\n\tvar _glExtensionStandardDerivatives;\n\tvar _glExtensionTextureFilterAnisotropic;\n\tvar _glExtensionCompressedTextureS3TC;\n\n\tinitGL();\n\n\tsetDefaultGLState();\n\n\tthis.context = _gl;\n\n\t// GPU capabilities\n\n\tvar _maxTextures = _gl.getParameter( _gl.MAX_TEXTURE_IMAGE_UNITS );\n\tvar _maxVertexTextures = _gl.getParameter( _gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );\n\tvar _maxTextureSize = _gl.getParameter( _gl.MAX_TEXTURE_SIZE );\n\tvar _maxCubemapSize = _gl.getParameter( _gl.MAX_CUBE_MAP_TEXTURE_SIZE );\n\n\tvar _maxAnisotropy = _glExtensionTextureFilterAnisotropic ? _gl.getParameter( _glExtensionTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT ) : 0;\n\n\tvar _supportsVertexTextures = ( _maxVertexTextures > 0 );\n\tvar _supportsBoneTextures = _supportsVertexTextures && _glExtensionTextureFloat;\n\n\tvar _compressedTextureFormats = _glExtensionCompressedTextureS3TC ? _gl.getParameter( _gl.COMPRESSED_TEXTURE_FORMATS ) : [];\n\n\t//\n\n\tvar _vertexShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.HIGH_FLOAT );\n\tvar _vertexShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.MEDIUM_FLOAT );\n\tvar _vertexShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.LOW_FLOAT );\n\n\tvar _fragmentShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.HIGH_FLOAT );\n\tvar _fragmentShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.MEDIUM_FLOAT );\n\tvar _fragmentShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.LOW_FLOAT );\n\n\tvar _vertexShaderPrecisionHighpInt = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.HIGH_INT );\n\tvar _vertexShaderPrecisionMediumpInt = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.MEDIUM_INT );\n\tvar _vertexShaderPrecisionLowpInt = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.LOW_INT );\n\n\tvar _fragmentShaderPrecisionHighpInt = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.HIGH_INT );\n\tvar _fragmentShaderPrecisionMediumpInt = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.MEDIUM_INT );\n\tvar _fragmentShaderPrecisionLowpInt = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.LOW_INT );\n\n\t// clamp precision to maximum available\n\n\tvar highpAvailable = _vertexShaderPrecisionHighpFloat.precision > 0 && _fragmentShaderPrecisionHighpFloat.precision > 0;\n\tvar mediumpAvailable = _vertexShaderPrecisionMediumpFloat.precision > 0 && _fragmentShaderPrecisionMediumpFloat.precision > 0;\n\n\tif ( _precision === \"highp\" && ! highpAvailable ) {\n\n\t\tif ( mediumpAvailable ) {\n\n\t\t\t_precision = \"mediump\";\n\t\t\tconsole.warn( \"WebGLRenderer: highp not supported, using mediump\" );\n\n\t\t} else {\n\n\t\t\t_precision = \"lowp\";\n\t\t\tconsole.warn( \"WebGLRenderer: highp and mediump not supported, using lowp\" );\n\n\t\t}\n\n\t}\n\n\tif ( _precision === \"mediump\" && ! mediumpAvailable ) {\n\n\t\t_precision = \"lowp\";\n\t\tconsole.warn( \"WebGLRenderer: mediump not supported, using lowp\" );\n\n\t}\n\n\t// API\n\n\tthis.getContext = function () {\n\n\t\treturn _gl;\n\n\t};\n\n\tthis.supportsVertexTextures = function () {\n\n\t\treturn _supportsVertexTextures;\n\n\t};\n\n\tthis.supportsFloatTextures = function () {\n\n\t\treturn _glExtensionTextureFloat;\n\n\t};\n\t\n\tthis.supportsStandardDerivatives = function () {\n\n\t\treturn _glExtensionStandardDerivatives;\n\n\t};\n\t\n\tthis.supportsCompressedTextureS3TC = function () {\n\n\t\treturn _glExtensionCompressedTextureS3TC;\n\n\t};\n\t\n\tthis.getMaxAnisotropy  = function () {\n\n\t\treturn _maxAnisotropy;\n\n\t};\n\n\tthis.getPrecision = function () {\n\n\t\treturn _precision;\n\n\t};\n\n\tthis.setSize = function ( width, height ) {\n\n\t\t_canvas.width = width * this.devicePixelRatio;\n\t\t_canvas.height = height * this.devicePixelRatio;\n\n\t\t_canvas.style.width = width + 'px';\n\t\t_canvas.style.height = height + 'px';\n\n\t\tthis.setViewport( 0, 0, _canvas.width, _canvas.height );\n\n\t};\n\n\tthis.setViewport = function ( x, y, width, height ) {\n\n\t\t_viewportX = x !== undefined ? x : 0;\n\t\t_viewportY = y !== undefined ? y : 0;\n\n\t\t_viewportWidth = width !== undefined ? width : _canvas.width;\n\t\t_viewportHeight = height !== undefined ? height : _canvas.height;\n\n\t\t_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );\n\n\t};\n\n\tthis.setScissor = function ( x, y, width, height ) {\n\n\t\t_gl.scissor( x, y, width, height );\n\n\t};\n\n\tthis.enableScissorTest = function ( enable ) {\n\n\t\tenable ? _gl.enable( _gl.SCISSOR_TEST ) : _gl.disable( _gl.SCISSOR_TEST );\n\n\t};\n\n\t// Clearing\n\n\tthis.setClearColorHex = function ( hex, alpha ) {\n\n\t\t_clearColor.setHex( hex );\n\t\t_clearAlpha = alpha;\n\n\t\t_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\n\t};\n\n\tthis.setClearColor = function ( color, alpha ) {\n\n\t\t_clearColor.copy( color );\n\t\t_clearAlpha = alpha;\n\n\t\t_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\n\t};\n\n\tthis.getClearColor = function () {\n\n\t\treturn _clearColor;\n\n\t};\n\n\tthis.getClearAlpha = function () {\n\n\t\treturn _clearAlpha;\n\n\t};\n\n\tthis.clear = function ( color, depth, stencil ) {\n\n\t\tvar bits = 0;\n\n\t\tif ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;\n\t\tif ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;\n\t\tif ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;\n\n\t\t_gl.clear( bits );\n\n\t};\n\n\tthis.clearTarget = function ( renderTarget, color, depth, stencil ) {\n\n\t\tthis.setRenderTarget( renderTarget );\n\t\tthis.clear( color, depth, stencil );\n\n\t};\n\n\t// Plugins\n\n\tthis.addPostPlugin = function ( plugin ) {\n\n\t\tplugin.init( this );\n\t\tthis.renderPluginsPost.push( plugin );\n\n\t};\n\n\tthis.addPrePlugin = function ( plugin ) {\n\n\t\tplugin.init( this );\n\t\tthis.renderPluginsPre.push( plugin );\n\n\t};\n\n\t// Rendering\n\n\tthis.updateShadowMap = function ( scene, camera ) {\n\n\t\t_currentProgram = null;\n\t\t_oldBlending = -1;\n\t\t_oldDepthTest = -1;\n\t\t_oldDepthWrite = -1;\n\t\t_currentGeometryGroupHash = -1;\n\t\t_currentMaterialId = -1;\n\t\t_lightsNeedUpdate = true;\n\t\t_oldDoubleSided = -1;\n\t\t_oldFlipSided = -1;\n\n\t\tthis.shadowMapPlugin.update( scene, camera );\n\n\t};\n\n\t// Internal functions\n\n\t// Buffer allocation\n\n\tfunction createParticleBuffers ( geometry ) {\n\n\t\tgeometry.__webglVertexBuffer = _gl.createBuffer();\n\t\tgeometry.__webglColorBuffer = _gl.createBuffer();\n\n\t\t_this.info.memory.geometries ++;\n\n\t};\n\n\tfunction createLineBuffers ( geometry ) {\n\n\t\tgeometry.__webglVertexBuffer = _gl.createBuffer();\n\t\tgeometry.__webglColorBuffer = _gl.createBuffer();\n\t\tgeometry.__webglLineDistanceBuffer = _gl.createBuffer();\n\n\t\t_this.info.memory.geometries ++;\n\n\t};\n\n\tfunction createRibbonBuffers ( geometry ) {\n\n\t\tgeometry.__webglVertexBuffer = _gl.createBuffer();\n\t\tgeometry.__webglColorBuffer = _gl.createBuffer();\n\t\tgeometry.__webglNormalBuffer = _gl.createBuffer();\n\n\t\t_this.info.memory.geometries ++;\n\n\t};\n\n\tfunction createMeshBuffers ( geometryGroup ) {\n\n\t\tgeometryGroup.__webglVertexBuffer = _gl.createBuffer();\n\t\tgeometryGroup.__webglNormalBuffer = _gl.createBuffer();\n\t\tgeometryGroup.__webglTangentBuffer = _gl.createBuffer();\n\t\tgeometryGroup.__webglColorBuffer = _gl.createBuffer();\n\t\tgeometryGroup.__webglUVBuffer = _gl.createBuffer();\n\t\tgeometryGroup.__webglUV2Buffer = _gl.createBuffer();\n\n\t\tgeometryGroup.__webglSkinIndicesBuffer = _gl.createBuffer();\n\t\tgeometryGroup.__webglSkinWeightsBuffer = _gl.createBuffer();\n\n\t\tgeometryGroup.__webglFaceBuffer = _gl.createBuffer();\n\t\tgeometryGroup.__webglLineBuffer = _gl.createBuffer();\n\n\t\tvar m, ml;\n\n\t\tif ( geometryGroup.numMorphTargets ) {\n\n\t\t\tgeometryGroup.__webglMorphTargetsBuffers = [];\n\n\t\t\tfor ( m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {\n\n\t\t\t\tgeometryGroup.__webglMorphTargetsBuffers.push( _gl.createBuffer() );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( geometryGroup.numMorphNormals ) {\n\n\t\t\tgeometryGroup.__webglMorphNormalsBuffers = [];\n\n\t\t\tfor ( m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {\n\n\t\t\t\tgeometryGroup.__webglMorphNormalsBuffers.push( _gl.createBuffer() );\n\n\t\t\t}\n\n\t\t}\n\n\t\t_this.info.memory.geometries ++;\n\n\t};\n\n\t// Events\n\n\tvar onGeometryDispose = function ( event ) {\n\n\t\tvar geometry = event.target;\n\n\t\tgeometry.removeEventListener( 'dispose', onGeometryDispose );\n\n\t\tdeallocateGeometry( geometry );\n\n\t\t_this.info.memory.geometries --;\n\n\t};\n\n\tvar onTextureDispose = function ( event ) {\n\n\t\tvar texture = event.target;\n\n\t\ttexture.removeEventListener( 'dispose', onTextureDispose );\n\n\t\tdeallocateTexture( texture );\n\n\t\t_this.info.memory.textures --;\n\n\n\t};\n\n\tvar onRenderTargetDispose = function ( event ) {\n\n\t\tvar renderTarget = event.target;\n\n\t\trenderTarget.removeEventListener( 'dispose', onRenderTargetDispose );\n\n\t\tdeallocateRenderTarget( renderTarget );\n\n\t\t_this.info.memory.textures --;\n\n\t};\n\n\tvar onMaterialDispose = function ( event ) {\n\n\t\tvar material = event.target;\n\n\t\tmaterial.removeEventListener( 'dispose', onMaterialDispose );\n\n\t\tdeallocateMaterial( material );\n\n\t};\n\n\t// Buffer deallocation\n\n\tvar deallocateGeometry = function ( geometry ) {\n\n\t\tgeometry.__webglInit = undefined;\n\n\t\tif ( geometry.__webglVertexBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglVertexBuffer );\n\t\tif ( geometry.__webglNormalBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglNormalBuffer );\n\t\tif ( geometry.__webglTangentBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglTangentBuffer );\n\t\tif ( geometry.__webglColorBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglColorBuffer );\n\t\tif ( geometry.__webglUVBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglUVBuffer );\n\t\tif ( geometry.__webglUV2Buffer !== undefined ) _gl.deleteBuffer( geometry.__webglUV2Buffer );\n\n\t\tif ( geometry.__webglSkinIndicesBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglSkinIndicesBuffer );\n\t\tif ( geometry.__webglSkinWeightsBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglSkinWeightsBuffer );\n\n\t\tif ( geometry.__webglFaceBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglFaceBuffer );\n\t\tif ( geometry.__webglLineBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglLineBuffer );\n\n\t\tif ( geometry.__webglLineDistanceBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglLineDistanceBuffer );\n\n\t\t// geometry groups\n\n\t\tif ( geometry.geometryGroups !== undefined ) {\n\n\t\t\tfor ( var g in geometry.geometryGroups ) {\n\n\t\t\t\tvar geometryGroup = geometry.geometryGroups[ g ];\n\n\t\t\t\tif ( geometryGroup.numMorphTargets !== undefined ) {\n\n\t\t\t\t\tfor ( var m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {\n\n\t\t\t\t\t\t_gl.deleteBuffer( geometryGroup.__webglMorphTargetsBuffers[ m ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( geometryGroup.numMorphNormals !== undefined ) {\n\n\t\t\t\t\tfor ( var m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {\n\n\t\t\t\t\t\t_gl.deleteBuffer( geometryGroup.__webglMorphNormalsBuffers[ m ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tdeleteCustomAttributesBuffers( geometryGroup );\n\n\t\t\t}\n\n\t\t}\n\n\t\tdeleteCustomAttributesBuffers( geometry );\n\n\t};\n\n\tvar deallocateTexture = function ( texture ) {\n\n\t\tif ( texture.image && texture.image.__webglTextureCube ) {\n\n\t\t\t// cube texture\n\n\t\t\t_gl.deleteTexture( texture.image.__webglTextureCube );\n\n\t\t} else {\n\n\t\t\t// 2D texture\n\n\t\t\tif ( ! texture.__webglInit ) return;\n\n\t\t\ttexture.__webglInit = false;\n\t\t\t_gl.deleteTexture( texture.__webglTexture );\n\n\t\t}\n\n\t};\n\n\tvar deallocateRenderTarget = function ( renderTarget ) {\n\n\t\tif ( !renderTarget || ! renderTarget.__webglTexture ) return;\n\n\t\t_gl.deleteTexture( renderTarget.__webglTexture );\n\n\t\tif ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {\n\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t_gl.deleteFramebuffer( renderTarget.__webglFramebuffer[ i ] );\n\t\t\t\t_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer[ i ] );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t_gl.deleteFramebuffer( renderTarget.__webglFramebuffer );\n\t\t\t_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer );\n\n\t\t}\n\n\t};\n\n\tvar deallocateMaterial = function ( material ) {\n\n\t\tvar program = material.program;\n\n\t\tif ( program === undefined ) return;\n\n\t\tmaterial.program = undefined;\n\n\t\t// only deallocate GL program if this was the last use of shared program\n\t\t// assumed there is only single copy of any program in the _programs list\n\t\t// (that's how it's constructed)\n\n\t\tvar i, il, programInfo;\n\t\tvar deleteProgram = false;\n\n\t\tfor ( i = 0, il = _programs.length; i < il; i ++ ) {\n\n\t\t\tprogramInfo = _programs[ i ];\n\n\t\t\tif ( programInfo.program === program ) {\n\n\t\t\t\tprogramInfo.usedTimes --;\n\n\t\t\t\tif ( programInfo.usedTimes === 0 ) {\n\n\t\t\t\t\tdeleteProgram = true;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( deleteProgram === true ) {\n\n\t\t\t// avoid using array.splice, this is costlier than creating new array from scratch\n\n\t\t\tvar newPrograms = [];\n\n\t\t\tfor ( i = 0, il = _programs.length; i < il; i ++ ) {\n\n\t\t\t\tprogramInfo = _programs[ i ];\n\n\t\t\t\tif ( programInfo.program !== program ) {\n\n\t\t\t\t\tnewPrograms.push( programInfo );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_programs = newPrograms;\n\n\t\t\t_gl.deleteProgram( program );\n\n\t\t\t_this.info.memory.programs --;\n\n\t\t}\n\n\t};\n\n\t//\n\n\t/*\n\tfunction deleteParticleBuffers ( geometry ) {\n\n\t\t_gl.deleteBuffer( geometry.__webglVertexBuffer );\n\t\t_gl.deleteBuffer( geometry.__webglColorBuffer );\n\n\t\tdeleteCustomAttributesBuffers( geometry );\n\n\t\t_this.info.memory.geometries --;\n\n\t};\n\n\tfunction deleteLineBuffers ( geometry ) {\n\n\t\t_gl.deleteBuffer( geometry.__webglVertexBuffer );\n\t\t_gl.deleteBuffer( geometry.__webglColorBuffer );\n\t\t_gl.deleteBuffer( geometry.__webglLineDistanceBuffer );\n\n\t\tdeleteCustomAttributesBuffers( geometry );\n\n\t\t_this.info.memory.geometries --;\n\n\t};\n\n\tfunction deleteRibbonBuffers ( geometry ) {\n\n\t\t_gl.deleteBuffer( geometry.__webglVertexBuffer );\n\t\t_gl.deleteBuffer( geometry.__webglColorBuffer );\n\t\t_gl.deleteBuffer( geometry.__webglNormalBuffer );\n\n\t\tdeleteCustomAttributesBuffers( geometry );\n\n\t\t_this.info.memory.geometries --;\n\n\t};\n\n\tfunction deleteMeshBuffers ( geometryGroup ) {\n\n\t\t_gl.deleteBuffer( geometryGroup.__webglVertexBuffer );\n\t\t_gl.deleteBuffer( geometryGroup.__webglNormalBuffer );\n\t\t_gl.deleteBuffer( geometryGroup.__webglTangentBuffer );\n\t\t_gl.deleteBuffer( geometryGroup.__webglColorBuffer );\n\t\t_gl.deleteBuffer( geometryGroup.__webglUVBuffer );\n\t\t_gl.deleteBuffer( geometryGroup.__webglUV2Buffer );\n\n\t\t_gl.deleteBuffer( geometryGroup.__webglSkinIndicesBuffer );\n\t\t_gl.deleteBuffer( geometryGroup.__webglSkinWeightsBuffer );\n\n\t\t_gl.deleteBuffer( geometryGroup.__webglFaceBuffer );\n\t\t_gl.deleteBuffer( geometryGroup.__webglLineBuffer );\n\n\t\tvar m, ml;\n\n\t\tif ( geometryGroup.numMorphTargets ) {\n\n\t\t\tfor ( m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {\n\n\t\t\t\t_gl.deleteBuffer( geometryGroup.__webglMorphTargetsBuffers[ m ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( geometryGroup.numMorphNormals ) {\n\n\t\t\tfor ( m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {\n\n\t\t\t\t_gl.deleteBuffer( geometryGroup.__webglMorphNormalsBuffers[ m ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tdeleteCustomAttributesBuffers( geometryGroup );\n\n\t\t_this.info.memory.geometries --;\n\n\t};\n\t*/\n\n\tfunction deleteCustomAttributesBuffers( geometry ) {\n\n\t\tif ( geometry.__webglCustomAttributesList ) {\n\n\t\t\tfor ( var id in geometry.__webglCustomAttributesList ) {\n\n\t\t\t\t_gl.deleteBuffer( geometry.__webglCustomAttributesList[ id ].buffer );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\t// Buffer initialization\n\n\tfunction initCustomAttributes ( geometry, object ) {\n\n\t\tvar nvertices = geometry.vertices.length;\n\n\t\tvar material = object.material;\n\n\t\tif ( material.attributes ) {\n\n\t\t\tif ( geometry.__webglCustomAttributesList === undefined ) {\n\n\t\t\t\tgeometry.__webglCustomAttributesList = [];\n\n\t\t\t}\n\n\t\t\tfor ( var a in material.attributes ) {\n\n\t\t\t\tvar attribute = material.attributes[ a ];\n\n\t\t\t\tif ( !attribute.__webglInitialized || attribute.createUniqueBuffers ) {\n\n\t\t\t\t\tattribute.__webglInitialized = true;\n\n\t\t\t\t\tvar size = 1;\t\t// \"f\" and \"i\"\n\n\t\t\t\t\tif ( attribute.type === \"v2\" ) size = 2;\n\t\t\t\t\telse if ( attribute.type === \"v3\" ) size = 3;\n\t\t\t\t\telse if ( attribute.type === \"v4\" ) size = 4;\n\t\t\t\t\telse if ( attribute.type === \"c\"  ) size = 3;\n\n\t\t\t\t\tattribute.size = size;\n\n\t\t\t\t\tattribute.array = new Float32Array( nvertices * size );\n\n\t\t\t\t\tattribute.buffer = _gl.createBuffer();\n\t\t\t\t\tattribute.buffer.belongsToAttribute = a;\n\n\t\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.__webglCustomAttributesList.push( attribute );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tfunction initParticleBuffers ( geometry, object ) {\n\n\t\tvar nvertices = geometry.vertices.length;\n\n\t\tgeometry.__vertexArray = new Float32Array( nvertices * 3 );\n\t\tgeometry.__colorArray = new Float32Array( nvertices * 3 );\n\n\t\tgeometry.__sortArray = [];\n\n\t\tgeometry.__webglParticleCount = nvertices;\n\n\t\tinitCustomAttributes ( geometry, object );\n\n\t};\n\n\tfunction initLineBuffers ( geometry, object ) {\n\n\t\tvar nvertices = geometry.vertices.length;\n\n\t\tgeometry.__vertexArray = new Float32Array( nvertices * 3 );\n\t\tgeometry.__colorArray = new Float32Array( nvertices * 3 );\n\t\tgeometry.__lineDistanceArray = new Float32Array( nvertices * 1 );\n\n\t\tgeometry.__webglLineCount = nvertices;\n\n\t\tinitCustomAttributes ( geometry, object );\n\n\t};\n\n\tfunction initRibbonBuffers ( geometry, object ) {\n\n\t\tvar nvertices = geometry.vertices.length;\n\n\t\tgeometry.__vertexArray = new Float32Array( nvertices * 3 );\n\t\tgeometry.__colorArray = new Float32Array( nvertices * 3 );\n\t\tgeometry.__normalArray = new Float32Array( nvertices * 3 );\n\n\t\tgeometry.__webglVertexCount = nvertices;\n\n\t\tinitCustomAttributes ( geometry, object );\n\n\t};\n\n\tfunction initMeshBuffers ( geometryGroup, object ) {\n\n\t\tvar geometry = object.geometry,\n\t\t\tfaces3 = geometryGroup.faces3,\n\t\t\tfaces4 = geometryGroup.faces4,\n\n\t\t\tnvertices = faces3.length * 3 + faces4.length * 4,\n\t\t\tntris     = faces3.length * 1 + faces4.length * 2,\n\t\t\tnlines    = faces3.length * 3 + faces4.length * 4,\n\n\t\t\tmaterial = getBufferMaterial( object, geometryGroup ),\n\n\t\t\tuvType = bufferGuessUVType( material ),\n\t\t\tnormalType = bufferGuessNormalType( material ),\n\t\t\tvertexColorType = bufferGuessVertexColorType( material );\n\n\t\t//console.log( \"uvType\", uvType, \"normalType\", normalType, \"vertexColorType\", vertexColorType, object, geometryGroup, material );\n\n\t\tgeometryGroup.__vertexArray = new Float32Array( nvertices * 3 );\n\n\t\tif ( normalType ) {\n\n\t\t\tgeometryGroup.__normalArray = new Float32Array( nvertices * 3 );\n\n\t\t}\n\n\t\tif ( geometry.hasTangents ) {\n\n\t\t\tgeometryGroup.__tangentArray = new Float32Array( nvertices * 4 );\n\n\t\t}\n\n\t\tif ( vertexColorType ) {\n\n\t\t\tgeometryGroup.__colorArray = new Float32Array( nvertices * 3 );\n\n\t\t}\n\n\t\tif ( uvType ) {\n\n\t\t\tif ( geometry.faceUvs.length > 0 || geometry.faceVertexUvs.length > 0 ) {\n\n\t\t\t\tgeometryGroup.__uvArray = new Float32Array( nvertices * 2 );\n\n\t\t\t}\n\n\t\t\tif ( geometry.faceUvs.length > 1 || geometry.faceVertexUvs.length > 1 ) {\n\n\t\t\t\tgeometryGroup.__uv2Array = new Float32Array( nvertices * 2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( object.geometry.skinWeights.length && object.geometry.skinIndices.length ) {\n\n\t\t\tgeometryGroup.__skinIndexArray = new Float32Array( nvertices * 4 );\n\t\t\tgeometryGroup.__skinWeightArray = new Float32Array( nvertices * 4 );\n\n\t\t}\n\n\t\tgeometryGroup.__faceArray = new Uint16Array( ntris * 3 );\n\t\tgeometryGroup.__lineArray = new Uint16Array( nlines * 2 );\n\n\t\tvar m, ml;\n\n\t\tif ( geometryGroup.numMorphTargets ) {\n\n\t\t\tgeometryGroup.__morphTargetsArrays = [];\n\n\t\t\tfor ( m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {\n\n\t\t\t\tgeometryGroup.__morphTargetsArrays.push( new Float32Array( nvertices * 3 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( geometryGroup.numMorphNormals ) {\n\n\t\t\tgeometryGroup.__morphNormalsArrays = [];\n\n\t\t\tfor ( m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {\n\n\t\t\t\tgeometryGroup.__morphNormalsArrays.push( new Float32Array( nvertices * 3 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometryGroup.__webglFaceCount = ntris * 3;\n\t\tgeometryGroup.__webglLineCount = nlines * 2;\n\n\n\t\t// custom attributes\n\n\t\tif ( material.attributes ) {\n\n\t\t\tif ( geometryGroup.__webglCustomAttributesList === undefined ) {\n\n\t\t\t\tgeometryGroup.__webglCustomAttributesList = [];\n\n\t\t\t}\n\n\t\t\tfor ( var a in material.attributes ) {\n\n\t\t\t\t// Do a shallow copy of the attribute object so different geometryGroup chunks use different\n\t\t\t\t// attribute buffers which are correctly indexed in the setMeshBuffers function\n\n\t\t\t\tvar originalAttribute = material.attributes[ a ];\n\n\t\t\t\tvar attribute = {};\n\n\t\t\t\tfor ( var property in originalAttribute ) {\n\n\t\t\t\t\tattribute[ property ] = originalAttribute[ property ];\n\n\t\t\t\t}\n\n\t\t\t\tif ( !attribute.__webglInitialized || attribute.createUniqueBuffers ) {\n\n\t\t\t\t\tattribute.__webglInitialized = true;\n\n\t\t\t\t\tvar size = 1;\t\t// \"f\" and \"i\"\n\n\t\t\t\t\tif( attribute.type === \"v2\" ) size = 2;\n\t\t\t\t\telse if( attribute.type === \"v3\" ) size = 3;\n\t\t\t\t\telse if( attribute.type === \"v4\" ) size = 4;\n\t\t\t\t\telse if( attribute.type === \"c\"  ) size = 3;\n\n\t\t\t\t\tattribute.size = size;\n\n\t\t\t\t\tattribute.array = new Float32Array( nvertices * size );\n\n\t\t\t\t\tattribute.buffer = _gl.createBuffer();\n\t\t\t\t\tattribute.buffer.belongsToAttribute = a;\n\n\t\t\t\t\toriginalAttribute.needsUpdate = true;\n\t\t\t\t\tattribute.__original = originalAttribute;\n\n\t\t\t\t}\n\n\t\t\t\tgeometryGroup.__webglCustomAttributesList.push( attribute );\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometryGroup.__inittedArrays = true;\n\n\t};\n\n\tfunction getBufferMaterial( object, geometryGroup ) {\n\n\t\treturn object.material instanceof THREE.MeshFaceMaterial\n\t\t\t? object.material.materials[ geometryGroup.materialIndex ]\n\t\t\t: object.material;\n\n\t};\n\n\tfunction materialNeedsSmoothNormals ( material ) {\n\n\t\treturn material && material.shading !== undefined && material.shading === THREE.SmoothShading;\n\n\t};\n\n\tfunction bufferGuessNormalType ( material ) {\n\n\t\t// only MeshBasicMaterial and MeshDepthMaterial don't need normals\n\n\t\tif ( ( material instanceof THREE.MeshBasicMaterial && !material.envMap ) || material instanceof THREE.MeshDepthMaterial ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tif ( materialNeedsSmoothNormals( material ) ) {\n\n\t\t\treturn THREE.SmoothShading;\n\n\t\t} else {\n\n\t\t\treturn THREE.FlatShading;\n\n\t\t}\n\n\t};\n\n\tfunction bufferGuessVertexColorType ( material ) {\n\n\t\tif ( material.vertexColors ) {\n\n\t\t\treturn material.vertexColors;\n\n\t\t}\n\n\t\treturn false;\n\n\t};\n\n\tfunction bufferGuessUVType ( material ) {\n\n\t\t// material must use some texture to require uvs\n\n\t\tif ( material.map || material.lightMap || material.bumpMap || material.normalMap || material.specularMap || material instanceof THREE.ShaderMaterial ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t};\n\n\t//\n\n\tfunction initDirectBuffers( geometry ) {\n\n\t\tvar a, attribute, type;\n\n\t\tfor ( a in geometry.attributes ) {\n\n\t\t\tif ( a === \"index\" ) {\n\n\t\t\t\ttype = _gl.ELEMENT_ARRAY_BUFFER;\n\n\t\t\t} else {\n\n\t\t\t\ttype = _gl.ARRAY_BUFFER;\n\n\t\t\t}\n\n\t\t\tattribute = geometry.attributes[ a ];\n\n\t\t\tattribute.buffer = _gl.createBuffer();\n\n\t\t\t_gl.bindBuffer( type, attribute.buffer );\n\t\t\t_gl.bufferData( type, attribute.array, _gl.STATIC_DRAW );\n\n\t\t}\n\n\t};\n\n\t// Buffer setting\n\n\tfunction setParticleBuffers ( geometry, hint, object ) {\n\n\t\tvar v, c, vertex, offset, index, color,\n\n\t\tvertices = geometry.vertices,\n\t\tvl = vertices.length,\n\n\t\tcolors = geometry.colors,\n\t\tcl = colors.length,\n\n\t\tvertexArray = geometry.__vertexArray,\n\t\tcolorArray = geometry.__colorArray,\n\n\t\tsortArray = geometry.__sortArray,\n\n\t\tdirtyVertices = geometry.verticesNeedUpdate,\n\t\tdirtyElements = geometry.elementsNeedUpdate,\n\t\tdirtyColors = geometry.colorsNeedUpdate,\n\n\t\tcustomAttributes = geometry.__webglCustomAttributesList,\n\t\ti, il,\n\t\ta, ca, cal, value,\n\t\tcustomAttribute;\n\n\t\tif ( object.sortParticles ) {\n\n\t\t\t_projScreenMatrixPS.copy( _projScreenMatrix );\n\t\t\t_projScreenMatrixPS.multiply( object.matrixWorld );\n\n\t\t\tfor ( v = 0; v < vl; v ++ ) {\n\n\t\t\t\tvertex = vertices[ v ];\n\n\t\t\t\t_vector3.copy( vertex );\n\t\t\t\t_vector3.applyProjection( _projScreenMatrixPS );\n\n\t\t\t\tsortArray[ v ] = [ _vector3.z, v ];\n\n\t\t\t}\n\n\t\t\tsortArray.sort( numericalSort );\n\n\t\t\tfor ( v = 0; v < vl; v ++ ) {\n\n\t\t\t\tvertex = vertices[ sortArray[v][1] ];\n\n\t\t\t\toffset = v * 3;\n\n\t\t\t\tvertexArray[ offset ]     = vertex.x;\n\t\t\t\tvertexArray[ offset + 1 ] = vertex.y;\n\t\t\t\tvertexArray[ offset + 2 ] = vertex.z;\n\n\t\t\t}\n\n\t\t\tfor ( c = 0; c < cl; c ++ ) {\n\n\t\t\t\toffset = c * 3;\n\n\t\t\t\tcolor = colors[ sortArray[c][1] ];\n\n\t\t\t\tcolorArray[ offset ]     = color.r;\n\t\t\t\tcolorArray[ offset + 1 ] = color.g;\n\t\t\t\tcolorArray[ offset + 2 ] = color.b;\n\n\t\t\t}\n\n\t\t\tif ( customAttributes ) {\n\n\t\t\t\tfor ( i = 0, il = customAttributes.length; i < il; i ++ ) {\n\n\t\t\t\t\tcustomAttribute = customAttributes[ i ];\n\n\t\t\t\t\tif ( ! ( customAttribute.boundTo === undefined || customAttribute.boundTo === \"vertices\" ) ) continue;\n\n\t\t\t\t\toffset = 0;\n\n\t\t\t\t\tcal = customAttribute.value.length;\n\n\t\t\t\t\tif ( customAttribute.size === 1 ) {\n\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\tindex = sortArray[ ca ][ 1 ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ ca ] = customAttribute.value[ index ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( customAttribute.size === 2 ) {\n\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\tindex = sortArray[ ca ][ 1 ];\n\n\t\t\t\t\t\t\tvalue = customAttribute.value[ index ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\n\n\t\t\t\t\t\t\toffset += 2;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( customAttribute.size === 3 ) {\n\n\t\t\t\t\t\tif ( customAttribute.type === \"c\" ) {\n\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\t\tindex = sortArray[ ca ][ 1 ];\n\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ index ];\n\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ]     = value.r;\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.g;\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.b;\n\n\t\t\t\t\t\t\t\toffset += 3;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\t\tindex = sortArray[ ca ][ 1 ];\n\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ index ];\n\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.x;\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.z;\n\n\t\t\t\t\t\t\t\toffset += 3;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( customAttribute.size === 4 ) {\n\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\tindex = sortArray[ ca ][ 1 ];\n\n\t\t\t\t\t\t\tvalue = customAttribute.value[ index ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset ]      = value.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1  ] = value.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2  ] = value.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 3  ] = value.w;\n\n\t\t\t\t\t\t\toffset += 4;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( dirtyVertices ) {\n\n\t\t\t\tfor ( v = 0; v < vl; v ++ ) {\n\n\t\t\t\t\tvertex = vertices[ v ];\n\n\t\t\t\t\toffset = v * 3;\n\n\t\t\t\t\tvertexArray[ offset ]     = vertex.x;\n\t\t\t\t\tvertexArray[ offset + 1 ] = vertex.y;\n\t\t\t\t\tvertexArray[ offset + 2 ] = vertex.z;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( dirtyColors ) {\n\n\t\t\t\tfor ( c = 0; c < cl; c ++ ) {\n\n\t\t\t\t\tcolor = colors[ c ];\n\n\t\t\t\t\toffset = c * 3;\n\n\t\t\t\t\tcolorArray[ offset ]     = color.r;\n\t\t\t\t\tcolorArray[ offset + 1 ] = color.g;\n\t\t\t\t\tcolorArray[ offset + 2 ] = color.b;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( customAttributes ) {\n\n\t\t\t\tfor ( i = 0, il = customAttributes.length; i < il; i ++ ) {\n\n\t\t\t\t\tcustomAttribute = customAttributes[ i ];\n\n\t\t\t\t\tif ( customAttribute.needsUpdate &&\n\t\t\t\t\t\t ( customAttribute.boundTo === undefined ||\n\t\t\t\t\t\t   customAttribute.boundTo === \"vertices\") ) {\n\n\t\t\t\t\t\tcal = customAttribute.value.length;\n\n\t\t\t\t\t\toffset = 0;\n\n\t\t\t\t\t\tif ( customAttribute.size === 1 ) {\n\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\t\tcustomAttribute.array[ ca ] = customAttribute.value[ ca ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else if ( customAttribute.size === 2 ) {\n\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\n\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.x;\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\n\n\t\t\t\t\t\t\t\toffset += 2;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else if ( customAttribute.size === 3 ) {\n\n\t\t\t\t\t\t\tif ( customAttribute.type === \"c\" ) {\n\n\t\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\n\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.r;\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.g;\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.b;\n\n\t\t\t\t\t\t\t\t\toffset += 3;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\n\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.x;\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.z;\n\n\t\t\t\t\t\t\t\t\toffset += 3;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else if ( customAttribute.size === 4 ) {\n\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\n\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ]      = value.x;\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1  ] = value.y;\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2  ] = value.z;\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 3  ] = value.w;\n\n\t\t\t\t\t\t\t\toffset += 4;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( dirtyVertices || object.sortParticles ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );\n\n\t\t}\n\n\t\tif ( dirtyColors || object.sortParticles ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );\n\n\t\t}\n\n\t\tif ( customAttributes ) {\n\n\t\t\tfor ( i = 0, il = customAttributes.length; i < il; i ++ ) {\n\n\t\t\t\tcustomAttribute = customAttributes[ i ];\n\n\t\t\t\tif ( customAttribute.needsUpdate || object.sortParticles ) {\n\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\n\t};\n\n\tfunction setLineBuffers ( geometry, hint ) {\n\n\t\tvar v, c, d, vertex, offset, color,\n\n\t\tvertices = geometry.vertices,\n\t\tcolors = geometry.colors,\n\t\tlineDistances = geometry.lineDistances,\n\n\t\tvl = vertices.length,\n\t\tcl = colors.length,\n\t\tdl = lineDistances.length,\n\n\t\tvertexArray = geometry.__vertexArray,\n\t\tcolorArray = geometry.__colorArray,\n\t\tlineDistanceArray = geometry.__lineDistanceArray,\n\n\t\tdirtyVertices = geometry.verticesNeedUpdate,\n\t\tdirtyColors = geometry.colorsNeedUpdate,\n\t\tdirtyLineDistances = geometry.lineDistancesNeedUpdate,\n\n\t\tcustomAttributes = geometry.__webglCustomAttributesList,\n\n\t\ti, il,\n\t\ta, ca, cal, value,\n\t\tcustomAttribute;\n\n\t\tif ( dirtyVertices ) {\n\n\t\t\tfor ( v = 0; v < vl; v ++ ) {\n\n\t\t\t\tvertex = vertices[ v ];\n\n\t\t\t\toffset = v * 3;\n\n\t\t\t\tvertexArray[ offset ]     = vertex.x;\n\t\t\t\tvertexArray[ offset + 1 ] = vertex.y;\n\t\t\t\tvertexArray[ offset + 2 ] = vertex.z;\n\n\t\t\t}\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );\n\n\t\t}\n\n\t\tif ( dirtyColors ) {\n\n\t\t\tfor ( c = 0; c < cl; c ++ ) {\n\n\t\t\t\tcolor = colors[ c ];\n\n\t\t\t\toffset = c * 3;\n\n\t\t\t\tcolorArray[ offset ]     = color.r;\n\t\t\t\tcolorArray[ offset + 1 ] = color.g;\n\t\t\t\tcolorArray[ offset + 2 ] = color.b;\n\n\t\t\t}\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );\n\n\t\t}\n\n\t\tif ( dirtyLineDistances ) {\n\n\t\t\tfor ( d = 0; d < dl; d ++ ) {\n\n\t\t\t\tlineDistanceArray[ d ] = lineDistances[ d ];\n\n\t\t\t}\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglLineDistanceBuffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, lineDistanceArray, hint );\n\n\t\t}\n\n\t\tif ( customAttributes ) {\n\n\t\t\tfor ( i = 0, il = customAttributes.length; i < il; i ++ ) {\n\n\t\t\t\tcustomAttribute = customAttributes[ i ];\n\n\t\t\t\tif ( customAttribute.needsUpdate &&\n\t\t\t\t\t ( customAttribute.boundTo === undefined ||\n\t\t\t\t\t   customAttribute.boundTo === \"vertices\" ) ) {\n\n\t\t\t\t\toffset = 0;\n\n\t\t\t\t\tcal = customAttribute.value.length;\n\n\t\t\t\t\tif ( customAttribute.size === 1 ) {\n\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\tcustomAttribute.array[ ca ] = customAttribute.value[ ca ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( customAttribute.size === 2 ) {\n\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\n\n\t\t\t\t\t\t\toffset += 2;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( customAttribute.size === 3 ) {\n\n\t\t\t\t\t\tif ( customAttribute.type === \"c\" ) {\n\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\n\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.r;\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.g;\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.b;\n\n\t\t\t\t\t\t\t\toffset += 3;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\n\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.x;\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.z;\n\n\t\t\t\t\t\t\t\toffset += 3;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( customAttribute.size === 4 ) {\n\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t = value.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1  ] = value.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2  ] = value.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 3  ] = value.w;\n\n\t\t\t\t\t\t\toffset += 4;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tfunction setRibbonBuffers ( geometry, hint ) {\n\n\t\tvar v, c, n, vertex, offset, color, normal,\n\n\t\ti, il, ca, cal, customAttribute, value,\n\n\t\tvertices = geometry.vertices,\n\t\tcolors = geometry.colors,\n\t\tnormals = geometry.normals,\n\n\t\tvl = vertices.length,\n\t\tcl = colors.length,\n\t\tnl = normals.length,\n\n\t\tvertexArray = geometry.__vertexArray,\n\t\tcolorArray = geometry.__colorArray,\n\t\tnormalArray = geometry.__normalArray,\n\n\t\tdirtyVertices = geometry.verticesNeedUpdate,\n\t\tdirtyColors = geometry.colorsNeedUpdate,\n\t\tdirtyNormals = geometry.normalsNeedUpdate,\n\n\t\tcustomAttributes = geometry.__webglCustomAttributesList;\n\n\t\tif ( dirtyVertices ) {\n\n\t\t\tfor ( v = 0; v < vl; v ++ ) {\n\n\t\t\t\tvertex = vertices[ v ];\n\n\t\t\t\toffset = v * 3;\n\n\t\t\t\tvertexArray[ offset ]     = vertex.x;\n\t\t\t\tvertexArray[ offset + 1 ] = vertex.y;\n\t\t\t\tvertexArray[ offset + 2 ] = vertex.z;\n\n\t\t\t}\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );\n\n\t\t}\n\n\t\tif ( dirtyColors ) {\n\n\t\t\tfor ( c = 0; c < cl; c ++ ) {\n\n\t\t\t\tcolor = colors[ c ];\n\n\t\t\t\toffset = c * 3;\n\n\t\t\t\tcolorArray[ offset ]     = color.r;\n\t\t\t\tcolorArray[ offset + 1 ] = color.g;\n\t\t\t\tcolorArray[ offset + 2 ] = color.b;\n\n\t\t\t}\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );\n\n\t\t}\n\n\t\tif ( dirtyNormals ) {\n\n\t\t\tfor ( n = 0; n < nl; n ++ ) {\n\n\t\t\t\tnormal = normals[ n ];\n\n\t\t\t\toffset = n * 3;\n\n\t\t\t\tnormalArray[ offset ]     = normal.x;\n\t\t\t\tnormalArray[ offset + 1 ] = normal.y;\n\t\t\t\tnormalArray[ offset + 2 ] = normal.z;\n\n\t\t\t}\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglNormalBuffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, normalArray, hint );\n\n\t\t}\n\n\t\tif ( customAttributes ) {\n\n\t\t\tfor ( i = 0, il = customAttributes.length; i < il; i ++ ) {\n\n\t\t\t\tcustomAttribute = customAttributes[ i ];\n\n\t\t\t\tif ( customAttribute.needsUpdate &&\n\t\t\t\t\t ( customAttribute.boundTo === undefined ||\n\t\t\t\t\t   customAttribute.boundTo === \"vertices\" ) ) {\n\n\t\t\t\t\toffset = 0;\n\n\t\t\t\t\tcal = customAttribute.value.length;\n\n\t\t\t\t\tif ( customAttribute.size === 1 ) {\n\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\tcustomAttribute.array[ ca ] = customAttribute.value[ ca ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( customAttribute.size === 2 ) {\n\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\n\n\t\t\t\t\t\t\toffset += 2;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( customAttribute.size === 3 ) {\n\n\t\t\t\t\t\tif ( customAttribute.type === \"c\" ) {\n\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\n\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.r;\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.g;\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.b;\n\n\t\t\t\t\t\t\t\toffset += 3;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\n\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.x;\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.z;\n\n\t\t\t\t\t\t\t\toffset += 3;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( customAttribute.size === 4 ) {\n\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t = value.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1  ] = value.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2  ] = value.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 3  ] = value.w;\n\n\t\t\t\t\t\t\toffset += 4;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tfunction setMeshBuffers( geometryGroup, object, hint, dispose, material ) {\n\n\t\tif ( ! geometryGroup.__inittedArrays ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar normalType = bufferGuessNormalType( material ),\n\t\tvertexColorType = bufferGuessVertexColorType( material ),\n\t\tuvType = bufferGuessUVType( material ),\n\n\t\tneedsSmoothNormals = ( normalType === THREE.SmoothShading );\n\n\t\tvar f, fl, fi, face,\n\t\tvertexNormals, faceNormal, normal,\n\t\tvertexColors, faceColor,\n\t\tvertexTangents,\n\t\tuv, uv2, v1, v2, v3, v4, t1, t2, t3, t4, n1, n2, n3, n4,\n\t\tc1, c2, c3, c4,\n\t\tsw1, sw2, sw3, sw4,\n\t\tsi1, si2, si3, si4,\n\t\tsa1, sa2, sa3, sa4,\n\t\tsb1, sb2, sb3, sb4,\n\t\tm, ml, i, il,\n\t\tvn, uvi, uv2i,\n\t\tvk, vkl, vka,\n\t\tnka, chf, faceVertexNormals,\n\t\ta,\n\n\t\tvertexIndex = 0,\n\n\t\toffset = 0,\n\t\toffset_uv = 0,\n\t\toffset_uv2 = 0,\n\t\toffset_face = 0,\n\t\toffset_normal = 0,\n\t\toffset_tangent = 0,\n\t\toffset_line = 0,\n\t\toffset_color = 0,\n\t\toffset_skin = 0,\n\t\toffset_morphTarget = 0,\n\t\toffset_custom = 0,\n\t\toffset_customSrc = 0,\n\n\t\tvalue,\n\n\t\tvertexArray = geometryGroup.__vertexArray,\n\t\tuvArray = geometryGroup.__uvArray,\n\t\tuv2Array = geometryGroup.__uv2Array,\n\t\tnormalArray = geometryGroup.__normalArray,\n\t\ttangentArray = geometryGroup.__tangentArray,\n\t\tcolorArray = geometryGroup.__colorArray,\n\n\t\tskinIndexArray = geometryGroup.__skinIndexArray,\n\t\tskinWeightArray = geometryGroup.__skinWeightArray,\n\n\t\tmorphTargetsArrays = geometryGroup.__morphTargetsArrays,\n\t\tmorphNormalsArrays = geometryGroup.__morphNormalsArrays,\n\n\t\tcustomAttributes = geometryGroup.__webglCustomAttributesList,\n\t\tcustomAttribute,\n\n\t\tfaceArray = geometryGroup.__faceArray,\n\t\tlineArray = geometryGroup.__lineArray,\n\n\t\tgeometry = object.geometry, // this is shared for all chunks\n\n\t\tdirtyVertices = geometry.verticesNeedUpdate,\n\t\tdirtyElements = geometry.elementsNeedUpdate,\n\t\tdirtyUvs = geometry.uvsNeedUpdate,\n\t\tdirtyNormals = geometry.normalsNeedUpdate,\n\t\tdirtyTangents = geometry.tangentsNeedUpdate,\n\t\tdirtyColors = geometry.colorsNeedUpdate,\n\t\tdirtyMorphTargets = geometry.morphTargetsNeedUpdate,\n\n\t\tvertices = geometry.vertices,\n\t\tchunk_faces3 = geometryGroup.faces3,\n\t\tchunk_faces4 = geometryGroup.faces4,\n\t\tobj_faces = geometry.faces,\n\n\t\tobj_uvs  = geometry.faceVertexUvs[ 0 ],\n\t\tobj_uvs2 = geometry.faceVertexUvs[ 1 ],\n\n\t\tobj_colors = geometry.colors,\n\n\t\tobj_skinIndices = geometry.skinIndices,\n\t\tobj_skinWeights = geometry.skinWeights,\n\n\t\tmorphTargets = geometry.morphTargets,\n\t\tmorphNormals = geometry.morphNormals;\n\n\t\tif ( dirtyVertices ) {\n\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\tface = obj_faces[ chunk_faces3[ f ] ];\n\n\t\t\t\tv1 = vertices[ face.a ];\n\t\t\t\tv2 = vertices[ face.b ];\n\t\t\t\tv3 = vertices[ face.c ];\n\n\t\t\t\tvertexArray[ offset ]     = v1.x;\n\t\t\t\tvertexArray[ offset + 1 ] = v1.y;\n\t\t\t\tvertexArray[ offset + 2 ] = v1.z;\n\n\t\t\t\tvertexArray[ offset + 3 ] = v2.x;\n\t\t\t\tvertexArray[ offset + 4 ] = v2.y;\n\t\t\t\tvertexArray[ offset + 5 ] = v2.z;\n\n\t\t\t\tvertexArray[ offset + 6 ] = v3.x;\n\t\t\t\tvertexArray[ offset + 7 ] = v3.y;\n\t\t\t\tvertexArray[ offset + 8 ] = v3.z;\n\n\t\t\t\toffset += 9;\n\n\t\t\t}\n\n\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\n\n\t\t\t\tface = obj_faces[ chunk_faces4[ f ] ];\n\n\t\t\t\tv1 = vertices[ face.a ];\n\t\t\t\tv2 = vertices[ face.b ];\n\t\t\t\tv3 = vertices[ face.c ];\n\t\t\t\tv4 = vertices[ face.d ];\n\n\t\t\t\tvertexArray[ offset ]     = v1.x;\n\t\t\t\tvertexArray[ offset + 1 ] = v1.y;\n\t\t\t\tvertexArray[ offset + 2 ] = v1.z;\n\n\t\t\t\tvertexArray[ offset + 3 ] = v2.x;\n\t\t\t\tvertexArray[ offset + 4 ] = v2.y;\n\t\t\t\tvertexArray[ offset + 5 ] = v2.z;\n\n\t\t\t\tvertexArray[ offset + 6 ] = v3.x;\n\t\t\t\tvertexArray[ offset + 7 ] = v3.y;\n\t\t\t\tvertexArray[ offset + 8 ] = v3.z;\n\n\t\t\t\tvertexArray[ offset + 9 ]  = v4.x;\n\t\t\t\tvertexArray[ offset + 10 ] = v4.y;\n\t\t\t\tvertexArray[ offset + 11 ] = v4.z;\n\n\t\t\t\toffset += 12;\n\n\t\t\t}\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );\n\n\t\t}\n\n\t\tif ( dirtyMorphTargets ) {\n\n\t\t\tfor ( vk = 0, vkl = morphTargets.length; vk < vkl; vk ++ ) {\n\n\t\t\t\toffset_morphTarget = 0;\n\n\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\t\tchf = chunk_faces3[ f ];\n\t\t\t\t\tface = obj_faces[ chf ];\n\n\t\t\t\t\t// morph positions\n\n\t\t\t\t\tv1 = morphTargets[ vk ].vertices[ face.a ];\n\t\t\t\t\tv2 = morphTargets[ vk ].vertices[ face.b ];\n\t\t\t\t\tv3 = morphTargets[ vk ].vertices[ face.c ];\n\n\t\t\t\t\tvka = morphTargetsArrays[ vk ];\n\n\t\t\t\t\tvka[ offset_morphTarget ] \t  = v1.x;\n\t\t\t\t\tvka[ offset_morphTarget + 1 ] = v1.y;\n\t\t\t\t\tvka[ offset_morphTarget + 2 ] = v1.z;\n\n\t\t\t\t\tvka[ offset_morphTarget + 3 ] = v2.x;\n\t\t\t\t\tvka[ offset_morphTarget + 4 ] = v2.y;\n\t\t\t\t\tvka[ offset_morphTarget + 5 ] = v2.z;\n\n\t\t\t\t\tvka[ offset_morphTarget + 6 ] = v3.x;\n\t\t\t\t\tvka[ offset_morphTarget + 7 ] = v3.y;\n\t\t\t\t\tvka[ offset_morphTarget + 8 ] = v3.z;\n\n\t\t\t\t\t// morph normals\n\n\t\t\t\t\tif ( material.morphNormals ) {\n\n\t\t\t\t\t\tif ( needsSmoothNormals ) {\n\n\t\t\t\t\t\t\tfaceVertexNormals = morphNormals[ vk ].vertexNormals[ chf ];\n\n\t\t\t\t\t\t\tn1 = faceVertexNormals.a;\n\t\t\t\t\t\t\tn2 = faceVertexNormals.b;\n\t\t\t\t\t\t\tn3 = faceVertexNormals.c;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tn1 = morphNormals[ vk ].faceNormals[ chf ];\n\t\t\t\t\t\t\tn2 = n1;\n\t\t\t\t\t\t\tn3 = n1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnka = morphNormalsArrays[ vk ];\n\n\t\t\t\t\t\tnka[ offset_morphTarget ] \t  = n1.x;\n\t\t\t\t\t\tnka[ offset_morphTarget + 1 ] = n1.y;\n\t\t\t\t\t\tnka[ offset_morphTarget + 2 ] = n1.z;\n\n\t\t\t\t\t\tnka[ offset_morphTarget + 3 ] = n2.x;\n\t\t\t\t\t\tnka[ offset_morphTarget + 4 ] = n2.y;\n\t\t\t\t\t\tnka[ offset_morphTarget + 5 ] = n2.z;\n\n\t\t\t\t\t\tnka[ offset_morphTarget + 6 ] = n3.x;\n\t\t\t\t\t\tnka[ offset_morphTarget + 7 ] = n3.y;\n\t\t\t\t\t\tnka[ offset_morphTarget + 8 ] = n3.z;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t//\n\n\t\t\t\t\toffset_morphTarget += 9;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\n\n\t\t\t\t\tchf = chunk_faces4[ f ];\n\t\t\t\t\tface = obj_faces[ chf ];\n\n\t\t\t\t\t// morph positions\n\n\t\t\t\t\tv1 = morphTargets[ vk ].vertices[ face.a ];\n\t\t\t\t\tv2 = morphTargets[ vk ].vertices[ face.b ];\n\t\t\t\t\tv3 = morphTargets[ vk ].vertices[ face.c ];\n\t\t\t\t\tv4 = morphTargets[ vk ].vertices[ face.d ];\n\n\t\t\t\t\tvka = morphTargetsArrays[ vk ];\n\n\t\t\t\t\tvka[ offset_morphTarget ] \t  = v1.x;\n\t\t\t\t\tvka[ offset_morphTarget + 1 ] = v1.y;\n\t\t\t\t\tvka[ offset_morphTarget + 2 ] = v1.z;\n\n\t\t\t\t\tvka[ offset_morphTarget + 3 ] = v2.x;\n\t\t\t\t\tvka[ offset_morphTarget + 4 ] = v2.y;\n\t\t\t\t\tvka[ offset_morphTarget + 5 ] = v2.z;\n\n\t\t\t\t\tvka[ offset_morphTarget + 6 ] = v3.x;\n\t\t\t\t\tvka[ offset_morphTarget + 7 ] = v3.y;\n\t\t\t\t\tvka[ offset_morphTarget + 8 ] = v3.z;\n\n\t\t\t\t\tvka[ offset_morphTarget + 9 ]  = v4.x;\n\t\t\t\t\tvka[ offset_morphTarget + 10 ] = v4.y;\n\t\t\t\t\tvka[ offset_morphTarget + 11 ] = v4.z;\n\n\t\t\t\t\t// morph normals\n\n\t\t\t\t\tif ( material.morphNormals ) {\n\n\t\t\t\t\t\tif ( needsSmoothNormals ) {\n\n\t\t\t\t\t\t\tfaceVertexNormals = morphNormals[ vk ].vertexNormals[ chf ];\n\n\t\t\t\t\t\t\tn1 = faceVertexNormals.a;\n\t\t\t\t\t\t\tn2 = faceVertexNormals.b;\n\t\t\t\t\t\t\tn3 = faceVertexNormals.c;\n\t\t\t\t\t\t\tn4 = faceVertexNormals.d;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tn1 = morphNormals[ vk ].faceNormals[ chf ];\n\t\t\t\t\t\t\tn2 = n1;\n\t\t\t\t\t\t\tn3 = n1;\n\t\t\t\t\t\t\tn4 = n1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnka = morphNormalsArrays[ vk ];\n\n\t\t\t\t\t\tnka[ offset_morphTarget ] \t  = n1.x;\n\t\t\t\t\t\tnka[ offset_morphTarget + 1 ] = n1.y;\n\t\t\t\t\t\tnka[ offset_morphTarget + 2 ] = n1.z;\n\n\t\t\t\t\t\tnka[ offset_morphTarget + 3 ] = n2.x;\n\t\t\t\t\t\tnka[ offset_morphTarget + 4 ] = n2.y;\n\t\t\t\t\t\tnka[ offset_morphTarget + 5 ] = n2.z;\n\n\t\t\t\t\t\tnka[ offset_morphTarget + 6 ] = n3.x;\n\t\t\t\t\t\tnka[ offset_morphTarget + 7 ] = n3.y;\n\t\t\t\t\t\tnka[ offset_morphTarget + 8 ] = n3.z;\n\n\t\t\t\t\t\tnka[ offset_morphTarget + 9 ]  = n4.x;\n\t\t\t\t\t\tnka[ offset_morphTarget + 10 ] = n4.y;\n\t\t\t\t\t\tnka[ offset_morphTarget + 11 ] = n4.z;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t//\n\n\t\t\t\t\toffset_morphTarget += 12;\n\n\t\t\t\t}\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ vk ] );\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, morphTargetsArrays[ vk ], hint );\n\n\t\t\t\tif ( material.morphNormals ) {\n\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ vk ] );\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, morphNormalsArrays[ vk ], hint );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( obj_skinWeights.length ) {\n\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\n\n\t\t\t\t// weights\n\n\t\t\t\tsw1 = obj_skinWeights[ face.a ];\n\t\t\t\tsw2 = obj_skinWeights[ face.b ];\n\t\t\t\tsw3 = obj_skinWeights[ face.c ];\n\n\t\t\t\tskinWeightArray[ offset_skin ]     = sw1.x;\n\t\t\t\tskinWeightArray[ offset_skin + 1 ] = sw1.y;\n\t\t\t\tskinWeightArray[ offset_skin + 2 ] = sw1.z;\n\t\t\t\tskinWeightArray[ offset_skin + 3 ] = sw1.w;\n\n\t\t\t\tskinWeightArray[ offset_skin + 4 ] = sw2.x;\n\t\t\t\tskinWeightArray[ offset_skin + 5 ] = sw2.y;\n\t\t\t\tskinWeightArray[ offset_skin + 6 ] = sw2.z;\n\t\t\t\tskinWeightArray[ offset_skin + 7 ] = sw2.w;\n\n\t\t\t\tskinWeightArray[ offset_skin + 8 ]  = sw3.x;\n\t\t\t\tskinWeightArray[ offset_skin + 9 ]  = sw3.y;\n\t\t\t\tskinWeightArray[ offset_skin + 10 ] = sw3.z;\n\t\t\t\tskinWeightArray[ offset_skin + 11 ] = sw3.w;\n\n\t\t\t\t// indices\n\n\t\t\t\tsi1 = obj_skinIndices[ face.a ];\n\t\t\t\tsi2 = obj_skinIndices[ face.b ];\n\t\t\t\tsi3 = obj_skinIndices[ face.c ];\n\n\t\t\t\tskinIndexArray[ offset_skin ]     = si1.x;\n\t\t\t\tskinIndexArray[ offset_skin + 1 ] = si1.y;\n\t\t\t\tskinIndexArray[ offset_skin + 2 ] = si1.z;\n\t\t\t\tskinIndexArray[ offset_skin + 3 ] = si1.w;\n\n\t\t\t\tskinIndexArray[ offset_skin + 4 ] = si2.x;\n\t\t\t\tskinIndexArray[ offset_skin + 5 ] = si2.y;\n\t\t\t\tskinIndexArray[ offset_skin + 6 ] = si2.z;\n\t\t\t\tskinIndexArray[ offset_skin + 7 ] = si2.w;\n\n\t\t\t\tskinIndexArray[ offset_skin + 8 ]  = si3.x;\n\t\t\t\tskinIndexArray[ offset_skin + 9 ]  = si3.y;\n\t\t\t\tskinIndexArray[ offset_skin + 10 ] = si3.z;\n\t\t\t\tskinIndexArray[ offset_skin + 11 ] = si3.w;\n\n\t\t\t\toffset_skin += 12;\n\n\t\t\t}\n\n\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\n\n\t\t\t\tface = obj_faces[ chunk_faces4[ f ] ];\n\n\t\t\t\t// weights\n\n\t\t\t\tsw1 = obj_skinWeights[ face.a ];\n\t\t\t\tsw2 = obj_skinWeights[ face.b ];\n\t\t\t\tsw3 = obj_skinWeights[ face.c ];\n\t\t\t\tsw4 = obj_skinWeights[ face.d ];\n\n\t\t\t\tskinWeightArray[ offset_skin ]     = sw1.x;\n\t\t\t\tskinWeightArray[ offset_skin + 1 ] = sw1.y;\n\t\t\t\tskinWeightArray[ offset_skin + 2 ] = sw1.z;\n\t\t\t\tskinWeightArray[ offset_skin + 3 ] = sw1.w;\n\n\t\t\t\tskinWeightArray[ offset_skin + 4 ] = sw2.x;\n\t\t\t\tskinWeightArray[ offset_skin + 5 ] = sw2.y;\n\t\t\t\tskinWeightArray[ offset_skin + 6 ] = sw2.z;\n\t\t\t\tskinWeightArray[ offset_skin + 7 ] = sw2.w;\n\n\t\t\t\tskinWeightArray[ offset_skin + 8 ]  = sw3.x;\n\t\t\t\tskinWeightArray[ offset_skin + 9 ]  = sw3.y;\n\t\t\t\tskinWeightArray[ offset_skin + 10 ] = sw3.z;\n\t\t\t\tskinWeightArray[ offset_skin + 11 ] = sw3.w;\n\n\t\t\t\tskinWeightArray[ offset_skin + 12 ] = sw4.x;\n\t\t\t\tskinWeightArray[ offset_skin + 13 ] = sw4.y;\n\t\t\t\tskinWeightArray[ offset_skin + 14 ] = sw4.z;\n\t\t\t\tskinWeightArray[ offset_skin + 15 ] = sw4.w;\n\n\t\t\t\t// indices\n\n\t\t\t\tsi1 = obj_skinIndices[ face.a ];\n\t\t\t\tsi2 = obj_skinIndices[ face.b ];\n\t\t\t\tsi3 = obj_skinIndices[ face.c ];\n\t\t\t\tsi4 = obj_skinIndices[ face.d ];\n\n\t\t\t\tskinIndexArray[ offset_skin ]     = si1.x;\n\t\t\t\tskinIndexArray[ offset_skin + 1 ] = si1.y;\n\t\t\t\tskinIndexArray[ offset_skin + 2 ] = si1.z;\n\t\t\t\tskinIndexArray[ offset_skin + 3 ] = si1.w;\n\n\t\t\t\tskinIndexArray[ offset_skin + 4 ] = si2.x;\n\t\t\t\tskinIndexArray[ offset_skin + 5 ] = si2.y;\n\t\t\t\tskinIndexArray[ offset_skin + 6 ] = si2.z;\n\t\t\t\tskinIndexArray[ offset_skin + 7 ] = si2.w;\n\n\t\t\t\tskinIndexArray[ offset_skin + 8 ]  = si3.x;\n\t\t\t\tskinIndexArray[ offset_skin + 9 ]  = si3.y;\n\t\t\t\tskinIndexArray[ offset_skin + 10 ] = si3.z;\n\t\t\t\tskinIndexArray[ offset_skin + 11 ] = si3.w;\n\n\t\t\t\tskinIndexArray[ offset_skin + 12 ] = si4.x;\n\t\t\t\tskinIndexArray[ offset_skin + 13 ] = si4.y;\n\t\t\t\tskinIndexArray[ offset_skin + 14 ] = si4.z;\n\t\t\t\tskinIndexArray[ offset_skin + 15 ] = si4.w;\n\n\t\t\t\toffset_skin += 16;\n\n\t\t\t}\n\n\t\t\tif ( offset_skin > 0 ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, skinIndexArray, hint );\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, skinWeightArray, hint );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( dirtyColors && vertexColorType ) {\n\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\n\n\t\t\t\tvertexColors = face.vertexColors;\n\t\t\t\tfaceColor = face.color;\n\n\t\t\t\tif ( vertexColors.length === 3 && vertexColorType === THREE.VertexColors ) {\n\n\t\t\t\t\tc1 = vertexColors[ 0 ];\n\t\t\t\t\tc2 = vertexColors[ 1 ];\n\t\t\t\t\tc3 = vertexColors[ 2 ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tc1 = faceColor;\n\t\t\t\t\tc2 = faceColor;\n\t\t\t\t\tc3 = faceColor;\n\n\t\t\t\t}\n\n\t\t\t\tcolorArray[ offset_color ]     = c1.r;\n\t\t\t\tcolorArray[ offset_color + 1 ] = c1.g;\n\t\t\t\tcolorArray[ offset_color + 2 ] = c1.b;\n\n\t\t\t\tcolorArray[ offset_color + 3 ] = c2.r;\n\t\t\t\tcolorArray[ offset_color + 4 ] = c2.g;\n\t\t\t\tcolorArray[ offset_color + 5 ] = c2.b;\n\n\t\t\t\tcolorArray[ offset_color + 6 ] = c3.r;\n\t\t\t\tcolorArray[ offset_color + 7 ] = c3.g;\n\t\t\t\tcolorArray[ offset_color + 8 ] = c3.b;\n\n\t\t\t\toffset_color += 9;\n\n\t\t\t}\n\n\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\n\n\t\t\t\tface = obj_faces[ chunk_faces4[ f ] ];\n\n\t\t\t\tvertexColors = face.vertexColors;\n\t\t\t\tfaceColor = face.color;\n\n\t\t\t\tif ( vertexColors.length === 4 && vertexColorType === THREE.VertexColors ) {\n\n\t\t\t\t\tc1 = vertexColors[ 0 ];\n\t\t\t\t\tc2 = vertexColors[ 1 ];\n\t\t\t\t\tc3 = vertexColors[ 2 ];\n\t\t\t\t\tc4 = vertexColors[ 3 ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tc1 = faceColor;\n\t\t\t\t\tc2 = faceColor;\n\t\t\t\t\tc3 = faceColor;\n\t\t\t\t\tc4 = faceColor;\n\n\t\t\t\t}\n\n\t\t\t\tcolorArray[ offset_color ]     = c1.r;\n\t\t\t\tcolorArray[ offset_color + 1 ] = c1.g;\n\t\t\t\tcolorArray[ offset_color + 2 ] = c1.b;\n\n\t\t\t\tcolorArray[ offset_color + 3 ] = c2.r;\n\t\t\t\tcolorArray[ offset_color + 4 ] = c2.g;\n\t\t\t\tcolorArray[ offset_color + 5 ] = c2.b;\n\n\t\t\t\tcolorArray[ offset_color + 6 ] = c3.r;\n\t\t\t\tcolorArray[ offset_color + 7 ] = c3.g;\n\t\t\t\tcolorArray[ offset_color + 8 ] = c3.b;\n\n\t\t\t\tcolorArray[ offset_color + 9 ]  = c4.r;\n\t\t\t\tcolorArray[ offset_color + 10 ] = c4.g;\n\t\t\t\tcolorArray[ offset_color + 11 ] = c4.b;\n\n\t\t\t\toffset_color += 12;\n\n\t\t\t}\n\n\t\t\tif ( offset_color > 0 ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( dirtyTangents && geometry.hasTangents ) {\n\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\n\n\t\t\t\tvertexTangents = face.vertexTangents;\n\n\t\t\t\tt1 = vertexTangents[ 0 ];\n\t\t\t\tt2 = vertexTangents[ 1 ];\n\t\t\t\tt3 = vertexTangents[ 2 ];\n\n\t\t\t\ttangentArray[ offset_tangent ]     = t1.x;\n\t\t\t\ttangentArray[ offset_tangent + 1 ] = t1.y;\n\t\t\t\ttangentArray[ offset_tangent + 2 ] = t1.z;\n\t\t\t\ttangentArray[ offset_tangent + 3 ] = t1.w;\n\n\t\t\t\ttangentArray[ offset_tangent + 4 ] = t2.x;\n\t\t\t\ttangentArray[ offset_tangent + 5 ] = t2.y;\n\t\t\t\ttangentArray[ offset_tangent + 6 ] = t2.z;\n\t\t\t\ttangentArray[ offset_tangent + 7 ] = t2.w;\n\n\t\t\t\ttangentArray[ offset_tangent + 8 ]  = t3.x;\n\t\t\t\ttangentArray[ offset_tangent + 9 ]  = t3.y;\n\t\t\t\ttangentArray[ offset_tangent + 10 ] = t3.z;\n\t\t\t\ttangentArray[ offset_tangent + 11 ] = t3.w;\n\n\t\t\t\toffset_tangent += 12;\n\n\t\t\t}\n\n\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\n\n\t\t\t\tface = obj_faces[ chunk_faces4[ f ] ];\n\n\t\t\t\tvertexTangents = face.vertexTangents;\n\n\t\t\t\tt1 = vertexTangents[ 0 ];\n\t\t\t\tt2 = vertexTangents[ 1 ];\n\t\t\t\tt3 = vertexTangents[ 2 ];\n\t\t\t\tt4 = vertexTangents[ 3 ];\n\n\t\t\t\ttangentArray[ offset_tangent ]     = t1.x;\n\t\t\t\ttangentArray[ offset_tangent + 1 ] = t1.y;\n\t\t\t\ttangentArray[ offset_tangent + 2 ] = t1.z;\n\t\t\t\ttangentArray[ offset_tangent + 3 ] = t1.w;\n\n\t\t\t\ttangentArray[ offset_tangent + 4 ] = t2.x;\n\t\t\t\ttangentArray[ offset_tangent + 5 ] = t2.y;\n\t\t\t\ttangentArray[ offset_tangent + 6 ] = t2.z;\n\t\t\t\ttangentArray[ offset_tangent + 7 ] = t2.w;\n\n\t\t\t\ttangentArray[ offset_tangent + 8 ]  = t3.x;\n\t\t\t\ttangentArray[ offset_tangent + 9 ]  = t3.y;\n\t\t\t\ttangentArray[ offset_tangent + 10 ] = t3.z;\n\t\t\t\ttangentArray[ offset_tangent + 11 ] = t3.w;\n\n\t\t\t\ttangentArray[ offset_tangent + 12 ] = t4.x;\n\t\t\t\ttangentArray[ offset_tangent + 13 ] = t4.y;\n\t\t\t\ttangentArray[ offset_tangent + 14 ] = t4.z;\n\t\t\t\ttangentArray[ offset_tangent + 15 ] = t4.w;\n\n\t\t\t\toffset_tangent += 16;\n\n\t\t\t}\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, tangentArray, hint );\n\n\t\t}\n\n\t\tif ( dirtyNormals && normalType ) {\n\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\n\n\t\t\t\tvertexNormals = face.vertexNormals;\n\t\t\t\tfaceNormal = face.normal;\n\n\t\t\t\tif ( vertexNormals.length === 3 && needsSmoothNormals ) {\n\n\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\tvn = vertexNormals[ i ];\n\n\t\t\t\t\t\tnormalArray[ offset_normal ]     = vn.x;\n\t\t\t\t\t\tnormalArray[ offset_normal + 1 ] = vn.y;\n\t\t\t\t\t\tnormalArray[ offset_normal + 2 ] = vn.z;\n\n\t\t\t\t\t\toffset_normal += 3;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\tnormalArray[ offset_normal ]     = faceNormal.x;\n\t\t\t\t\t\tnormalArray[ offset_normal + 1 ] = faceNormal.y;\n\t\t\t\t\t\tnormalArray[ offset_normal + 2 ] = faceNormal.z;\n\n\t\t\t\t\t\toffset_normal += 3;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\n\n\t\t\t\tface = obj_faces[ chunk_faces4[ f ] ];\n\n\t\t\t\tvertexNormals = face.vertexNormals;\n\t\t\t\tfaceNormal = face.normal;\n\n\t\t\t\tif ( vertexNormals.length === 4 && needsSmoothNormals ) {\n\n\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\t\tvn = vertexNormals[ i ];\n\n\t\t\t\t\t\tnormalArray[ offset_normal ]     = vn.x;\n\t\t\t\t\t\tnormalArray[ offset_normal + 1 ] = vn.y;\n\t\t\t\t\t\tnormalArray[ offset_normal + 2 ] = vn.z;\n\n\t\t\t\t\t\toffset_normal += 3;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\t\tnormalArray[ offset_normal ]     = faceNormal.x;\n\t\t\t\t\t\tnormalArray[ offset_normal + 1 ] = faceNormal.y;\n\t\t\t\t\t\tnormalArray[ offset_normal + 2 ] = faceNormal.z;\n\n\t\t\t\t\t\toffset_normal += 3;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, normalArray, hint );\n\n\t\t}\n\n\t\tif ( dirtyUvs && obj_uvs && uvType ) {\n\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\tfi = chunk_faces3[ f ];\n\n\t\t\t\tuv = obj_uvs[ fi ];\n\n\t\t\t\tif ( uv === undefined ) continue;\n\n\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tuvi = uv[ i ];\n\n\t\t\t\t\tuvArray[ offset_uv ]     = uvi.x;\n\t\t\t\t\tuvArray[ offset_uv + 1 ] = uvi.y;\n\n\t\t\t\t\toffset_uv += 2;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\n\n\t\t\t\tfi = chunk_faces4[ f ];\n\n\t\t\t\tuv = obj_uvs[ fi ];\n\n\t\t\t\tif ( uv === undefined ) continue;\n\n\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\tuvi = uv[ i ];\n\n\t\t\t\t\tuvArray[ offset_uv ]     = uvi.x;\n\t\t\t\t\tuvArray[ offset_uv + 1 ] = uvi.y;\n\n\t\t\t\t\toffset_uv += 2;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( offset_uv > 0 ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, uvArray, hint );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( dirtyUvs && obj_uvs2 && uvType ) {\n\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\tfi = chunk_faces3[ f ];\n\n\t\t\t\tuv2 = obj_uvs2[ fi ];\n\n\t\t\t\tif ( uv2 === undefined ) continue;\n\n\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tuv2i = uv2[ i ];\n\n\t\t\t\t\tuv2Array[ offset_uv2 ]     = uv2i.x;\n\t\t\t\t\tuv2Array[ offset_uv2 + 1 ] = uv2i.y;\n\n\t\t\t\t\toffset_uv2 += 2;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\n\n\t\t\t\tfi = chunk_faces4[ f ];\n\n\t\t\t\tuv2 = obj_uvs2[ fi ];\n\n\t\t\t\tif ( uv2 === undefined ) continue;\n\n\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\tuv2i = uv2[ i ];\n\n\t\t\t\t\tuv2Array[ offset_uv2 ]     = uv2i.x;\n\t\t\t\t\tuv2Array[ offset_uv2 + 1 ] = uv2i.y;\n\n\t\t\t\t\toffset_uv2 += 2;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( offset_uv2 > 0 ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, uv2Array, hint );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( dirtyElements ) {\n\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\tfaceArray[ offset_face ] \t = vertexIndex;\n\t\t\t\tfaceArray[ offset_face + 1 ] = vertexIndex + 1;\n\t\t\t\tfaceArray[ offset_face + 2 ] = vertexIndex + 2;\n\n\t\t\t\toffset_face += 3;\n\n\t\t\t\tlineArray[ offset_line ]     = vertexIndex;\n\t\t\t\tlineArray[ offset_line + 1 ] = vertexIndex + 1;\n\n\t\t\t\tlineArray[ offset_line + 2 ] = vertexIndex;\n\t\t\t\tlineArray[ offset_line + 3 ] = vertexIndex + 2;\n\n\t\t\t\tlineArray[ offset_line + 4 ] = vertexIndex + 1;\n\t\t\t\tlineArray[ offset_line + 5 ] = vertexIndex + 2;\n\n\t\t\t\toffset_line += 6;\n\n\t\t\t\tvertexIndex += 3;\n\n\t\t\t}\n\n\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\n\n\t\t\t\tfaceArray[ offset_face ]     = vertexIndex;\n\t\t\t\tfaceArray[ offset_face + 1 ] = vertexIndex + 1;\n\t\t\t\tfaceArray[ offset_face + 2 ] = vertexIndex + 3;\n\n\t\t\t\tfaceArray[ offset_face + 3 ] = vertexIndex + 1;\n\t\t\t\tfaceArray[ offset_face + 4 ] = vertexIndex + 2;\n\t\t\t\tfaceArray[ offset_face + 5 ] = vertexIndex + 3;\n\n\t\t\t\toffset_face += 6;\n\n\t\t\t\tlineArray[ offset_line ]     = vertexIndex;\n\t\t\t\tlineArray[ offset_line + 1 ] = vertexIndex + 1;\n\n\t\t\t\tlineArray[ offset_line + 2 ] = vertexIndex;\n\t\t\t\tlineArray[ offset_line + 3 ] = vertexIndex + 3;\n\n\t\t\t\tlineArray[ offset_line + 4 ] = vertexIndex + 1;\n\t\t\t\tlineArray[ offset_line + 5 ] = vertexIndex + 2;\n\n\t\t\t\tlineArray[ offset_line + 6 ] = vertexIndex + 2;\n\t\t\t\tlineArray[ offset_line + 7 ] = vertexIndex + 3;\n\n\t\t\t\toffset_line += 8;\n\n\t\t\t\tvertexIndex += 4;\n\n\t\t\t}\n\n\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );\n\t\t\t_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, faceArray, hint );\n\n\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );\n\t\t\t_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, lineArray, hint );\n\n\t\t}\n\n\t\tif ( customAttributes ) {\n\n\t\t\tfor ( i = 0, il = customAttributes.length; i < il; i ++ ) {\n\n\t\t\t\tcustomAttribute = customAttributes[ i ];\n\n\t\t\t\tif ( ! customAttribute.__original.needsUpdate ) continue;\n\n\t\t\t\toffset_custom = 0;\n\t\t\t\toffset_customSrc = 0;\n\n\t\t\t\tif ( customAttribute.size === 1 ) {\n\n\t\t\t\t\tif ( customAttribute.boundTo === undefined || customAttribute.boundTo === \"vertices\" ) {\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = customAttribute.value[ face.a ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = customAttribute.value[ face.b ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = customAttribute.value[ face.c ];\n\n\t\t\t\t\t\t\toffset_custom += 3;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tface = obj_faces[ chunk_faces4[ f ] ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = customAttribute.value[ face.a ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = customAttribute.value[ face.b ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = customAttribute.value[ face.c ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = customAttribute.value[ face.d ];\n\n\t\t\t\t\t\t\toffset_custom += 4;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( customAttribute.boundTo === \"faces\" ) {\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = value;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = value;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = value;\n\n\t\t\t\t\t\t\toffset_custom += 3;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces4[ f ] ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = value;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = value;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = value;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = value;\n\n\t\t\t\t\t\t\toffset_custom += 4;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( customAttribute.size === 2 ) {\n\n\t\t\t\t\tif ( customAttribute.boundTo === undefined || customAttribute.boundTo === \"vertices\" ) {\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\n\n\t\t\t\t\t\t\tv1 = customAttribute.value[ face.a ];\n\t\t\t\t\t\t\tv2 = customAttribute.value[ face.b ];\n\t\t\t\t\t\t\tv3 = customAttribute.value[ face.c ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = v1.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1.y;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v2.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2.y;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v3.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v3.y;\n\n\t\t\t\t\t\t\toffset_custom += 6;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tface = obj_faces[ chunk_faces4[ f ] ];\n\n\t\t\t\t\t\t\tv1 = customAttribute.value[ face.a ];\n\t\t\t\t\t\t\tv2 = customAttribute.value[ face.b ];\n\t\t\t\t\t\t\tv3 = customAttribute.value[ face.c ];\n\t\t\t\t\t\t\tv4 = customAttribute.value[ face.d ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = v1.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1.y;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v2.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2.y;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v3.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v3.y;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6 ] = v4.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7 ] = v4.y;\n\n\t\t\t\t\t\t\toffset_custom += 8;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( customAttribute.boundTo === \"faces\" ) {\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\n\n\t\t\t\t\t\t\tv1 = value;\n\t\t\t\t\t\t\tv2 = value;\n\t\t\t\t\t\t\tv3 = value;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = v1.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1.y;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v2.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2.y;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v3.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v3.y;\n\n\t\t\t\t\t\t\toffset_custom += 6;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces4[ f ] ];\n\n\t\t\t\t\t\t\tv1 = value;\n\t\t\t\t\t\t\tv2 = value;\n\t\t\t\t\t\t\tv3 = value;\n\t\t\t\t\t\t\tv4 = value;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = v1.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1.y;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v2.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2.y;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v3.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v3.y;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6 ] = v4.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7 ] = v4.y;\n\n\t\t\t\t\t\t\toffset_custom += 8;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( customAttribute.size === 3 ) {\n\n\t\t\t\t\tvar pp;\n\n\t\t\t\t\tif ( customAttribute.type === \"c\" ) {\n\n\t\t\t\t\t\tpp = [ \"r\", \"g\", \"b\" ];\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpp = [ \"x\", \"y\", \"z\" ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( customAttribute.boundTo === undefined || customAttribute.boundTo === \"vertices\" ) {\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\n\n\t\t\t\t\t\t\tv1 = customAttribute.value[ face.a ];\n\t\t\t\t\t\t\tv2 = customAttribute.value[ face.b ];\n\t\t\t\t\t\t\tv3 = customAttribute.value[ face.c ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = v1[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\toffset_custom += 9;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tface = obj_faces[ chunk_faces4[ f ] ];\n\n\t\t\t\t\t\t\tv1 = customAttribute.value[ face.a ];\n\t\t\t\t\t\t\tv2 = customAttribute.value[ face.b ];\n\t\t\t\t\t\t\tv3 = customAttribute.value[ face.c ];\n\t\t\t\t\t\t\tv4 = customAttribute.value[ face.d ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ] \t= v1[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v2[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v3[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v3[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v4[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v4[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v4[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\toffset_custom += 12;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( customAttribute.boundTo === \"faces\" ) {\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\n\n\t\t\t\t\t\t\tv1 = value;\n\t\t\t\t\t\t\tv2 = value;\n\t\t\t\t\t\t\tv3 = value;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = v1[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\toffset_custom += 9;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces4[ f ] ];\n\n\t\t\t\t\t\t\tv1 = value;\n\t\t\t\t\t\t\tv2 = value;\n\t\t\t\t\t\t\tv3 = value;\n\t\t\t\t\t\t\tv4 = value;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ] \t= v1[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v2[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v3[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v3[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v4[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v4[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v4[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\toffset_custom += 12;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( customAttribute.boundTo === \"faceVertices\" ) {\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\n\n\t\t\t\t\t\t\tv1 = value[ 0 ];\n\t\t\t\t\t\t\tv2 = value[ 1 ];\n\t\t\t\t\t\t\tv3 = value[ 2 ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = v1[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\toffset_custom += 9;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces4[ f ] ];\n\n\t\t\t\t\t\t\tv1 = value[ 0 ];\n\t\t\t\t\t\t\tv2 = value[ 1 ];\n\t\t\t\t\t\t\tv3 = value[ 2 ];\n\t\t\t\t\t\t\tv4 = value[ 3 ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ] \t= v1[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v2[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v3[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v3[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v4[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v4[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v4[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\toffset_custom += 12;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( customAttribute.size === 4 ) {\n\n\t\t\t\t\tif ( customAttribute.boundTo === undefined || customAttribute.boundTo === \"vertices\" ) {\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\n\n\t\t\t\t\t\t\tv1 = customAttribute.value[ face.a ];\n\t\t\t\t\t\t\tv2 = customAttribute.value[ face.b ];\n\t\t\t\t\t\t\tv3 = customAttribute.value[ face.c ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ] \t= v1.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v1.w;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v2.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v2.w;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v3.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v3.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v3.w;\n\n\t\t\t\t\t\t\toffset_custom += 12;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tface = obj_faces[ chunk_faces4[ f ] ];\n\n\t\t\t\t\t\t\tv1 = customAttribute.value[ face.a ];\n\t\t\t\t\t\t\tv2 = customAttribute.value[ face.b ];\n\t\t\t\t\t\t\tv3 = customAttribute.value[ face.c ];\n\t\t\t\t\t\t\tv4 = customAttribute.value[ face.d ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ] \t= v1.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v1.w;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v2.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v2.w;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v3.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v3.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v3.w;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 12 ] = v4.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 13 ] = v4.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 14 ] = v4.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 15 ] = v4.w;\n\n\t\t\t\t\t\t\toffset_custom += 16;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( customAttribute.boundTo === \"faces\" ) {\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\n\n\t\t\t\t\t\t\tv1 = value;\n\t\t\t\t\t\t\tv2 = value;\n\t\t\t\t\t\t\tv3 = value;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ] \t= v1.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v1.w;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v2.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v2.w;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v3.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v3.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v3.w;\n\n\t\t\t\t\t\t\toffset_custom += 12;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces4[ f ] ];\n\n\t\t\t\t\t\t\tv1 = value;\n\t\t\t\t\t\t\tv2 = value;\n\t\t\t\t\t\t\tv3 = value;\n\t\t\t\t\t\t\tv4 = value;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ] \t= v1.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v1.w;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v2.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v2.w;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v3.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v3.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v3.w;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 12 ] = v4.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 13 ] = v4.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 14 ] = v4.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 15 ] = v4.w;\n\n\t\t\t\t\t\t\toffset_custom += 16;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( customAttribute.boundTo === \"faceVertices\" ) {\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\n\n\t\t\t\t\t\t\tv1 = value[ 0 ];\n\t\t\t\t\t\t\tv2 = value[ 1 ];\n\t\t\t\t\t\t\tv3 = value[ 2 ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ] \t= v1.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v1.w;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v2.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v2.w;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v3.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v3.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v3.w;\n\n\t\t\t\t\t\t\toffset_custom += 12;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces4[ f ] ];\n\n\t\t\t\t\t\t\tv1 = value[ 0 ];\n\t\t\t\t\t\t\tv2 = value[ 1 ];\n\t\t\t\t\t\t\tv3 = value[ 2 ];\n\t\t\t\t\t\t\tv4 = value[ 3 ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ] \t= v1.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v1.w;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v2.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v2.w;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v3.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v3.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v3.w;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 12 ] = v4.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 13 ] = v4.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 14 ] = v4.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 15 ] = v4.w;\n\n\t\t\t\t\t\t\toffset_custom += 16;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( dispose ) {\n\n\t\t\tdelete geometryGroup.__inittedArrays;\n\t\t\tdelete geometryGroup.__colorArray;\n\t\t\tdelete geometryGroup.__normalArray;\n\t\t\tdelete geometryGroup.__tangentArray;\n\t\t\tdelete geometryGroup.__uvArray;\n\t\t\tdelete geometryGroup.__uv2Array;\n\t\t\tdelete geometryGroup.__faceArray;\n\t\t\tdelete geometryGroup.__vertexArray;\n\t\t\tdelete geometryGroup.__lineArray;\n\t\t\tdelete geometryGroup.__skinIndexArray;\n\t\t\tdelete geometryGroup.__skinWeightArray;\n\n\t\t}\n\n\t};\n\n\tfunction setDirectBuffers ( geometry, hint, dispose ) {\n\n\t\tvar attributes = geometry.attributes;\n\n\t\tvar index = attributes[ \"index\" ];\n\t\tvar position = attributes[ \"position\" ];\n\t\tvar normal = attributes[ \"normal\" ];\n\t\tvar uv = attributes[ \"uv\" ];\n\t\tvar color = attributes[ \"color\" ];\n\t\tvar tangent = attributes[ \"tangent\" ];\n\n\t\tif ( geometry.elementsNeedUpdate && index !== undefined ) {\n\n\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );\n\t\t\t_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, index.array, hint );\n\n\t\t}\n\n\t\tif ( geometry.verticesNeedUpdate && position !== undefined ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, position.buffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, position.array, hint );\n\n\t\t}\n\n\t\tif ( geometry.normalsNeedUpdate && normal !== undefined ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, normal.buffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, normal.array, hint );\n\n\t\t}\n\n\t\tif ( geometry.uvsNeedUpdate && uv !== undefined ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, uv.buffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, uv.array, hint );\n\n\t\t}\n\n\t\tif ( geometry.colorsNeedUpdate && color !== undefined ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, color.buffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, color.array, hint );\n\n\t\t}\n\n\t\tif ( geometry.tangentsNeedUpdate && tangent !== undefined ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, tangent.buffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, tangent.array, hint );\n\n\t\t}\n\n\t\tif ( dispose ) {\n\n\t\t\tfor ( var i in geometry.attributes ) {\n\n\t\t\t\tdelete geometry.attributes[ i ].array;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\t// Buffer rendering\n\n\tthis.renderBufferImmediate = function ( object, program, material ) {\n\n\t\tif ( object.hasPositions && ! object.__webglVertexBuffer ) object.__webglVertexBuffer = _gl.createBuffer();\n\t\tif ( object.hasNormals && ! object.__webglNormalBuffer ) object.__webglNormalBuffer = _gl.createBuffer();\n\t\tif ( object.hasUvs && ! object.__webglUvBuffer ) object.__webglUvBuffer = _gl.createBuffer();\n\t\tif ( object.hasColors && ! object.__webglColorBuffer ) object.__webglColorBuffer = _gl.createBuffer();\n\n\t\tif ( object.hasPositions ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglVertexBuffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );\n\t\t\t_gl.enableVertexAttribArray( program.attributes.position );\n\t\t\t_gl.vertexAttribPointer( program.attributes.position, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t}\n\n\t\tif ( object.hasNormals ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglNormalBuffer );\n\n\t\t\tif ( material.shading === THREE.FlatShading ) {\n\n\t\t\t\tvar nx, ny, nz,\n\t\t\t\t\tnax, nbx, ncx, nay, nby, ncy, naz, nbz, ncz,\n\t\t\t\t\tnormalArray,\n\t\t\t\t\ti, il = object.count * 3;\n\n\t\t\t\tfor( i = 0; i < il; i += 9 ) {\n\n\t\t\t\t\tnormalArray = object.normalArray;\n\n\t\t\t\t\tnax  = normalArray[ i ];\n\t\t\t\t\tnay  = normalArray[ i + 1 ];\n\t\t\t\t\tnaz  = normalArray[ i + 2 ];\n\n\t\t\t\t\tnbx  = normalArray[ i + 3 ];\n\t\t\t\t\tnby  = normalArray[ i + 4 ];\n\t\t\t\t\tnbz  = normalArray[ i + 5 ];\n\n\t\t\t\t\tncx  = normalArray[ i + 6 ];\n\t\t\t\t\tncy  = normalArray[ i + 7 ];\n\t\t\t\t\tncz  = normalArray[ i + 8 ];\n\n\t\t\t\t\tnx = ( nax + nbx + ncx ) / 3;\n\t\t\t\t\tny = ( nay + nby + ncy ) / 3;\n\t\t\t\t\tnz = ( naz + nbz + ncz ) / 3;\n\n\t\t\t\t\tnormalArray[ i ] \t = nx;\n\t\t\t\t\tnormalArray[ i + 1 ] = ny;\n\t\t\t\t\tnormalArray[ i + 2 ] = nz;\n\n\t\t\t\t\tnormalArray[ i + 3 ] = nx;\n\t\t\t\t\tnormalArray[ i + 4 ] = ny;\n\t\t\t\t\tnormalArray[ i + 5 ] = nz;\n\n\t\t\t\t\tnormalArray[ i + 6 ] = nx;\n\t\t\t\t\tnormalArray[ i + 7 ] = ny;\n\t\t\t\t\tnormalArray[ i + 8 ] = nz;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );\n\t\t\t_gl.enableVertexAttribArray( program.attributes.normal );\n\t\t\t_gl.vertexAttribPointer( program.attributes.normal, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t}\n\n\t\tif ( object.hasUvs && material.map ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglUvBuffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );\n\t\t\t_gl.enableVertexAttribArray( program.attributes.uv );\n\t\t\t_gl.vertexAttribPointer( program.attributes.uv, 2, _gl.FLOAT, false, 0, 0 );\n\n\t\t}\n\n\t\tif ( object.hasColors && material.vertexColors !== THREE.NoColors ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglColorBuffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );\n\t\t\t_gl.enableVertexAttribArray( program.attributes.color );\n\t\t\t_gl.vertexAttribPointer( program.attributes.color, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t}\n\n\t\t_gl.drawArrays( _gl.TRIANGLES, 0, object.count );\n\n\t\tobject.count = 0;\n\n\t};\n\n\tthis.renderBufferDirect = function ( camera, lights, fog, material, geometry, object ) {\n\n\t\tif ( material.visible === false ) return;\n\n\t\tvar program, attributes, linewidth, primitives, a, attribute;\n\n\t\tprogram = setProgram( camera, lights, fog, material, object );\n\n\t\tattributes = program.attributes;\n\n\t\tvar updateBuffers = false,\n\t\t\twireframeBit = material.wireframe ? 1 : 0,\n\t\t\tgeometryHash = ( geometry.id * 0xffffff ) + ( program.id * 2 ) + wireframeBit;\n\n\t\tif ( geometryHash !== _currentGeometryGroupHash ) {\n\n\t\t\t_currentGeometryGroupHash = geometryHash;\n\t\t\tupdateBuffers = true;\n\n\t\t}\n\n\t\tif ( updateBuffers ) {\n\n\t\t\tdisableAttributes();\n\n\t\t}\n\n\t\t// render mesh\n\n\t\tif ( object instanceof THREE.Mesh ) {\n\n\t\t\tvar index = geometry.attributes[ \"index\" ];\n\n\t\t\t// indexed triangles\n\n\t\t\tif ( index ) {\n\n\t\t\t\tvar offsets = geometry.offsets;\n\n\t\t\t\t// if there is more than 1 chunk\n\t\t\t\t// must set attribute pointers to use new offsets for each chunk\n\t\t\t\t// even if geometry and materials didn't change\n\n\t\t\t\tif ( offsets.length > 1 ) updateBuffers = true;\n\n\t\t\t\tfor ( var i = 0, il = offsets.length; i < il; i ++ ) {\n\n\t\t\t\t\tvar startIndex = offsets[ i ].index;\n\n\t\t\t\t\tif ( updateBuffers ) {\n\n\t\t\t\t\t\t// vertices\n\n\t\t\t\t\t\tvar position = geometry.attributes[ \"position\" ];\n\t\t\t\t\t\tvar positionSize = position.itemSize;\n\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, position.buffer );\n\t\t\t\t\t\tenableAttribute( attributes.position );\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes.position, positionSize, _gl.FLOAT, false, 0, startIndex * positionSize * 4 ); // 4 bytes per Float32\n\n\t\t\t\t\t\t// normals\n\n\t\t\t\t\t\tvar normal = geometry.attributes[ \"normal\" ];\n\n\t\t\t\t\t\tif ( attributes.normal >= 0 && normal ) {\n\n\t\t\t\t\t\t\tvar normalSize = normal.itemSize;\n\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, normal.buffer );\n\t\t\t\t\t\t\tenableAttribute( attributes.normal );\n\t\t\t\t\t\t\t_gl.vertexAttribPointer( attributes.normal, normalSize, _gl.FLOAT, false, 0, startIndex * normalSize * 4 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// uvs\n\n\t\t\t\t\t\tvar uv = geometry.attributes[ \"uv\" ];\n\n\t\t\t\t\t\tif ( attributes.uv >= 0 && uv ) {\n\n\t\t\t\t\t\t\tvar uvSize = uv.itemSize;\n\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, uv.buffer );\n\t\t\t\t\t\t\tenableAttribute( attributes.uv );\n\t\t\t\t\t\t\t_gl.vertexAttribPointer( attributes.uv, uvSize, _gl.FLOAT, false, 0, startIndex * uvSize * 4 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// colors\n\n\t\t\t\t\t\tvar color = geometry.attributes[ \"color\" ];\n\n\t\t\t\t\t\tif ( attributes.color >= 0 && color ) {\n\n\t\t\t\t\t\t\tvar colorSize = color.itemSize;\n\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, color.buffer );\n\t\t\t\t\t\t\tenableAttribute( attributes.color );\n\t\t\t\t\t\t\t_gl.vertexAttribPointer( attributes.color, colorSize, _gl.FLOAT, false, 0, startIndex * colorSize * 4 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// tangents\n\n\t\t\t\t\t\tvar tangent = geometry.attributes[ \"tangent\" ];\n\n\t\t\t\t\t\tif ( attributes.tangent >= 0 && tangent ) {\n\n\t\t\t\t\t\t\tvar tangentSize = tangent.itemSize;\n\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, tangent.buffer );\n\t\t\t\t\t\t\tenableAttribute( attributes.tangent );\n\t\t\t\t\t\t\t_gl.vertexAttribPointer( attributes.tangent, tangentSize, _gl.FLOAT, false, 0, startIndex * tangentSize * 4 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// indices\n\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// render indexed triangles\n\n\t\t\t\t\t_gl.drawElements( _gl.TRIANGLES, offsets[ i ].count, _gl.UNSIGNED_SHORT, offsets[ i ].start * 2 ); // 2 bytes per Uint16\n\n\t\t\t\t\t_this.info.render.calls ++;\n\t\t\t\t\t_this.info.render.vertices += offsets[ i ].count; // not really true, here vertices can be shared\n\t\t\t\t\t_this.info.render.faces += offsets[ i ].count / 3;\n\n\t\t\t\t}\n\n\t\t\t// non-indexed triangles\n\n\t\t\t} else {\n\n\t\t\t\tif ( updateBuffers ) {\n\n\t\t\t\t\t// vertices\n\n\t\t\t\t\tvar position = geometry.attributes[ \"position\" ];\n\t\t\t\t\tvar positionSize = position.itemSize;\n\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, position.buffer );\n\t\t\t\t\tenableAttribute( attributes.position );\n\t\t\t\t\t_gl.vertexAttribPointer( attributes.position, positionSize, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t\t\t// normals\n\n\t\t\t\t\tvar normal = geometry.attributes[ \"normal\" ];\n\n\t\t\t\t\tif ( attributes.normal >= 0 && normal ) {\n\n\t\t\t\t\t\tvar normalSize = normal.itemSize;\n\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, normal.buffer );\n\t\t\t\t\t\tenableAttribute( attributes.normal );\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes.normal, normalSize, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// uvs\n\n\t\t\t\t\tvar uv = geometry.attributes[ \"uv\" ];\n\n\t\t\t\t\tif ( attributes.uv >= 0 && uv ) {\n\n\t\t\t\t\t\tvar uvSize = uv.itemSize;\n\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, uv.buffer );\n\t\t\t\t\t\tenableAttribute( attributes.uv );\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes.uv, uvSize, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// colors\n\n\t\t\t\t\tvar color = geometry.attributes[ \"color\" ];\n\n\t\t\t\t\tif ( attributes.color >= 0 && color ) {\n\n\t\t\t\t\t\tvar colorSize = color.itemSize;\n\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, color.buffer );\n\t\t\t\t\t\tenableAttribute( attributes.color );\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes.color, colorSize, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// tangents\n\n\t\t\t\t\tvar tangent = geometry.attributes[ \"tangent\" ];\n\n\t\t\t\t\tif ( attributes.tangent >= 0 && tangent ) {\n\n\t\t\t\t\t\tvar tangentSize = tangent.itemSize;\n\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, tangent.buffer );\n\t\t\t\t\t\tenableAttribute( attributes.tangent );\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes.tangent, tangentSize, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// render non-indexed triangles\n\n\t\t\t\t_gl.drawArrays( _gl.TRIANGLES, 0, position.numItems / 3 );\n\n\t\t\t\t_this.info.render.calls ++;\n\t\t\t\t_this.info.render.vertices += position.numItems / 3;\n\t\t\t\t_this.info.render.faces += position.numItems / 3 / 3;\n\n\t\t\t}\n\n\t\t// render particles\n\n\t\t} else if ( object instanceof THREE.ParticleSystem ) {\n\n\t\t\tif ( updateBuffers ) {\n\n\t\t\t\t// vertices\n\n\t\t\t\tvar position = geometry.attributes[ \"position\" ];\n\t\t\t\tvar positionSize = position.itemSize;\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, position.buffer );\n\t\t\t\tenableAttribute( attributes.position );\n\t\t\t\t_gl.vertexAttribPointer( attributes.position, positionSize, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t\t// colors\n\n\t\t\t\tvar color = geometry.attributes[ \"color\" ];\n\n\t\t\t\tif ( attributes.color >= 0 && color ) {\n\n\t\t\t\t\tvar colorSize = color.itemSize;\n\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, color.buffer );\n\t\t\t\t\tenableAttribute( attributes.color );\n\t\t\t\t\t_gl.vertexAttribPointer( attributes.color, colorSize, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t\t// render particles\n\n\t\t\t\t_gl.drawArrays( _gl.POINTS, 0, position.numItems / 3 );\n\n\t\t\t\t_this.info.render.calls ++;\n\t\t\t\t_this.info.render.points += position.numItems / 3;\n\n\t\t\t}\n\n\t\t} else if ( object instanceof THREE.Line ) {\n\n\t\t\tif ( updateBuffers ) {\n\n\t\t\t\t// vertices\n\n\t\t\t\tvar position = geometry.attributes[ \"position\" ];\n\t\t\t\tvar positionSize = position.itemSize;\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, position.buffer );\n\t\t\t\tenableAttribute( attributes.position );\n\t\t\t\t_gl.vertexAttribPointer( attributes.position, positionSize, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t\t// colors\n\n\t\t\t\tvar color = geometry.attributes[ \"color\" ];\n\n\t\t\t\tif ( attributes.color >= 0 && color ) {\n\n\t\t\t\t\tvar colorSize = color.itemSize;\n\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, color.buffer );\n\t\t\t\t\tenableAttribute( attributes.color );\n\t\t\t\t\t_gl.vertexAttribPointer( attributes.color, colorSize, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t\t// render lines\n\n\t\t\t\tsetLineWidth( material.linewidth );\n\n\t\t\t\t_gl.drawArrays( _gl.LINE_STRIP, 0, position.numItems / 3 );\n\n\t\t\t\t_this.info.render.calls ++;\n\t\t\t\t_this.info.render.points += position.numItems;\n\n\t\t\t}\n\n    }\n\n\t};\n\n\tthis.renderBuffer = function ( camera, lights, fog, material, geometryGroup, object ) {\n\n\t\tif ( material.visible === false ) return;\n\n\t\tvar program, attributes, linewidth, primitives, a, attribute, i, il;\n\n\t\tprogram = setProgram( camera, lights, fog, material, object );\n\n\t\tattributes = program.attributes;\n\n\t\tvar updateBuffers = false,\n\t\t\twireframeBit = material.wireframe ? 1 : 0,\n\t\t\tgeometryGroupHash = ( geometryGroup.id * 0xffffff ) + ( program.id * 2 ) + wireframeBit;\n\n\t\tif ( geometryGroupHash !== _currentGeometryGroupHash ) {\n\n\t\t\t_currentGeometryGroupHash = geometryGroupHash;\n\t\t\tupdateBuffers = true;\n\n\t\t}\n\n\t\tif ( updateBuffers ) {\n\n\t\t\tdisableAttributes();\n\n\t\t}\n\n\t\t// vertices\n\n\t\tif ( !material.morphTargets && attributes.position >= 0 ) {\n\n\t\t\tif ( updateBuffers ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );\n\t\t\t\tenableAttribute( attributes.position );\n\t\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( object.morphTargetBase ) {\n\n\t\t\t\tsetupMorphTargets( material, geometryGroup, object );\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tif ( updateBuffers ) {\n\n\t\t\t// custom attributes\n\n\t\t\t// Use the per-geometryGroup custom attribute arrays which are setup in initMeshBuffers\n\n\t\t\tif ( geometryGroup.__webglCustomAttributesList ) {\n\n\t\t\t\tfor ( i = 0, il = geometryGroup.__webglCustomAttributesList.length; i < il; i ++ ) {\n\n\t\t\t\t\tattribute = geometryGroup.__webglCustomAttributesList[ i ];\n\n\t\t\t\t\tif ( attributes[ attribute.buffer.belongsToAttribute ] >= 0 ) {\n\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, attribute.buffer );\n\t\t\t\t\t\tenableAttribute( attributes[ attribute.buffer.belongsToAttribute ] );\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes[ attribute.buffer.belongsToAttribute ], attribute.size, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\t// colors\n\n\t\t\tif ( attributes.color >= 0 ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );\n\t\t\t\tenableAttribute( attributes.color );\n\t\t\t\t_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t}\n\n\t\t\t// normals\n\n\t\t\tif ( attributes.normal >= 0 ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );\n\t\t\t\tenableAttribute( attributes.normal );\n\t\t\t\t_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t}\n\n\t\t\t// tangents\n\n\t\t\tif ( attributes.tangent >= 0 ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );\n\t\t\t\tenableAttribute( attributes.tangent );\n\t\t\t\t_gl.vertexAttribPointer( attributes.tangent, 4, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t}\n\n\t\t\t// uvs\n\n\t\t\tif ( attributes.uv >= 0 ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );\n\t\t\t\tenableAttribute( attributes.uv );\n\t\t\t\t_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t}\n\n\t\t\tif ( attributes.uv2 >= 0 ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );\n\t\t\t\tenableAttribute( attributes.uv2 );\n\t\t\t\t_gl.vertexAttribPointer( attributes.uv2, 2, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t}\n\n\t\t\tif ( material.skinning &&\n\t\t\t\t attributes.skinIndex >= 0 && attributes.skinWeight >= 0 ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );\n\t\t\t\tenableAttribute( attributes.skinIndex );\n\t\t\t\t_gl.vertexAttribPointer( attributes.skinIndex, 4, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );\n\t\t\t\tenableAttribute( attributes.skinWeight );\n\t\t\t\t_gl.vertexAttribPointer( attributes.skinWeight, 4, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t}\n\n\t\t\t// line distances\n\n\t\t\tif ( attributes.lineDistance >= 0 ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglLineDistanceBuffer );\n\t\t\t\tenableAttribute( attributes.lineDistance );\n\t\t\t\t_gl.vertexAttribPointer( attributes.lineDistance, 1, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// render mesh\n\n\t\tif ( object instanceof THREE.Mesh ) {\n\n\t\t\t// wireframe\n\n\t\t\tif ( material.wireframe ) {\n\n\t\t\t\tsetLineWidth( material.wireframeLinewidth );\n\n\t\t\t\tif ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );\n\t\t\t\t_gl.drawElements( _gl.LINES, geometryGroup.__webglLineCount, _gl.UNSIGNED_SHORT, 0 );\n\n\t\t\t// triangles\n\n\t\t\t} else {\n\n\t\t\t\tif ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );\n\t\t\t\t_gl.drawElements( _gl.TRIANGLES, geometryGroup.__webglFaceCount, _gl.UNSIGNED_SHORT, 0 );\n\n\t\t\t}\n\n\t\t\t_this.info.render.calls ++;\n\t\t\t_this.info.render.vertices += geometryGroup.__webglFaceCount;\n\t\t\t_this.info.render.faces += geometryGroup.__webglFaceCount / 3;\n\n\t\t// render lines\n\n\t\t} else if ( object instanceof THREE.Line ) {\n\n\t\t\tprimitives = ( object.type === THREE.LineStrip ) ? _gl.LINE_STRIP : _gl.LINES;\n\n\t\t\tsetLineWidth( material.linewidth );\n\n\t\t\t_gl.drawArrays( primitives, 0, geometryGroup.__webglLineCount );\n\n\t\t\t_this.info.render.calls ++;\n\n\t\t// render particles\n\n\t\t} else if ( object instanceof THREE.ParticleSystem ) {\n\n\t\t\t_gl.drawArrays( _gl.POINTS, 0, geometryGroup.__webglParticleCount );\n\n\t\t\t_this.info.render.calls ++;\n\t\t\t_this.info.render.points += geometryGroup.__webglParticleCount;\n\n\t\t// render ribbon\n\n\t\t} else if ( object instanceof THREE.Ribbon ) {\n\n\t\t\t_gl.drawArrays( _gl.TRIANGLE_STRIP, 0, geometryGroup.__webglVertexCount );\n\n\t\t\t_this.info.render.calls ++;\n\n\t\t}\n\n\t};\n\n\tfunction enableAttribute( attribute ) {\n\n\t\tif ( ! _enabledAttributes[ attribute ] ) {\n\n\t\t\t_gl.enableVertexAttribArray( attribute );\n\t\t\t_enabledAttributes[ attribute ] = true;\n\n\t\t}\n\n\t};\n\n\tfunction disableAttributes() {\n\n\t\tfor ( var attribute in _enabledAttributes ) {\n\n\t\t\tif ( _enabledAttributes[ attribute ] ) {\n\n\t\t\t\t_gl.disableVertexAttribArray( attribute );\n\t\t\t\t_enabledAttributes[ attribute ] = false;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tfunction setupMorphTargets ( material, geometryGroup, object ) {\n\n\t\t// set base\n\n\t\tvar attributes = material.program.attributes;\n\n\t\tif ( object.morphTargetBase !== -1 && attributes.position >= 0 ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ object.morphTargetBase ] );\n\t\t\tenableAttribute( attributes.position );\n\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t} else if ( attributes.position >= 0 ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );\n\t\t\tenableAttribute( attributes.position );\n\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t}\n\n\t\tif ( object.morphTargetForcedOrder.length ) {\n\n\t\t\t// set forced order\n\n\t\t\tvar m = 0;\n\t\t\tvar order = object.morphTargetForcedOrder;\n\t\t\tvar influences = object.morphTargetInfluences;\n\n\t\t\twhile ( m < material.numSupportedMorphTargets && m < order.length ) {\n\n\t\t\t\tif ( attributes[ \"morphTarget\" + m ] >= 0 ) {\n\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ order[ m ] ] );\n\t\t\t\t\tenableAttribute( attributes[ \"morphTarget\" + m ] );\n\t\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphTarget\" + m ], 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( attributes[ \"morphNormal\" + m ] >= 0 && material.morphNormals ) {\n\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ order[ m ] ] );\n\t\t\t\t\tenableAttribute( attributes[ \"morphNormal\" + m ] );\n\t\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphNormal\" + m ], 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t\tobject.__webglMorphTargetInfluences[ m ] = influences[ order[ m ] ];\n\n\t\t\t\tm ++;\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// find the most influencing\n\n\t\t\tvar influence, activeInfluenceIndices = [];\n\t\t\tvar influences = object.morphTargetInfluences;\n\t\t\tvar i, il = influences.length;\n\n\t\t\tfor ( i = 0; i < il; i ++ ) {\n\n\t\t\t\tinfluence = influences[ i ];\n\n\t\t\t\tif ( influence > 0 ) {\n\n\t\t\t\t\tactiveInfluenceIndices.push( [ influence, i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( activeInfluenceIndices.length > material.numSupportedMorphTargets ) {\n\n\t\t\t\tactiveInfluenceIndices.sort( numericalSort );\n\t\t\t\tactiveInfluenceIndices.length = material.numSupportedMorphTargets;\n\n\t\t\t} else if ( activeInfluenceIndices.length > material.numSupportedMorphNormals ) {\n\n\t\t\t\tactiveInfluenceIndices.sort( numericalSort );\n\n\t\t\t} else if ( activeInfluenceIndices.length === 0 ) {\n\n\t\t\t\tactiveInfluenceIndices.push( [ 0, 0 ] );\n\n\t\t\t};\n\n\t\t\tvar influenceIndex, m = 0;\n\n\t\t\twhile ( m < material.numSupportedMorphTargets ) {\n\n\t\t\t\tif ( activeInfluenceIndices[ m ] ) {\n\n\t\t\t\t\tinfluenceIndex = activeInfluenceIndices[ m ][ 1 ];\n\n\t\t\t\t\tif ( attributes[ \"morphTarget\" + m ] >= 0 ) {\n\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ influenceIndex ] );\n\t\t\t\t\t\tenableAttribute( attributes[ \"morphTarget\" + m ] );\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphTarget\" + m ], 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( attributes[ \"morphNormal\" + m ] >= 0 && material.morphNormals ) {\n\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ influenceIndex ] );\n\t\t\t\t\t\tenableAttribute( attributes[ \"morphNormal\" + m ] );\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphNormal\" + m ], 3, _gl.FLOAT, false, 0, 0 );\n\n\n\t\t\t\t\t}\n\n\t\t\t\t\tobject.__webglMorphTargetInfluences[ m ] = influences[ influenceIndex ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\t/*\n\t\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphTarget\" + m ], 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t\t\tif ( material.morphNormals ) {\n\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphNormal\" + m ], 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t\t\t}\n\t\t\t\t\t*/\n\n\t\t\t\t\tobject.__webglMorphTargetInfluences[ m ] = 0;\n\n\t\t\t\t}\n\n\t\t\t\tm ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// load updated influences uniform\n\n\t\tif ( material.program.uniforms.morphTargetInfluences !== null ) {\n\n\t\t\t_gl.uniform1fv( material.program.uniforms.morphTargetInfluences, object.__webglMorphTargetInfluences );\n\n\t\t}\n\n\t};\n\n\t// Sorting\n\n\tfunction painterSortStable ( a, b ) {\n\n\t\tif ( a.z !== b.z ) {\n\n\t\t\treturn b.z - a.z;\n\n\t\t} else {\n\n\t\t\treturn b.id - a.id;\n\n\t\t}\n\n\t};\n\n\tfunction numericalSort ( a, b ) {\n\n\t\treturn b[ 0 ] - a[ 0 ];\n\n\t};\n\n\n\t// Rendering\n\n\tthis.render = function ( scene, camera, renderTarget, forceClear ) {\n\n\t\tif ( camera instanceof THREE.Camera === false ) {\n\n\t\t\tconsole.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar i, il,\n\n\t\twebglObject, object,\n\t\trenderList,\n\n\t\tlights = scene.__lights,\n\t\tfog = scene.fog;\n\n\t\t// reset caching for this frame\n\n\t\t_currentMaterialId = -1;\n\t\t_lightsNeedUpdate = true;\n\n\t\t// update scene graph\n\n\t\tif ( this.autoUpdateScene ) scene.updateMatrixWorld();\n\n\t\t// update camera matrices and frustum\n\n\t\tif ( camera.parent === undefined ) camera.updateMatrixWorld();\n\n\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\n\n\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\t\t_frustum.setFromMatrix( _projScreenMatrix );\n\n\t\t// update WebGL objects\n\n\t\tif ( this.autoUpdateObjects ) this.initWebGLObjects( scene );\n\n\t\t// custom render plugins (pre pass)\n\n\t\trenderPlugins( this.renderPluginsPre, scene, camera );\n\n\t\t//\n\n\t\t_this.info.render.calls = 0;\n\t\t_this.info.render.vertices = 0;\n\t\t_this.info.render.faces = 0;\n\t\t_this.info.render.points = 0;\n\n\t\tthis.setRenderTarget( renderTarget );\n\n\t\tif ( this.autoClear || forceClear ) {\n\n\t\t\tthis.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );\n\n\t\t}\n\n\t\t// set matrices for regular objects (frustum culled)\n\n\t\trenderList = scene.__webglObjects;\n\n\t\tfor ( i = 0, il = renderList.length; i < il; i ++ ) {\n\n\t\t\twebglObject = renderList[ i ];\n\t\t\tobject = webglObject.object;\n\n\t\t\twebglObject.render = false;\n\n\t\t\tif ( object.visible ) {\n\n\t\t\t\tif ( ! ( object instanceof THREE.Mesh || object instanceof THREE.ParticleSystem ) || ! ( object.frustumCulled ) || _frustum.intersectsObject( object ) ) {\n\n\t\t\t\t\tsetupMatrices( object, camera );\n\n\t\t\t\t\tunrollBufferMaterial( webglObject );\n\n\t\t\t\t\twebglObject.render = true;\n\n\t\t\t\t\tif ( this.sortObjects === true ) {\n\n\t\t\t\t\t\tif ( object.renderDepth !== null ) {\n\n\t\t\t\t\t\t\twebglObject.z = object.renderDepth;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t_vector3.getPositionFromMatrix( object.matrixWorld );\n\t\t\t\t\t\t\t_vector3.applyProjection( _projScreenMatrix );\n\n\t\t\t\t\t\t\twebglObject.z = _vector3.z;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\twebglObject.id = object.id;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.sortObjects ) {\n\n\t\t\trenderList.sort( painterSortStable );\n\n\t\t}\n\n\t\t// set matrices for immediate objects\n\n\t\trenderList = scene.__webglObjectsImmediate;\n\n\t\tfor ( i = 0, il = renderList.length; i < il; i ++ ) {\n\n\t\t\twebglObject = renderList[ i ];\n\t\t\tobject = webglObject.object;\n\n\t\t\tif ( object.visible ) {\n\n\t\t\t\tsetupMatrices( object, camera );\n\n\t\t\t\tunrollImmediateBufferMaterial( webglObject );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( scene.overrideMaterial ) {\n\n\t\t\tvar material = scene.overrideMaterial;\n\n\t\t\tthis.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\n\t\t\tthis.setDepthTest( material.depthTest );\n\t\t\tthis.setDepthWrite( material.depthWrite );\n\t\t\tsetPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\n\n\t\t\trenderObjects( scene.__webglObjects, false, \"\", camera, lights, fog, true, material );\n\t\t\trenderObjectsImmediate( scene.__webglObjectsImmediate, \"\", camera, lights, fog, false, material );\n\n\t\t} else {\n\n\t\t\tvar material = null;\n\n\t\t\t// opaque pass (front-to-back order)\n\n\t\t\tthis.setBlending( THREE.NoBlending );\n\n\t\t\trenderObjects( scene.__webglObjects, true, \"opaque\", camera, lights, fog, false, material );\n\t\t\trenderObjectsImmediate( scene.__webglObjectsImmediate, \"opaque\", camera, lights, fog, false, material );\n\n\t\t\t// transparent pass (back-to-front order)\n\n\t\t\trenderObjects( scene.__webglObjects, false, \"transparent\", camera, lights, fog, true, material );\n\t\t\trenderObjectsImmediate( scene.__webglObjectsImmediate, \"transparent\", camera, lights, fog, true, material );\n\n\t\t}\n\n\t\t// custom render plugins (post pass)\n\n\t\trenderPlugins( this.renderPluginsPost, scene, camera );\n\n\n\t\t// Generate mipmap if we're using any kind of mipmap filtering\n\n\t\tif ( renderTarget && renderTarget.generateMipmaps && renderTarget.minFilter !== THREE.NearestFilter && renderTarget.minFilter !== THREE.LinearFilter ) {\n\n\t\t\tupdateRenderTargetMipmap( renderTarget );\n\n\t\t}\n\n\t\t// Ensure depth buffer writing is enabled so it can be cleared on next render\n\n\t\tthis.setDepthTest( true );\n\t\tthis.setDepthWrite( true );\n\n\t\t// _gl.finish();\n\n\t};\n\n\tfunction renderPlugins( plugins, scene, camera ) {\n\n\t\tif ( ! plugins.length ) return;\n\n\t\tfor ( var i = 0, il = plugins.length; i < il; i ++ ) {\n\n\t\t\t// reset state for plugin (to start from clean slate)\n\n\t\t\t_currentProgram = null;\n\t\t\t_currentCamera = null;\n\n\t\t\t_oldBlending = -1;\n\t\t\t_oldDepthTest = -1;\n\t\t\t_oldDepthWrite = -1;\n\t\t\t_oldDoubleSided = -1;\n\t\t\t_oldFlipSided = -1;\n\t\t\t_currentGeometryGroupHash = -1;\n\t\t\t_currentMaterialId = -1;\n\n\t\t\t_lightsNeedUpdate = true;\n\n\t\t\tplugins[ i ].render( scene, camera, _currentWidth, _currentHeight );\n\n\t\t\t// reset state after plugin (anything could have changed)\n\n\t\t\t_currentProgram = null;\n\t\t\t_currentCamera = null;\n\n\t\t\t_oldBlending = -1;\n\t\t\t_oldDepthTest = -1;\n\t\t\t_oldDepthWrite = -1;\n\t\t\t_oldDoubleSided = -1;\n\t\t\t_oldFlipSided = -1;\n\t\t\t_currentGeometryGroupHash = -1;\n\t\t\t_currentMaterialId = -1;\n\n\t\t\t_lightsNeedUpdate = true;\n\n\t\t}\n\n\t};\n\n\tfunction renderObjects ( renderList, reverse, materialType, camera, lights, fog, useBlending, overrideMaterial ) {\n\n\t\tvar webglObject, object, buffer, material, start, end, delta;\n\n\t\tif ( reverse ) {\n\n\t\t\tstart = renderList.length - 1;\n\t\t\tend = -1;\n\t\t\tdelta = -1;\n\n\t\t} else {\n\n\t\t\tstart = 0;\n\t\t\tend = renderList.length;\n\t\t\tdelta = 1;\n\t\t}\n\n\t\tfor ( var i = start; i !== end; i += delta ) {\n\n\t\t\twebglObject = renderList[ i ];\n\n\t\t\tif ( webglObject.render ) {\n\n\t\t\t\tobject = webglObject.object;\n\t\t\t\tbuffer = webglObject.buffer;\n\n\t\t\t\tif ( overrideMaterial ) {\n\n\t\t\t\t\tmaterial = overrideMaterial;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmaterial = webglObject[ materialType ];\n\n\t\t\t\t\tif ( ! material ) continue;\n\n\t\t\t\t\tif ( useBlending ) _this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\n\n\t\t\t\t\t_this.setDepthTest( material.depthTest );\n\t\t\t\t\t_this.setDepthWrite( material.depthWrite );\n\t\t\t\t\tsetPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\n\n\t\t\t\t}\n\n\t\t\t\t_this.setMaterialFaces( material );\n\n\t\t\t\tif ( buffer instanceof THREE.BufferGeometry ) {\n\n\t\t\t\t\t_this.renderBufferDirect( camera, lights, fog, material, buffer, object );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_this.renderBuffer( camera, lights, fog, material, buffer, object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tfunction renderObjectsImmediate ( renderList, materialType, camera, lights, fog, useBlending, overrideMaterial ) {\n\n\t\tvar webglObject, object, material, program;\n\n\t\tfor ( var i = 0, il = renderList.length; i < il; i ++ ) {\n\n\t\t\twebglObject = renderList[ i ];\n\t\t\tobject = webglObject.object;\n\n\t\t\tif ( object.visible ) {\n\n\t\t\t\tif ( overrideMaterial ) {\n\n\t\t\t\t\tmaterial = overrideMaterial;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmaterial = webglObject[ materialType ];\n\n\t\t\t\t\tif ( ! material ) continue;\n\n\t\t\t\t\tif ( useBlending ) _this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\n\n\t\t\t\t\t_this.setDepthTest( material.depthTest );\n\t\t\t\t\t_this.setDepthWrite( material.depthWrite );\n\t\t\t\t\tsetPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\n\n\t\t\t\t}\n\n\t\t\t\t_this.renderImmediateObject( camera, lights, fog, material, object );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tthis.renderImmediateObject = function ( camera, lights, fog, material, object ) {\n\n\t\tvar program = setProgram( camera, lights, fog, material, object );\n\n\t\t_currentGeometryGroupHash = -1;\n\n\t\t_this.setMaterialFaces( material );\n\n\t\tif ( object.immediateRenderCallback ) {\n\n\t\t\tobject.immediateRenderCallback( program, _gl, _frustum );\n\n\t\t} else {\n\n\t\t\tobject.render( function( object ) { _this.renderBufferImmediate( object, program, material ); } );\n\n\t\t}\n\n\t};\n\n\tfunction unrollImmediateBufferMaterial ( globject ) {\n\n\t\tvar object = globject.object,\n\t\t\tmaterial = object.material;\n\n\t\tif ( material.transparent ) {\n\n\t\t\tglobject.transparent = material;\n\t\t\tglobject.opaque = null;\n\n\t\t} else {\n\n\t\t\tglobject.opaque = material;\n\t\t\tglobject.transparent = null;\n\n\t\t}\n\n\t};\n\n\tfunction unrollBufferMaterial ( globject ) {\n\n\t\tvar object = globject.object,\n\t\t\tbuffer = globject.buffer,\n\t\t\tmaterial, materialIndex, meshMaterial;\n\n\t\tmeshMaterial = object.material;\n\n\t\tif ( meshMaterial instanceof THREE.MeshFaceMaterial ) {\n\n\t\t\tmaterialIndex = buffer.materialIndex;\n\n\t\t\tmaterial = meshMaterial.materials[ materialIndex ];\n\n\t\t\tif ( material.transparent ) {\n\n\t\t\t\tglobject.transparent = material;\n\t\t\t\tglobject.opaque = null;\n\n\t\t\t} else {\n\n\t\t\t\tglobject.opaque = material;\n\t\t\t\tglobject.transparent = null;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tmaterial = meshMaterial;\n\n\t\t\tif ( material ) {\n\n\t\t\t\tif ( material.transparent ) {\n\n\t\t\t\t\tglobject.transparent = material;\n\t\t\t\t\tglobject.opaque = null;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tglobject.opaque = material;\n\t\t\t\t\tglobject.transparent = null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\t// Geometry splitting\n\n\tfunction sortFacesByMaterial ( geometry, material ) {\n\n\t\tvar f, fl, face, materialIndex, vertices,\n\t\t\tgroupHash, hash_map = {};\n\n\t\tvar numMorphTargets = geometry.morphTargets.length;\n\t\tvar numMorphNormals = geometry.morphNormals.length;\n\n\t\tvar usesFaceMaterial = material instanceof THREE.MeshFaceMaterial;\n\n\t\tgeometry.geometryGroups = {};\n\n\t\tfor ( f = 0, fl = geometry.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = geometry.faces[ f ];\n\t\t\tmaterialIndex = usesFaceMaterial ? face.materialIndex : 0;\n\n\t\t\tif ( hash_map[ materialIndex ] === undefined ) {\n\n\t\t\t\thash_map[ materialIndex ] = { 'hash': materialIndex, 'counter': 0 };\n\n\t\t\t}\n\n\t\t\tgroupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;\n\n\t\t\tif ( geometry.geometryGroups[ groupHash ] === undefined ) {\n\n\t\t\t\tgeometry.geometryGroups[ groupHash ] = { 'faces3': [], 'faces4': [], 'materialIndex': materialIndex, 'vertices': 0, 'numMorphTargets': numMorphTargets, 'numMorphNormals': numMorphNormals };\n\n\t\t\t}\n\n\t\t\tvertices = face instanceof THREE.Face3 ? 3 : 4;\n\n\t\t\tif ( geometry.geometryGroups[ groupHash ].vertices + vertices > 65535 ) {\n\n\t\t\t\thash_map[ materialIndex ].counter += 1;\n\t\t\t\tgroupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;\n\n\t\t\t\tif ( geometry.geometryGroups[ groupHash ] === undefined ) {\n\n\t\t\t\t\tgeometry.geometryGroups[ groupHash ] = { 'faces3': [], 'faces4': [], 'materialIndex': materialIndex, 'vertices': 0, 'numMorphTargets': numMorphTargets, 'numMorphNormals': numMorphNormals };\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( face instanceof THREE.Face3 ) {\n\n\t\t\t\tgeometry.geometryGroups[ groupHash ].faces3.push( f );\n\n\t\t\t} else {\n\n\t\t\t\tgeometry.geometryGroups[ groupHash ].faces4.push( f );\n\n\t\t\t}\n\n\t\t\tgeometry.geometryGroups[ groupHash ].vertices += vertices;\n\n\t\t}\n\n\t\tgeometry.geometryGroupsList = [];\n\n\t\tfor ( var g in geometry.geometryGroups ) {\n\n\t\t\tgeometry.geometryGroups[ g ].id = _geometryGroupCounter ++;\n\n\t\t\tgeometry.geometryGroupsList.push( geometry.geometryGroups[ g ] );\n\n\t\t}\n\n\t};\n\n\t// Objects refresh\n\n\tthis.initWebGLObjects = function ( scene ) {\n\n\t\tif ( !scene.__webglObjects ) {\n\n\t\t\tscene.__webglObjects = [];\n\t\t\tscene.__webglObjectsImmediate = [];\n\t\t\tscene.__webglSprites = [];\n\t\t\tscene.__webglFlares = [];\n\n\t\t}\n\n\t\twhile ( scene.__objectsAdded.length ) {\n\n\t\t\taddObject( scene.__objectsAdded[ 0 ], scene );\n\t\t\tscene.__objectsAdded.splice( 0, 1 );\n\n\t\t}\n\n\t\twhile ( scene.__objectsRemoved.length ) {\n\n\t\t\tremoveObject( scene.__objectsRemoved[ 0 ], scene );\n\t\t\tscene.__objectsRemoved.splice( 0, 1 );\n\n\t\t}\n\n\t\t// update must be called after objects adding / removal\n\n\t\tfor ( var o = 0, ol = scene.__webglObjects.length; o < ol; o ++ ) {\n\n\t\t\tupdateObject( scene.__webglObjects[ o ].object );\n\n\t\t}\n\n\t};\n\n\t// Objects adding\n\n\tfunction addObject ( object, scene ) {\n\n\t\tvar g, geometry, material, geometryGroup;\n\n\t\tif ( ! object.__webglInit ) {\n\n\t\t\tobject.__webglInit = true;\n\n\t\t\tobject._modelViewMatrix = new THREE.Matrix4();\n\t\t\tobject._normalMatrix = new THREE.Matrix3();\n\n\t\t\tif ( object.geometry !== undefined && object.geometry.__webglInit === undefined ) {\n\n\t\t\t\tobject.geometry.__webglInit = true;\n\t\t\t\tobject.geometry.addEventListener( 'dispose', onGeometryDispose );\n\n\t\t\t}\n\n\t\t\tif ( object instanceof THREE.Mesh ) {\n\n\t\t\t\tgeometry = object.geometry;\n\t\t\t\tmaterial = object.material;\n\n\t\t\t\tif ( geometry instanceof THREE.Geometry ) {\n\n\t\t\t\t\tif ( geometry.geometryGroups === undefined ) {\n\n\t\t\t\t\t\tsortFacesByMaterial( geometry, material );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// create separate VBOs per geometry chunk\n\n\t\t\t\t\tfor ( g in geometry.geometryGroups ) {\n\n\t\t\t\t\t\tgeometryGroup = geometry.geometryGroups[ g ];\n\n\t\t\t\t\t\t// initialise VBO on the first access\n\n\t\t\t\t\t\tif ( ! geometryGroup.__webglVertexBuffer ) {\n\n\t\t\t\t\t\t\tcreateMeshBuffers( geometryGroup );\n\t\t\t\t\t\t\tinitMeshBuffers( geometryGroup, object );\n\n\t\t\t\t\t\t\tgeometry.verticesNeedUpdate = true;\n\t\t\t\t\t\t\tgeometry.morphTargetsNeedUpdate = true;\n\t\t\t\t\t\t\tgeometry.elementsNeedUpdate = true;\n\t\t\t\t\t\t\tgeometry.uvsNeedUpdate = true;\n\t\t\t\t\t\t\tgeometry.normalsNeedUpdate = true;\n\t\t\t\t\t\t\tgeometry.tangentsNeedUpdate = true;\n\t\t\t\t\t\t\tgeometry.colorsNeedUpdate = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\t\t\tinitDirectBuffers( geometry );\n\n\t\t\t\t}\n\n\t\t\t} else if ( object instanceof THREE.Ribbon ) {\n\n\t\t\t\tgeometry = object.geometry;\n\n\t\t\t\tif ( ! geometry.__webglVertexBuffer ) {\n\n\t\t\t\t\tcreateRibbonBuffers( geometry );\n\t\t\t\t\tinitRibbonBuffers( geometry, object );\n\n\t\t\t\t\tgeometry.verticesNeedUpdate = true;\n\t\t\t\t\tgeometry.colorsNeedUpdate = true;\n\t\t\t\t\tgeometry.normalsNeedUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t} else if ( object instanceof THREE.Line ) {\n\n\t\t\t\tgeometry = object.geometry;\n\n\t\t\t\tif ( ! geometry.__webglVertexBuffer ) {\n\n\t\t\t\t\tif ( geometry instanceof THREE.Geometry ) {\n\n            createLineBuffers( geometry );\n            initLineBuffers( geometry, object );\n\n            geometry.verticesNeedUpdate = true;\n            geometry.colorsNeedUpdate = true;\n            geometry.lineDistancesNeedUpdate = true;\n\n          } else if ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\t\t\t\tinitDirectBuffers( geometry );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( object instanceof THREE.ParticleSystem ) {\n\n\t\t\t\tgeometry = object.geometry;\n\n\t\t\t\tif ( ! geometry.__webglVertexBuffer ) {\n\n\t\t\t\t\tif ( geometry instanceof THREE.Geometry ) {\n\n\t\t\t\t\t\tcreateParticleBuffers( geometry );\n\t\t\t\t\t\tinitParticleBuffers( geometry, object );\n\n\t\t\t\t\t\tgeometry.verticesNeedUpdate = true;\n\t\t\t\t\t\tgeometry.colorsNeedUpdate = true;\n\n\t\t\t\t\t} else if ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\t\t\t\tinitDirectBuffers( geometry );\n\n\t\t\t\t\t}\n\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( ! object.__webglActive ) {\n\n\t\t\tif ( object instanceof THREE.Mesh ) {\n\n\t\t\t\tgeometry = object.geometry;\n\n\t\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\t\t\taddBuffer( scene.__webglObjects, geometry, object );\n\n\t\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\n\n\t\t\t\t\tfor ( g in geometry.geometryGroups ) {\n\n\t\t\t\t\t\tgeometryGroup = geometry.geometryGroups[ g ];\n\n\t\t\t\t\t\taddBuffer( scene.__webglObjects, geometryGroup, object );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( object instanceof THREE.Ribbon ||\n\t\t\t\t\t\tobject instanceof THREE.Line ||\n\t\t\t\t\t\tobject instanceof THREE.ParticleSystem ) {\n\n\t\t\t\tgeometry = object.geometry;\n\t\t\t\taddBuffer( scene.__webglObjects, geometry, object );\n\n\t\t\t} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {\n\n\t\t\t\taddBufferImmediate( scene.__webglObjectsImmediate, object );\n\n\t\t\t} else if ( object instanceof THREE.Sprite ) {\n\n\t\t\t\tscene.__webglSprites.push( object );\n\n\t\t\t} else if ( object instanceof THREE.LensFlare ) {\n\n\t\t\t\tscene.__webglFlares.push( object );\n\n\t\t\t}\n\n\t\t\tobject.__webglActive = true;\n\n\t\t}\n\n\t};\n\n\tfunction addBuffer ( objlist, buffer, object ) {\n\n\t\tobjlist.push(\n\t\t\t{\n\t\t\t\tbuffer: buffer,\n\t\t\t\tobject: object,\n\t\t\t\topaque: null,\n\t\t\t\ttransparent: null\n\t\t\t}\n\t\t);\n\n\t};\n\n\tfunction addBufferImmediate ( objlist, object ) {\n\n\t\tobjlist.push(\n\t\t\t{\n\t\t\t\tobject: object,\n\t\t\t\topaque: null,\n\t\t\t\ttransparent: null\n\t\t\t}\n\t\t);\n\n\t};\n\n\t// Objects updates\n\n\tfunction updateObject ( object ) {\n\n\t\tvar geometry = object.geometry,\n\t\t\tgeometryGroup, customAttributesDirty, material;\n\n\t\tif ( object instanceof THREE.Mesh ) {\n\n\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\t\tif ( geometry.verticesNeedUpdate || geometry.elementsNeedUpdate ||\n\t\t\t\t\t geometry.uvsNeedUpdate || geometry.normalsNeedUpdate ||\n\t\t\t\t\t geometry.colorsNeedUpdate || geometry.tangentsNeedUpdate ) {\n\n\t\t\t\t\tsetDirectBuffers( geometry, _gl.DYNAMIC_DRAW, !geometry.dynamic );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.verticesNeedUpdate = false;\n\t\t\t\tgeometry.elementsNeedUpdate = false;\n\t\t\t\tgeometry.uvsNeedUpdate = false;\n\t\t\t\tgeometry.normalsNeedUpdate = false;\n\t\t\t\tgeometry.colorsNeedUpdate = false;\n\t\t\t\tgeometry.tangentsNeedUpdate = false;\n\n\t\t\t} else {\n\n\t\t\t\t// check all geometry groups\n\n\t\t\t\tfor( var i = 0, il = geometry.geometryGroupsList.length; i < il; i ++ ) {\n\n\t\t\t\t\tgeometryGroup = geometry.geometryGroupsList[ i ];\n\n\t\t\t\t\tmaterial = getBufferMaterial( object, geometryGroup );\n\n\t\t\t\t\tif ( geometry.buffersNeedUpdate ) {\n\n\t\t\t\t\t\tinitMeshBuffers( geometryGroup, object );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcustomAttributesDirty = material.attributes && areCustomAttributesDirty( material );\n\n\t\t\t\t\tif ( geometry.verticesNeedUpdate || geometry.morphTargetsNeedUpdate || geometry.elementsNeedUpdate ||\n\t\t\t\t\t\t geometry.uvsNeedUpdate || geometry.normalsNeedUpdate ||\n\t\t\t\t\t\t geometry.colorsNeedUpdate || geometry.tangentsNeedUpdate || customAttributesDirty ) {\n\n\t\t\t\t\t\tsetMeshBuffers( geometryGroup, object, _gl.DYNAMIC_DRAW, !geometry.dynamic, material );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.verticesNeedUpdate = false;\n\t\t\t\tgeometry.morphTargetsNeedUpdate = false;\n\t\t\t\tgeometry.elementsNeedUpdate = false;\n\t\t\t\tgeometry.uvsNeedUpdate = false;\n\t\t\t\tgeometry.normalsNeedUpdate = false;\n\t\t\t\tgeometry.colorsNeedUpdate = false;\n\t\t\t\tgeometry.tangentsNeedUpdate = false;\n\n\t\t\t\tgeometry.buffersNeedUpdate = false;\n\n\t\t\t\tmaterial.attributes && clearCustomAttributes( material );\n\n\t\t\t}\n\n\t\t} else if ( object instanceof THREE.Ribbon ) {\n\n\t\t\tmaterial = getBufferMaterial( object, geometry );\n\n\t\t\tcustomAttributesDirty = material.attributes && areCustomAttributesDirty( material );\n\n\t\t\tif ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || geometry.normalsNeedUpdate || customAttributesDirty ) {\n\n\t\t\t\tsetRibbonBuffers( geometry, _gl.DYNAMIC_DRAW );\n\n\t\t\t}\n\n\t\t\tgeometry.verticesNeedUpdate = false;\n\t\t\tgeometry.colorsNeedUpdate = false;\n\t\t\tgeometry.normalsNeedUpdate = false;\n\n\t\t\tmaterial.attributes && clearCustomAttributes( material );\n\n\t\t} else if ( object instanceof THREE.Line ) {\n\n      if ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\t\tif ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate ) {\n\n\t\t\t\t\tsetDirectBuffers( geometry, _gl.DYNAMIC_DRAW, !geometry.dynamic );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.verticesNeedUpdate = false;\n\t\t\t\tgeometry.colorsNeedUpdate = false;\n\n\t\t\t} else {\n\n        material = getBufferMaterial( object, geometry );\n\n        customAttributesDirty = material.attributes && areCustomAttributesDirty( material );\n\n        if ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || geometry.lineDistancesNeedUpdate || customAttributesDirty ) {\n\n          setLineBuffers( geometry, _gl.DYNAMIC_DRAW );\n\n        }\n\n        geometry.verticesNeedUpdate = false;\n        geometry.colorsNeedUpdate = false;\n        geometry.lineDistancesNeedUpdate = false;\n\n        material.attributes && clearCustomAttributes( material );\n\n      }\n\n\t\t} else if ( object instanceof THREE.ParticleSystem ) {\n\n\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\t\tif ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate ) {\n\n\t\t\t\t\tsetDirectBuffers( geometry, _gl.DYNAMIC_DRAW, !geometry.dynamic );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.verticesNeedUpdate = false;\n\t\t\t\tgeometry.colorsNeedUpdate = false;\n\n\t\t\t} else {\n\n\t\t\t\tmaterial = getBufferMaterial( object, geometry );\n\n\t\t\t\tcustomAttributesDirty = material.attributes && areCustomAttributesDirty( material );\n\n\t\t\t\tif ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || object.sortParticles || customAttributesDirty ) {\n\n\t\t\t\t\tsetParticleBuffers( geometry, _gl.DYNAMIC_DRAW, object );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.verticesNeedUpdate = false;\n\t\t\t\tgeometry.colorsNeedUpdate = false;\n\n\t\t\t\tmaterial.attributes && clearCustomAttributes( material );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\t// Objects updates - custom attributes check\n\n\tfunction areCustomAttributesDirty ( material ) {\n\n\t\tfor ( var a in material.attributes ) {\n\n\t\t\tif ( material.attributes[ a ].needsUpdate ) return true;\n\n\t\t}\n\n\t\treturn false;\n\n\t};\n\n\tfunction clearCustomAttributes ( material ) {\n\n\t\tfor ( var a in material.attributes ) {\n\n\t\t\tmaterial.attributes[ a ].needsUpdate = false;\n\n\t\t}\n\n\t};\n\n\t// Objects removal\n\n\tfunction removeObject ( object, scene ) {\n\n\t\tif ( object instanceof THREE.Mesh  ||\n\t\t\t object instanceof THREE.ParticleSystem ||\n\t\t\t object instanceof THREE.Ribbon ||\n\t\t\t object instanceof THREE.Line ) {\n\n\t\t\tremoveInstances( scene.__webglObjects, object );\n\n\t\t} else if ( object instanceof THREE.Sprite ) {\n\n\t\t\tremoveInstancesDirect( scene.__webglSprites, object );\n\n\t\t} else if ( object instanceof THREE.LensFlare ) {\n\n\t\t\tremoveInstancesDirect( scene.__webglFlares, object );\n\n\t\t} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {\n\n\t\t\tremoveInstances( scene.__webglObjectsImmediate, object );\n\n\t\t}\n\n\t\tobject.__webglActive = false;\n\n\t};\n\n\tfunction removeInstances ( objlist, object ) {\n\n\t\tfor ( var o = objlist.length - 1; o >= 0; o -- ) {\n\n\t\t\tif ( objlist[ o ].object === object ) {\n\n\t\t\t\tobjlist.splice( o, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tfunction removeInstancesDirect ( objlist, object ) {\n\n\t\tfor ( var o = objlist.length - 1; o >= 0; o -- ) {\n\n\t\t\tif ( objlist[ o ] === object ) {\n\n\t\t\t\tobjlist.splice( o, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\t// Materials\n\n\tthis.initMaterial = function ( material, lights, fog, object ) {\n\n\t\tmaterial.addEventListener( 'dispose', onMaterialDispose );\n\n\t\tvar u, a, identifiers, i, parameters, maxLightCount, maxBones, maxShadows, shaderID;\n\n\t\tif ( material instanceof THREE.MeshDepthMaterial ) {\n\n\t\t\tshaderID = 'depth';\n\n\t\t} else if ( material instanceof THREE.MeshNormalMaterial ) {\n\n\t\t\tshaderID = 'normal';\n\n\t\t} else if ( material instanceof THREE.MeshBasicMaterial ) {\n\n\t\t\tshaderID = 'basic';\n\n\t\t} else if ( material instanceof THREE.MeshLambertMaterial ) {\n\n\t\t\tshaderID = 'lambert';\n\n\t\t} else if ( material instanceof THREE.MeshPhongMaterial ) {\n\n\t\t\tshaderID = 'phong';\n\n\t\t} else if ( material instanceof THREE.LineBasicMaterial ) {\n\n\t\t\tshaderID = 'basic';\n\n\t\t} else if ( material instanceof THREE.LineDashedMaterial ) {\n\n\t\t\tshaderID = 'dashed';\n\n\t\t} else if ( material instanceof THREE.ParticleBasicMaterial ) {\n\n\t\t\tshaderID = 'particle_basic';\n\n\t\t}\n\n\t\tif ( shaderID ) {\n\n\t\t\tsetMaterialShaders( material, THREE.ShaderLib[ shaderID ] );\n\n\t\t}\n\n\t\t// heuristics to create shader parameters according to lights in the scene\n\t\t// (not to blow over maxLights budget)\n\n\t\tmaxLightCount = allocateLights( lights );\n\n\t\tmaxShadows = allocateShadows( lights );\n\n\t\tmaxBones = allocateBones( object );\n\n\t\tparameters = {\n\n\t\t\tmap: !!material.map,\n\t\t\tenvMap: !!material.envMap,\n\t\t\tlightMap: !!material.lightMap,\n\t\t\tbumpMap: !!material.bumpMap,\n\t\t\tnormalMap: !!material.normalMap,\n\t\t\tspecularMap: !!material.specularMap,\n\n\t\t\tvertexColors: material.vertexColors,\n\n\t\t\tfog: fog,\n\t\t\tuseFog: material.fog,\n\t\t\tfogExp: fog instanceof THREE.FogExp2,\n\n\t\t\tsizeAttenuation: material.sizeAttenuation,\n\n\t\t\tskinning: material.skinning,\n\t\t\tmaxBones: maxBones,\n\t\t\tuseVertexTexture: _supportsBoneTextures && object && object.useVertexTexture,\n\t\t\tboneTextureWidth: object && object.boneTextureWidth,\n\t\t\tboneTextureHeight: object && object.boneTextureHeight,\n\n\t\t\tmorphTargets: material.morphTargets,\n\t\t\tmorphNormals: material.morphNormals,\n\t\t\tmaxMorphTargets: this.maxMorphTargets,\n\t\t\tmaxMorphNormals: this.maxMorphNormals,\n\n\t\t\tmaxDirLights: maxLightCount.directional,\n\t\t\tmaxPointLights: maxLightCount.point,\n\t\t\tmaxSpotLights: maxLightCount.spot,\n\t\t\tmaxHemiLights: maxLightCount.hemi,\n\n\t\t\tmaxShadows: maxShadows,\n\t\t\tshadowMapEnabled: this.shadowMapEnabled && object.receiveShadow,\n\t\t\tshadowMapType: this.shadowMapType,\n\t\t\tshadowMapDebug: this.shadowMapDebug,\n\t\t\tshadowMapCascade: this.shadowMapCascade,\n\n\t\t\talphaTest: material.alphaTest,\n\t\t\tmetal: material.metal,\n\t\t\tperPixel: material.perPixel,\n\t\t\twrapAround: material.wrapAround,\n\t\t\tdoubleSided: material.side === THREE.DoubleSide,\n\t\t\tflipSided: material.side === THREE.BackSide\n\n\t\t};\n\n\t\tmaterial.program = buildProgram( shaderID, material.fragmentShader, material.vertexShader, material.uniforms, material.attributes, material.defines, parameters );\n\n\t\tvar attributes = material.program.attributes;\n\n\t\tif ( material.morphTargets ) {\n\n\t\t\tmaterial.numSupportedMorphTargets = 0;\n\n\t\t\tvar id, base = \"morphTarget\";\n\n\t\t\tfor ( i = 0; i < this.maxMorphTargets; i ++ ) {\n\n\t\t\t\tid = base + i;\n\n\t\t\t\tif ( attributes[ id ] >= 0 ) {\n\n\t\t\t\t\tmaterial.numSupportedMorphTargets ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( material.morphNormals ) {\n\n\t\t\tmaterial.numSupportedMorphNormals = 0;\n\n\t\t\tvar id, base = \"morphNormal\";\n\n\t\t\tfor ( i = 0; i < this.maxMorphNormals; i ++ ) {\n\n\t\t\t\tid = base + i;\n\n\t\t\t\tif ( attributes[ id ] >= 0 ) {\n\n\t\t\t\t\tmaterial.numSupportedMorphNormals ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tmaterial.uniformsList = [];\n\n\t\tfor ( u in material.uniforms ) {\n\n\t\t\tmaterial.uniformsList.push( [ material.uniforms[ u ], u ] );\n\n\t\t}\n\n\t};\n\n\tfunction setMaterialShaders( material, shaders ) {\n\n\t\tmaterial.uniforms = THREE.UniformsUtils.clone( shaders.uniforms );\n\t\tmaterial.vertexShader = shaders.vertexShader;\n\t\tmaterial.fragmentShader = shaders.fragmentShader;\n\n\t};\n\n\tfunction setProgram( camera, lights, fog, material, object ) {\n\n\t\t_usedTextureUnits = 0;\n\n\t\tif ( material.needsUpdate ) {\n\n\t\t\tif ( material.program ) deallocateMaterial( material );\n\n\t\t\t_this.initMaterial( material, lights, fog, object );\n\t\t\tmaterial.needsUpdate = false;\n\n\t\t}\n\n\t\tif ( material.morphTargets ) {\n\n\t\t\tif ( ! object.__webglMorphTargetInfluences ) {\n\n\t\t\t\tobject.__webglMorphTargetInfluences = new Float32Array( _this.maxMorphTargets );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar refreshMaterial = false;\n\n\t\tvar program = material.program,\n\t\t\tp_uniforms = program.uniforms,\n\t\t\tm_uniforms = material.uniforms;\n\n\t\tif ( program !== _currentProgram ) {\n\n\t\t\t_gl.useProgram( program );\n\t\t\t_currentProgram = program;\n\n\t\t\trefreshMaterial = true;\n\n\t\t}\n\n\t\tif ( material.id !== _currentMaterialId ) {\n\n\t\t\t_currentMaterialId = material.id;\n\t\t\trefreshMaterial = true;\n\n\t\t}\n\n\t\tif ( refreshMaterial || camera !== _currentCamera ) {\n\n\t\t\t_gl.uniformMatrix4fv( p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\n\n\t\t\tif ( camera !== _currentCamera ) _currentCamera = camera;\n\n\t\t}\n\n\t\t// skinning uniforms must be set even if material didn't change\n\t\t// auto-setting of texture unit for bone texture must go before other textures\n\t\t// not sure why, but otherwise weird things happen\n\n\t\tif ( material.skinning ) {\n\n\t\t\tif ( _supportsBoneTextures && object.useVertexTexture ) {\n\n\t\t\t\tif ( p_uniforms.boneTexture !== null ) {\n\n\t\t\t\t\tvar textureUnit = getTextureUnit();\n\n\t\t\t\t\t_gl.uniform1i( p_uniforms.boneTexture, textureUnit );\n\t\t\t\t\t_this.setTexture( object.boneTexture, textureUnit );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( p_uniforms.boneGlobalMatrices !== null ) {\n\n\t\t\t\t\t_gl.uniformMatrix4fv( p_uniforms.boneGlobalMatrices, false, object.boneMatrices );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( refreshMaterial ) {\n\n\t\t\t// refresh uniforms common to several materials\n\n\t\t\tif ( fog && material.fog ) {\n\n\t\t\t\trefreshUniformsFog( m_uniforms, fog );\n\n\t\t\t}\n\n\t\t\tif ( material instanceof THREE.MeshPhongMaterial ||\n\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\n\t\t\t\t material.lights ) {\n\n\t\t\t\tif ( _lightsNeedUpdate ) {\n\n\t\t\t\t\tsetupLights( program, lights );\n\t\t\t\t\t_lightsNeedUpdate = false;\n\n\t\t\t\t}\n\n\t\t\t\trefreshUniformsLights( m_uniforms, _lights );\n\n\t\t\t}\n\n\t\t\tif ( material instanceof THREE.MeshBasicMaterial ||\n\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\n\t\t\t\t material instanceof THREE.MeshPhongMaterial ) {\n\n\t\t\t\trefreshUniformsCommon( m_uniforms, material );\n\n\t\t\t}\n\n\t\t\t// refresh single material specific uniforms\n\n\t\t\tif ( material instanceof THREE.LineBasicMaterial ) {\n\n\t\t\t\trefreshUniformsLine( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.LineDashedMaterial ) {\n\n\t\t\t\trefreshUniformsLine( m_uniforms, material );\n\t\t\t\trefreshUniformsDash( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.ParticleBasicMaterial ) {\n\n\t\t\t\trefreshUniformsParticle( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.MeshPhongMaterial ) {\n\n\t\t\t\trefreshUniformsPhong( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.MeshLambertMaterial ) {\n\n\t\t\t\trefreshUniformsLambert( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.MeshDepthMaterial ) {\n\n\t\t\t\tm_uniforms.mNear.value = camera.near;\n\t\t\t\tm_uniforms.mFar.value = camera.far;\n\t\t\t\tm_uniforms.opacity.value = material.opacity;\n\n\t\t\t} else if ( material instanceof THREE.MeshNormalMaterial ) {\n\n\t\t\t\tm_uniforms.opacity.value = material.opacity;\n\n\t\t\t}\n\n\t\t\tif ( object.receiveShadow && ! material._shadowPass ) {\n\n\t\t\t\trefreshUniformsShadow( m_uniforms, lights );\n\n\t\t\t}\n\n\t\t\t// load common uniforms\n\n\t\t\tloadUniformsGeneric( program, material.uniformsList );\n\n\t\t\t// load material specific uniforms\n\t\t\t// (shader material also gets them for the sake of genericity)\n\n\t\t\tif ( material instanceof THREE.ShaderMaterial ||\n\t\t\t\t material instanceof THREE.MeshPhongMaterial ||\n\t\t\t\t material.envMap ) {\n\n\t\t\t\tif ( p_uniforms.cameraPosition !== null ) {\n\n\t\t\t\t\t_vector3.getPositionFromMatrix( camera.matrixWorld );\n\t\t\t\t\t_gl.uniform3f( p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( material instanceof THREE.MeshPhongMaterial ||\n\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\n\t\t\t\t material instanceof THREE.ShaderMaterial ||\n\t\t\t\t material.skinning ) {\n\n\t\t\t\tif ( p_uniforms.viewMatrix !== null ) {\n\n\t\t\t\t\t_gl.uniformMatrix4fv( p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tloadUniformsMatrices( p_uniforms, object );\n\n\t\tif ( p_uniforms.modelMatrix !== null ) {\n\n\t\t\t_gl.uniformMatrix4fv( p_uniforms.modelMatrix, false, object.matrixWorld.elements );\n\n\t\t}\n\n\t\treturn program;\n\n\t};\n\n\t// Uniforms (refresh uniforms objects)\n\n\tfunction refreshUniformsCommon ( uniforms, material ) {\n\n\t\tuniforms.opacity.value = material.opacity;\n\n\t\tif ( _this.gammaInput ) {\n\n\t\t\tuniforms.diffuse.value.copyGammaToLinear( material.color );\n\n\t\t} else {\n\n\t\t\tuniforms.diffuse.value = material.color;\n\n\t\t}\n\n\t\tuniforms.map.value = material.map;\n\t\tuniforms.lightMap.value = material.lightMap;\n\t\tuniforms.specularMap.value = material.specularMap;\n\n\t\tif ( material.bumpMap ) {\n\n\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\n\t\t}\n\n\t\tif ( material.normalMap ) {\n\n\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\n\t\t}\n\n\t\t// uv repeat and offset setting priorities\n\t\t//\t1. color map\n\t\t//\t2. specular map\n\t\t//\t3. normal map\n\t\t//\t4. bump map\n\n\t\tvar uvScaleMap;\n\n\t\tif ( material.map ) {\n\n\t\t\tuvScaleMap = material.map;\n\n\t\t} else if ( material.specularMap ) {\n\n\t\t\tuvScaleMap = material.specularMap;\n\n\t\t} else if ( material.normalMap ) {\n\n\t\t\tuvScaleMap = material.normalMap;\n\n\t\t} else if ( material.bumpMap ) {\n\n\t\t\tuvScaleMap = material.bumpMap;\n\n\t\t}\n\n\t\tif ( uvScaleMap !== undefined ) {\n\n\t\t\tvar offset = uvScaleMap.offset;\n\t\t\tvar repeat = uvScaleMap.repeat;\n\n\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\n\n\t\t}\n\n\t\tuniforms.envMap.value = material.envMap;\n\t\tuniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : -1;\n\n\t\tif ( _this.gammaInput ) {\n\n\t\t\t//uniforms.reflectivity.value = material.reflectivity * material.reflectivity;\n\t\t\tuniforms.reflectivity.value = material.reflectivity;\n\n\t\t} else {\n\n\t\t\tuniforms.reflectivity.value = material.reflectivity;\n\n\t\t}\n\n\t\tuniforms.refractionRatio.value = material.refractionRatio;\n\t\tuniforms.combine.value = material.combine;\n\t\tuniforms.useRefract.value = material.envMap && material.envMap.mapping instanceof THREE.CubeRefractionMapping;\n\n\t};\n\n\tfunction refreshUniformsLine ( uniforms, material ) {\n\n\t\tuniforms.diffuse.value = material.color;\n\t\tuniforms.opacity.value = material.opacity;\n\n\t};\n\n\tfunction refreshUniformsDash ( uniforms, material ) {\n\n\t\tuniforms.dashSize.value = material.dashSize;\n\t\tuniforms.totalSize.value = material.dashSize + material.gapSize;\n\t\tuniforms.scale.value = material.scale;\n\n\t};\n\n\tfunction refreshUniformsParticle ( uniforms, material ) {\n\n\t\tuniforms.psColor.value = material.color;\n\t\tuniforms.opacity.value = material.opacity;\n\t\tuniforms.size.value = material.size;\n\t\tuniforms.scale.value = _canvas.height / 2.0; // TODO: Cache this.\n\n\t\tuniforms.map.value = material.map;\n\n\t};\n\n\tfunction refreshUniformsFog ( uniforms, fog ) {\n\n\t\tuniforms.fogColor.value = fog.color;\n\n\t\tif ( fog instanceof THREE.Fog ) {\n\n\t\t\tuniforms.fogNear.value = fog.near;\n\t\t\tuniforms.fogFar.value = fog.far;\n\n\t\t} else if ( fog instanceof THREE.FogExp2 ) {\n\n\t\t\tuniforms.fogDensity.value = fog.density;\n\n\t\t}\n\n\t};\n\n\tfunction refreshUniformsPhong ( uniforms, material ) {\n\n\t\tuniforms.shininess.value = material.shininess;\n\n\t\tif ( _this.gammaInput ) {\n\n\t\t\tuniforms.ambient.value.copyGammaToLinear( material.ambient );\n\t\t\tuniforms.emissive.value.copyGammaToLinear( material.emissive );\n\t\t\tuniforms.specular.value.copyGammaToLinear( material.specular );\n\n\t\t} else {\n\n\t\t\tuniforms.ambient.value = material.ambient;\n\t\t\tuniforms.emissive.value = material.emissive;\n\t\t\tuniforms.specular.value = material.specular;\n\n\t\t}\n\n\t\tif ( material.wrapAround ) {\n\n\t\t\tuniforms.wrapRGB.value.copy( material.wrapRGB );\n\n\t\t}\n\n\t};\n\n\tfunction refreshUniformsLambert ( uniforms, material ) {\n\n\t\tif ( _this.gammaInput ) {\n\n\t\t\tuniforms.ambient.value.copyGammaToLinear( material.ambient );\n\t\t\tuniforms.emissive.value.copyGammaToLinear( material.emissive );\n\n\t\t} else {\n\n\t\t\tuniforms.ambient.value = material.ambient;\n\t\t\tuniforms.emissive.value = material.emissive;\n\n\t\t}\n\n\t\tif ( material.wrapAround ) {\n\n\t\t\tuniforms.wrapRGB.value.copy( material.wrapRGB );\n\n\t\t}\n\n\t};\n\n\tfunction refreshUniformsLights ( uniforms, lights ) {\n\n\t\tuniforms.ambientLightColor.value = lights.ambient;\n\n\t\tuniforms.directionalLightColor.value = lights.directional.colors;\n\t\tuniforms.directionalLightDirection.value = lights.directional.positions;\n\n\t\tuniforms.pointLightColor.value = lights.point.colors;\n\t\tuniforms.pointLightPosition.value = lights.point.positions;\n\t\tuniforms.pointLightDistance.value = lights.point.distances;\n\n\t\tuniforms.spotLightColor.value = lights.spot.colors;\n\t\tuniforms.spotLightPosition.value = lights.spot.positions;\n\t\tuniforms.spotLightDistance.value = lights.spot.distances;\n\t\tuniforms.spotLightDirection.value = lights.spot.directions;\n\t\tuniforms.spotLightAngleCos.value = lights.spot.anglesCos;\n\t\tuniforms.spotLightExponent.value = lights.spot.exponents;\n\n\t\tuniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;\n\t\tuniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;\n\t\tuniforms.hemisphereLightDirection.value = lights.hemi.positions;\n\n\t};\n\n\tfunction refreshUniformsShadow ( uniforms, lights ) {\n\n\t\tif ( uniforms.shadowMatrix ) {\n\n\t\t\tvar j = 0;\n\n\t\t\tfor ( var i = 0, il = lights.length; i < il; i ++ ) {\n\n\t\t\t\tvar light = lights[ i ];\n\n\t\t\t\tif ( ! light.castShadow ) continue;\n\n\t\t\t\tif ( light instanceof THREE.SpotLight || ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) ) {\n\n\t\t\t\t\tuniforms.shadowMap.value[ j ] = light.shadowMap;\n\t\t\t\t\tuniforms.shadowMapSize.value[ j ] = light.shadowMapSize;\n\n\t\t\t\t\tuniforms.shadowMatrix.value[ j ] = light.shadowMatrix;\n\n\t\t\t\t\tuniforms.shadowDarkness.value[ j ] = light.shadowDarkness;\n\t\t\t\t\tuniforms.shadowBias.value[ j ] = light.shadowBias;\n\n\t\t\t\t\tj ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\t// Uniforms (load to GPU)\n\n\tfunction loadUniformsMatrices ( uniforms, object ) {\n\n\t\t_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, object._modelViewMatrix.elements );\n\n\t\tif ( uniforms.normalMatrix ) {\n\n\t\t\t_gl.uniformMatrix3fv( uniforms.normalMatrix, false, object._normalMatrix.elements );\n\n\t\t}\n\n\t};\n\n\tfunction getTextureUnit() {\n\n\t\tvar textureUnit = _usedTextureUnits;\n\n\t\tif ( textureUnit >= _maxTextures ) {\n\n\t\t\tconsole.warn( \"WebGLRenderer: trying to use \" + textureUnit + \" texture units while this GPU supports only \" + _maxTextures );\n\n\t\t}\n\n\t\t_usedTextureUnits += 1;\n\n\t\treturn textureUnit;\n\n\t};\n\n\tfunction loadUniformsGeneric ( program, uniforms ) {\n\n\t\tvar uniform, value, type, location, texture, textureUnit, i, il, j, jl, offset;\n\n\t\tfor ( j = 0, jl = uniforms.length; j < jl; j ++ ) {\n\n\t\t\tlocation = program.uniforms[ uniforms[ j ][ 1 ] ];\n\t\t\tif ( !location ) continue;\n\n\t\t\tuniform = uniforms[ j ][ 0 ];\n\n\t\t\ttype = uniform.type;\n\t\t\tvalue = uniform.value;\n\n\t\t\tif ( type === \"i\" ) { // single integer\n\n\t\t\t\t_gl.uniform1i( location, value );\n\n\t\t\t} else if ( type === \"f\" ) { // single float\n\n\t\t\t\t_gl.uniform1f( location, value );\n\n\t\t\t} else if ( type === \"v2\" ) { // single THREE.Vector2\n\n\t\t\t\t_gl.uniform2f( location, value.x, value.y );\n\n\t\t\t} else if ( type === \"v3\" ) { // single THREE.Vector3\n\n\t\t\t\t_gl.uniform3f( location, value.x, value.y, value.z );\n\n\t\t\t} else if ( type === \"v4\" ) { // single THREE.Vector4\n\n\t\t\t\t_gl.uniform4f( location, value.x, value.y, value.z, value.w );\n\n\t\t\t} else if ( type === \"c\" ) { // single THREE.Color\n\n\t\t\t\t_gl.uniform3f( location, value.r, value.g, value.b );\n\n\t\t\t} else if ( type === \"iv1\" ) { // flat array of integers (JS or typed array)\n\n\t\t\t\t_gl.uniform1iv( location, value );\n\n\t\t\t} else if ( type === \"iv\" ) { // flat array of integers with 3 x N size (JS or typed array)\n\n\t\t\t\t_gl.uniform3iv( location, value );\n\n\t\t\t} else if ( type === \"fv1\" ) { // flat array of floats (JS or typed array)\n\n\t\t\t\t_gl.uniform1fv( location, value );\n\n\t\t\t} else if ( type === \"fv\" ) { // flat array of floats with 3 x N size (JS or typed array)\n\n\t\t\t\t_gl.uniform3fv( location, value );\n\n\t\t\t} else if ( type === \"v2v\" ) { // array of THREE.Vector2\n\n\t\t\t\tif ( uniform._array === undefined ) {\n\n\t\t\t\t\tuniform._array = new Float32Array( 2 * value.length );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( i = 0, il = value.length; i < il; i ++ ) {\n\n\t\t\t\t\toffset = i * 2;\n\n\t\t\t\t\tuniform._array[ offset ] \t = value[ i ].x;\n\t\t\t\t\tuniform._array[ offset + 1 ] = value[ i ].y;\n\n\t\t\t\t}\n\n\t\t\t\t_gl.uniform2fv( location, uniform._array );\n\n\t\t\t} else if ( type === \"v3v\" ) { // array of THREE.Vector3\n\n\t\t\t\tif ( uniform._array === undefined ) {\n\n\t\t\t\t\tuniform._array = new Float32Array( 3 * value.length );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( i = 0, il = value.length; i < il; i ++ ) {\n\n\t\t\t\t\toffset = i * 3;\n\n\t\t\t\t\tuniform._array[ offset ] \t = value[ i ].x;\n\t\t\t\t\tuniform._array[ offset + 1 ] = value[ i ].y;\n\t\t\t\t\tuniform._array[ offset + 2 ] = value[ i ].z;\n\n\t\t\t\t}\n\n\t\t\t\t_gl.uniform3fv( location, uniform._array );\n\n\t\t\t} else if ( type === \"v4v\" ) { // array of THREE.Vector4\n\n\t\t\t\tif ( uniform._array === undefined ) {\n\n\t\t\t\t\tuniform._array = new Float32Array( 4 * value.length );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( i = 0, il = value.length; i < il; i ++ ) {\n\n\t\t\t\t\toffset = i * 4;\n\n\t\t\t\t\tuniform._array[ offset ] \t = value[ i ].x;\n\t\t\t\t\tuniform._array[ offset + 1 ] = value[ i ].y;\n\t\t\t\t\tuniform._array[ offset + 2 ] = value[ i ].z;\n\t\t\t\t\tuniform._array[ offset + 3 ] = value[ i ].w;\n\n\t\t\t\t}\n\n\t\t\t\t_gl.uniform4fv( location, uniform._array );\n\n\t\t\t} else if ( type === \"m4\") { // single THREE.Matrix4\n\n\t\t\t\tif ( uniform._array === undefined ) {\n\n\t\t\t\t\tuniform._array = new Float32Array( 16 );\n\n\t\t\t\t}\n\n\t\t\t\tvalue.flattenToArray( uniform._array );\n\t\t\t\t_gl.uniformMatrix4fv( location, false, uniform._array );\n\n\t\t\t} else if ( type === \"m4v\" ) { // array of THREE.Matrix4\n\n\t\t\t\tif ( uniform._array === undefined ) {\n\n\t\t\t\t\tuniform._array = new Float32Array( 16 * value.length );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( i = 0, il = value.length; i < il; i ++ ) {\n\n\t\t\t\t\tvalue[ i ].flattenToArrayOffset( uniform._array, i * 16 );\n\n\t\t\t\t}\n\n\t\t\t\t_gl.uniformMatrix4fv( location, false, uniform._array );\n\n\t\t\t} else if ( type === \"t\" ) { // single THREE.Texture (2d or cube)\n\n\t\t\t\ttexture = value;\n\t\t\t\ttextureUnit = getTextureUnit();\n\n\t\t\t\t_gl.uniform1i( location, textureUnit );\n\n\t\t\t\tif ( !texture ) continue;\n\n\t\t\t\tif ( texture.image instanceof Array && texture.image.length === 6 ) {\n\n\t\t\t\t\tsetCubeTexture( texture, textureUnit );\n\n\t\t\t\t} else if ( texture instanceof THREE.WebGLRenderTargetCube ) {\n\n\t\t\t\t\tsetCubeTextureDynamic( texture, textureUnit );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_this.setTexture( texture, textureUnit );\n\n\t\t\t\t}\n\n\t\t\t} else if ( type === \"tv\" ) { // array of THREE.Texture (2d)\n\n\t\t\t\tif ( uniform._array === undefined ) {\n\n\t\t\t\t\tuniform._array = [];\n\n\t\t\t\t}\n\n\t\t\t\tfor( i = 0, il = uniform.value.length; i < il; i ++ ) {\n\n\t\t\t\t\tuniform._array[ i ] = getTextureUnit();\n\n\t\t\t\t}\n\n\t\t\t\t_gl.uniform1iv( location, uniform._array );\n\n\t\t\t\tfor( i = 0, il = uniform.value.length; i < il; i ++ ) {\n\n\t\t\t\t\ttexture = uniform.value[ i ];\n\t\t\t\t\ttextureUnit = uniform._array[ i ];\n\n\t\t\t\t\tif ( !texture ) continue;\n\n\t\t\t\t\t_this.setTexture( texture, textureUnit );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tfunction setupMatrices ( object, camera ) {\n\n\t\tobject._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\n\n\t\tobject._normalMatrix.getInverse( object._modelViewMatrix );\n\t\tobject._normalMatrix.transpose();\n\n\t};\n\n\t//\n\n\tfunction setColorGamma( array, offset, color, intensitySq ) {\n\n\t\tarray[ offset ]     = color.r * color.r * intensitySq;\n\t\tarray[ offset + 1 ] = color.g * color.g * intensitySq;\n\t\tarray[ offset + 2 ] = color.b * color.b * intensitySq;\n\n\t};\n\n\tfunction setColorLinear( array, offset, color, intensity ) {\n\n\t\tarray[ offset ]     = color.r * intensity;\n\t\tarray[ offset + 1 ] = color.g * intensity;\n\t\tarray[ offset + 2 ] = color.b * intensity;\n\n\t};\n\n\tfunction setupLights ( program, lights ) {\n\n\t\tvar l, ll, light, n,\n\t\tr = 0, g = 0, b = 0,\n\t\tcolor, skyColor, groundColor,\n\t\tintensity,  intensitySq,\n\t\tposition,\n\t\tdistance,\n\n\t\tzlights = _lights,\n\n\t\tdirColors = zlights.directional.colors,\n\t\tdirPositions = zlights.directional.positions,\n\n\t\tpointColors = zlights.point.colors,\n\t\tpointPositions = zlights.point.positions,\n\t\tpointDistances = zlights.point.distances,\n\n\t\tspotColors = zlights.spot.colors,\n\t\tspotPositions = zlights.spot.positions,\n\t\tspotDistances = zlights.spot.distances,\n\t\tspotDirections = zlights.spot.directions,\n\t\tspotAnglesCos = zlights.spot.anglesCos,\n\t\tspotExponents = zlights.spot.exponents,\n\n\t\themiSkyColors = zlights.hemi.skyColors,\n\t\themiGroundColors = zlights.hemi.groundColors,\n\t\themiPositions = zlights.hemi.positions,\n\n\t\tdirLength = 0,\n\t\tpointLength = 0,\n\t\tspotLength = 0,\n\t\themiLength = 0,\n\n\t\tdirCount = 0,\n\t\tpointCount = 0,\n\t\tspotCount = 0,\n\t\themiCount = 0,\n\n\t\tdirOffset = 0,\n\t\tpointOffset = 0,\n\t\tspotOffset = 0,\n\t\themiOffset = 0;\n\n\t\tfor ( l = 0, ll = lights.length; l < ll; l ++ ) {\n\n\t\t\tlight = lights[ l ];\n\n\t\t\tif ( light.onlyShadow ) continue;\n\n\t\t\tcolor = light.color;\n\t\t\tintensity = light.intensity;\n\t\t\tdistance = light.distance;\n\n\t\t\tif ( light instanceof THREE.AmbientLight ) {\n\n\t\t\t\tif ( ! light.visible ) continue;\n\n\t\t\t\tif ( _this.gammaInput ) {\n\n\t\t\t\t\tr += color.r * color.r;\n\t\t\t\t\tg += color.g * color.g;\n\t\t\t\t\tb += color.b * color.b;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tr += color.r;\n\t\t\t\t\tg += color.g;\n\t\t\t\t\tb += color.b;\n\n\t\t\t\t}\n\n\t\t\t} else if ( light instanceof THREE.DirectionalLight ) {\n\n\t\t\t\tdirCount += 1;\n\n\t\t\t\tif ( ! light.visible ) continue;\n\n\t\t\t\t_direction.getPositionFromMatrix( light.matrixWorld );\n\t\t\t\t_vector3.getPositionFromMatrix( light.target.matrixWorld );\n\t\t\t\t_direction.sub( _vector3 );\n\t\t\t\t_direction.normalize();\n\n\t\t\t\t// skip lights with undefined direction\n\t\t\t\t// these create troubles in OpenGL (making pixel black)\n\n\t\t\t\tif ( _direction.x === 0 && _direction.y === 0 && _direction.z === 0 ) continue;\n\n\t\t\t\tdirOffset = dirLength * 3;\n\n\t\t\t\tdirPositions[ dirOffset ]     = _direction.x;\n\t\t\t\tdirPositions[ dirOffset + 1 ] = _direction.y;\n\t\t\t\tdirPositions[ dirOffset + 2 ] = _direction.z;\n\n\t\t\t\tif ( _this.gammaInput ) {\n\n\t\t\t\t\tsetColorGamma( dirColors, dirOffset, color, intensity * intensity );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsetColorLinear( dirColors, dirOffset, color, intensity );\n\n\t\t\t\t}\n\n\t\t\t\tdirLength += 1;\n\n\t\t\t} else if ( light instanceof THREE.PointLight ) {\n\n\t\t\t\tpointCount += 1;\n\n\t\t\t\tif ( ! light.visible ) continue;\n\n\t\t\t\tpointOffset = pointLength * 3;\n\n\t\t\t\tif ( _this.gammaInput ) {\n\n\t\t\t\t\tsetColorGamma( pointColors, pointOffset, color, intensity * intensity );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsetColorLinear( pointColors, pointOffset, color, intensity );\n\n\t\t\t\t}\n\n\t\t\t\t_vector3.getPositionFromMatrix( light.matrixWorld );\n\n\t\t\t\tpointPositions[ pointOffset ]     = _vector3.x;\n\t\t\t\tpointPositions[ pointOffset + 1 ] = _vector3.y;\n\t\t\t\tpointPositions[ pointOffset + 2 ] = _vector3.z;\n\n\t\t\t\tpointDistances[ pointLength ] = distance;\n\n\t\t\t\tpointLength += 1;\n\n\t\t\t} else if ( light instanceof THREE.SpotLight ) {\n\n\t\t\t\tspotCount += 1;\n\n\t\t\t\tif ( ! light.visible ) continue;\n\n\t\t\t\tspotOffset = spotLength * 3;\n\n\t\t\t\tif ( _this.gammaInput ) {\n\n\t\t\t\t\tsetColorGamma( spotColors, spotOffset, color, intensity * intensity );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsetColorLinear( spotColors, spotOffset, color, intensity );\n\n\t\t\t\t}\n\n\t\t\t\t_vector3.getPositionFromMatrix( light.matrixWorld );\n\n\t\t\t\tspotPositions[ spotOffset ]     = _vector3.x;\n\t\t\t\tspotPositions[ spotOffset + 1 ] = _vector3.y;\n\t\t\t\tspotPositions[ spotOffset + 2 ] = _vector3.z;\n\n\t\t\t\tspotDistances[ spotLength ] = distance;\n\n\t\t\t\t_direction.copy( _vector3 );\n\t\t\t\t_vector3.getPositionFromMatrix( light.target.matrixWorld );\n\t\t\t\t_direction.sub( _vector3 );\n\t\t\t\t_direction.normalize();\n\n\t\t\t\tspotDirections[ spotOffset ]     = _direction.x;\n\t\t\t\tspotDirections[ spotOffset + 1 ] = _direction.y;\n\t\t\t\tspotDirections[ spotOffset + 2 ] = _direction.z;\n\n\t\t\t\tspotAnglesCos[ spotLength ] = Math.cos( light.angle );\n\t\t\t\tspotExponents[ spotLength ] = light.exponent;\n\n\t\t\t\tspotLength += 1;\n\n\t\t\t} else if ( light instanceof THREE.HemisphereLight ) {\n\n\t\t\t\themiCount += 1;\n\n\t\t\t\tif ( ! light.visible ) continue;\n\n\t\t\t\t_direction.getPositionFromMatrix( light.matrixWorld );\n\t\t\t\t_direction.normalize();\n\n\t\t\t\t// skip lights with undefined direction\n\t\t\t\t// these create troubles in OpenGL (making pixel black)\n\n\t\t\t\tif ( _direction.x === 0 && _direction.y === 0 && _direction.z === 0 ) continue;\n\n\t\t\t\themiOffset = hemiLength * 3;\n\n\t\t\t\themiPositions[ hemiOffset ]     = _direction.x;\n\t\t\t\themiPositions[ hemiOffset + 1 ] = _direction.y;\n\t\t\t\themiPositions[ hemiOffset + 2 ] = _direction.z;\n\n\t\t\t\tskyColor = light.color;\n\t\t\t\tgroundColor = light.groundColor;\n\n\t\t\t\tif ( _this.gammaInput ) {\n\n\t\t\t\t\tintensitySq = intensity * intensity;\n\n\t\t\t\t\tsetColorGamma( hemiSkyColors, hemiOffset, skyColor, intensitySq );\n\t\t\t\t\tsetColorGamma( hemiGroundColors, hemiOffset, groundColor, intensitySq );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsetColorLinear( hemiSkyColors, hemiOffset, skyColor, intensity );\n\t\t\t\t\tsetColorLinear( hemiGroundColors, hemiOffset, groundColor, intensity );\n\n\t\t\t\t}\n\n\t\t\t\themiLength += 1;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// null eventual remains from removed lights\n\t\t// (this is to avoid if in shader)\n\n\t\tfor ( l = dirLength * 3, ll = Math.max( dirColors.length, dirCount * 3 ); l < ll; l ++ ) dirColors[ l ] = 0.0;\n\t\tfor ( l = pointLength * 3, ll = Math.max( pointColors.length, pointCount * 3 ); l < ll; l ++ ) pointColors[ l ] = 0.0;\n\t\tfor ( l = spotLength * 3, ll = Math.max( spotColors.length, spotCount * 3 ); l < ll; l ++ ) spotColors[ l ] = 0.0;\n\t\tfor ( l = hemiLength * 3, ll = Math.max( hemiSkyColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiSkyColors[ l ] = 0.0;\n\t\tfor ( l = hemiLength * 3, ll = Math.max( hemiGroundColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiGroundColors[ l ] = 0.0;\n\n\t\tzlights.directional.length = dirLength;\n\t\tzlights.point.length = pointLength;\n\t\tzlights.spot.length = spotLength;\n\t\tzlights.hemi.length = hemiLength;\n\n\t\tzlights.ambient[ 0 ] = r;\n\t\tzlights.ambient[ 1 ] = g;\n\t\tzlights.ambient[ 2 ] = b;\n\n\t};\n\n\t// GL state setting\n\n\tthis.setFaceCulling = function ( cullFace, frontFaceDirection ) {\n\n\t\tif ( cullFace === THREE.CullFaceNone ) {\n\n\t\t\t_gl.disable( _gl.CULL_FACE );\n\n\t\t} else {\n\n\t\t\tif ( frontFaceDirection === THREE.FrontFaceDirectionCW ) {\n\n\t\t\t\t_gl.frontFace( _gl.CW );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.frontFace( _gl.CCW );\n\n\t\t\t}\n\n\t\t\tif ( cullFace === THREE.CullFaceBack ) {\n\n\t\t\t\t_gl.cullFace( _gl.BACK );\n\n\t\t\t} else if ( cullFace === THREE.CullFaceFront ) {\n\n\t\t\t\t_gl.cullFace( _gl.FRONT );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.cullFace( _gl.FRONT_AND_BACK );\n\n\t\t\t}\n\n\t\t\t_gl.enable( _gl.CULL_FACE );\n\n\t\t}\n\n\t};\n\n\tthis.setMaterialFaces = function ( material ) {\n\n\t\tvar doubleSided = material.side === THREE.DoubleSide;\n\t\tvar flipSided = material.side === THREE.BackSide;\n\n\t\tif ( _oldDoubleSided !== doubleSided ) {\n\n\t\t\tif ( doubleSided ) {\n\n\t\t\t\t_gl.disable( _gl.CULL_FACE );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.enable( _gl.CULL_FACE );\n\n\t\t\t}\n\n\t\t\t_oldDoubleSided = doubleSided;\n\n\t\t}\n\n\t\tif ( _oldFlipSided !== flipSided ) {\n\n\t\t\tif ( flipSided ) {\n\n\t\t\t\t_gl.frontFace( _gl.CW );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.frontFace( _gl.CCW );\n\n\t\t\t}\n\n\t\t\t_oldFlipSided = flipSided;\n\n\t\t}\n\n\t};\n\n\tthis.setDepthTest = function ( depthTest ) {\n\n\t\tif ( _oldDepthTest !== depthTest ) {\n\n\t\t\tif ( depthTest ) {\n\n\t\t\t\t_gl.enable( _gl.DEPTH_TEST );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.disable( _gl.DEPTH_TEST );\n\n\t\t\t}\n\n\t\t\t_oldDepthTest = depthTest;\n\n\t\t}\n\n\t};\n\n\tthis.setDepthWrite = function ( depthWrite ) {\n\n\t\tif ( _oldDepthWrite !== depthWrite ) {\n\n\t\t\t_gl.depthMask( depthWrite );\n\t\t\t_oldDepthWrite = depthWrite;\n\n\t\t}\n\n\t};\n\n\tfunction setLineWidth ( width ) {\n\n\t\tif ( width !== _oldLineWidth ) {\n\n\t\t\t_gl.lineWidth( width );\n\n\t\t\t_oldLineWidth = width;\n\n\t\t}\n\n\t};\n\n\tfunction setPolygonOffset ( polygonoffset, factor, units ) {\n\n\t\tif ( _oldPolygonOffset !== polygonoffset ) {\n\n\t\t\tif ( polygonoffset ) {\n\n\t\t\t\t_gl.enable( _gl.POLYGON_OFFSET_FILL );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.disable( _gl.POLYGON_OFFSET_FILL );\n\n\t\t\t}\n\n\t\t\t_oldPolygonOffset = polygonoffset;\n\n\t\t}\n\n\t\tif ( polygonoffset && ( _oldPolygonOffsetFactor !== factor || _oldPolygonOffsetUnits !== units ) ) {\n\n\t\t\t_gl.polygonOffset( factor, units );\n\n\t\t\t_oldPolygonOffsetFactor = factor;\n\t\t\t_oldPolygonOffsetUnits = units;\n\n\t\t}\n\n\t};\n\n\tthis.setBlending = function ( blending, blendEquation, blendSrc, blendDst ) {\n\n\t\tif ( blending !== _oldBlending ) {\n\n\t\t\tif ( blending === THREE.NoBlending ) {\n\n\t\t\t\t_gl.disable( _gl.BLEND );\n\n\t\t\t} else if ( blending === THREE.AdditiveBlending ) {\n\n\t\t\t\t_gl.enable( _gl.BLEND );\n\t\t\t\t_gl.blendEquation( _gl.FUNC_ADD );\n\t\t\t\t_gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE );\n\n\t\t\t} else if ( blending === THREE.SubtractiveBlending ) {\n\n\t\t\t\t// TODO: Find blendFuncSeparate() combination\n\t\t\t\t_gl.enable( _gl.BLEND );\n\t\t\t\t_gl.blendEquation( _gl.FUNC_ADD );\n\t\t\t\t_gl.blendFunc( _gl.ZERO, _gl.ONE_MINUS_SRC_COLOR );\n\n\t\t\t} else if ( blending === THREE.MultiplyBlending ) {\n\n\t\t\t\t// TODO: Find blendFuncSeparate() combination\n\t\t\t\t_gl.enable( _gl.BLEND );\n\t\t\t\t_gl.blendEquation( _gl.FUNC_ADD );\n\t\t\t\t_gl.blendFunc( _gl.ZERO, _gl.SRC_COLOR );\n\n\t\t\t} else if ( blending === THREE.CustomBlending ) {\n\n\t\t\t\t_gl.enable( _gl.BLEND );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.enable( _gl.BLEND );\n\t\t\t\t_gl.blendEquationSeparate( _gl.FUNC_ADD, _gl.FUNC_ADD );\n\t\t\t\t_gl.blendFuncSeparate( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA, _gl.ONE, _gl.ONE_MINUS_SRC_ALPHA );\n\n\t\t\t}\n\n\t\t\t_oldBlending = blending;\n\n\t\t}\n\n\t\tif ( blending === THREE.CustomBlending ) {\n\n\t\t\tif ( blendEquation !== _oldBlendEquation ) {\n\n\t\t\t\t_gl.blendEquation( paramThreeToGL( blendEquation ) );\n\n\t\t\t\t_oldBlendEquation = blendEquation;\n\n\t\t\t}\n\n\t\t\tif ( blendSrc !== _oldBlendSrc || blendDst !== _oldBlendDst ) {\n\n\t\t\t\t_gl.blendFunc( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ) );\n\n\t\t\t\t_oldBlendSrc = blendSrc;\n\t\t\t\t_oldBlendDst = blendDst;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t_oldBlendEquation = null;\n\t\t\t_oldBlendSrc = null;\n\t\t\t_oldBlendDst = null;\n\n\t\t}\n\n\t};\n\n\t// Defines\n\n\tfunction generateDefines ( defines ) {\n\n\t\tvar value, chunk, chunks = [];\n\n\t\tfor ( var d in defines ) {\n\n\t\t\tvalue = defines[ d ];\n\t\t\tif ( value === false ) continue;\n\n\t\t\tchunk = \"#define \" + d + \" \" + value;\n\t\t\tchunks.push( chunk );\n\n\t\t}\n\n\t\treturn chunks.join( \"\\n\" );\n\n\t};\n\n\t// Shaders\n\n\tfunction buildProgram ( shaderID, fragmentShader, vertexShader, uniforms, attributes, defines, parameters ) {\n\n\t\tvar p, pl, d, program, code;\n\t\tvar chunks = [];\n\n\t\t// Generate code\n\n\t\tif ( shaderID ) {\n\n\t\t\tchunks.push( shaderID );\n\n\t\t} else {\n\n\t\t\tchunks.push( fragmentShader );\n\t\t\tchunks.push( vertexShader );\n\n\t\t}\n\n\t\tfor ( d in defines ) {\n\n\t\t\tchunks.push( d );\n\t\t\tchunks.push( defines[ d ] );\n\n\t\t}\n\n\t\tfor ( p in parameters ) {\n\n\t\t\tchunks.push( p );\n\t\t\tchunks.push( parameters[ p ] );\n\n\t\t}\n\n\t\tcode = chunks.join();\n\n\t\t// Check if code has been already compiled\n\n\t\tfor ( p = 0, pl = _programs.length; p < pl; p ++ ) {\n\n\t\t\tvar programInfo = _programs[ p ];\n\n\t\t\tif ( programInfo.code === code ) {\n\n\t\t\t\t//console.log( \"Code already compiled.\" /*: \\n\\n\" + code*/ );\n\n\t\t\t\tprogramInfo.usedTimes ++;\n\n\t\t\t\treturn programInfo.program;\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar shadowMapTypeDefine = \"SHADOWMAP_TYPE_BASIC\";\n\n\t\tif ( parameters.shadowMapType === THREE.PCFShadowMap ) {\n\n\t\t\tshadowMapTypeDefine = \"SHADOWMAP_TYPE_PCF\";\n\n\t\t} else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {\n\n\t\t\tshadowMapTypeDefine = \"SHADOWMAP_TYPE_PCF_SOFT\";\n\n\t\t}\n\n\t\t//console.log( \"building new program \" );\n\n\t\t//\n\n\t\tvar customDefines = generateDefines( defines );\n\n\t\t//\n\n\t\tprogram = _gl.createProgram();\n\n\t\tvar prefix_vertex = [\n\n\t\t\t\"precision \" + _precision + \" float;\",\n\n\t\t\tcustomDefines,\n\n\t\t\t_supportsVertexTextures ? \"#define VERTEX_TEXTURES\" : \"\",\n\n\t\t\t_this.gammaInput ? \"#define GAMMA_INPUT\" : \"\",\n\t\t\t_this.gammaOutput ? \"#define GAMMA_OUTPUT\" : \"\",\n\t\t\t_this.physicallyBasedShading ? \"#define PHYSICALLY_BASED_SHADING\" : \"\",\n\n\t\t\t\"#define MAX_DIR_LIGHTS \" + parameters.maxDirLights,\n\t\t\t\"#define MAX_POINT_LIGHTS \" + parameters.maxPointLights,\n\t\t\t\"#define MAX_SPOT_LIGHTS \" + parameters.maxSpotLights,\n\t\t\t\"#define MAX_HEMI_LIGHTS \" + parameters.maxHemiLights,\n\n\t\t\t\"#define MAX_SHADOWS \" + parameters.maxShadows,\n\n\t\t\t\"#define MAX_BONES \" + parameters.maxBones,\n\n\t\t\tparameters.map ? \"#define USE_MAP\" : \"\",\n\t\t\tparameters.envMap ? \"#define USE_ENVMAP\" : \"\",\n\t\t\tparameters.lightMap ? \"#define USE_LIGHTMAP\" : \"\",\n\t\t\tparameters.bumpMap ? \"#define USE_BUMPMAP\" : \"\",\n\t\t\tparameters.normalMap ? \"#define USE_NORMALMAP\" : \"\",\n\t\t\tparameters.specularMap ? \"#define USE_SPECULARMAP\" : \"\",\n\t\t\tparameters.vertexColors ? \"#define USE_COLOR\" : \"\",\n\n\t\t\tparameters.skinning ? \"#define USE_SKINNING\" : \"\",\n\t\t\tparameters.useVertexTexture ? \"#define BONE_TEXTURE\" : \"\",\n\t\t\tparameters.boneTextureWidth ? \"#define N_BONE_PIXEL_X \" + parameters.boneTextureWidth.toFixed( 1 ) : \"\",\n\t\t\tparameters.boneTextureHeight ? \"#define N_BONE_PIXEL_Y \" + parameters.boneTextureHeight.toFixed( 1 ) : \"\",\n\n\t\t\tparameters.morphTargets ? \"#define USE_MORPHTARGETS\" : \"\",\n\t\t\tparameters.morphNormals ? \"#define USE_MORPHNORMALS\" : \"\",\n\t\t\tparameters.perPixel ? \"#define PHONG_PER_PIXEL\" : \"\",\n\t\t\tparameters.wrapAround ? \"#define WRAP_AROUND\" : \"\",\n\t\t\tparameters.doubleSided ? \"#define DOUBLE_SIDED\" : \"\",\n\t\t\tparameters.flipSided ? \"#define FLIP_SIDED\" : \"\",\n\n\t\t\tparameters.shadowMapEnabled ? \"#define USE_SHADOWMAP\" : \"\",\n\t\t\tparameters.shadowMapEnabled ? \"#define \" + shadowMapTypeDefine : \"\",\n\t\t\tparameters.shadowMapDebug ? \"#define SHADOWMAP_DEBUG\" : \"\",\n\t\t\tparameters.shadowMapCascade ? \"#define SHADOWMAP_CASCADE\" : \"\",\n\n\t\t\tparameters.sizeAttenuation ? \"#define USE_SIZEATTENUATION\" : \"\",\n\n\t\t\t\"uniform mat4 modelMatrix;\",\n\t\t\t\"uniform mat4 modelViewMatrix;\",\n\t\t\t\"uniform mat4 projectionMatrix;\",\n\t\t\t\"uniform mat4 viewMatrix;\",\n\t\t\t\"uniform mat3 normalMatrix;\",\n\t\t\t\"uniform vec3 cameraPosition;\",\n\n\t\t\t\"attribute vec3 position;\",\n\t\t\t\"attribute vec3 normal;\",\n\t\t\t\"attribute vec2 uv;\",\n\t\t\t\"attribute vec2 uv2;\",\n\n\t\t\t\"#ifdef USE_COLOR\",\n\n\t\t\t\t\"attribute vec3 color;\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"#ifdef USE_MORPHTARGETS\",\n\n\t\t\t\t\"attribute vec3 morphTarget0;\",\n\t\t\t\t\"attribute vec3 morphTarget1;\",\n\t\t\t\t\"attribute vec3 morphTarget2;\",\n\t\t\t\t\"attribute vec3 morphTarget3;\",\n\n\t\t\t\t\"#ifdef USE_MORPHNORMALS\",\n\n\t\t\t\t\t\"attribute vec3 morphNormal0;\",\n\t\t\t\t\t\"attribute vec3 morphNormal1;\",\n\t\t\t\t\t\"attribute vec3 morphNormal2;\",\n\t\t\t\t\t\"attribute vec3 morphNormal3;\",\n\n\t\t\t\t\"#else\",\n\n\t\t\t\t\t\"attribute vec3 morphTarget4;\",\n\t\t\t\t\t\"attribute vec3 morphTarget5;\",\n\t\t\t\t\t\"attribute vec3 morphTarget6;\",\n\t\t\t\t\t\"attribute vec3 morphTarget7;\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"#ifdef USE_SKINNING\",\n\n\t\t\t\t\"attribute vec4 skinIndex;\",\n\t\t\t\t\"attribute vec4 skinWeight;\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"\"\n\n\t\t].join(\"\\n\");\n\n\t\tvar prefix_fragment = [\n\n\t\t\t\"precision \" + _precision + \" float;\",\n\n\t\t\t( parameters.bumpMap || parameters.normalMap ) ? \"#extension GL_OES_standard_derivatives : enable\" : \"\",\n\n\t\t\tcustomDefines,\n\n\t\t\t\"#define MAX_DIR_LIGHTS \" + parameters.maxDirLights,\n\t\t\t\"#define MAX_POINT_LIGHTS \" + parameters.maxPointLights,\n\t\t\t\"#define MAX_SPOT_LIGHTS \" + parameters.maxSpotLights,\n\t\t\t\"#define MAX_HEMI_LIGHTS \" + parameters.maxHemiLights,\n\n\t\t\t\"#define MAX_SHADOWS \" + parameters.maxShadows,\n\n\t\t\tparameters.alphaTest ? \"#define ALPHATEST \" + parameters.alphaTest: \"\",\n\n\t\t\t_this.gammaInput ? \"#define GAMMA_INPUT\" : \"\",\n\t\t\t_this.gammaOutput ? \"#define GAMMA_OUTPUT\" : \"\",\n\t\t\t_this.physicallyBasedShading ? \"#define PHYSICALLY_BASED_SHADING\" : \"\",\n\n\t\t\t( parameters.useFog && parameters.fog ) ? \"#define USE_FOG\" : \"\",\n\t\t\t( parameters.useFog && parameters.fogExp ) ? \"#define FOG_EXP2\" : \"\",\n\n\t\t\tparameters.map ? \"#define USE_MAP\" : \"\",\n\t\t\tparameters.envMap ? \"#define USE_ENVMAP\" : \"\",\n\t\t\tparameters.lightMap ? \"#define USE_LIGHTMAP\" : \"\",\n\t\t\tparameters.bumpMap ? \"#define USE_BUMPMAP\" : \"\",\n\t\t\tparameters.normalMap ? \"#define USE_NORMALMAP\" : \"\",\n\t\t\tparameters.specularMap ? \"#define USE_SPECULARMAP\" : \"\",\n\t\t\tparameters.vertexColors ? \"#define USE_COLOR\" : \"\",\n\n\t\t\tparameters.metal ? \"#define METAL\" : \"\",\n\t\t\tparameters.perPixel ? \"#define PHONG_PER_PIXEL\" : \"\",\n\t\t\tparameters.wrapAround ? \"#define WRAP_AROUND\" : \"\",\n\t\t\tparameters.doubleSided ? \"#define DOUBLE_SIDED\" : \"\",\n\t\t\tparameters.flipSided ? \"#define FLIP_SIDED\" : \"\",\n\n\t\t\tparameters.shadowMapEnabled ? \"#define USE_SHADOWMAP\" : \"\",\n\t\t\tparameters.shadowMapEnabled ? \"#define \" + shadowMapTypeDefine : \"\",\n\t\t\tparameters.shadowMapDebug ? \"#define SHADOWMAP_DEBUG\" : \"\",\n\t\t\tparameters.shadowMapCascade ? \"#define SHADOWMAP_CASCADE\" : \"\",\n\n\t\t\t\"uniform mat4 viewMatrix;\",\n\t\t\t\"uniform vec3 cameraPosition;\",\n\t\t\t\"\"\n\n\t\t].join(\"\\n\");\n\n\t\tvar glFragmentShader = getShader( \"fragment\", prefix_fragment + fragmentShader );\n\t\tvar glVertexShader = getShader( \"vertex\", prefix_vertex + vertexShader );\n\n\t\t_gl.attachShader( program, glVertexShader );\n\t\t_gl.attachShader( program, glFragmentShader );\n\n\t\t_gl.linkProgram( program );\n\n\t\tif ( !_gl.getProgramParameter( program, _gl.LINK_STATUS ) ) {\n\n\t\t\tconsole.error( \"Could not initialise shader\\n\" + \"VALIDATE_STATUS: \" + _gl.getProgramParameter( program, _gl.VALIDATE_STATUS ) + \", gl error [\" + _gl.getError() + \"]\" );\n\n\t\t}\n\n\t\t// clean up\n\n\t\t_gl.deleteShader( glFragmentShader );\n\t\t_gl.deleteShader( glVertexShader );\n\n\t\t//console.log( prefix_fragment + fragmentShader );\n\t\t//console.log( prefix_vertex + vertexShader );\n\n\t\tprogram.uniforms = {};\n\t\tprogram.attributes = {};\n\n\t\tvar identifiers, u, a, i;\n\n\t\t// cache uniform locations\n\n\t\tidentifiers = [\n\n\t\t\t'viewMatrix', 'modelViewMatrix', 'projectionMatrix', 'normalMatrix', 'modelMatrix', 'cameraPosition',\n\t\t\t'morphTargetInfluences'\n\n\t\t];\n\n\t\tif ( parameters.useVertexTexture ) {\n\n\t\t\tidentifiers.push( 'boneTexture' );\n\n\t\t} else {\n\n\t\t\tidentifiers.push( 'boneGlobalMatrices' );\n\n\t\t}\n\n\t\tfor ( u in uniforms ) {\n\n\t\t\tidentifiers.push( u );\n\n\t\t}\n\n\t\tcacheUniformLocations( program, identifiers );\n\n\t\t// cache attributes locations\n\n\t\tidentifiers = [\n\n\t\t\t\"position\", \"normal\", \"uv\", \"uv2\", \"tangent\", \"color\",\n\t\t\t\"skinIndex\", \"skinWeight\", \"lineDistance\"\n\n\t\t];\n\n\t\tfor ( i = 0; i < parameters.maxMorphTargets; i ++ ) {\n\n\t\t\tidentifiers.push( \"morphTarget\" + i );\n\n\t\t}\n\n\t\tfor ( i = 0; i < parameters.maxMorphNormals; i ++ ) {\n\n\t\t\tidentifiers.push( \"morphNormal\" + i );\n\n\t\t}\n\n\t\tfor ( a in attributes ) {\n\n\t\t\tidentifiers.push( a );\n\n\t\t}\n\n\t\tcacheAttributeLocations( program, identifiers );\n\n\t\tprogram.id = _programs_counter ++;\n\n\t\t_programs.push( { program: program, code: code, usedTimes: 1 } );\n\n\t\t_this.info.memory.programs = _programs.length;\n\n\t\treturn program;\n\n\t};\n\n\t// Shader parameters cache\n\n\tfunction cacheUniformLocations ( program, identifiers ) {\n\n\t\tvar i, l, id;\n\n\t\tfor( i = 0, l = identifiers.length; i < l; i ++ ) {\n\n\t\t\tid = identifiers[ i ];\n\t\t\tprogram.uniforms[ id ] = _gl.getUniformLocation( program, id );\n\n\t\t}\n\n\t};\n\n\tfunction cacheAttributeLocations ( program, identifiers ) {\n\n\t\tvar i, l, id;\n\n\t\tfor( i = 0, l = identifiers.length; i < l; i ++ ) {\n\n\t\t\tid = identifiers[ i ];\n\t\t\tprogram.attributes[ id ] = _gl.getAttribLocation( program, id );\n\n\t\t}\n\n\t};\n\n\tfunction addLineNumbers ( string ) {\n\n\t\tvar chunks = string.split( \"\\n\" );\n\n\t\tfor ( var i = 0, il = chunks.length; i < il; i ++ ) {\n\n\t\t\t// Chrome reports shader errors on lines\n\t\t\t// starting counting from 1\n\n\t\t\tchunks[ i ] = ( i + 1 ) + \": \" + chunks[ i ];\n\n\t\t}\n\n\t\treturn chunks.join( \"\\n\" );\n\n\t};\n\n\tfunction getShader ( type, string ) {\n\n\t\tvar shader;\n\n\t\tif ( type === \"fragment\" ) {\n\n\t\t\tshader = _gl.createShader( _gl.FRAGMENT_SHADER );\n\n\t\t} else if ( type === \"vertex\" ) {\n\n\t\t\tshader = _gl.createShader( _gl.VERTEX_SHADER );\n\n\t\t}\n\n\t\t_gl.shaderSource( shader, string );\n\t\t_gl.compileShader( shader );\n\n\t\tif ( !_gl.getShaderParameter( shader, _gl.COMPILE_STATUS ) ) {\n\n\t\t\tconsole.error( _gl.getShaderInfoLog( shader ) );\n\t\t\tconsole.error( addLineNumbers( string ) );\n\t\t\treturn null;\n\n\t\t}\n\n\t\treturn shader;\n\n\t};\n\n\t// Textures\n\n\n\tfunction isPowerOfTwo ( value ) {\n\n\t\treturn ( value & ( value - 1 ) ) === 0;\n\n\t};\n\n\tfunction setTextureParameters ( textureType, texture, isImagePowerOfTwo ) {\n\n\t\tif ( isImagePowerOfTwo ) {\n\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );\n\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );\n\n\t\t} else {\n\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\n\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );\n\n\t\t}\n\n\t\tif ( _glExtensionTextureFilterAnisotropic && texture.type !== THREE.FloatType ) {\n\n\t\t\tif ( texture.anisotropy > 1 || texture.__oldAnisotropy ) {\n\n\t\t\t\t_gl.texParameterf( textureType, _glExtensionTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _maxAnisotropy ) );\n\t\t\t\ttexture.__oldAnisotropy = texture.anisotropy;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tthis.setTexture = function ( texture, slot ) {\n\n\t\tif ( texture.needsUpdate ) {\n\n\t\t\tif ( ! texture.__webglInit ) {\n\n\t\t\t\ttexture.__webglInit = true;\n\n\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\n\t\t\t\ttexture.__webglTexture = _gl.createTexture();\n\n\t\t\t\t_this.info.memory.textures ++;\n\n\t\t\t}\n\n\t\t\t_gl.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );\n\n\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );\n\n\t\t\tvar image = texture.image,\n\t\t\tisImagePowerOfTwo = isPowerOfTwo( image.width ) && isPowerOfTwo( image.height ),\n\t\t\tglFormat = paramThreeToGL( texture.format ),\n\t\t\tglType = paramThreeToGL( texture.type );\n\n\t\t\tsetTextureParameters( _gl.TEXTURE_2D, texture, isImagePowerOfTwo );\n\n\t\t\tvar mipmap, mipmaps = texture.mipmaps;\n\n\t\t\tif ( texture instanceof THREE.DataTexture ) {\n\n\t\t\t\t// use manually created mipmaps if available\n\t\t\t\t// if there are no manual mipmaps\n\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\n\t\t\t\tif ( mipmaps.length > 0 && isImagePowerOfTwo ) {\n\n\t\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.generateMipmaps = false;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );\n\n\t\t\t\t}\n\n\t\t\t} else if ( texture instanceof THREE.CompressedTexture ) {\n\n\t\t\t\t// compressed textures can only use manually created mipmaps\n\t\t\t\t// WebGL can't generate mipmaps for DDS textures\n\n\t\t\t\tfor( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\t\t\t\t_gl.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\n\t\t\t\t}\n\n\t\t\t} else { // regular Texture (image, video, canvas)\n\n\t\t\t\t// use manually created mipmaps if available\n\t\t\t\t// if there are no manual mipmaps\n\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\n\t\t\t\tif ( mipmaps.length > 0 && isImagePowerOfTwo ) {\n\n\t\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.generateMipmaps = false;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( texture.generateMipmaps && isImagePowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );\n\n\t\t\ttexture.needsUpdate = false;\n\n\t\t\tif ( texture.onUpdate ) texture.onUpdate();\n\n\t\t} else {\n\n\t\t\t_gl.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );\n\n\t\t}\n\n\t};\n\n\tfunction clampToMaxSize ( image, maxSize ) {\n\n\t\tif ( image.width <= maxSize && image.height <= maxSize ) {\n\n\t\t\treturn image;\n\n\t\t}\n\n\t\t// Warning: Scaling through the canvas will only work with images that use\n\t\t// premultiplied alpha.\n\n\t\tvar maxDimension = Math.max( image.width, image.height );\n\t\tvar newWidth = Math.floor( image.width * maxSize / maxDimension );\n\t\tvar newHeight = Math.floor( image.height * maxSize / maxDimension );\n\n\t\tvar canvas = document.createElement( 'canvas' );\n\t\tcanvas.width = newWidth;\n\t\tcanvas.height = newHeight;\n\n\t\tvar ctx = canvas.getContext( \"2d\" );\n\t\tctx.drawImage( image, 0, 0, image.width, image.height, 0, 0, newWidth, newHeight );\n\n\t\treturn canvas;\n\n\t}\n\n\tfunction setCubeTexture ( texture, slot ) {\n\n\t\tif ( texture.image.length === 6 ) {\n\n\t\t\tif ( texture.needsUpdate ) {\n\n\t\t\t\tif ( ! texture.image.__webglTextureCube ) {\n\n\t\t\t\t\ttexture.image.__webglTextureCube = _gl.createTexture();\n\n\t\t\t\t\t_this.info.memory.textures ++;\n\n\t\t\t\t}\n\n\t\t\t\t_gl.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );\n\n\t\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\n\t\t\t\tvar isCompressed = texture instanceof THREE.CompressedTexture;\n\n\t\t\t\tvar cubeImage = [];\n\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\tif ( _this.autoScaleCubemaps && ! isCompressed ) {\n\n\t\t\t\t\t\tcubeImage[ i ] = clampToMaxSize( texture.image[ i ], _maxCubemapSize );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tcubeImage[ i ] = texture.image[ i ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar image = cubeImage[ 0 ],\n\t\t\t\tisImagePowerOfTwo = isPowerOfTwo( image.width ) && isPowerOfTwo( image.height ),\n\t\t\t\tglFormat = paramThreeToGL( texture.format ),\n\t\t\t\tglType = paramThreeToGL( texture.type );\n\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo );\n\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\tif ( isCompressed ) {\n\n\t\t\t\t\t\tvar mipmap, mipmaps = cubeImage[ i ].mipmaps;\n\n\t\t\t\t\t\tfor( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tmipmap = mipmaps[ j ];\n\t\t\t\t\t\t\t_gl.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( texture.generateMipmaps && isImagePowerOfTwo ) {\n\n\t\t\t\t\t_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\n\n\t\t\t\t}\n\n\t\t\t\ttexture.needsUpdate = false;\n\n\t\t\t\tif ( texture.onUpdate ) texture.onUpdate();\n\n\t\t\t} else {\n\n\t\t\t\t_gl.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tfunction setCubeTextureDynamic ( texture, slot ) {\n\n\t\t_gl.activeTexture( _gl.TEXTURE0 + slot );\n\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.__webglTexture );\n\n\t};\n\n\t// Render targets\n\n\tfunction setupFrameBuffer ( framebuffer, renderTarget, textureTarget ) {\n\n\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureTarget, renderTarget.__webglTexture, 0 );\n\n\t};\n\n\tfunction setupRenderBuffer ( renderbuffer, renderTarget  ) {\n\n\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );\n\n\t\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\n\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );\n\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\n\t\t/* For some reason this is not working. Defaulting to RGBA4.\n\t\t} else if( ! renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\n\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.STENCIL_INDEX8, renderTarget.width, renderTarget.height );\n\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\t\t*/\n\t\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\n\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );\n\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\n\t\t} else {\n\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );\n\n\t\t}\n\n\t};\n\n\tthis.setRenderTarget = function ( renderTarget ) {\n\n\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\n\n\t\tif ( renderTarget && ! renderTarget.__webglFramebuffer ) {\n\n\t\t\tif ( renderTarget.depthBuffer === undefined ) renderTarget.depthBuffer = true;\n\t\t\tif ( renderTarget.stencilBuffer === undefined ) renderTarget.stencilBuffer = true;\n\n\t\t\trenderTarget.addEventListener( 'dispose', onRenderTargetDispose );\n\n\t\t\trenderTarget.__webglTexture = _gl.createTexture();\n\n\t\t\t_this.info.memory.textures ++;\n\n\t\t\t// Setup texture, create render and frame buffers\n\n\t\t\tvar isTargetPowerOfTwo = isPowerOfTwo( renderTarget.width ) && isPowerOfTwo( renderTarget.height ),\n\t\t\t\tglFormat = paramThreeToGL( renderTarget.format ),\n\t\t\t\tglType = paramThreeToGL( renderTarget.type );\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\trenderTarget.__webglFramebuffer = [];\n\t\t\t\trenderTarget.__webglRenderbuffer = [];\n\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget, isTargetPowerOfTwo );\n\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\trenderTarget.__webglFramebuffer[ i ] = _gl.createFramebuffer();\n\t\t\t\t\trenderTarget.__webglRenderbuffer[ i ] = _gl.createRenderbuffer();\n\n\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\n\n\t\t\t\t\tsetupFrameBuffer( renderTarget.__webglFramebuffer[ i ], renderTarget, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );\n\t\t\t\t\tsetupRenderBuffer( renderTarget.__webglRenderbuffer[ i ], renderTarget );\n\n\t\t\t\t}\n\n\t\t\t\tif ( isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\n\n\t\t\t} else {\n\n\t\t\t\trenderTarget.__webglFramebuffer = _gl.createFramebuffer();\n\n\t\t\t\tif ( renderTarget.shareDepthFrom ) {\n\n\t\t\t\t\trenderTarget.__webglRenderbuffer = renderTarget.shareDepthFrom.__webglRenderbuffer;\n\n\t\t\t\t} else {\n\n\t\t\t\t\trenderTarget.__webglRenderbuffer = _gl.createRenderbuffer();\n\n\t\t\t\t}\n\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_2D, renderTarget, isTargetPowerOfTwo );\n\n\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\n\n\t\t\t\tsetupFrameBuffer( renderTarget.__webglFramebuffer, renderTarget, _gl.TEXTURE_2D );\n\n\t\t\t\tif ( renderTarget.shareDepthFrom ) {\n\n\t\t\t\t\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\n\n\t\t\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );\n\n\t\t\t\t\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\n\n\t\t\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsetupRenderBuffer( renderTarget.__webglRenderbuffer, renderTarget );\n\n\t\t\t\t}\n\n\t\t\t\tif ( isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );\n\n\t\t\t}\n\n\t\t\t// Release everything\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, null );\n\n\t\t\t}\n\n\t\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\n\t\t}\n\n\t\tvar framebuffer, width, height, vx, vy;\n\n\t\tif ( renderTarget ) {\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\tframebuffer = renderTarget.__webglFramebuffer[ renderTarget.activeCubeFace ];\n\n\t\t\t} else {\n\n\t\t\t\tframebuffer = renderTarget.__webglFramebuffer;\n\n\t\t\t}\n\n\t\t\twidth = renderTarget.width;\n\t\t\theight = renderTarget.height;\n\n\t\t\tvx = 0;\n\t\t\tvy = 0;\n\n\t\t} else {\n\n\t\t\tframebuffer = null;\n\n\t\t\twidth = _viewportWidth;\n\t\t\theight = _viewportHeight;\n\n\t\t\tvx = _viewportX;\n\t\t\tvy = _viewportY;\n\n\t\t}\n\n\t\tif ( framebuffer !== _currentFramebuffer ) {\n\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\t\t\t_gl.viewport( vx, vy, width, height );\n\n\t\t\t_currentFramebuffer = framebuffer;\n\n\t\t}\n\n\t\t_currentWidth = width;\n\t\t_currentHeight = height;\n\n\t};\n\n\tfunction updateRenderTargetMipmap ( renderTarget ) {\n\n\t\tif ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {\n\n\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );\n\t\t\t_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\n\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\n\n\t\t} else {\n\n\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );\n\t\t\t_gl.generateMipmap( _gl.TEXTURE_2D );\n\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, null );\n\n\t\t}\n\n\t};\n\n\t// Fallback filters for non-power-of-2 textures\n\n\tfunction filterFallback ( f ) {\n\n\t\tif ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {\n\n\t\t\treturn _gl.NEAREST;\n\n\t\t}\n\n\t\treturn _gl.LINEAR;\n\n\t};\n\n\t// Map three.js constants to WebGL constants\n\n\tfunction paramThreeToGL ( p ) {\n\n\t\tif ( p === THREE.RepeatWrapping ) return _gl.REPEAT;\n\t\tif ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;\n\t\tif ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;\n\n\t\tif ( p === THREE.NearestFilter ) return _gl.NEAREST;\n\t\tif ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;\n\t\tif ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;\n\n\t\tif ( p === THREE.LinearFilter ) return _gl.LINEAR;\n\t\tif ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;\n\t\tif ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;\n\n\t\tif ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;\n\t\tif ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;\n\t\tif ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;\n\t\tif ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;\n\n\t\tif ( p === THREE.ByteType ) return _gl.BYTE;\n\t\tif ( p === THREE.ShortType ) return _gl.SHORT;\n\t\tif ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;\n\t\tif ( p === THREE.IntType ) return _gl.INT;\n\t\tif ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;\n\t\tif ( p === THREE.FloatType ) return _gl.FLOAT;\n\n\t\tif ( p === THREE.AlphaFormat ) return _gl.ALPHA;\n\t\tif ( p === THREE.RGBFormat ) return _gl.RGB;\n\t\tif ( p === THREE.RGBAFormat ) return _gl.RGBA;\n\t\tif ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;\n\t\tif ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;\n\n\t\tif ( p === THREE.AddEquation ) return _gl.FUNC_ADD;\n\t\tif ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;\n\t\tif ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;\n\n\t\tif ( p === THREE.ZeroFactor ) return _gl.ZERO;\n\t\tif ( p === THREE.OneFactor ) return _gl.ONE;\n\t\tif ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;\n\t\tif ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;\n\t\tif ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;\n\t\tif ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;\n\t\tif ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;\n\t\tif ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;\n\n\t\tif ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;\n\t\tif ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;\n\t\tif ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;\n\n\t\tif ( _glExtensionCompressedTextureS3TC !== undefined ) {\n\n\t\t\tif ( p === THREE.RGB_S3TC_DXT1_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGB_S3TC_DXT1_EXT;\n\t\t\tif ( p === THREE.RGBA_S3TC_DXT1_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n\t\t\tif ( p === THREE.RGBA_S3TC_DXT3_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n\t\t\tif ( p === THREE.RGBA_S3TC_DXT5_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n\n\t\t}\n\n\t\treturn 0;\n\n\t};\n\n\t// Allocations\n\n\tfunction allocateBones ( object ) {\n\n\t\tif ( _supportsBoneTextures && object && object.useVertexTexture ) {\n\n\t\t\treturn 1024;\n\n\t\t} else {\n\n\t\t\t// default for when object is not specified\n\t\t\t// ( for example when prebuilding shader\n\t\t\t//   to be used with multiple objects )\n\t\t\t//\n\t\t\t// \t- leave some extra space for other uniforms\n\t\t\t//  - limit here is ANGLE's 254 max uniform vectors\n\t\t\t//    (up to 54 should be safe)\n\n\t\t\tvar nVertexUniforms = _gl.getParameter( _gl.MAX_VERTEX_UNIFORM_VECTORS );\n\t\t\tvar nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );\n\n\t\t\tvar maxBones = nVertexMatrices;\n\n\t\t\tif ( object !== undefined && object instanceof THREE.SkinnedMesh ) {\n\n\t\t\t\tmaxBones = Math.min( object.bones.length, maxBones );\n\n\t\t\t\tif ( maxBones < object.bones.length ) {\n\n\t\t\t\t\tconsole.warn( \"WebGLRenderer: too many bones - \" + object.bones.length + \", this GPU supports just \" + maxBones + \" (try OpenGL instead of ANGLE)\" );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn maxBones;\n\n\t\t}\n\n\t};\n\n\tfunction allocateLights ( lights ) {\n\n\t\tvar l, ll, light, dirLights, pointLights, spotLights, hemiLights;\n\n\t\tdirLights = pointLights = spotLights = hemiLights = 0;\n\n\t\tfor ( l = 0, ll = lights.length; l < ll; l ++ ) {\n\n\t\t\tlight = lights[ l ];\n\n\t\t\tif ( light.onlyShadow ) continue;\n\n\t\t\tif ( light instanceof THREE.DirectionalLight ) dirLights ++;\n\t\t\tif ( light instanceof THREE.PointLight ) pointLights ++;\n\t\t\tif ( light instanceof THREE.SpotLight ) spotLights ++;\n\t\t\tif ( light instanceof THREE.HemisphereLight ) hemiLights ++;\n\n\t\t}\n\n\t\treturn { 'directional' : dirLights, 'point' : pointLights, 'spot': spotLights, 'hemi': hemiLights };\n\n\t};\n\n\tfunction allocateShadows ( lights ) {\n\n\t\tvar l, ll, light, maxShadows = 0;\n\n\t\tfor ( l = 0, ll = lights.length; l < ll; l++ ) {\n\n\t\t\tlight = lights[ l ];\n\n\t\t\tif ( ! light.castShadow ) continue;\n\n\t\t\tif ( light instanceof THREE.SpotLight ) maxShadows ++;\n\t\t\tif ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) maxShadows ++;\n\n\t\t}\n\n\t\treturn maxShadows;\n\n\t};\n\n\t// Initialization\n\n\tfunction initGL () {\n\n\t\ttry {\n\n\t\t\tif ( ! ( _gl = _canvas.getContext( 'experimental-webgl', { alpha: _alpha, premultipliedAlpha: _premultipliedAlpha, antialias: _antialias, stencil: _stencil, preserveDrawingBuffer: _preserveDrawingBuffer } ) ) ) {\n\n\t\t\t\tthrow 'Error creating WebGL context.';\n\n\t\t\t}\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( error );\n\n\t\t}\n\n\t\t_glExtensionTextureFloat = _gl.getExtension( 'OES_texture_float' );\n\t\t_glExtensionStandardDerivatives = _gl.getExtension( 'OES_standard_derivatives' );\n\n\t\t_glExtensionTextureFilterAnisotropic = _gl.getExtension( 'EXT_texture_filter_anisotropic' ) ||\n\t\t\t\t\t\t\t\t\t\t\t   _gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) ||\n\t\t\t\t\t\t\t\t\t\t\t   _gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );\n\n\n\t\t_glExtensionCompressedTextureS3TC = _gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) ||\n\t\t\t\t\t\t\t\t\t\t\t_gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) ||\n\t\t\t\t\t\t\t\t\t\t\t_gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );\n\n\t\tif ( ! _glExtensionTextureFloat ) {\n\n\t\t\tconsole.log( 'THREE.WebGLRenderer: Float textures not supported.' );\n\n\t\t}\n\n\t\tif ( ! _glExtensionStandardDerivatives ) {\n\n\t\t\tconsole.log( 'THREE.WebGLRenderer: Standard derivatives not supported.' );\n\n\t\t}\n\n\t\tif ( ! _glExtensionTextureFilterAnisotropic ) {\n\n\t\t\tconsole.log( 'THREE.WebGLRenderer: Anisotropic texture filtering not supported.' );\n\n\t\t}\n\n\t\tif ( ! _glExtensionCompressedTextureS3TC ) {\n\n\t\t\tconsole.log( 'THREE.WebGLRenderer: S3TC compressed textures not supported.' );\n\n\t\t}\n\t\t\n\t\tif ( _gl.getShaderPrecisionFormat === undefined ) {\n\t\t\t\n\t\t\t_gl.getShaderPrecisionFormat = function() { \n\t\t\t\t\n\t\t\t\treturn {\n\t\t\t\t\t\"rangeMin\"  : 1,\n\t\t\t\t\t\"rangeMax\"  : 1,\n\t\t\t\t\t\"precision\" : 1\n\t\t\t\t};\n\t\t\t\t\n\t\t\t}\n\t\t}\n\n\t};\n\n\tfunction setDefaultGLState () {\n\n\t\t_gl.clearColor( 0, 0, 0, 1 );\n\t\t_gl.clearDepth( 1 );\n\t\t_gl.clearStencil( 0 );\n\n\t\t_gl.enable( _gl.DEPTH_TEST );\n\t\t_gl.depthFunc( _gl.LEQUAL );\n\n\t\t_gl.frontFace( _gl.CCW );\n\t\t_gl.cullFace( _gl.BACK );\n\t\t_gl.enable( _gl.CULL_FACE );\n\n\t\t_gl.enable( _gl.BLEND );\n\t\t_gl.blendEquation( _gl.FUNC_ADD );\n\t\t_gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA );\n\n\t\t_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\n\t};\n\n\t// default plugins (order is important)\n\n\tthis.shadowMapPlugin = new THREE.ShadowMapPlugin();\n\tthis.addPrePlugin( this.shadowMapPlugin );\n\n\tthis.addPostPlugin( new THREE.SpritePlugin() );\n\tthis.addPostPlugin( new THREE.LensFlarePlugin() );\n\n};\n/**\n * @author szimek / https://github.com/szimek/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.WebGLRenderTarget = function ( width, height, options ) {\n\n\tTHREE.EventDispatcher.call( this );\n\n\tthis.width = width;\n\tthis.height = height;\n\n\toptions = options || {};\n\n\tthis.wrapS = options.wrapS !== undefined ? options.wrapS : THREE.ClampToEdgeWrapping;\n\tthis.wrapT = options.wrapT !== undefined ? options.wrapT : THREE.ClampToEdgeWrapping;\n\n\tthis.magFilter = options.magFilter !== undefined ? options.magFilter : THREE.LinearFilter;\n\tthis.minFilter = options.minFilter !== undefined ? options.minFilter : THREE.LinearMipMapLinearFilter;\n\n\tthis.anisotropy = options.anisotropy !== undefined ? options.anisotropy : 1;\n\n\tthis.offset = new THREE.Vector2( 0, 0 );\n\tthis.repeat = new THREE.Vector2( 1, 1 );\n\n\tthis.format = options.format !== undefined ? options.format : THREE.RGBAFormat;\n\tthis.type = options.type !== undefined ? options.type : THREE.UnsignedByteType;\n\n\tthis.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\n\tthis.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;\n\n\tthis.generateMipmaps = true;\n\n\tthis.shareDepthFrom = null;\n\n};\n\nTHREE.WebGLRenderTarget.prototype.clone = function() {\n\n\tvar tmp = new THREE.WebGLRenderTarget( this.width, this.height );\n\n\ttmp.wrapS = this.wrapS;\n\ttmp.wrapT = this.wrapT;\n\n\ttmp.magFilter = this.magFilter;\n\ttmp.minFilter = this.minFilter;\n\n\ttmp.anisotropy = this.anisotropy;\n\n\ttmp.offset.copy( this.offset );\n\ttmp.repeat.copy( this.repeat );\n\n\ttmp.format = this.format;\n\ttmp.type = this.type;\n\n\ttmp.depthBuffer = this.depthBuffer;\n\ttmp.stencilBuffer = this.stencilBuffer;\n\n\ttmp.generateMipmaps = this.generateMipmaps;\n\n\ttmp.shareDepthFrom = this.shareDepthFrom;\n\n\treturn tmp;\n\n};\n\nTHREE.WebGLRenderTarget.prototype.dispose = function () {\n\n\tthis.dispatchEvent( { type: 'dispose' } );\n\n};\n/**\n * @author alteredq / http://alteredqualia.com\n */\n\nTHREE.WebGLRenderTargetCube = function ( width, height, options ) {\n\n\tTHREE.WebGLRenderTarget.call( this, width, height, options );\n\n\tthis.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5\n\n};\n\nTHREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.RenderableVertex = function () {\n\n\tthis.positionWorld = new THREE.Vector3();\n\tthis.positionScreen = new THREE.Vector4();\n\n\tthis.visible = true;\n\n};\n\nTHREE.RenderableVertex.prototype.copy = function ( vertex ) {\n\n\tthis.positionWorld.copy( vertex.positionWorld );\n\tthis.positionScreen.copy( vertex.positionScreen );\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.RenderableFace3 = function () {\n\n\tthis.v1 = new THREE.RenderableVertex();\n\tthis.v2 = new THREE.RenderableVertex();\n\tthis.v3 = new THREE.RenderableVertex();\n\n\tthis.centroidModel = new THREE.Vector3();\n\n\tthis.normalModel = new THREE.Vector3();\n\tthis.normalModelView = new THREE.Vector3();\n\n\tthis.vertexNormalsLength = 0;\n\tthis.vertexNormalsModel = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];\n\tthis.vertexNormalsModelView = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];\n\n\tthis.color = null;\n\tthis.material = null;\n\tthis.uvs = [[]];\n\n\tthis.z = null;\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.RenderableFace4 = function () {\n\n\tthis.v1 = new THREE.RenderableVertex();\n\tthis.v2 = new THREE.RenderableVertex();\n\tthis.v3 = new THREE.RenderableVertex();\n\tthis.v4 = new THREE.RenderableVertex();\n\n\tthis.centroidModel = new THREE.Vector3();\n\n\tthis.normalModel = new THREE.Vector3();\n\tthis.normalModelView = new THREE.Vector3();\n\n\tthis.vertexNormalsLength = 0;\n\tthis.vertexNormalsModel = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];\n\tthis.vertexNormalsModelView = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];\n\n\tthis.color = null;\n\tthis.material = null;\n\tthis.uvs = [[]];\n\n\tthis.z = null;\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.RenderableObject = function () {\n\n\tthis.object = null;\n\tthis.z = null;\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.RenderableParticle = function () {\n\n\tthis.object = null;\n\n\tthis.x = null;\n\tthis.y = null;\n\tthis.z = null;\n\n\tthis.rotation = null;\n\tthis.scale = new THREE.Vector2();\n\n\tthis.material = null;\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.RenderableLine = function () {\n\n\tthis.z = null;\n\n\tthis.v1 = new THREE.RenderableVertex();\n\tthis.v2 = new THREE.RenderableVertex();\n\n\tthis.material = null;\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.GeometryUtils = {\n\n\t// Merge two geometries or geometry and geometry from object (using object's transform)\n\n\tmerge: function ( geometry1, object2 /* mesh | geometry */ ) {\n\n\t\tvar matrix, normalMatrix,\n\t\tvertexOffset = geometry1.vertices.length,\n\t\tuvPosition = geometry1.faceVertexUvs[ 0 ].length,\n\t\tgeometry2 = object2 instanceof THREE.Mesh ? object2.geometry : object2,\n\t\tvertices1 = geometry1.vertices,\n\t\tvertices2 = geometry2.vertices,\n\t\tfaces1 = geometry1.faces,\n\t\tfaces2 = geometry2.faces,\n\t\tuvs1 = geometry1.faceVertexUvs[ 0 ],\n\t\tuvs2 = geometry2.faceVertexUvs[ 0 ];\n\n\t\tif ( object2 instanceof THREE.Mesh ) {\n\n\t\t\tobject2.matrixAutoUpdate && object2.updateMatrix();\n\n\t\t\tmatrix = object2.matrix;\n\n\t\t\tnormalMatrix = new THREE.Matrix3();\n\t\t\tnormalMatrix.getInverse( matrix );\n\t\t\tnormalMatrix.transpose();\n\n\t\t}\n\n\t\t// vertices\n\n\t\tfor ( var i = 0, il = vertices2.length; i < il; i ++ ) {\n\n\t\t\tvar vertex = vertices2[ i ];\n\n\t\t\tvar vertexCopy = vertex.clone();\n\n\t\t\tif ( matrix ) vertexCopy.applyMatrix4( matrix );\n\n\t\t\tvertices1.push( vertexCopy );\n\n\t\t}\n\n\t\t// faces\n\n\t\tfor ( i = 0, il = faces2.length; i < il; i ++ ) {\n\n\t\t\tvar face = faces2[ i ], faceCopy, normal, color,\n\t\t\tfaceVertexNormals = face.vertexNormals,\n\t\t\tfaceVertexColors = face.vertexColors;\n\n\t\t\tif ( face instanceof THREE.Face3 ) {\n\n\t\t\t\tfaceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );\n\n\t\t\t} else if ( face instanceof THREE.Face4 ) {\n\n\t\t\t\tfaceCopy = new THREE.Face4( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset, face.d + vertexOffset );\n\n\t\t\t}\n\n\t\t\tfaceCopy.normal.copy( face.normal );\n\n\t\t\tif ( normalMatrix ) {\n\n\t\t\t\tfaceCopy.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t}\n\n\t\t\tfor ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\tnormal = faceVertexNormals[ j ].clone();\n\n\t\t\t\tif ( normalMatrix ) {\n\n\t\t\t\t\tnormal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t\t}\n\n\t\t\t\tfaceCopy.vertexNormals.push( normal );\n\n\t\t\t}\n\n\t\t\tfaceCopy.color.copy( face.color );\n\n\t\t\tfor ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {\n\n\t\t\t\tcolor = faceVertexColors[ j ];\n\t\t\t\tfaceCopy.vertexColors.push( color.clone() );\n\n\t\t\t}\n\n\t\t\tfaceCopy.materialIndex = face.materialIndex;\n\n\t\t\tfaceCopy.centroid.copy( face.centroid );\n\n\t\t\tif ( matrix ) {\n\n\t\t\t\tfaceCopy.centroid.applyMatrix4( matrix );\n\n\t\t\t}\n\n\t\t\tfaces1.push( faceCopy );\n\n\t\t}\n\n\t\t// uvs\n\n\t\tfor ( i = 0, il = uvs2.length; i < il; i ++ ) {\n\n\t\t\tvar uv = uvs2[ i ], uvCopy = [];\n\n\t\t\tfor ( var j = 0, jl = uv.length; j < jl; j ++ ) {\n\n\t\t\t\tuvCopy.push( new THREE.Vector2( uv[ j ].x, uv[ j ].y ) );\n\n\t\t\t}\n\n\t\t\tuvs1.push( uvCopy );\n\n\t\t}\n\n\t},\n\n\tremoveMaterials: function ( geometry, materialIndexArray ) {\n\n\t\tvar materialIndexMap = {};\n\n\t\tfor ( var i = 0, il = materialIndexArray.length; i < il; i ++ ) {\n\n\t\t\tmaterialIndexMap[ materialIndexArray[i] ] = true;\n\n\t\t}\n\n\t\tvar face, newFaces = [];\n\n\t\tfor ( var i = 0, il = geometry.faces.length; i < il; i ++ ) {\n\n\t\t\tface = geometry.faces[ i ];\n\t\t\tif ( ! ( face.materialIndex in materialIndexMap ) ) newFaces.push( face );\n\n\t\t}\n\n\t\tgeometry.faces = newFaces;\n\n\t},\n\n\t// Get random point in triangle (via barycentric coordinates)\n\t// \t(uniform distribution)\n\t// \thttp://www.cgafaq.info/wiki/Random_Point_In_Triangle\n\n\trandomPointInTriangle: function ( vectorA, vectorB, vectorC ) {\n\n\t\tvar a, b, c,\n\t\t\tpoint = new THREE.Vector3(),\n\t\t\ttmp = THREE.GeometryUtils.__v1;\n\n\t\ta = THREE.GeometryUtils.random();\n\t\tb = THREE.GeometryUtils.random();\n\n\t\tif ( ( a + b ) > 1 ) {\n\n\t\t\ta = 1 - a;\n\t\t\tb = 1 - b;\n\n\t\t}\n\n\t\tc = 1 - a - b;\n\n\t\tpoint.copy( vectorA );\n\t\tpoint.multiplyScalar( a );\n\n\t\ttmp.copy( vectorB );\n\t\ttmp.multiplyScalar( b );\n\n\t\tpoint.add( tmp );\n\n\t\ttmp.copy( vectorC );\n\t\ttmp.multiplyScalar( c );\n\n\t\tpoint.add( tmp );\n\n\t\treturn point;\n\n\t},\n\n\t// Get random point in face (triangle / quad)\n\t// (uniform distribution)\n\n\trandomPointInFace: function ( face, geometry, useCachedAreas ) {\n\n\t\tvar vA, vB, vC, vD;\n\n\t\tif ( face instanceof THREE.Face3 ) {\n\n\t\t\tvA = geometry.vertices[ face.a ];\n\t\t\tvB = geometry.vertices[ face.b ];\n\t\t\tvC = geometry.vertices[ face.c ];\n\n\t\t\treturn THREE.GeometryUtils.randomPointInTriangle( vA, vB, vC );\n\n\t\t} else if ( face instanceof THREE.Face4 ) {\n\n\t\t\tvA = geometry.vertices[ face.a ];\n\t\t\tvB = geometry.vertices[ face.b ];\n\t\t\tvC = geometry.vertices[ face.c ];\n\t\t\tvD = geometry.vertices[ face.d ];\n\n\t\t\tvar area1, area2;\n\n\t\t\tif ( useCachedAreas ) {\n\n\t\t\t\tif ( face._area1 && face._area2 ) {\n\n\t\t\t\t\tarea1 = face._area1;\n\t\t\t\t\tarea2 = face._area2;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tarea1 = THREE.GeometryUtils.triangleArea( vA, vB, vD );\n\t\t\t\t\tarea2 = THREE.GeometryUtils.triangleArea( vB, vC, vD );\n\n\t\t\t\t\tface._area1 = area1;\n\t\t\t\t\tface._area2 = area2;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tarea1 = THREE.GeometryUtils.triangleArea( vA, vB, vD ),\n\t\t\t\tarea2 = THREE.GeometryUtils.triangleArea( vB, vC, vD );\n\n\t\t\t}\n\n\t\t\tvar r = THREE.GeometryUtils.random() * ( area1 + area2 );\n\n\t\t\tif ( r < area1 ) {\n\n\t\t\t\treturn THREE.GeometryUtils.randomPointInTriangle( vA, vB, vD );\n\n\t\t\t} else {\n\n\t\t\t\treturn THREE.GeometryUtils.randomPointInTriangle( vB, vC, vD );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t// Get uniformly distributed random points in mesh\n\t// \t- create array with cumulative sums of face areas\n\t//  - pick random number from 0 to total area\n\t//  - find corresponding place in area array by binary search\n\t//\t- get random point in face\n\n\trandomPointsInGeometry: function ( geometry, n ) {\n\n\t\tvar face, i,\n\t\t\tfaces = geometry.faces,\n\t\t\tvertices = geometry.vertices,\n\t\t\til = faces.length,\n\t\t\ttotalArea = 0,\n\t\t\tcumulativeAreas = [],\n\t\t\tvA, vB, vC, vD;\n\n\t\t// precompute face areas\n\n\t\tfor ( i = 0; i < il; i ++ ) {\n\n\t\t\tface = faces[ i ];\n\n\t\t\tif ( face instanceof THREE.Face3 ) {\n\n\t\t\t\tvA = vertices[ face.a ];\n\t\t\t\tvB = vertices[ face.b ];\n\t\t\t\tvC = vertices[ face.c ];\n\n\t\t\t\tface._area = THREE.GeometryUtils.triangleArea( vA, vB, vC );\n\n\t\t\t} else if ( face instanceof THREE.Face4 ) {\n\n\t\t\t\tvA = vertices[ face.a ];\n\t\t\t\tvB = vertices[ face.b ];\n\t\t\t\tvC = vertices[ face.c ];\n\t\t\t\tvD = vertices[ face.d ];\n\n\t\t\t\tface._area1 = THREE.GeometryUtils.triangleArea( vA, vB, vD );\n\t\t\t\tface._area2 = THREE.GeometryUtils.triangleArea( vB, vC, vD );\n\n\t\t\t\tface._area = face._area1 + face._area2;\n\n\t\t\t}\n\n\t\t\ttotalArea += face._area;\n\n\t\t\tcumulativeAreas[ i ] = totalArea;\n\n\t\t}\n\n\t\t// binary search cumulative areas array\n\n\t\tfunction binarySearchIndices( value ) {\n\n\t\t\tfunction binarySearch( start, end ) {\n\n\t\t\t\t// return closest larger index\n\t\t\t\t// if exact number is not found\n\n\t\t\t\tif ( end < start )\n\t\t\t\t\treturn start;\n\n\t\t\t\tvar mid = start + Math.floor( ( end - start ) / 2 );\n\n\t\t\t\tif ( cumulativeAreas[ mid ] > value ) {\n\n\t\t\t\t\treturn binarySearch( start, mid - 1 );\n\n\t\t\t\t} else if ( cumulativeAreas[ mid ] < value ) {\n\n\t\t\t\t\treturn binarySearch( mid + 1, end );\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn mid;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar result = binarySearch( 0, cumulativeAreas.length - 1 )\n\t\t\treturn result;\n\n\t\t}\n\n\t\t// pick random face weighted by face area\n\n\t\tvar r, index,\n\t\t\tresult = [];\n\n\t\tvar stats = {};\n\n\t\tfor ( i = 0; i < n; i ++ ) {\n\n\t\t\tr = THREE.GeometryUtils.random() * totalArea;\n\n\t\t\tindex = binarySearchIndices( r );\n\n\t\t\tresult[ i ] = THREE.GeometryUtils.randomPointInFace( faces[ index ], geometry, true );\n\n\t\t\tif ( ! stats[ index ] ) {\n\n\t\t\t\tstats[ index ] = 1;\n\n\t\t\t} else {\n\n\t\t\t\tstats[ index ] += 1;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t},\n\n\t// Get triangle area (half of parallelogram)\n\t//\thttp://mathworld.wolfram.com/TriangleArea.html\n\n\ttriangleArea: function ( vectorA, vectorB, vectorC ) {\n\n\t\tvar tmp1 = THREE.GeometryUtils.__v1,\n\t\t\ttmp2 = THREE.GeometryUtils.__v2;\n\n\t\ttmp1.subVectors( vectorB, vectorA );\n\t\ttmp2.subVectors( vectorC, vectorA );\n\t\ttmp1.cross( tmp2 );\n\n\t\treturn 0.5 * tmp1.length();\n\n\t},\n\n\t// Center geometry so that 0,0,0 is in center of bounding box\n\n\tcenter: function ( geometry ) {\n\n\t\tgeometry.computeBoundingBox();\n\n\t\tvar bb = geometry.boundingBox;\n\n\t\tvar offset = new THREE.Vector3();\n\n\t\toffset.addVectors( bb.min, bb.max );\n\t\toffset.multiplyScalar( -0.5 );\n\n\t\tgeometry.applyMatrix( new THREE.Matrix4().makeTranslation( offset.x, offset.y, offset.z ) );\n\t\tgeometry.computeBoundingBox();\n\n\t\treturn offset;\n\n\t},\n\n\t// Normalize UVs to be from <0,1>\n\t// (for now just the first set of UVs)\n\n\tnormalizeUVs: function ( geometry ) {\n\n\t\tvar uvSet = geometry.faceVertexUvs[ 0 ];\n\n\t\tfor ( var i = 0, il = uvSet.length; i < il; i ++ ) {\n\n\t\t\tvar uvs = uvSet[ i ];\n\n\t\t\tfor ( var j = 0, jl = uvs.length; j < jl; j ++ ) {\n\n\t\t\t\t// texture repeat\n\n\t\t\t\tif( uvs[ j ].x !== 1.0 ) uvs[ j ].x = uvs[ j ].x - Math.floor( uvs[ j ].x );\n\t\t\t\tif( uvs[ j ].y !== 1.0 ) uvs[ j ].y = uvs[ j ].y - Math.floor( uvs[ j ].y );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\ttriangulateQuads: function ( geometry ) {\n\n\t\tvar i, il, j, jl;\n\n\t\tvar faces = [];\n\t\tvar faceUvs = [];\n\t\tvar faceVertexUvs = [];\n\n\t\tfor ( i = 0, il = geometry.faceUvs.length; i < il; i ++ ) {\n\n\t\t\tfaceUvs[ i ] = [];\n\n\t\t}\n\n\t\tfor ( i = 0, il = geometry.faceVertexUvs.length; i < il; i ++ ) {\n\n\t\t\tfaceVertexUvs[ i ] = [];\n\n\t\t}\n\n\t\tfor ( i = 0, il = geometry.faces.length; i < il; i ++ ) {\n\n\t\t\tvar face = geometry.faces[ i ];\n\n\t\t\tif ( face instanceof THREE.Face4 ) {\n\n\t\t\t\tvar a = face.a;\n\t\t\t\tvar b = face.b;\n\t\t\t\tvar c = face.c;\n\t\t\t\tvar d = face.d;\n\n\t\t\t\tvar triA = new THREE.Face3();\n\t\t\t\tvar triB = new THREE.Face3();\n\n\t\t\t\ttriA.color.copy( face.color );\n\t\t\t\ttriB.color.copy( face.color );\n\n\t\t\t\ttriA.materialIndex = face.materialIndex;\n\t\t\t\ttriB.materialIndex = face.materialIndex;\n\n\t\t\t\ttriA.a = a;\n\t\t\t\ttriA.b = b;\n\t\t\t\ttriA.c = d;\n\n\t\t\t\ttriB.a = b;\n\t\t\t\ttriB.b = c;\n\t\t\t\ttriB.c = d;\n\n\t\t\t\tif ( face.vertexColors.length === 4 ) {\n\n\t\t\t\t\ttriA.vertexColors[ 0 ] = face.vertexColors[ 0 ].clone();\n\t\t\t\t\ttriA.vertexColors[ 1 ] = face.vertexColors[ 1 ].clone();\n\t\t\t\t\ttriA.vertexColors[ 2 ] = face.vertexColors[ 3 ].clone();\n\n\t\t\t\t\ttriB.vertexColors[ 0 ] = face.vertexColors[ 1 ].clone();\n\t\t\t\t\ttriB.vertexColors[ 1 ] = face.vertexColors[ 2 ].clone();\n\t\t\t\t\ttriB.vertexColors[ 2 ] = face.vertexColors[ 3 ].clone();\n\n\t\t\t\t}\n\n\t\t\t\tfaces.push( triA, triB );\n\n\t\t\t\tfor ( j = 0, jl = geometry.faceVertexUvs.length; j < jl; j ++ ) {\n\n\t\t\t\t\tif ( geometry.faceVertexUvs[ j ].length ) {\n\n\t\t\t\t\t\tvar uvs = geometry.faceVertexUvs[ j ][ i ];\n\n\t\t\t\t\t\tvar uvA = uvs[ 0 ];\n\t\t\t\t\t\tvar uvB = uvs[ 1 ];\n\t\t\t\t\t\tvar uvC = uvs[ 2 ];\n\t\t\t\t\t\tvar uvD = uvs[ 3 ];\n\n\t\t\t\t\t\tvar uvsTriA = [ uvA.clone(), uvB.clone(), uvD.clone() ];\n\t\t\t\t\t\tvar uvsTriB = [ uvB.clone(), uvC.clone(), uvD.clone() ];\n\n\t\t\t\t\t\tfaceVertexUvs[ j ].push( uvsTriA, uvsTriB );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfor ( j = 0, jl = geometry.faceUvs.length; j < jl; j ++ ) {\n\n\t\t\t\t\tif ( geometry.faceUvs[ j ].length ) {\n\n\t\t\t\t\t\tvar faceUv = geometry.faceUvs[ j ][ i ];\n\n\t\t\t\t\t\tfaceUvs[ j ].push( faceUv, faceUv );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tfaces.push( face );\n\n\t\t\t\tfor ( j = 0, jl = geometry.faceUvs.length; j < jl; j ++ ) {\n\n\t\t\t\t\tfaceUvs[ j ].push( geometry.faceUvs[ j ][ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( j = 0, jl = geometry.faceVertexUvs.length; j < jl; j ++ ) {\n\n\t\t\t\t\tfaceVertexUvs[ j ].push( geometry.faceVertexUvs[ j ][ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometry.faces = faces;\n\t\tgeometry.faceUvs = faceUvs;\n\t\tgeometry.faceVertexUvs = faceVertexUvs;\n\n\t\tgeometry.computeCentroids();\n\t\tgeometry.computeFaceNormals();\n\t\tgeometry.computeVertexNormals();\n\n\t\tif ( geometry.hasTangents ) geometry.computeTangents();\n\n\t},\n\n\tsetMaterialIndex: function ( geometry, index, startFace, endFace ){\n\n\t\tvar faces = geometry.faces;\n\t\tvar start = startFace || 0;\n\t\tvar end = endFace || faces.length - 1;\n\n\t\tfor ( var i = start; i <= end; i ++ ) {\n\n\t\t\tfaces[i].materialIndex = index;\n\n\t\t}\n\n    }\n\n};\n\nTHREE.GeometryUtils.random = THREE.Math.random16;\n\nTHREE.GeometryUtils.__v1 = new THREE.Vector3();\nTHREE.GeometryUtils.__v2 = new THREE.Vector3();\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.ImageUtils = {\n\n\tcrossOrigin: 'anonymous',\n\n\tloadTexture: function ( url, mapping, onLoad, onError ) {\n\n\t\tvar image = new Image();\n\t\tvar texture = new THREE.Texture( image, mapping );\n\n\t\tvar loader = new THREE.ImageLoader();\n\n\t\tloader.addEventListener( 'load', function ( event ) {\n\n\t\t\ttexture.image = event.content;\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t} );\n\n\t\tloader.addEventListener( 'error', function ( event ) {\n\n\t\t\tif ( onError ) onError( event.message );\n\n\t\t} );\n\n\t\tloader.crossOrigin = this.crossOrigin;\n\t\tloader.load( url, image );\n\n\t\ttexture.sourceFile = url;\n\n\t\treturn texture;\n\n\t},\n\n\tloadCompressedTexture: function ( url, mapping, onLoad, onError ) {\n\n\t\tvar texture = new THREE.CompressedTexture();\n\t\ttexture.mapping = mapping;\n\n\t\tvar request = new XMLHttpRequest();\n\n\t\trequest.onload = function () {\n\n\t\t\tvar buffer = request.response;\n\t\t\tvar dds = THREE.ImageUtils.parseDDS( buffer, true );\n\n\t\t\ttexture.format = dds.format;\n\n\t\t\ttexture.mipmaps = dds.mipmaps;\n\t\t\ttexture.image.width = dds.width;\n\t\t\ttexture.image.height = dds.height;\n\n\t\t\t// gl.generateMipmap fails for compressed textures\n\t\t\t// mipmaps must be embedded in the DDS file\n\t\t\t// or texture filters must not use mipmapping\n\n\t\t\ttexture.generateMipmaps = false;\n\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t}\n\n\t\trequest.onerror = onError;\n\n\t\trequest.open( 'GET', url, true );\n\t\trequest.responseType = \"arraybuffer\";\n\t\trequest.send( null );\n\n\t\treturn texture;\n\n\t},\n\n\tloadTextureCube: function ( array, mapping, onLoad, onError ) {\n\n\t\tvar images = [];\n\t\timages.loadCount = 0;\n\n\t\tvar texture = new THREE.Texture();\n\t\ttexture.image = images;\n\t\tif ( mapping !== undefined ) texture.mapping = mapping;\n\n\t\t// no flipping needed for cube textures\n\n\t\ttexture.flipY = false;\n\n\t\tfor ( var i = 0, il = array.length; i < il; ++ i ) {\n\n\t\t\tvar cubeImage = new Image();\n\t\t\timages[ i ] = cubeImage;\n\n\t\t\tcubeImage.onload = function () {\n\n\t\t\t\timages.loadCount += 1;\n\n\t\t\t\tif ( images.loadCount === 6 ) {\n\n\t\t\t\t\ttexture.needsUpdate = true;\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tcubeImage.onerror = onError;\n\n\t\t\tcubeImage.crossOrigin = this.crossOrigin;\n\t\t\tcubeImage.src = array[ i ];\n\n\t\t}\n\n\t\treturn texture;\n\n\t},\n\n\tloadCompressedTextureCube: function ( array, mapping, onLoad, onError ) {\n\n\t\tvar images = [];\n\t\timages.loadCount = 0;\n\n\t\tvar texture = new THREE.CompressedTexture();\n\t\ttexture.image = images;\n\t\tif ( mapping !== undefined ) texture.mapping = mapping;\n\n\t\t// no flipping for cube textures\n\t\t// (also flipping doesn't work for compressed textures )\n\n\t\ttexture.flipY = false;\n\n\t\t// can't generate mipmaps for compressed textures\n\t\t// mips must be embedded in DDS files\n\n\t\ttexture.generateMipmaps = false;\n\n\t\tvar generateCubeFaceCallback = function ( rq, img ) {\n\n\t\t\treturn function () {\n\n\t\t\t\tvar buffer = rq.response;\n\t\t\t\tvar dds = THREE.ImageUtils.parseDDS( buffer, true );\n\n\t\t\t\timg.format = dds.format;\n\n\t\t\t\timg.mipmaps = dds.mipmaps;\n\t\t\t\timg.width = dds.width;\n\t\t\t\timg.height = dds.height;\n\n\t\t\t\timages.loadCount += 1;\n\n\t\t\t\tif ( images.loadCount === 6 ) {\n\n\t\t\t\t\ttexture.format = dds.format;\n\t\t\t\t\ttexture.needsUpdate = true;\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// compressed cubemap textures as 6 separate DDS files\n\n\t\tif ( array instanceof Array ) {\n\n\t\t\tfor ( var i = 0, il = array.length; i < il; ++ i ) {\n\n\t\t\t\tvar cubeImage = {};\n\t\t\t\timages[ i ] = cubeImage;\n\n\t\t\t\tvar request = new XMLHttpRequest();\n\n\t\t\t\trequest.onload = generateCubeFaceCallback( request, cubeImage );\n\t\t\t\trequest.onerror = onError;\n\n\t\t\t\tvar url = array[ i ];\n\n\t\t\t\trequest.open( 'GET', url, true );\n\t\t\t\trequest.responseType = \"arraybuffer\";\n\t\t\t\trequest.send( null );\n\n\t\t\t}\n\n\t\t// compressed cubemap texture stored in a single DDS file\n\n\t\t} else {\n\n\t\t\tvar url = array;\n\t\t\tvar request = new XMLHttpRequest();\n\n\t\t\trequest.onload = function( ) {\n\n\t\t\t\tvar buffer = request.response;\n\t\t\t\tvar dds = THREE.ImageUtils.parseDDS( buffer, true );\n\n\t\t\t\tif ( dds.isCubemap ) {\n\n\t\t\t\t\tvar faces = dds.mipmaps.length / dds.mipmapCount;\n\n\t\t\t\t\tfor ( var f = 0; f < faces; f ++ ) {\n\n\t\t\t\t\t\timages[ f ] = { mipmaps : [] };\n\n\t\t\t\t\t\tfor ( var i = 0; i < dds.mipmapCount; i ++ ) {\n\n\t\t\t\t\t\t\timages[ f ].mipmaps.push( dds.mipmaps[ f * dds.mipmapCount + i ] );\n\t\t\t\t\t\t\timages[ f ].format = dds.format;\n\t\t\t\t\t\t\timages[ f ].width = dds.width;\n\t\t\t\t\t\t\timages[ f ].height = dds.height;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.format = dds.format;\n\t\t\t\t\ttexture.needsUpdate = true;\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\trequest.onerror = onError;\n\n\t\t\trequest.open( 'GET', url, true );\n\t\t\trequest.responseType = \"arraybuffer\";\n\t\t\trequest.send( null );\n\n\t\t}\n\n\t\treturn texture;\n\n\t},\n\n\tparseDDS: function ( buffer, loadMipmaps ) {\n\n\t\tvar dds = { mipmaps: [], width: 0, height: 0, format: null, mipmapCount: 1 };\n\n\t\t// Adapted from @toji's DDS utils\n\t\t//\thttps://github.com/toji/webgl-texture-utils/blob/master/texture-util/dds.js\n\n\t\t// All values and structures referenced from:\n\t\t// http://msdn.microsoft.com/en-us/library/bb943991.aspx/\n\n\t\tvar DDS_MAGIC = 0x20534444;\n\n\t\tvar DDSD_CAPS = 0x1,\n\t\t\tDDSD_HEIGHT = 0x2,\n\t\t\tDDSD_WIDTH = 0x4,\n\t\t\tDDSD_PITCH = 0x8,\n\t\t\tDDSD_PIXELFORMAT = 0x1000,\n\t\t\tDDSD_MIPMAPCOUNT = 0x20000,\n\t\t\tDDSD_LINEARSIZE = 0x80000,\n\t\t\tDDSD_DEPTH = 0x800000;\n\n\t\tvar DDSCAPS_COMPLEX = 0x8,\n\t\t\tDDSCAPS_MIPMAP = 0x400000,\n\t\t\tDDSCAPS_TEXTURE = 0x1000;\n\n\t\tvar DDSCAPS2_CUBEMAP = 0x200,\n\t\t\tDDSCAPS2_CUBEMAP_POSITIVEX = 0x400,\n\t\t\tDDSCAPS2_CUBEMAP_NEGATIVEX = 0x800,\n\t\t\tDDSCAPS2_CUBEMAP_POSITIVEY = 0x1000,\n\t\t\tDDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000,\n\t\t\tDDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000,\n\t\t\tDDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000,\n\t\t\tDDSCAPS2_VOLUME = 0x200000;\n\n\t\tvar DDPF_ALPHAPIXELS = 0x1,\n\t\t\tDDPF_ALPHA = 0x2,\n\t\t\tDDPF_FOURCC = 0x4,\n\t\t\tDDPF_RGB = 0x40,\n\t\t\tDDPF_YUV = 0x200,\n\t\t\tDDPF_LUMINANCE = 0x20000;\n\n\t\tfunction fourCCToInt32( value ) {\n\n\t\t\treturn value.charCodeAt(0) +\n\t\t\t\t(value.charCodeAt(1) << 8) +\n\t\t\t\t(value.charCodeAt(2) << 16) +\n\t\t\t\t(value.charCodeAt(3) << 24);\n\n\t\t}\n\n\t\tfunction int32ToFourCC( value ) {\n\n\t\t\treturn String.fromCharCode(\n\t\t\t\tvalue & 0xff,\n\t\t\t\t(value >> 8) & 0xff,\n\t\t\t\t(value >> 16) & 0xff,\n\t\t\t\t(value >> 24) & 0xff\n\t\t\t);\n\t\t}\n\n\t\tvar FOURCC_DXT1 = fourCCToInt32(\"DXT1\");\n\t\tvar FOURCC_DXT3 = fourCCToInt32(\"DXT3\");\n\t\tvar FOURCC_DXT5 = fourCCToInt32(\"DXT5\");\n\n\t\tvar headerLengthInt = 31; // The header length in 32 bit ints\n\n\t\t// Offsets into the header array\n\n\t\tvar off_magic = 0;\n\n\t\tvar off_size = 1;\n\t\tvar off_flags = 2;\n\t\tvar off_height = 3;\n\t\tvar off_width = 4;\n\n\t\tvar off_mipmapCount = 7;\n\n\t\tvar off_pfFlags = 20;\n\t\tvar off_pfFourCC = 21;\n\n\t\tvar off_caps = 27;\n\t\tvar off_caps2 = 28;\n\t\tvar off_caps3 = 29;\n\t\tvar off_caps4 = 30;\n\n\t\t// Parse header\n\n\t\tvar header = new Int32Array( buffer, 0, headerLengthInt );\n\n\t\tif ( header[ off_magic ] !== DDS_MAGIC ) {\n\n\t\t\tconsole.error( \"ImageUtils.parseDDS(): Invalid magic number in DDS header\" );\n\t\t\treturn dds;\n\n\t\t}\n\n\t\tif ( ! header[ off_pfFlags ] & DDPF_FOURCC ) {\n\n\t\t\tconsole.error( \"ImageUtils.parseDDS(): Unsupported format, must contain a FourCC code\" );\n\t\t\treturn dds;\n\n\t\t}\n\n\t\tvar blockBytes;\n\n\t\tvar fourCC = header[ off_pfFourCC ];\n\n\t\tswitch ( fourCC ) {\n\n\t\t\tcase FOURCC_DXT1:\n\n\t\t\t\tblockBytes = 8;\n\t\t\t\tdds.format = THREE.RGB_S3TC_DXT1_Format;\n\t\t\t\tbreak;\n\n\t\t\tcase FOURCC_DXT3:\n\n\t\t\t\tblockBytes = 16;\n\t\t\t\tdds.format = THREE.RGBA_S3TC_DXT3_Format;\n\t\t\t\tbreak;\n\n\t\t\tcase FOURCC_DXT5:\n\n\t\t\t\tblockBytes = 16;\n\t\t\t\tdds.format = THREE.RGBA_S3TC_DXT5_Format;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tconsole.error( \"ImageUtils.parseDDS(): Unsupported FourCC code: \", int32ToFourCC( fourCC ) );\n\t\t\t\treturn dds;\n\n\t\t}\n\n\t\tdds.mipmapCount = 1;\n\n\t\tif ( header[ off_flags ] & DDSD_MIPMAPCOUNT && loadMipmaps !== false ) {\n\n\t\t\tdds.mipmapCount = Math.max( 1, header[ off_mipmapCount ] );\n\n\t\t}\n\n\t\t//TODO: Verify that all faces of the cubemap are present with DDSCAPS2_CUBEMAP_POSITIVEX, etc.\n\n\t\tdds.isCubemap = header[ off_caps2 ] & DDSCAPS2_CUBEMAP ? true : false;\n\n\t\tdds.width = header[ off_width ];\n\t\tdds.height = header[ off_height ];\n\n\t\tvar dataOffset = header[ off_size ] + 4;\n\n\t\t// Extract mipmaps buffers\n\n\t\tvar width = dds.width;\n\t\tvar height = dds.height;\n\n\t\tvar faces = dds.isCubemap ? 6 : 1;\n\n\t\tfor ( var face = 0; face < faces; face ++ ) {\n\n\t\t\tfor ( var i = 0; i < dds.mipmapCount; i ++ ) {\n\n\t\t\t\tvar dataLength = Math.max( 4, width ) / 4 * Math.max( 4, height ) / 4 * blockBytes;\n\t\t\t\tvar byteArray = new Uint8Array( buffer, dataOffset, dataLength );\n\n\t\t\t\tvar mipmap = { \"data\": byteArray, \"width\": width, \"height\": height };\n\t\t\t\tdds.mipmaps.push( mipmap );\n\n\t\t\t\tdataOffset += dataLength;\n\n\t\t\t\twidth = Math.max( width * 0.5, 1 );\n\t\t\t\theight = Math.max( height * 0.5, 1 );\n\n\t\t\t}\n\n\t\t\twidth = dds.width;\n\t\t\theight = dds.height;\n\n\t\t}\n\n\t\treturn dds;\n\n\t},\n\n\tgetNormalMap: function ( image, depth ) {\n\n\t\t// Adapted from http://www.paulbrunt.co.uk/lab/heightnormal/\n\n\t\tvar cross = function ( a, b ) {\n\n\t\t\treturn [ a[ 1 ] * b[ 2 ] - a[ 2 ] * b[ 1 ], a[ 2 ] * b[ 0 ] - a[ 0 ] * b[ 2 ], a[ 0 ] * b[ 1 ] - a[ 1 ] * b[ 0 ] ];\n\n\t\t}\n\n\t\tvar subtract = function ( a, b ) {\n\n\t\t\treturn [ a[ 0 ] - b[ 0 ], a[ 1 ] - b[ 1 ], a[ 2 ] - b[ 2 ] ];\n\n\t\t}\n\n\t\tvar normalize = function ( a ) {\n\n\t\t\tvar l = Math.sqrt( a[ 0 ] * a[ 0 ] + a[ 1 ] * a[ 1 ] + a[ 2 ] * a[ 2 ] );\n\t\t\treturn [ a[ 0 ] / l, a[ 1 ] / l, a[ 2 ] / l ];\n\n\t\t}\n\n\t\tdepth = depth | 1;\n\n\t\tvar width = image.width;\n\t\tvar height = image.height;\n\n\t\tvar canvas = document.createElement( 'canvas' );\n\t\tcanvas.width = width;\n\t\tcanvas.height = height;\n\n\t\tvar context = canvas.getContext( '2d' );\n\t\tcontext.drawImage( image, 0, 0 );\n\n\t\tvar data = context.getImageData( 0, 0, width, height ).data;\n\t\tvar imageData = context.createImageData( width, height );\n\t\tvar output = imageData.data;\n\n\t\tfor ( var x = 0; x < width; x ++ ) {\n\n\t\t\tfor ( var y = 0; y < height; y ++ ) {\n\n\t\t\t\tvar ly = y - 1 < 0 ? 0 : y - 1;\n\t\t\t\tvar uy = y + 1 > height - 1 ? height - 1 : y + 1;\n\t\t\t\tvar lx = x - 1 < 0 ? 0 : x - 1;\n\t\t\t\tvar ux = x + 1 > width - 1 ? width - 1 : x + 1;\n\n\t\t\t\tvar points = [];\n\t\t\t\tvar origin = [ 0, 0, data[ ( y * width + x ) * 4 ] / 255 * depth ];\n\t\t\t\tpoints.push( [ - 1, 0, data[ ( y * width + lx ) * 4 ] / 255 * depth ] );\n\t\t\t\tpoints.push( [ - 1, - 1, data[ ( ly * width + lx ) * 4 ] / 255 * depth ] );\n\t\t\t\tpoints.push( [ 0, - 1, data[ ( ly * width + x ) * 4 ] / 255 * depth ] );\n\t\t\t\tpoints.push( [  1, - 1, data[ ( ly * width + ux ) * 4 ] / 255 * depth ] );\n\t\t\t\tpoints.push( [ 1, 0, data[ ( y * width + ux ) * 4 ] / 255 * depth ] );\n\t\t\t\tpoints.push( [ 1, 1, data[ ( uy * width + ux ) * 4 ] / 255 * depth ] );\n\t\t\t\tpoints.push( [ 0, 1, data[ ( uy * width + x ) * 4 ] / 255 * depth ] );\n\t\t\t\tpoints.push( [ - 1, 1, data[ ( uy * width + lx ) * 4 ] / 255 * depth ] );\n\n\t\t\t\tvar normals = [];\n\t\t\t\tvar num_points = points.length;\n\n\t\t\t\tfor ( var i = 0; i < num_points; i ++ ) {\n\n\t\t\t\t\tvar v1 = points[ i ];\n\t\t\t\t\tvar v2 = points[ ( i + 1 ) % num_points ];\n\t\t\t\t\tv1 = subtract( v1, origin );\n\t\t\t\t\tv2 = subtract( v2, origin );\n\t\t\t\t\tnormals.push( normalize( cross( v1, v2 ) ) );\n\n\t\t\t\t}\n\n\t\t\t\tvar normal = [ 0, 0, 0 ];\n\n\t\t\t\tfor ( var i = 0; i < normals.length; i ++ ) {\n\n\t\t\t\t\tnormal[ 0 ] += normals[ i ][ 0 ];\n\t\t\t\t\tnormal[ 1 ] += normals[ i ][ 1 ];\n\t\t\t\t\tnormal[ 2 ] += normals[ i ][ 2 ];\n\n\t\t\t\t}\n\n\t\t\t\tnormal[ 0 ] /= normals.length;\n\t\t\t\tnormal[ 1 ] /= normals.length;\n\t\t\t\tnormal[ 2 ] /= normals.length;\n\n\t\t\t\tvar idx = ( y * width + x ) * 4;\n\n\t\t\t\toutput[ idx ] = ( ( normal[ 0 ] + 1.0 ) / 2.0 * 255 ) | 0;\n\t\t\t\toutput[ idx + 1 ] = ( ( normal[ 1 ] + 1.0 ) / 2.0 * 255 ) | 0;\n\t\t\t\toutput[ idx + 2 ] = ( normal[ 2 ] * 255 ) | 0;\n\t\t\t\toutput[ idx + 3 ] = 255;\n\n\t\t\t}\n\n\t\t}\n\n\t\tcontext.putImageData( imageData, 0, 0 );\n\n\t\treturn canvas;\n\n\t},\n\n\tgenerateDataTexture: function ( width, height, color ) {\n\n\t\tvar size = width * height;\n\t\tvar data = new Uint8Array( 3 * size );\n\n\t\tvar r = Math.floor( color.r * 255 );\n\t\tvar g = Math.floor( color.g * 255 );\n\t\tvar b = Math.floor( color.b * 255 );\n\n\t\tfor ( var i = 0; i < size; i ++ ) {\n\n\t\t\tdata[ i * 3 ] \t  = r;\n\t\t\tdata[ i * 3 + 1 ] = g;\n\t\t\tdata[ i * 3 + 2 ] = b;\n\n\t\t}\n\n\t\tvar texture = new THREE.DataTexture( data, width, height, THREE.RGBFormat );\n\t\ttexture.needsUpdate = true;\n\n\t\treturn texture;\n\n\t}\n\n};\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.SceneUtils = {\n\n\tcreateMultiMaterialObject: function ( geometry, materials ) {\n\n\t\tvar group = new THREE.Object3D();\n\n\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\tgroup.add( new THREE.Mesh( geometry, materials[ i ] ) );\n\n\t\t}\n\n\t\treturn group;\n\n\t},\n\n\tdetach : function ( child, parent, scene ) {\n\n\t\tchild.applyMatrix( parent.matrixWorld );\n\t\tparent.remove( child );\n\t\tscene.add( child );\n\n\t},\n\n\tattach: function ( child, scene, parent ) {\n\n\t\tvar matrixWorldInverse = new THREE.Matrix4();\n\t\tmatrixWorldInverse.getInverse( parent.matrixWorld );\n\t\tchild.applyMatrix( matrixWorldInverse );\n\n\t\tscene.remove( child );\n\t\tparent.add( child );\n\n\t}\n\n};\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * @author alteredq / http://alteredqualia.com/\n *\n * For Text operations in three.js (See TextGeometry)\n *\n * It uses techniques used in:\n *\n * \ttypeface.js and canvastext\n * \t\tFor converting fonts and rendering with javascript\n *\t\thttp://typeface.neocracy.org\n *\n *\tTriangulation ported from AS3\n *\t\tSimple Polygon Triangulation\n *\t\thttp://actionsnippet.com/?p=1462\n *\n * \tA Method to triangulate shapes with holes\n *\t\thttp://www.sakri.net/blog/2009/06/12/an-approach-to-triangulating-polygons-with-holes/\n *\n */\n\nTHREE.FontUtils = {\n\n\tfaces : {},\n\n\t// Just for now. face[weight][style]\n\n\tface : \"helvetiker\",\n\tweight: \"normal\",\n\tstyle : \"normal\",\n\tsize : 150,\n\tdivisions : 10,\n\n\tgetFace : function() {\n\n\t\treturn this.faces[ this.face ][ this.weight ][ this.style ];\n\n\t},\n\n\tloadFace : function( data ) {\n\n\t\tvar family = data.familyName.toLowerCase();\n\n\t\tvar ThreeFont = this;\n\n\t\tThreeFont.faces[ family ] = ThreeFont.faces[ family ] || {};\n\n\t\tThreeFont.faces[ family ][ data.cssFontWeight ] = ThreeFont.faces[ family ][ data.cssFontWeight ] || {};\n\t\tThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;\n\n\t\tvar face = ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;\n\n\t\treturn data;\n\n\t},\n\n\tdrawText : function( text ) {\n\n\t\tvar characterPts = [], allPts = [];\n\n\t\t// RenderText\n\n\t\tvar i, p,\n\t\t\tface = this.getFace(),\n\t\t\tscale = this.size / face.resolution,\n\t\t\toffset = 0,\n\t\t\tchars = String( text ).split( '' ),\n\t\t\tlength = chars.length;\n\n\t\tvar fontPaths = [];\n\n\t\tfor ( i = 0; i < length; i ++ ) {\n\n\t\t\tvar path = new THREE.Path();\n\n\t\t\tvar ret = this.extractGlyphPoints( chars[ i ], face, scale, offset, path );\n\t\t\toffset += ret.offset;\n\n\t\t\tfontPaths.push( ret.path );\n\n\t\t}\n\n\t\t// get the width\n\n\t\tvar width = offset / 2;\n\t\t//\n\t\t// for ( p = 0; p < allPts.length; p++ ) {\n\t\t//\n\t\t// \tallPts[ p ].x -= width;\n\t\t//\n\t\t// }\n\n\t\t//var extract = this.extractPoints( allPts, characterPts );\n\t\t//extract.contour = allPts;\n\n\t\t//extract.paths = fontPaths;\n\t\t//extract.offset = width;\n\n\t\treturn { paths : fontPaths, offset : width };\n\n\t},\n\n\n\n\n\textractGlyphPoints : function( c, face, scale, offset, path ) {\n\n\t\tvar pts = [];\n\n\t\tvar i, i2, divisions,\n\t\t\toutline, action, length,\n\t\t\tscaleX, scaleY,\n\t\t\tx, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2,\n\t\t\tlaste,\n\t\t\tglyph = face.glyphs[ c ] || face.glyphs[ '?' ];\n\n\t\tif ( !glyph ) return;\n\n\t\tif ( glyph.o ) {\n\n\t\t\toutline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );\n\t\t\tlength = outline.length;\n\n\t\t\tscaleX = scale;\n\t\t\tscaleY = scale;\n\n\t\t\tfor ( i = 0; i < length; ) {\n\n\t\t\t\taction = outline[ i ++ ];\n\n\t\t\t\t//console.log( action );\n\n\t\t\t\tswitch( action ) {\n\n\t\t\t\tcase 'm':\n\n\t\t\t\t\t// Move To\n\n\t\t\t\t\tx = outline[ i++ ] * scaleX + offset;\n\t\t\t\t\ty = outline[ i++ ] * scaleY;\n\n\t\t\t\t\tpath.moveTo( x, y );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'l':\n\n\t\t\t\t\t// Line To\n\n\t\t\t\t\tx = outline[ i++ ] * scaleX + offset;\n\t\t\t\t\ty = outline[ i++ ] * scaleY;\n\t\t\t\t\tpath.lineTo(x,y);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'q':\n\n\t\t\t\t\t// QuadraticCurveTo\n\n\t\t\t\t\tcpx  = outline[ i++ ] * scaleX + offset;\n\t\t\t\t\tcpy  = outline[ i++ ] * scaleY;\n\t\t\t\t\tcpx1 = outline[ i++ ] * scaleX + offset;\n\t\t\t\t\tcpy1 = outline[ i++ ] * scaleY;\n\n\t\t\t\t\tpath.quadraticCurveTo(cpx1, cpy1, cpx, cpy);\n\n\t\t\t\t\tlaste = pts[ pts.length - 1 ];\n\n\t\t\t\t\tif ( laste ) {\n\n\t\t\t\t\t\tcpx0 = laste.x;\n\t\t\t\t\t\tcpy0 = laste.y;\n\n\t\t\t\t\t\tfor ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {\n\n\t\t\t\t\t\t\tvar t = i2 / divisions;\n\t\t\t\t\t\t\tvar tx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );\n\t\t\t\t\t\t\tvar ty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );\n\t\t\t\t\t  }\n\n\t\t\t\t  }\n\n\t\t\t\t  break;\n\n\t\t\t\tcase 'b':\n\n\t\t\t\t\t// Cubic Bezier Curve\n\n\t\t\t\t\tcpx  = outline[ i++ ] *  scaleX + offset;\n\t\t\t\t\tcpy  = outline[ i++ ] *  scaleY;\n\t\t\t\t\tcpx1 = outline[ i++ ] *  scaleX + offset;\n\t\t\t\t\tcpy1 = outline[ i++ ] * -scaleY;\n\t\t\t\t\tcpx2 = outline[ i++ ] *  scaleX + offset;\n\t\t\t\t\tcpy2 = outline[ i++ ] * -scaleY;\n\n\t\t\t\t\tpath.bezierCurveTo( cpx, cpy, cpx1, cpy1, cpx2, cpy2 );\n\n\t\t\t\t\tlaste = pts[ pts.length - 1 ];\n\n\t\t\t\t\tif ( laste ) {\n\n\t\t\t\t\t\tcpx0 = laste.x;\n\t\t\t\t\t\tcpy0 = laste.y;\n\n\t\t\t\t\t\tfor ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {\n\n\t\t\t\t\t\t\tvar t = i2 / divisions;\n\t\t\t\t\t\t\tvar tx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );\n\t\t\t\t\t\t\tvar ty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\n\n\t\treturn { offset: glyph.ha*scale, path:path};\n\t}\n\n};\n\n\nTHREE.FontUtils.generateShapes = function( text, parameters ) {\n\n\t// Parameters \n\n\tparameters = parameters || {};\n\n\tvar size = parameters.size !== undefined ? parameters.size : 100;\n\tvar curveSegments = parameters.curveSegments !== undefined ? parameters.curveSegments: 4;\n\n\tvar font = parameters.font !== undefined ? parameters.font : \"helvetiker\";\n\tvar weight = parameters.weight !== undefined ? parameters.weight : \"normal\";\n\tvar style = parameters.style !== undefined ? parameters.style : \"normal\";\n\n\tTHREE.FontUtils.size = size;\n\tTHREE.FontUtils.divisions = curveSegments;\n\n\tTHREE.FontUtils.face = font;\n\tTHREE.FontUtils.weight = weight;\n\tTHREE.FontUtils.style = style;\n\n\t// Get a Font data json object\n\n\tvar data = THREE.FontUtils.drawText( text );\n\n\tvar paths = data.paths;\n\tvar shapes = [];\n\n\tfor ( var p = 0, pl = paths.length; p < pl; p ++ ) {\n\n\t\tArray.prototype.push.apply( shapes, paths[ p ].toShapes() );\n\n\t}\n\n\treturn shapes;\n\n};\n\n\n/**\n * This code is a quick port of code written in C++ which was submitted to\n * flipcode.com by John W. Ratcliff  // July 22, 2000\n * See original code and more information here:\n * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml\n *\n * ported to actionscript by Zevan Rosser\n * www.actionsnippet.com\n *\n * ported to javascript by Joshua Koo\n * http://www.lab4games.net/zz85/blog\n *\n */\n\n\n( function( namespace ) {\n\n\tvar EPSILON = 0.0000000001;\n\n\t// takes in an contour array and returns\n\n\tvar process = function( contour, indices ) {\n\n\t\tvar n = contour.length;\n\n\t\tif ( n < 3 ) return null;\n\n\t\tvar result = [],\n\t\t\tverts = [],\n\t\t\tvertIndices = [];\n\n\t\t/* we want a counter-clockwise polygon in verts */\n\n\t\tvar u, v, w;\n\n\t\tif ( area( contour ) > 0.0 ) {\n\n\t\t\tfor ( v = 0; v < n; v++ ) verts[ v ] = v;\n\n\t\t} else {\n\n\t\t\tfor ( v = 0; v < n; v++ ) verts[ v ] = ( n - 1 ) - v;\n\n\t\t}\n\n\t\tvar nv = n;\n\n\t\t/*  remove nv - 2 vertices, creating 1 triangle every time */\n\n\t\tvar count = 2 * nv;   /* error detection */\n\n\t\tfor( v = nv - 1; nv > 2; ) {\n\n\t\t\t/* if we loop, it is probably a non-simple polygon */\n\n\t\t\tif ( ( count-- ) <= 0 ) {\n\n\t\t\t\t//** Triangulate: ERROR - probable bad polygon!\n\n\t\t\t\t//throw ( \"Warning, unable to triangulate polygon!\" );\n\t\t\t\t//return null;\n\t\t\t\t// Sometimes warning is fine, especially polygons are triangulated in reverse.\n\t\t\t\tconsole.log( \"Warning, unable to triangulate polygon!\" );\n\n\t\t\t\tif ( indices ) return vertIndices;\n\t\t\t\treturn result;\n\n\t\t\t}\n\n\t\t\t/* three consecutive vertices in current polygon, <u,v,w> */\n\n\t\t\tu = v; \t \tif ( nv <= u ) u = 0;     /* previous */\n\t\t\tv = u + 1;  if ( nv <= v ) v = 0;     /* new v    */\n\t\t\tw = v + 1;  if ( nv <= w ) w = 0;     /* next     */\n\n\t\t\tif ( snip( contour, u, v, w, nv, verts ) ) {\n\n\t\t\t\tvar a, b, c, s, t;\n\n\t\t\t\t/* true names of the vertices */\n\n\t\t\t\ta = verts[ u ];\n\t\t\t\tb = verts[ v ];\n\t\t\t\tc = verts[ w ];\n\n\t\t\t\t/* output Triangle */\n\n\t\t\t\tresult.push( [ contour[ a ],\n\t\t\t\t\tcontour[ b ],\n\t\t\t\t\tcontour[ c ] ] );\n\n\n\t\t\t\tvertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );\n\n\t\t\t\t/* remove v from the remaining polygon */\n\n\t\t\t\tfor( s = v, t = v + 1; t < nv; s++, t++ ) {\n\n\t\t\t\t\tverts[ s ] = verts[ t ];\n\n\t\t\t\t}\n\n\t\t\t\tnv--;\n\n\t\t\t\t/* reset error detection counter */\n\n\t\t\t\tcount = 2 * nv;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( indices ) return vertIndices;\n\t\treturn result;\n\n\t};\n\n\t// calculate area of the contour polygon\n\n\tvar area = function ( contour ) {\n\n\t\tvar n = contour.length;\n\t\tvar a = 0.0;\n\n\t\tfor( var p = n - 1, q = 0; q < n; p = q++ ) {\n\n\t\t\ta += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\n\n\t\t}\n\n\t\treturn a * 0.5;\n\n\t};\n\n\tvar snip = function ( contour, u, v, w, n, verts ) {\n\n\t\tvar p;\n\t\tvar ax, ay, bx, by;\n\t\tvar cx, cy, px, py;\n\n\t\tax = contour[ verts[ u ] ].x;\n\t\tay = contour[ verts[ u ] ].y;\n\n\t\tbx = contour[ verts[ v ] ].x;\n\t\tby = contour[ verts[ v ] ].y;\n\n\t\tcx = contour[ verts[ w ] ].x;\n\t\tcy = contour[ verts[ w ] ].y;\n\n\t\tif ( EPSILON > (((bx-ax)*(cy-ay)) - ((by-ay)*(cx-ax))) ) return false;\n\n\t\tvar aX, aY, bX, bY, cX, cY;\n\t\tvar apx, apy, bpx, bpy, cpx, cpy;\n\t\tvar cCROSSap, bCROSScp, aCROSSbp;\n\n\t\taX = cx - bx;  aY = cy - by;\n\t\tbX = ax - cx;  bY = ay - cy;\n\t\tcX = bx - ax;  cY = by - ay;\n\n\t\tfor ( p = 0; p < n; p++ ) {\n\n\t\t\tif( (p === u) || (p === v) || (p === w) ) continue;\n\n\t\t\tpx = contour[ verts[ p ] ].x\n\t\t\tpy = contour[ verts[ p ] ].y\n\n\t\t\tapx = px - ax;  apy = py - ay;\n\t\t\tbpx = px - bx;  bpy = py - by;\n\t\t\tcpx = px - cx;  cpy = py - cy;\n\n\t\t\t// see if p is inside triangle abc\n\n\t\t\taCROSSbp = aX*bpy - aY*bpx;\n\t\t\tcCROSSap = cX*apy - cY*apx;\n\t\t\tbCROSScp = bX*cpy - bY*cpx;\n\n\t\t\tif ( (aCROSSbp >= 0.0) && (bCROSScp >= 0.0) && (cCROSSap >= 0.0) ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t};\n\n\n\tnamespace.Triangulate = process;\n\tnamespace.Triangulate.area = area;\n\n\treturn namespace;\n\n})(THREE.FontUtils);\n\n// To use the typeface.js face files, hook up the API\nself._typeface_js = { faces: THREE.FontUtils.faces, loadFace: THREE.FontUtils.loadFace };/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * Extensible curve object\n *\n * Some common of Curve methods\n * .getPoint(t), getTangent(t)\n * .getPointAt(u), getTagentAt(u)\n * .getPoints(), .getSpacedPoints()\n * .getLength()\n * .updateArcLengths()\n *\n * This file contains following classes:\n *\n * -- 2d classes --\n * THREE.Curve\n * THREE.LineCurve\n * THREE.QuadraticBezierCurve\n * THREE.CubicBezierCurve\n * THREE.SplineCurve\n * THREE.ArcCurve\n * THREE.EllipseCurve\n *\n * -- 3d classes --\n * THREE.LineCurve3\n * THREE.QuadraticBezierCurve3\n * THREE.CubicBezierCurve3\n * THREE.SplineCurve3\n * THREE.ClosedSplineCurve3\n *\n * A series of curves can be represented as a THREE.CurvePath\n *\n **/\n\n/**************************************************************\n *\tAbstract Curve base class\n **************************************************************/\n\nTHREE.Curve = function () {\n\n};\n\n// Virtual base class method to overwrite and implement in subclasses\n//\t- t [0 .. 1]\n\nTHREE.Curve.prototype.getPoint = function ( t ) {\n\n\tconsole.log( \"Warning, getPoint() not implemented!\" );\n\treturn null;\n\n};\n\n// Get point at relative position in curve according to arc length\n// - u [0 .. 1]\n\nTHREE.Curve.prototype.getPointAt = function ( u ) {\n\n\tvar t = this.getUtoTmapping( u );\n\treturn this.getPoint( t );\n\n};\n\n// Get sequence of points using getPoint( t )\n\nTHREE.Curve.prototype.getPoints = function ( divisions ) {\n\n\tif ( !divisions ) divisions = 5;\n\n\tvar d, pts = [];\n\n\tfor ( d = 0; d <= divisions; d ++ ) {\n\n\t\tpts.push( this.getPoint( d / divisions ) );\n\n\t}\n\n\treturn pts;\n\n};\n\n// Get sequence of points using getPointAt( u )\n\nTHREE.Curve.prototype.getSpacedPoints = function ( divisions ) {\n\n\tif ( !divisions ) divisions = 5;\n\n\tvar d, pts = [];\n\n\tfor ( d = 0; d <= divisions; d ++ ) {\n\n\t\tpts.push( this.getPointAt( d / divisions ) );\n\n\t}\n\n\treturn pts;\n\n};\n\n// Get total curve arc length\n\nTHREE.Curve.prototype.getLength = function () {\n\n\tvar lengths = this.getLengths();\n\treturn lengths[ lengths.length - 1 ];\n\n};\n\n// Get list of cumulative segment lengths\n\nTHREE.Curve.prototype.getLengths = function ( divisions ) {\n\n\tif ( !divisions ) divisions = (this.__arcLengthDivisions) ? (this.__arcLengthDivisions): 200;\n\n\tif ( this.cacheArcLengths\n\t\t&& ( this.cacheArcLengths.length == divisions + 1 )\n\t\t&& !this.needsUpdate) {\n\n\t\t//console.log( \"cached\", this.cacheArcLengths );\n\t\treturn this.cacheArcLengths;\n\n\t}\n\n\tthis.needsUpdate = false;\n\n\tvar cache = [];\n\tvar current, last = this.getPoint( 0 );\n\tvar p, sum = 0;\n\n\tcache.push( 0 );\n\n\tfor ( p = 1; p <= divisions; p ++ ) {\n\n\t\tcurrent = this.getPoint ( p / divisions );\n\t\tsum += current.distanceTo( last );\n\t\tcache.push( sum );\n\t\tlast = current;\n\n\t}\n\n\tthis.cacheArcLengths = cache;\n\n\treturn cache; // { sums: cache, sum:sum }; Sum is in the last element.\n\n};\n\n\nTHREE.Curve.prototype.updateArcLengths = function() {\n\tthis.needsUpdate = true;\n\tthis.getLengths();\n};\n\n// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance\n\nTHREE.Curve.prototype.getUtoTmapping = function ( u, distance ) {\n\n\tvar arcLengths = this.getLengths();\n\n\tvar i = 0, il = arcLengths.length;\n\n\tvar targetArcLength; // The targeted u distance value to get\n\n\tif ( distance ) {\n\n\t\ttargetArcLength = distance;\n\n\t} else {\n\n\t\ttargetArcLength = u * arcLengths[ il - 1 ];\n\n\t}\n\n\t//var time = Date.now();\n\n\t// binary search for the index with largest value smaller than target u distance\n\n\tvar low = 0, high = il - 1, comparison;\n\n\twhile ( low <= high ) {\n\n\t\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\n\n\t\tcomparison = arcLengths[ i ] - targetArcLength;\n\n\t\tif ( comparison < 0 ) {\n\n\t\t\tlow = i + 1;\n\t\t\tcontinue;\n\n\t\t} else if ( comparison > 0 ) {\n\n\t\t\thigh = i - 1;\n\t\t\tcontinue;\n\n\t\t} else {\n\n\t\t\thigh = i;\n\t\t\tbreak;\n\n\t\t\t// DONE\n\n\t\t}\n\n\t}\n\n\ti = high;\n\n\t//console.log('b' , i, low, high, Date.now()- time);\n\n\tif ( arcLengths[ i ] == targetArcLength ) {\n\n\t\tvar t = i / ( il - 1 );\n\t\treturn t;\n\n\t}\n\n\t// we could get finer grain at lengths, or use simple interpolatation between two points\n\n\tvar lengthBefore = arcLengths[ i ];\n    var lengthAfter = arcLengths[ i + 1 ];\n\n    var segmentLength = lengthAfter - lengthBefore;\n\n    // determine where we are between the 'before' and 'after' points\n\n    var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\n\n    // add that fractional amount to t\n\n    var t = ( i + segmentFraction ) / ( il -1 );\n\n\treturn t;\n\n};\n\n// Returns a unit vector tangent at t\n// In case any sub curve does not implement its tangent derivation,\n// 2 points a small delta apart will be used to find its gradient\n// which seems to give a reasonable approximation\n\nTHREE.Curve.prototype.getTangent = function( t ) {\n\n\tvar delta = 0.0001;\n\tvar t1 = t - delta;\n\tvar t2 = t + delta;\n\n\t// Capping in case of danger\n\n\tif ( t1 < 0 ) t1 = 0;\n\tif ( t2 > 1 ) t2 = 1;\n\n\tvar pt1 = this.getPoint( t1 );\n\tvar pt2 = this.getPoint( t2 );\n\n\tvar vec = pt2.clone().sub(pt1);\n\treturn vec.normalize();\n\n};\n\n\nTHREE.Curve.prototype.getTangentAt = function ( u ) {\n\n\tvar t = this.getUtoTmapping( u );\n\treturn this.getTangent( t );\n\n};\n\n/**************************************************************\n *\tLine\n **************************************************************/\n\nTHREE.LineCurve = function ( v1, v2 ) {\n\n\tthis.v1 = v1;\n\tthis.v2 = v2;\n\n};\n\nTHREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );\n\nTHREE.LineCurve.prototype.getPoint = function ( t ) {\n\n\tvar point = this.v2.clone().sub(this.v1);\n\tpoint.multiplyScalar( t ).add( this.v1 );\n\n\treturn point;\n\n};\n\n// Line curve is linear, so we can overwrite default getPointAt\n\nTHREE.LineCurve.prototype.getPointAt = function ( u ) {\n\n\treturn this.getPoint( u );\n\n};\n\nTHREE.LineCurve.prototype.getTangent = function( t ) {\n\n\tvar tangent = this.v2.clone().sub(this.v1);\n\n\treturn tangent.normalize();\n\n};\n\n/**************************************************************\n *\tQuadratic Bezier curve\n **************************************************************/\n\n\nTHREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {\n\n\tthis.v0 = v0;\n\tthis.v1 = v1;\n\tthis.v2 = v2;\n\n};\n\nTHREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );\n\n\nTHREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {\n\n\tvar tx, ty;\n\n\ttx = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );\n\tty = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );\n\n\treturn new THREE.Vector2( tx, ty );\n\n};\n\n\nTHREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {\n\n\tvar tx, ty;\n\n\ttx = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x );\n\tty = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y );\n\n\t// returns unit vector\n\n\tvar tangent = new THREE.Vector2( tx, ty );\n\ttangent.normalize();\n\n\treturn tangent;\n\n};\n\n\n/**************************************************************\n *\tCubic Bezier curve\n **************************************************************/\n\nTHREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {\n\n\tthis.v0 = v0;\n\tthis.v1 = v1;\n\tthis.v2 = v2;\n\tthis.v3 = v3;\n\n};\n\nTHREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );\n\nTHREE.CubicBezierCurve.prototype.getPoint = function ( t ) {\n\n\tvar tx, ty;\n\n\ttx = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );\n\tty = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );\n\n\treturn new THREE.Vector2( tx, ty );\n\n};\n\nTHREE.CubicBezierCurve.prototype.getTangent = function( t ) {\n\n\tvar tx, ty;\n\n\ttx = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );\n\tty = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );\n\n\tvar tangent = new THREE.Vector2( tx, ty );\n\ttangent.normalize();\n\n\treturn tangent;\n\n};\n\n\n/**************************************************************\n *\tSpline curve\n **************************************************************/\n\nTHREE.SplineCurve = function ( points /* array of Vector2 */ ) {\n\n\tthis.points = (points == undefined) ? [] : points;\n\n};\n\nTHREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );\n\nTHREE.SplineCurve.prototype.getPoint = function ( t ) {\n\n\tvar v = new THREE.Vector2();\n\tvar c = [];\n\tvar points = this.points, point, intPoint, weight;\n\tpoint = ( points.length - 1 ) * t;\n\n\tintPoint = Math.floor( point );\n\tweight = point - intPoint;\n\n\tc[ 0 ] = intPoint == 0 ? intPoint : intPoint - 1;\n\tc[ 1 ] = intPoint;\n\tc[ 2 ] = intPoint  > points.length - 2 ? points.length -1 : intPoint + 1;\n\tc[ 3 ] = intPoint  > points.length - 3 ? points.length -1 : intPoint + 2;\n\n\tv.x = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].x, points[ c[ 1 ] ].x, points[ c[ 2 ] ].x, points[ c[ 3 ] ].x, weight );\n\tv.y = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].y, points[ c[ 1 ] ].y, points[ c[ 2 ] ].y, points[ c[ 3 ] ].y, weight );\n\n\treturn v;\n\n};\n\n/**************************************************************\n *\tEllipse curve\n **************************************************************/\n\nTHREE.EllipseCurve = function ( aX, aY, xRadius, yRadius,\n\t\t\t\t\t\t\taStartAngle, aEndAngle,\n\t\t\t\t\t\t\taClockwise ) {\n\n\tthis.aX = aX;\n\tthis.aY = aY;\n\n\tthis.xRadius = xRadius;\n\tthis.yRadius = yRadius;\n\n\tthis.aStartAngle = aStartAngle;\n\tthis.aEndAngle = aEndAngle;\n\n\tthis.aClockwise = aClockwise;\n\n};\n\nTHREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );\n\nTHREE.EllipseCurve.prototype.getPoint = function ( t ) {\n\n\tvar deltaAngle = this.aEndAngle - this.aStartAngle;\n\n\tif ( !this.aClockwise ) {\n\n\t\tt = 1 - t;\n\n\t}\n\n\tvar angle = this.aStartAngle + t * deltaAngle;\n\n\tvar tx = this.aX + this.xRadius * Math.cos( angle );\n\tvar ty = this.aY + this.yRadius * Math.sin( angle );\n\n\treturn new THREE.Vector2( tx, ty );\n\n};\n\n/**************************************************************\n *\tArc curve\n **************************************************************/\n\nTHREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\tTHREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n};\n\nTHREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );\n\n\n/**************************************************************\n *\tUtils\n **************************************************************/\n\nTHREE.Curve.Utils = {\n\n\ttangentQuadraticBezier: function ( t, p0, p1, p2 ) {\n\n\t\treturn 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );\n\n\t},\n\n\t// Puay Bing, thanks for helping with this derivative!\n\n\ttangentCubicBezier: function (t, p0, p1, p2, p3 ) {\n\n\t\treturn -3 * p0 * (1 - t) * (1 - t)  +\n\t\t\t3 * p1 * (1 - t) * (1-t) - 6 *t *p1 * (1-t) +\n\t\t\t6 * t *  p2 * (1-t) - 3 * t * t * p2 +\n\t\t\t3 * t * t * p3;\n\t},\n\n\n\ttangentSpline: function ( t, p0, p1, p2, p3 ) {\n\n\t\t// To check if my formulas are correct\n\n\t\tvar h00 = 6 * t * t - 6 * t; \t// derived from 2t^3 - 3t^2 + 1\n\t\tvar h10 = 3 * t * t - 4 * t + 1; // t^3 - 2t^2 + t\n\t\tvar h01 = -6 * t * t + 6 * t; \t// - 2t3 + 3t2\n\t\tvar h11 = 3 * t * t - 2 * t;\t// t3 - t2\n\n\t\treturn h00 + h10 + h01 + h11;\n\n\t},\n\n\t// Catmull-Rom\n\n\tinterpolate: function( p0, p1, p2, p3, t ) {\n\n\t\tvar v0 = ( p2 - p0 ) * 0.5;\n\t\tvar v1 = ( p3 - p1 ) * 0.5;\n\t\tvar t2 = t * t;\n\t\tvar t3 = t * t2;\n\t\treturn ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\n\t}\n\n};\n\n\n// TODO: Transformation for Curves?\n\n/**************************************************************\n *\t3D Curves\n **************************************************************/\n\n// A Factory method for creating new curve subclasses\n\nTHREE.Curve.create = function ( constructor, getPointFunc ) {\n\n\tconstructor.prototype = Object.create( THREE.Curve.prototype );\n\tconstructor.prototype.getPoint = getPointFunc;\n\n\treturn constructor;\n\n};\n\n\n/**************************************************************\n *\tLine3D\n **************************************************************/\n\nTHREE.LineCurve3 = THREE.Curve.create(\n\n\tfunction ( v1, v2 ) {\n\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t},\n\n\tfunction ( t ) {\n\n\t\tvar r = new THREE.Vector3();\n\n\n\t\tr.subVectors( this.v2, this.v1 ); // diff\n\t\tr.multiplyScalar( t );\n\t\tr.add( this.v1 );\n\n\t\treturn r;\n\n\t}\n\n);\n\n\n/**************************************************************\n *\tQuadratic Bezier 3D curve\n **************************************************************/\n\nTHREE.QuadraticBezierCurve3 = THREE.Curve.create(\n\n\tfunction ( v0, v1, v2 ) {\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t},\n\n\tfunction ( t ) {\n\n\t\tvar tx, ty, tz;\n\n\t\ttx = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );\n\t\tty = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );\n\t\ttz = THREE.Shape.Utils.b2( t, this.v0.z, this.v1.z, this.v2.z );\n\n\t\treturn new THREE.Vector3( tx, ty, tz );\n\n\t}\n\n);\n\n\n\n/**************************************************************\n *\tCubic Bezier 3D curve\n **************************************************************/\n\nTHREE.CubicBezierCurve3 = THREE.Curve.create(\n\n\tfunction ( v0, v1, v2, v3 ) {\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\t\tthis.v3 = v3;\n\n\t},\n\n\tfunction ( t ) {\n\n\t\tvar tx, ty, tz;\n\n\t\ttx = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );\n\t\tty = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );\n\t\ttz = THREE.Shape.Utils.b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z );\n\n\t\treturn new THREE.Vector3( tx, ty, tz );\n\n\t}\n\n);\n\n\n\n/**************************************************************\n *\tSpline 3D curve\n **************************************************************/\n\n\nTHREE.SplineCurve3 = THREE.Curve.create(\n\n\tfunction ( points /* array of Vector3 */) {\n\n\t\tthis.points = (points == undefined) ? [] : points;\n\n\t},\n\n\tfunction ( t ) {\n\n\t\tvar v = new THREE.Vector3();\n\t\tvar c = [];\n\t\tvar points = this.points, point, intPoint, weight;\n\t\tpoint = ( points.length - 1 ) * t;\n\n\t\tintPoint = Math.floor( point );\n\t\tweight = point - intPoint;\n\n\t\tc[ 0 ] = intPoint == 0 ? intPoint : intPoint - 1;\n\t\tc[ 1 ] = intPoint;\n\t\tc[ 2 ] = intPoint  > points.length - 2 ? points.length - 1 : intPoint + 1;\n\t\tc[ 3 ] = intPoint  > points.length - 3 ? points.length - 1 : intPoint + 2;\n\n\t\tvar pt0 = points[ c[0] ],\n\t\t\tpt1 = points[ c[1] ],\n\t\t\tpt2 = points[ c[2] ],\n\t\t\tpt3 = points[ c[3] ];\n\n\t\tv.x = THREE.Curve.Utils.interpolate(pt0.x, pt1.x, pt2.x, pt3.x, weight);\n\t\tv.y = THREE.Curve.Utils.interpolate(pt0.y, pt1.y, pt2.y, pt3.y, weight);\n\t\tv.z = THREE.Curve.Utils.interpolate(pt0.z, pt1.z, pt2.z, pt3.z, weight);\n\n\t\treturn v;\n\n\t}\n\n);\n\n\n// THREE.SplineCurve3.prototype.getTangent = function(t) {\n// \t\tvar v = new THREE.Vector3();\n// \t\tvar c = [];\n// \t\tvar points = this.points, point, intPoint, weight;\n// \t\tpoint = ( points.length - 1 ) * t;\n\n// \t\tintPoint = Math.floor( point );\n// \t\tweight = point - intPoint;\n\n// \t\tc[ 0 ] = intPoint == 0 ? intPoint : intPoint - 1;\n// \t\tc[ 1 ] = intPoint;\n// \t\tc[ 2 ] = intPoint  > points.length - 2 ? points.length - 1 : intPoint + 1;\n// \t\tc[ 3 ] = intPoint  > points.length - 3 ? points.length - 1 : intPoint + 2;\n\n// \t\tvar pt0 = points[ c[0] ],\n// \t\t\tpt1 = points[ c[1] ],\n// \t\t\tpt2 = points[ c[2] ],\n// \t\t\tpt3 = points[ c[3] ];\n\n// \t// t = weight;\n// \tv.x = THREE.Curve.Utils.tangentSpline( t, pt0.x, pt1.x, pt2.x, pt3.x );\n// \tv.y = THREE.Curve.Utils.tangentSpline( t, pt0.y, pt1.y, pt2.y, pt3.y );\n// \tv.z = THREE.Curve.Utils.tangentSpline( t, pt0.z, pt1.z, pt2.z, pt3.z );\n\n// \treturn v;\n\n// }\n\n/**************************************************************\n *\tClosed Spline 3D curve\n **************************************************************/\n\n\nTHREE.ClosedSplineCurve3 = THREE.Curve.create(\n\n\tfunction ( points /* array of Vector3 */) {\n\n\t\tthis.points = (points == undefined) ? [] : points;\n\n\t},\n\n    function ( t ) {\n\n        var v = new THREE.Vector3();\n        var c = [];\n        var points = this.points, point, intPoint, weight;\n        point = ( points.length - 0 ) * t;\n            // This needs to be from 0-length +1\n\n        intPoint = Math.floor( point );\n        weight = point - intPoint;\n\n        intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;\n        c[ 0 ] = ( intPoint - 1 ) % points.length;\n        c[ 1 ] = ( intPoint ) % points.length;\n        c[ 2 ] = ( intPoint + 1 ) % points.length;\n        c[ 3 ] = ( intPoint + 2 ) % points.length;\n\n        v.x = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].x, points[ c[ 1 ] ].x, points[ c[ 2 ] ].x, points[ c[ 3 ] ].x, weight );\n        v.y = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].y, points[ c[ 1 ] ].y, points[ c[ 2 ] ].y, points[ c[ 3 ] ].y, weight );\n        v.z = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].z, points[ c[ 1 ] ].z, points[ c[ 2 ] ].z, points[ c[ 3 ] ].z, weight );\n\n        return v;\n\n    }\n\n);\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n *\n **/\n\n/**************************************************************\n *\tCurved Path - a curve path is simply a array of connected\n *  curves, but retains the api of a curve\n **************************************************************/\n\nTHREE.CurvePath = function () {\n\n\tthis.curves = [];\n\tthis.bends = [];\n\t\n\tthis.autoClose = false; // Automatically closes the path\n};\n\nTHREE.CurvePath.prototype = Object.create( THREE.Curve.prototype );\n\nTHREE.CurvePath.prototype.add = function ( curve ) {\n\n\tthis.curves.push( curve );\n\n};\n\nTHREE.CurvePath.prototype.checkConnection = function() {\n\t// TODO\n\t// If the ending of curve is not connected to the starting\n\t// or the next curve, then, this is not a real path\n};\n\nTHREE.CurvePath.prototype.closePath = function() {\n\t// TODO Test\n\t// and verify for vector3 (needs to implement equals)\n\t// Add a line curve if start and end of lines are not connected\n\tvar startPoint = this.curves[0].getPoint(0);\n\tvar endPoint = this.curves[this.curves.length-1].getPoint(1);\n\t\n\tif (!startPoint.equals(endPoint)) {\n\t\tthis.curves.push( new THREE.LineCurve(endPoint, startPoint) );\n\t}\n\t\n};\n\n// To get accurate point with reference to\n// entire path distance at time t,\n// following has to be done:\n\n// 1. Length of each sub path have to be known\n// 2. Locate and identify type of curve\n// 3. Get t for the curve\n// 4. Return curve.getPointAt(t')\n\nTHREE.CurvePath.prototype.getPoint = function( t ) {\n\n\tvar d = t * this.getLength();\n\tvar curveLengths = this.getCurveLengths();\n\tvar i = 0, diff, curve;\n\n\t// To think about boundaries points.\n\n\twhile ( i < curveLengths.length ) {\n\n\t\tif ( curveLengths[ i ] >= d ) {\n\n\t\t\tdiff = curveLengths[ i ] - d;\n\t\t\tcurve = this.curves[ i ];\n\n\t\t\tvar u = 1 - diff / curve.getLength();\n\n\t\t\treturn curve.getPointAt( u );\n\n\t\t\tbreak;\n\t\t}\n\n\t\ti ++;\n\n\t}\n\n\treturn null;\n\n\t// loop where sum != 0, sum > d , sum+1 <d\n\n};\n\n/*\nTHREE.CurvePath.prototype.getTangent = function( t ) {\n};*/\n\n\n// We cannot use the default THREE.Curve getPoint() with getLength() because in\n// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\n// getPoint() depends on getLength\n\nTHREE.CurvePath.prototype.getLength = function() {\n\n\tvar lens = this.getCurveLengths();\n\treturn lens[ lens.length - 1 ];\n\n};\n\n// Compute lengths and cache them\n// We cannot overwrite getLengths() because UtoT mapping uses it.\n\nTHREE.CurvePath.prototype.getCurveLengths = function() {\n\n\t// We use cache values if curves and cache array are same length\n\n\tif ( this.cacheLengths && this.cacheLengths.length == this.curves.length ) {\n\n\t\treturn this.cacheLengths;\n\n\t};\n\n\t// Get length of subsurve\n\t// Push sums into cached array\n\n\tvar lengths = [], sums = 0;\n\tvar i, il = this.curves.length;\n\n\tfor ( i = 0; i < il; i ++ ) {\n\n\t\tsums += this.curves[ i ].getLength();\n\t\tlengths.push( sums );\n\n\t}\n\n\tthis.cacheLengths = lengths;\n\n\treturn lengths;\n\n};\n\n\n\n// Returns min and max coordinates, as well as centroid\n\nTHREE.CurvePath.prototype.getBoundingBox = function () {\n\n\tvar points = this.getPoints();\n\n\tvar maxX, maxY, maxZ;\n\tvar minX, minY, minZ;\n\n\tmaxX = maxY = Number.NEGATIVE_INFINITY;\n\tminX = minY = Number.POSITIVE_INFINITY;\n\n\tvar p, i, il, sum;\n\n\tvar v3 = points[0] instanceof THREE.Vector3;\n\n\tsum = v3 ? new THREE.Vector3() : new THREE.Vector2();\n\n\tfor ( i = 0, il = points.length; i < il; i ++ ) {\n\n\t\tp = points[ i ];\n\n\t\tif ( p.x > maxX ) maxX = p.x;\n\t\telse if ( p.x < minX ) minX = p.x;\n\n\t\tif ( p.y > maxY ) maxY = p.y;\n\t\telse if ( p.y < minY ) minY = p.y;\n\n\t\tif ( v3 ) {\n\n\t\t\tif ( p.z > maxZ ) maxZ = p.z;\n\t\t\telse if ( p.z < minZ ) minZ = p.z;\n\n\t\t}\n\n\t\tsum.add( p );\n\n\t}\n\n\tvar ret = {\n\n\t\tminX: minX,\n\t\tminY: minY,\n\t\tmaxX: maxX,\n\t\tmaxY: maxY,\n\t\tcentroid: sum.divideScalar( il )\n\n\t};\n\n\tif ( v3 ) {\n\n\t\tret.maxZ = maxZ;\n\t\tret.minZ = minZ;\n\n\t}\n\n\treturn ret;\n\n};\n\n/**************************************************************\n *\tCreate Geometries Helpers\n **************************************************************/\n\n/// Generate geometry from path points (for Line or ParticleSystem objects)\n\nTHREE.CurvePath.prototype.createPointsGeometry = function( divisions ) {\n\n\tvar pts = this.getPoints( divisions, true );\n\treturn this.createGeometry( pts );\n\n};\n\n// Generate geometry from equidistance sampling along the path\n\nTHREE.CurvePath.prototype.createSpacedPointsGeometry = function( divisions ) {\n\n\tvar pts = this.getSpacedPoints( divisions, true );\n\treturn this.createGeometry( pts );\n\n};\n\nTHREE.CurvePath.prototype.createGeometry = function( points ) {\n\n\tvar geometry = new THREE.Geometry();\n\n\tfor ( var i = 0; i < points.length; i ++ ) {\n\n\t\tgeometry.vertices.push( new THREE.Vector3( points[ i ].x, points[ i ].y, points[ i ].z || 0) );\n\n\t}\n\n\treturn geometry;\n\n};\n\n\n/**************************************************************\n *\tBend / Wrap Helper Methods\n **************************************************************/\n\n// Wrap path / Bend modifiers?\n\nTHREE.CurvePath.prototype.addWrapPath = function ( bendpath ) {\n\n\tthis.bends.push( bendpath );\n\n};\n\nTHREE.CurvePath.prototype.getTransformedPoints = function( segments, bends ) {\n\n\tvar oldPts = this.getPoints( segments ); // getPoints getSpacedPoints\n\tvar i, il;\n\n\tif ( !bends ) {\n\n\t\tbends = this.bends;\n\n\t}\n\n\tfor ( i = 0, il = bends.length; i < il; i ++ ) {\n\n\t\toldPts = this.getWrapPoints( oldPts, bends[ i ] );\n\n\t}\n\n\treturn oldPts;\n\n};\n\nTHREE.CurvePath.prototype.getTransformedSpacedPoints = function( segments, bends ) {\n\n\tvar oldPts = this.getSpacedPoints( segments );\n\n\tvar i, il;\n\n\tif ( !bends ) {\n\n\t\tbends = this.bends;\n\n\t}\n\n\tfor ( i = 0, il = bends.length; i < il; i ++ ) {\n\n\t\toldPts = this.getWrapPoints( oldPts, bends[ i ] );\n\n\t}\n\n\treturn oldPts;\n\n};\n\n// This returns getPoints() bend/wrapped around the contour of a path.\n// Read http://www.planetclegg.com/projects/WarpingTextToSplines.html\n\nTHREE.CurvePath.prototype.getWrapPoints = function ( oldPts, path ) {\n\n\tvar bounds = this.getBoundingBox();\n\n\tvar i, il, p, oldX, oldY, xNorm;\n\n\tfor ( i = 0, il = oldPts.length; i < il; i ++ ) {\n\n\t\tp = oldPts[ i ];\n\n\t\toldX = p.x;\n\t\toldY = p.y;\n\n\t\txNorm = oldX / bounds.maxX;\n\n\t\t// If using actual distance, for length > path, requires line extrusions\n\t\t//xNorm = path.getUtoTmapping(xNorm, oldX); // 3 styles. 1) wrap stretched. 2) wrap stretch by arc length 3) warp by actual distance\n\n\t\txNorm = path.getUtoTmapping( xNorm, oldX );\n\n\t\t// check for out of bounds?\n\n\t\tvar pathPt = path.getPoint( xNorm );\n\t\tvar normal = path.getNormalVector( xNorm ).multiplyScalar( oldY );\n\n\t\tp.x = pathPt.x + normal.x;\n\t\tp.y = pathPt.y + normal.y;\n\n\t}\n\n\treturn oldPts;\n\n};\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Gyroscope = function () {\n\n\tTHREE.Object3D.call( this );\n\n};\n\nTHREE.Gyroscope.prototype = Object.create( THREE.Object3D.prototype );\n\nTHREE.Gyroscope.prototype.updateMatrixWorld = function ( force ) {\n\n\tthis.matrixAutoUpdate && this.updateMatrix();\n\n\t// update matrixWorld\n\n\tif ( this.matrixWorldNeedsUpdate || force ) {\n\n\t\tif ( this.parent ) {\n\n\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\n\t\t\tthis.matrixWorld.decompose( this.translationWorld, this.rotationWorld, this.scaleWorld );\n\t\t\tthis.matrix.decompose( this.translationObject, this.rotationObject, this.scaleObject );\n\n\t\t\tthis.matrixWorld.compose( this.translationWorld, this.rotationObject, this.scaleWorld );\n\n\n\t\t} else {\n\n\t\t\tthis.matrixWorld.copy( this.matrix );\n\n\t\t}\n\n\n\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\tforce = true;\n\n\t}\n\n\t// update children\n\n\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\n\t\tthis.children[ i ].updateMatrixWorld( force );\n\n\t}\n\n};\n\nTHREE.Gyroscope.prototype.translationWorld = new THREE.Vector3();\nTHREE.Gyroscope.prototype.translationObject = new THREE.Vector3();\nTHREE.Gyroscope.prototype.rotationWorld = new THREE.Quaternion();\nTHREE.Gyroscope.prototype.rotationObject = new THREE.Quaternion();\nTHREE.Gyroscope.prototype.scaleWorld = new THREE.Vector3();\nTHREE.Gyroscope.prototype.scaleObject = new THREE.Vector3();\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * Creates free form 2d path using series of points, lines or curves.\n *\n **/\n\nTHREE.Path = function ( points ) {\n\n\tTHREE.CurvePath.call(this);\n\n\tthis.actions = [];\n\n\tif ( points ) {\n\n\t\tthis.fromPoints( points );\n\n\t}\n\n};\n\nTHREE.Path.prototype = Object.create( THREE.CurvePath.prototype );\n\nTHREE.PathActions = {\n\n\tMOVE_TO: 'moveTo',\n\tLINE_TO: 'lineTo',\n\tQUADRATIC_CURVE_TO: 'quadraticCurveTo', // Bezier quadratic curve\n\tBEZIER_CURVE_TO: 'bezierCurveTo', \t\t// Bezier cubic curve\n\tCSPLINE_THRU: 'splineThru',\t\t\t\t// Catmull-rom spline\n\tARC: 'arc',\t\t\t\t\t\t\t\t// Circle\n\tELLIPSE: 'ellipse'\n};\n\n// TODO Clean up PATH API\n\n// Create path using straight lines to connect all points\n// - vectors: array of Vector2\n\nTHREE.Path.prototype.fromPoints = function ( vectors ) {\n\n\tthis.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );\n\n\tfor ( var v = 1, vlen = vectors.length; v < vlen; v ++ ) {\n\n\t\tthis.lineTo( vectors[ v ].x, vectors[ v ].y );\n\n\t};\n\n};\n\n// startPath() endPath()?\n\nTHREE.Path.prototype.moveTo = function ( x, y ) {\n\n\tvar args = Array.prototype.slice.call( arguments );\n\tthis.actions.push( { action: THREE.PathActions.MOVE_TO, args: args } );\n\n};\n\nTHREE.Path.prototype.lineTo = function ( x, y ) {\n\n\tvar args = Array.prototype.slice.call( arguments );\n\n\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\n\n\tvar x0 = lastargs[ lastargs.length - 2 ];\n\tvar y0 = lastargs[ lastargs.length - 1 ];\n\n\tvar curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );\n\tthis.curves.push( curve );\n\n\tthis.actions.push( { action: THREE.PathActions.LINE_TO, args: args } );\n\n};\n\nTHREE.Path.prototype.quadraticCurveTo = function( aCPx, aCPy, aX, aY ) {\n\n\tvar args = Array.prototype.slice.call( arguments );\n\n\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\n\n\tvar x0 = lastargs[ lastargs.length - 2 ];\n\tvar y0 = lastargs[ lastargs.length - 1 ];\n\n\tvar curve = new THREE.QuadraticBezierCurve( new THREE.Vector2( x0, y0 ),\n\t\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aCPx, aCPy ),\n\t\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aX, aY ) );\n\tthis.curves.push( curve );\n\n\tthis.actions.push( { action: THREE.PathActions.QUADRATIC_CURVE_TO, args: args } );\n\n};\n\nTHREE.Path.prototype.bezierCurveTo = function( aCP1x, aCP1y,\n                                               aCP2x, aCP2y,\n                                               aX, aY ) {\n\n\tvar args = Array.prototype.slice.call( arguments );\n\n\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\n\n\tvar x0 = lastargs[ lastargs.length - 2 ];\n\tvar y0 = lastargs[ lastargs.length - 1 ];\n\n\tvar curve = new THREE.CubicBezierCurve( new THREE.Vector2( x0, y0 ),\n\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aCP1x, aCP1y ),\n\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aCP2x, aCP2y ),\n\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aX, aY ) );\n\tthis.curves.push( curve );\n\n\tthis.actions.push( { action: THREE.PathActions.BEZIER_CURVE_TO, args: args } );\n\n};\n\nTHREE.Path.prototype.splineThru = function( pts /*Array of Vector*/ ) {\n\n\tvar args = Array.prototype.slice.call( arguments );\n\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\n\n\tvar x0 = lastargs[ lastargs.length - 2 ];\n\tvar y0 = lastargs[ lastargs.length - 1 ];\n//---\n\tvar npts = [ new THREE.Vector2( x0, y0 ) ];\n\tArray.prototype.push.apply( npts, pts );\n\n\tvar curve = new THREE.SplineCurve( npts );\n\tthis.curves.push( curve );\n\n\tthis.actions.push( { action: THREE.PathActions.CSPLINE_THRU, args: args } );\n\n};\n\n// FUTURE: Change the API or follow canvas API?\n\nTHREE.Path.prototype.arc = function ( aX, aY, aRadius,\n\t\t\t\t\t\t\t\t\t  aStartAngle, aEndAngle, aClockwise ) {\n\n\tvar lastargs = this.actions[ this.actions.length - 1].args;\n\tvar x0 = lastargs[ lastargs.length - 2 ];\n\tvar y0 = lastargs[ lastargs.length - 1 ];\n\n\tthis.absarc(aX + x0, aY + y0, aRadius,\n\t\taStartAngle, aEndAngle, aClockwise );\n\t\n };\n\n THREE.Path.prototype.absarc = function ( aX, aY, aRadius,\n\t\t\t\t\t\t\t\t\t  aStartAngle, aEndAngle, aClockwise ) {\n\tthis.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);\n };\n \nTHREE.Path.prototype.ellipse = function ( aX, aY, xRadius, yRadius,\n\t\t\t\t\t\t\t\t\t  aStartAngle, aEndAngle, aClockwise ) {\n\n\tvar lastargs = this.actions[ this.actions.length - 1].args;\n\tvar x0 = lastargs[ lastargs.length - 2 ];\n\tvar y0 = lastargs[ lastargs.length - 1 ];\n\n\tthis.absellipse(aX + x0, aY + y0, xRadius, yRadius,\n\t\taStartAngle, aEndAngle, aClockwise );\n\n };\n \n\nTHREE.Path.prototype.absellipse = function ( aX, aY, xRadius, yRadius,\n\t\t\t\t\t\t\t\t\t  aStartAngle, aEndAngle, aClockwise ) {\n\n\tvar args = Array.prototype.slice.call( arguments );\n\tvar curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius,\n\t\t\t\t\t\t\t\t\taStartAngle, aEndAngle, aClockwise );\n\tthis.curves.push( curve );\n\n\tvar lastPoint = curve.getPoint(aClockwise ? 1 : 0);\n\targs.push(lastPoint.x);\n\targs.push(lastPoint.y);\n\n\tthis.actions.push( { action: THREE.PathActions.ELLIPSE, args: args } );\n\n };\n\nTHREE.Path.prototype.getSpacedPoints = function ( divisions, closedPath ) {\n\n\tif ( ! divisions ) divisions = 40;\n\n\tvar points = [];\n\n\tfor ( var i = 0; i < divisions; i ++ ) {\n\n\t\tpoints.push( this.getPoint( i / divisions ) );\n\n\t\t//if( !this.getPoint( i / divisions ) ) throw \"DIE\";\n\n\t}\n\n\t// if ( closedPath ) {\n\t//\n\t// \tpoints.push( points[ 0 ] );\n\t//\n\t// }\n\n\treturn points;\n\n};\n\n/* Return an array of vectors based on contour of the path */\n\nTHREE.Path.prototype.getPoints = function( divisions, closedPath ) {\n\n\tif (this.useSpacedPoints) {\n\t\tconsole.log('tata');\n\t\treturn this.getSpacedPoints( divisions, closedPath );\n\t}\n\n\tdivisions = divisions || 12;\n\n\tvar points = [];\n\n\tvar i, il, item, action, args;\n\tvar cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,\n\t\tlaste, j,\n\t\tt, tx, ty;\n\n\tfor ( i = 0, il = this.actions.length; i < il; i ++ ) {\n\n\t\titem = this.actions[ i ];\n\n\t\taction = item.action;\n\t\targs = item.args;\n\n\t\tswitch( action ) {\n\n\t\tcase THREE.PathActions.MOVE_TO:\n\n\t\t\tpoints.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );\n\n\t\t\tbreak;\n\n\t\tcase THREE.PathActions.LINE_TO:\n\n\t\t\tpoints.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );\n\n\t\t\tbreak;\n\n\t\tcase THREE.PathActions.QUADRATIC_CURVE_TO:\n\n\t\t\tcpx  = args[ 2 ];\n\t\t\tcpy  = args[ 3 ];\n\n\t\t\tcpx1 = args[ 0 ];\n\t\t\tcpy1 = args[ 1 ];\n\n\t\t\tif ( points.length > 0 ) {\n\n\t\t\t\tlaste = points[ points.length - 1 ];\n\n\t\t\t\tcpx0 = laste.x;\n\t\t\t\tcpy0 = laste.y;\n\n\t\t\t} else {\n\n\t\t\t\tlaste = this.actions[ i - 1 ].args;\n\n\t\t\t\tcpx0 = laste[ laste.length - 2 ];\n\t\t\t\tcpy0 = laste[ laste.length - 1 ];\n\n\t\t\t}\n\n\t\t\tfor ( j = 1; j <= divisions; j ++ ) {\n\n\t\t\t\tt = j / divisions;\n\n\t\t\t\ttx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );\n\t\t\t\tty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );\n\n\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\n\n\t\t  \t}\n\n\t\t\tbreak;\n\n\t\tcase THREE.PathActions.BEZIER_CURVE_TO:\n\n\t\t\tcpx  = args[ 4 ];\n\t\t\tcpy  = args[ 5 ];\n\n\t\t\tcpx1 = args[ 0 ];\n\t\t\tcpy1 = args[ 1 ];\n\n\t\t\tcpx2 = args[ 2 ];\n\t\t\tcpy2 = args[ 3 ];\n\n\t\t\tif ( points.length > 0 ) {\n\n\t\t\t\tlaste = points[ points.length - 1 ];\n\n\t\t\t\tcpx0 = laste.x;\n\t\t\t\tcpy0 = laste.y;\n\n\t\t\t} else {\n\n\t\t\t\tlaste = this.actions[ i - 1 ].args;\n\n\t\t\t\tcpx0 = laste[ laste.length - 2 ];\n\t\t\t\tcpy0 = laste[ laste.length - 1 ];\n\n\t\t\t}\n\n\n\t\t\tfor ( j = 1; j <= divisions; j ++ ) {\n\n\t\t\t\tt = j / divisions;\n\n\t\t\t\ttx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );\n\t\t\t\tty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );\n\n\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase THREE.PathActions.CSPLINE_THRU:\n\n\t\t\tlaste = this.actions[ i - 1 ].args;\n\n\t\t\tvar last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );\n\t\t\tvar spts = [ last ];\n\n\t\t\tvar n = divisions * args[ 0 ].length;\n\n\t\t\tspts = spts.concat( args[ 0 ] );\n\n\t\t\tvar spline = new THREE.SplineCurve( spts );\n\n\t\t\tfor ( j = 1; j <= n; j ++ ) {\n\n\t\t\t\tpoints.push( spline.getPointAt( j / n ) ) ;\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase THREE.PathActions.ARC:\n\n\t\t\tvar aX = args[ 0 ], aY = args[ 1 ],\n\t\t\t\taRadius = args[ 2 ],\n\t\t\t\taStartAngle = args[ 3 ], aEndAngle = args[ 4 ],\n\t\t\t\taClockwise = !!args[ 5 ];\n\n\t\t\tvar deltaAngle = aEndAngle - aStartAngle;\n\t\t\tvar angle;\n\t\t\tvar tdivisions = divisions * 2;\n\n\t\t\tfor ( j = 1; j <= tdivisions; j ++ ) {\n\n\t\t\t\tt = j / tdivisions;\n\n\t\t\t\tif ( ! aClockwise ) {\n\n\t\t\t\t\tt = 1 - t;\n\n\t\t\t\t}\n\n\t\t\t\tangle = aStartAngle + t * deltaAngle;\n\n\t\t\t\ttx = aX + aRadius * Math.cos( angle );\n\t\t\t\tty = aY + aRadius * Math.sin( angle );\n\n\t\t\t\t//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\n\n\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\n\n\t\t\t}\n\n\t\t\t//console.log(points);\n\n\t\t  break;\n\t\t  \n\t\tcase THREE.PathActions.ELLIPSE:\n\n\t\t\tvar aX = args[ 0 ], aY = args[ 1 ],\n\t\t\t\txRadius = args[ 2 ],\n\t\t\t\tyRadius = args[ 3 ],\n\t\t\t\taStartAngle = args[ 4 ], aEndAngle = args[ 5 ],\n\t\t\t\taClockwise = !!args[ 6 ];\n\n\n\t\t\tvar deltaAngle = aEndAngle - aStartAngle;\n\t\t\tvar angle;\n\t\t\tvar tdivisions = divisions * 2;\n\n\t\t\tfor ( j = 1; j <= tdivisions; j ++ ) {\n\n\t\t\t\tt = j / tdivisions;\n\n\t\t\t\tif ( ! aClockwise ) {\n\n\t\t\t\t\tt = 1 - t;\n\n\t\t\t\t}\n\n\t\t\t\tangle = aStartAngle + t * deltaAngle;\n\n\t\t\t\ttx = aX + xRadius * Math.cos( angle );\n\t\t\t\tty = aY + yRadius * Math.sin( angle );\n\n\t\t\t\t//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\n\n\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\n\n\t\t\t}\n\n\t\t\t//console.log(points);\n\n\t\t  break;\n\n\t\t} // end switch\n\n\t}\n\n\n\n\t// Normalize to remove the closing point by default.\n\tvar lastPoint = points[ points.length - 1];\n\tvar EPSILON = 0.0000000001;\n\tif ( Math.abs(lastPoint.x - points[ 0 ].x) < EPSILON &&\n             Math.abs(lastPoint.y - points[ 0 ].y) < EPSILON)\n\t\tpoints.splice( points.length - 1, 1);\n\tif ( closedPath ) {\n\n\t\tpoints.push( points[ 0 ] );\n\n\t}\n\n\treturn points;\n\n};\n\n// Breaks path into shapes\n\nTHREE.Path.prototype.toShapes = function() {\n\n\tvar i, il, item, action, args;\n\n\tvar subPaths = [], lastPath = new THREE.Path();\n\n\tfor ( i = 0, il = this.actions.length; i < il; i ++ ) {\n\n\t\titem = this.actions[ i ];\n\n\t\targs = item.args;\n\t\taction = item.action;\n\n\t\tif ( action == THREE.PathActions.MOVE_TO ) {\n\n\t\t\tif ( lastPath.actions.length != 0 ) {\n\n\t\t\t\tsubPaths.push( lastPath );\n\t\t\t\tlastPath = new THREE.Path();\n\n\t\t\t}\n\n\t\t}\n\n\t\tlastPath[ action ].apply( lastPath, args );\n\n\t}\n\n\tif ( lastPath.actions.length != 0 ) {\n\n\t\tsubPaths.push( lastPath );\n\n\t}\n\n\t// console.log(subPaths);\n\n\tif ( subPaths.length == 0 ) return [];\n\n\tvar tmpPath, tmpShape, shapes = [];\n\n\tvar holesFirst = !THREE.Shape.Utils.isClockWise( subPaths[ 0 ].getPoints() );\n\t// console.log(\"Holes first\", holesFirst);\n\n\tif ( subPaths.length == 1) {\n\t\ttmpPath = subPaths[0];\n\t\ttmpShape = new THREE.Shape();\n\t\ttmpShape.actions = tmpPath.actions;\n\t\ttmpShape.curves = tmpPath.curves;\n\t\tshapes.push( tmpShape );\n\t\treturn shapes;\n\t};\n\n\tif ( holesFirst ) {\n\n\t\ttmpShape = new THREE.Shape();\n\n\t\tfor ( i = 0, il = subPaths.length; i < il; i ++ ) {\n\n\t\t\ttmpPath = subPaths[ i ];\n\n\t\t\tif ( THREE.Shape.Utils.isClockWise( tmpPath.getPoints() ) ) {\n\n\t\t\t\ttmpShape.actions = tmpPath.actions;\n\t\t\t\ttmpShape.curves = tmpPath.curves;\n\n\t\t\t\tshapes.push( tmpShape );\n\t\t\t\ttmpShape = new THREE.Shape();\n\n\t\t\t\t//console.log('cw', i);\n\n\t\t\t} else {\n\n\t\t\t\ttmpShape.holes.push( tmpPath );\n\n\t\t\t\t//console.log('ccw', i);\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\t// Shapes first\n\n\t\tfor ( i = 0, il = subPaths.length; i < il; i ++ ) {\n\n\t\t\ttmpPath = subPaths[ i ];\n\n\t\t\tif ( THREE.Shape.Utils.isClockWise( tmpPath.getPoints() ) ) {\n\n\n\t\t\t\tif ( tmpShape ) shapes.push( tmpShape );\n\n\t\t\t\ttmpShape = new THREE.Shape();\n\t\t\t\ttmpShape.actions = tmpPath.actions;\n\t\t\t\ttmpShape.curves = tmpPath.curves;\n\n\t\t\t} else {\n\n\t\t\t\ttmpShape.holes.push( tmpPath );\n\n\t\t\t}\n\n\t\t}\n\n\t\tshapes.push( tmpShape );\n\n\t}\n\n\t//console.log(\"shape\", shapes);\n\n\treturn shapes;\n\n};\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * Defines a 2d shape plane using paths.\n **/\n\n// STEP 1 Create a path.\n// STEP 2 Turn path into shape.\n// STEP 3 ExtrudeGeometry takes in Shape/Shapes\n// STEP 3a - Extract points from each shape, turn to vertices\n// STEP 3b - Triangulate each shape, add faces.\n\nTHREE.Shape = function () {\n\n\tTHREE.Path.apply( this, arguments );\n\tthis.holes = [];\n\n};\n\nTHREE.Shape.prototype = Object.create( THREE.Path.prototype );\n\n// Convenience method to return ExtrudeGeometry\n\nTHREE.Shape.prototype.extrude = function ( options ) {\n\n\tvar extruded = new THREE.ExtrudeGeometry( this, options );\n\treturn extruded;\n\n};\n\n// Convenience method to return ShapeGeometry\n\nTHREE.Shape.prototype.makeGeometry = function ( options ) {\n\n\tvar geometry = new THREE.ShapeGeometry( this, options );\n\treturn geometry;\n\n};\n\n// Get points of holes\n\nTHREE.Shape.prototype.getPointsHoles = function ( divisions ) {\n\n\tvar i, il = this.holes.length, holesPts = [];\n\n\tfor ( i = 0; i < il; i ++ ) {\n\n\t\tholesPts[ i ] = this.holes[ i ].getTransformedPoints( divisions, this.bends );\n\n\t}\n\n\treturn holesPts;\n\n};\n\n// Get points of holes (spaced by regular distance)\n\nTHREE.Shape.prototype.getSpacedPointsHoles = function ( divisions ) {\n\n\tvar i, il = this.holes.length, holesPts = [];\n\n\tfor ( i = 0; i < il; i ++ ) {\n\n\t\tholesPts[ i ] = this.holes[ i ].getTransformedSpacedPoints( divisions, this.bends );\n\n\t}\n\n\treturn holesPts;\n\n};\n\n\n// Get points of shape and holes (keypoints based on segments parameter)\n\nTHREE.Shape.prototype.extractAllPoints = function ( divisions ) {\n\n\treturn {\n\n\t\tshape: this.getTransformedPoints( divisions ),\n\t\tholes: this.getPointsHoles( divisions )\n\n\t};\n\n};\n\nTHREE.Shape.prototype.extractPoints = function ( divisions ) {\n\n\tif (this.useSpacedPoints) {\n\t\treturn this.extractAllSpacedPoints(divisions);\n\t}\n\n\treturn this.extractAllPoints(divisions);\n\n};\n\n//\n// THREE.Shape.prototype.extractAllPointsWithBend = function ( divisions, bend ) {\n//\n// \treturn {\n//\n// \t\tshape: this.transform( bend, divisions ),\n// \t\tholes: this.getPointsHoles( divisions, bend )\n//\n// \t};\n//\n// };\n\n// Get points of shape and holes (spaced by regular distance)\n\nTHREE.Shape.prototype.extractAllSpacedPoints = function ( divisions ) {\n\n\treturn {\n\n\t\tshape: this.getTransformedSpacedPoints( divisions ),\n\t\tholes: this.getSpacedPointsHoles( divisions )\n\n\t};\n\n};\n\n/**************************************************************\n *\tUtils\n **************************************************************/\n\nTHREE.Shape.Utils = {\n\n\t/*\n\t\tcontour - array of vector2 for contour\n\t\tholes   - array of array of vector2\n\t*/\n\n\tremoveHoles: function ( contour, holes ) {\n\n\t\tvar shape = contour.concat(); // work on this shape\n\t\tvar allpoints = shape.concat();\n\n\t\t/* For each isolated shape, find the closest points and break to the hole to allow triangulation */\n\n\n\t\tvar prevShapeVert, nextShapeVert,\n\t\t\tprevHoleVert, nextHoleVert,\n\t\t\tholeIndex, shapeIndex,\n\t\t\tshapeId, shapeGroup,\n\t\t\th, h2,\n\t\t\thole, shortest, d,\n\t\t\tp, pts1, pts2,\n\t\t\ttmpShape1, tmpShape2,\n\t\t\ttmpHole1, tmpHole2,\n\t\t\tverts = [];\n\n\t\tfor ( h = 0; h < holes.length; h ++ ) {\n\n\t\t\thole = holes[ h ];\n\n\t\t\t/*\n\t\t\tshapeholes[ h ].concat(); // preserves original\n\t\t\tholes.push( hole );\n\t\t\t*/\n\n\t\t\tArray.prototype.push.apply( allpoints, hole );\n\n\t\t\tshortest = Number.POSITIVE_INFINITY;\n\n\n\t\t\t// Find the shortest pair of pts between shape and hole\n\n\t\t\t// Note: Actually, I'm not sure now if we could optimize this to be faster than O(m*n)\n\t\t\t// Using distanceToSquared() intead of distanceTo() should speed a little\n\t\t\t// since running square roots operations are reduced.\n\n\t\t\tfor ( h2 = 0; h2 < hole.length; h2 ++ ) {\n\n\t\t\t\tpts1 = hole[ h2 ];\n\t\t\t\tvar dist = [];\n\n\t\t\t\tfor ( p = 0; p < shape.length; p++ ) {\n\n\t\t\t\t\tpts2 = shape[ p ];\n\t\t\t\t\td = pts1.distanceToSquared( pts2 );\n\t\t\t\t\tdist.push( d );\n\n\t\t\t\t\tif ( d < shortest ) {\n\n\t\t\t\t\t\tshortest = d;\n\t\t\t\t\t\tholeIndex = h2;\n\t\t\t\t\t\tshapeIndex = p;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//console.log(\"shortest\", shortest, dist);\n\n\t\t\tprevShapeVert = ( shapeIndex - 1 ) >= 0 ? shapeIndex - 1 : shape.length - 1;\n\t\t\tprevHoleVert = ( holeIndex - 1 ) >= 0 ? holeIndex - 1 : hole.length - 1;\n\n\t\t\tvar areaapts = [\n\n\t\t\t\thole[ holeIndex ],\n\t\t\t\tshape[ shapeIndex ],\n\t\t\t\tshape[ prevShapeVert ]\n\n\t\t\t];\n\n\t\t\tvar areaa = THREE.FontUtils.Triangulate.area( areaapts );\n\n\t\t\tvar areabpts = [\n\n\t\t\t\thole[ holeIndex ],\n\t\t\t\thole[ prevHoleVert ],\n\t\t\t\tshape[ shapeIndex ]\n\n\t\t\t];\n\n\t\t\tvar areab = THREE.FontUtils.Triangulate.area( areabpts );\n\n\t\t\tvar shapeOffset = 1;\n\t\t\tvar holeOffset = -1;\n\n\t\t\tvar oldShapeIndex = shapeIndex, oldHoleIndex = holeIndex;\n\t\t\tshapeIndex += shapeOffset;\n\t\t\tholeIndex += holeOffset;\n\n\t\t\tif ( shapeIndex < 0 ) { shapeIndex += shape.length;  }\n\t\t\tshapeIndex %= shape.length;\n\n\t\t\tif ( holeIndex < 0 ) { holeIndex += hole.length;  }\n\t\t\tholeIndex %= hole.length;\n\n\t\t\tprevShapeVert = ( shapeIndex - 1 ) >= 0 ? shapeIndex - 1 : shape.length - 1;\n\t\t\tprevHoleVert = ( holeIndex - 1 ) >= 0 ? holeIndex - 1 : hole.length - 1;\n\n\t\t\tareaapts = [\n\n\t\t\t\thole[ holeIndex ],\n\t\t\t\tshape[ shapeIndex ],\n\t\t\t\tshape[ prevShapeVert ]\n\n\t\t\t];\n\n\t\t\tvar areaa2 = THREE.FontUtils.Triangulate.area( areaapts );\n\n\t\t\tareabpts = [\n\n\t\t\t\thole[ holeIndex ],\n\t\t\t\thole[ prevHoleVert ],\n\t\t\t\tshape[ shapeIndex ]\n\n\t\t\t];\n\n\t\t\tvar areab2 = THREE.FontUtils.Triangulate.area( areabpts );\n\t\t\t//console.log(areaa,areab ,areaa2,areab2, ( areaa + areab ),  ( areaa2 + areab2 ));\n\n\t\t\tif ( ( areaa + areab ) > ( areaa2 + areab2 ) ) {\n\n\t\t\t\t// In case areas are not correct.\n\t\t\t\t//console.log(\"USE THIS\");\n\n\t\t\t\tshapeIndex = oldShapeIndex;\n\t\t\t\tholeIndex = oldHoleIndex ;\n\n\t\t\t\tif ( shapeIndex < 0 ) { shapeIndex += shape.length;  }\n\t\t\t\tshapeIndex %= shape.length;\n\n\t\t\t\tif ( holeIndex < 0 ) { holeIndex += hole.length;  }\n\t\t\t\tholeIndex %= hole.length;\n\n\t\t\t\tprevShapeVert = ( shapeIndex - 1 ) >= 0 ? shapeIndex - 1 : shape.length - 1;\n\t\t\t\tprevHoleVert = ( holeIndex - 1 ) >= 0 ? holeIndex - 1 : hole.length - 1;\n\n\t\t\t} else {\n\n\t\t\t\t//console.log(\"USE THAT \")\n\n\t\t\t}\n\n\t\t\ttmpShape1 = shape.slice( 0, shapeIndex );\n\t\t\ttmpShape2 = shape.slice( shapeIndex );\n\t\t\ttmpHole1 = hole.slice( holeIndex );\n\t\t\ttmpHole2 = hole.slice( 0, holeIndex );\n\n\t\t\t// Should check orders here again?\n\n\t\t\tvar trianglea = [\n\n\t\t\t\thole[ holeIndex ],\n\t\t\t\tshape[ shapeIndex ],\n\t\t\t\tshape[ prevShapeVert ]\n\n\t\t\t];\n\n\t\t\tvar triangleb = [\n\n\t\t\t\thole[ holeIndex ] ,\n\t\t\t\thole[ prevHoleVert ],\n\t\t\t\tshape[ shapeIndex ]\n\n\t\t\t];\n\n\t\t\tverts.push( trianglea );\n\t\t\tverts.push( triangleb );\n\n\t\t\tshape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );\n\n\t\t}\n\n\t\treturn {\n\n\t\t\tshape:shape, \t\t/* shape with no holes */\n\t\t\tisolatedPts: verts, /* isolated faces */\n\t\t\tallpoints: allpoints\n\n\t\t}\n\n\n\t},\n\n\ttriangulateShape: function ( contour, holes ) {\n\n\t\tvar shapeWithoutHoles = THREE.Shape.Utils.removeHoles( contour, holes );\n\n\t\tvar shape = shapeWithoutHoles.shape,\n\t\t\tallpoints = shapeWithoutHoles.allpoints,\n\t\t\tisolatedPts = shapeWithoutHoles.isolatedPts;\n\n\t\tvar triangles = THREE.FontUtils.Triangulate( shape, false ); // True returns indices for points of spooled shape\n\n\t\t// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.\n\n\t\t//console.log( \"triangles\",triangles, triangles.length );\n\t\t//console.log( \"allpoints\",allpoints, allpoints.length );\n\n\t\tvar i, il, f, face,\n\t\t\tkey, index,\n\t\t\tallPointsMap = {},\n\t\t\tisolatedPointsMap = {};\n\n\t\t// prepare all points map\n\n\t\tfor ( i = 0, il = allpoints.length; i < il; i ++ ) {\n\n\t\t\tkey = allpoints[ i ].x + \":\" + allpoints[ i ].y;\n\n\t\t\tif ( allPointsMap[ key ] !== undefined ) {\n\n\t\t\t\tconsole.log( \"Duplicate point\", key );\n\n\t\t\t}\n\n\t\t\tallPointsMap[ key ] = i;\n\n\t\t}\n\n\t\t// check all face vertices against all points map\n\n\t\tfor ( i = 0, il = triangles.length; i < il; i ++ ) {\n\n\t\t\tface = triangles[ i ];\n\n\t\t\tfor ( f = 0; f < 3; f ++ ) {\n\n\t\t\t\tkey = face[ f ].x + \":\" + face[ f ].y;\n\n\t\t\t\tindex = allPointsMap[ key ];\n\n\t\t\t\tif ( index !== undefined ) {\n\n\t\t\t\t\tface[ f ] = index;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check isolated points vertices against all points map\n\n\t\tfor ( i = 0, il = isolatedPts.length; i < il; i ++ ) {\n\n\t\t\tface = isolatedPts[ i ];\n\n\t\t\tfor ( f = 0; f < 3; f ++ ) {\n\n\t\t\t\tkey = face[ f ].x + \":\" + face[ f ].y;\n\n\t\t\t\tindex = allPointsMap[ key ];\n\n\t\t\t\tif ( index !== undefined ) {\n\n\t\t\t\t\tface[ f ] = index;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn triangles.concat( isolatedPts );\n\n\t}, // end triangulate shapes\n\n\t/*\n\ttriangulate2 : function( pts, holes ) {\n\n\t\t// For use with Poly2Tri.js\n\n\t\tvar allpts = pts.concat();\n\t\tvar shape = [];\n\t\tfor (var p in pts) {\n\t\t\tshape.push(new js.poly2tri.Point(pts[p].x, pts[p].y));\n\t\t}\n\n\t\tvar swctx = new js.poly2tri.SweepContext(shape);\n\n\t\tfor (var h in holes) {\n\t\t\tvar aHole = holes[h];\n\t\t\tvar newHole = []\n\t\t\tfor (i in aHole) {\n\t\t\t\tnewHole.push(new js.poly2tri.Point(aHole[i].x, aHole[i].y));\n\t\t\t\tallpts.push(aHole[i]);\n\t\t\t}\n\t\t\tswctx.AddHole(newHole);\n\t\t}\n\n\t\tvar find;\n\t\tvar findIndexForPt = function (pt) {\n\t\t\tfind = new THREE.Vector2(pt.x, pt.y);\n\t\t\tvar p;\n\t\t\tfor (p=0, pl = allpts.length; p<pl; p++) {\n\t\t\t\tif (allpts[p].equals(find)) return p;\n\t\t\t}\n\t\t\treturn -1;\n\t\t};\n\n\t\t// triangulate\n\t\tjs.poly2tri.sweep.Triangulate(swctx);\n\n\t\tvar triangles =  swctx.GetTriangles();\n\t\tvar tr ;\n\t\tvar facesPts = [];\n\t\tfor (var t in triangles) {\n\t\t\ttr =  triangles[t];\n\t\t\tfacesPts.push([\n\t\t\t\tfindIndexForPt(tr.GetPoint(0)),\n\t\t\t\tfindIndexForPt(tr.GetPoint(1)),\n\t\t\t\tfindIndexForPt(tr.GetPoint(2))\n\t\t\t\t\t]);\n\t\t}\n\n\n\t//\tconsole.log(facesPts);\n\t//\tconsole.log(\"triangles\", triangles.length, triangles);\n\n\t\t// Returns array of faces with 3 element each\n\treturn facesPts;\n\t},\n*/\n\n\tisClockWise: function ( pts ) {\n\n\t\treturn THREE.FontUtils.Triangulate.area( pts ) < 0;\n\n\t},\n\n\t// Bezier Curves formulas obtained from\n\t// http://en.wikipedia.org/wiki/B%C3%A9zier_curve\n\n\t// Quad Bezier Functions\n\n\tb2p0: function ( t, p ) {\n\n\t\tvar k = 1 - t;\n\t\treturn k * k * p;\n\n\t},\n\n\tb2p1: function ( t, p ) {\n\n\t\treturn 2 * ( 1 - t ) * t * p;\n\n\t},\n\n\tb2p2: function ( t, p ) {\n\n\t\treturn t * t * p;\n\n\t},\n\n\tb2: function ( t, p0, p1, p2 ) {\n\n\t\treturn this.b2p0( t, p0 ) + this.b2p1( t, p1 ) + this.b2p2( t, p2 );\n\n\t},\n\n\t// Cubic Bezier Functions\n\n\tb3p0: function ( t, p ) {\n\n\t\tvar k = 1 - t;\n\t\treturn k * k * k * p;\n\n\t},\n\n\tb3p1: function ( t, p ) {\n\n\t\tvar k = 1 - t;\n\t\treturn 3 * k * k * t * p;\n\n\t},\n\n\tb3p2: function ( t, p ) {\n\n\t\tvar k = 1 - t;\n\t\treturn 3 * k * t * t * p;\n\n\t},\n\n\tb3p3: function ( t, p ) {\n\n\t\treturn t * t * t * p;\n\n\t},\n\n\tb3: function ( t, p0, p1, p2, p3 ) {\n\n\t\treturn this.b3p0( t, p0 ) + this.b3p1( t, p1 ) + this.b3p2( t, p2 ) +  this.b3p3( t, p3 );\n\n\t}\n\n};\n\n/**\n * @author mikael emtinger / http://gomo.se/\n */\n\nTHREE.AnimationHandler = (function() {\n\n\tvar playing = [];\n\tvar library = {};\n\tvar that    = {};\n\n\n\t//--- update ---\n\n\tthat.update = function( deltaTimeMS ) {\n\n\t\tfor( var i = 0; i < playing.length; i ++ )\n\t\t\tplaying[ i ].update( deltaTimeMS );\n\n\t};\n\n\n\t//--- add ---\n\n\tthat.addToUpdate = function( animation ) {\n\n\t\tif ( playing.indexOf( animation ) === -1 )\n\t\t\tplaying.push( animation );\n\n\t};\n\n\n\t//--- remove ---\n\n\tthat.removeFromUpdate = function( animation ) {\n\n\t\tvar index = playing.indexOf( animation );\n\n\t\tif( index !== -1 )\n\t\t\tplaying.splice( index, 1 );\n\n\t};\n\n\n\t//--- add ---\n\n\tthat.add = function( data ) {\n\n\t\tif ( library[ data.name ] !== undefined )\n\t\t\tconsole.log( \"THREE.AnimationHandler.add: Warning! \" + data.name + \" already exists in library. Overwriting.\" );\n\n\t\tlibrary[ data.name ] = data;\n\t\tinitData( data );\n\n\t};\n\n\n\t//--- get ---\n\n\tthat.get = function( name ) {\n\n\t\tif ( typeof name === \"string\" ) {\n\n\t\t\tif ( library[ name ] ) {\n\n\t\t\t\treturn library[ name ];\n\n\t\t\t} else {\n\n\t\t\t\tconsole.log( \"THREE.AnimationHandler.get: Couldn't find animation \" + name );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// todo: add simple tween library\n\n\t\t}\n\n\t};\n\n\t//--- parse ---\n\n\tthat.parse = function( root ) {\n\n\t\t// setup hierarchy\n\n\t\tvar hierarchy = [];\n\n\t\tif ( root instanceof THREE.SkinnedMesh ) {\n\n\t\t\tfor( var b = 0; b < root.bones.length; b++ ) {\n\n\t\t\t\thierarchy.push( root.bones[ b ] );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tparseRecurseHierarchy( root, hierarchy );\n\n\t\t}\n\n\t\treturn hierarchy;\n\n\t};\n\n\tvar parseRecurseHierarchy = function( root, hierarchy ) {\n\n\t\thierarchy.push( root );\n\n\t\tfor( var c = 0; c < root.children.length; c++ )\n\t\t\tparseRecurseHierarchy( root.children[ c ], hierarchy );\n\n\t}\n\n\n\t//--- init data ---\n\n\tvar initData = function( data ) {\n\n\t\tif( data.initialized === true )\n\t\t\treturn;\n\n\n\t\t// loop through all keys\n\n\t\tfor( var h = 0; h < data.hierarchy.length; h ++ ) {\n\n\t\t\tfor( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\n\n\t\t\t\t// remove minus times\n\n\t\t\t\tif( data.hierarchy[ h ].keys[ k ].time < 0 )\n\t\t\t\t\tdata.hierarchy[ h ].keys[ k ].time = 0;\n\n\n\t\t\t\t// create quaternions\n\n\t\t\t\tif( data.hierarchy[ h ].keys[ k ].rot !== undefined &&\n\t\t\t\t !( data.hierarchy[ h ].keys[ k ].rot instanceof THREE.Quaternion ) ) {\n\n\t\t\t\t\tvar quat = data.hierarchy[ h ].keys[ k ].rot;\n\t\t\t\t\tdata.hierarchy[ h ].keys[ k ].rot = new THREE.Quaternion( quat[0], quat[1], quat[2], quat[3] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\t// prepare morph target keys\n\n\t\t\tif( data.hierarchy[ h ].keys.length && data.hierarchy[ h ].keys[ 0 ].morphTargets !== undefined ) {\n\n\t\t\t\t// get all used\n\n\t\t\t\tvar usedMorphTargets = {};\n\n\t\t\t\tfor ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\n\n\t\t\t\t\tfor ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {\n\n\t\t\t\t\t\tvar morphTargetName = data.hierarchy[ h ].keys[ k ].morphTargets[ m ];\n\t\t\t\t\t\tusedMorphTargets[ morphTargetName ] = -1;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tdata.hierarchy[ h ].usedMorphTargets = usedMorphTargets;\n\n\n\t\t\t\t// set all used on all frames\n\n\t\t\t\tfor ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\n\n\t\t\t\t\tvar influences = {};\n\n\t\t\t\t\tfor ( var morphTargetName in usedMorphTargets ) {\n\n\t\t\t\t\t\tfor ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {\n\n\t\t\t\t\t\t\tif ( data.hierarchy[ h ].keys[ k ].morphTargets[ m ] === morphTargetName ) {\n\n\t\t\t\t\t\t\t\tinfluences[ morphTargetName ] = data.hierarchy[ h ].keys[ k ].morphTargetsInfluences[ m ];\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( m === data.hierarchy[ h ].keys[ k ].morphTargets.length ) {\n\n\t\t\t\t\t\t\tinfluences[ morphTargetName ] = 0;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tdata.hierarchy[ h ].keys[ k ].morphTargetsInfluences = influences;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\t// remove all keys that are on the same time\n\n\t\t\tfor ( var k = 1; k < data.hierarchy[ h ].keys.length; k ++ ) {\n\n\t\t\t\tif ( data.hierarchy[ h ].keys[ k ].time === data.hierarchy[ h ].keys[ k - 1 ].time ) {\n\n\t\t\t\t\tdata.hierarchy[ h ].keys.splice( k, 1 );\n\t\t\t\t\tk --;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\t// set index\n\n\t\t\tfor ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\n\n\t\t\t\tdata.hierarchy[ h ].keys[ k ].index = k;\n\n\t\t\t}\n\n\t\t}\n\n\n\t\t// JIT\n\n\t\tvar lengthInFrames = parseInt( data.length * data.fps, 10 );\n\n\t\tdata.JIT = {};\n\t\tdata.JIT.hierarchy = [];\n\n\t\tfor( var h = 0; h < data.hierarchy.length; h ++ )\n\t\t\tdata.JIT.hierarchy.push( new Array( lengthInFrames ) );\n\n\n\t\t// done\n\n\t\tdata.initialized = true;\n\n\t};\n\n\n\t// interpolation types\n\n\tthat.LINEAR = 0;\n\tthat.CATMULLROM = 1;\n\tthat.CATMULLROM_FORWARD = 2;\n\n\treturn that;\n\n}());\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Animation = function ( root, name, interpolationType ) {\n\n\tthis.root = root;\n\tthis.data = THREE.AnimationHandler.get( name );\n\tthis.hierarchy = THREE.AnimationHandler.parse( root );\n\n\tthis.currentTime = 0;\n\tthis.timeScale = 1;\n\n\tthis.isPlaying = false;\n\tthis.isPaused = true;\n\tthis.loop = true;\n\n\tthis.interpolationType = interpolationType !== undefined ? interpolationType : THREE.AnimationHandler.LINEAR;\n\n\tthis.points = [];\n\tthis.target = new THREE.Vector3();\n\n};\n\nTHREE.Animation.prototype.play = function ( loop, startTimeMS ) {\n\n\tif ( this.isPlaying === false ) {\n\n\t\tthis.isPlaying = true;\n\t\tthis.loop = loop !== undefined ? loop : true;\n\t\tthis.currentTime = startTimeMS !== undefined ? startTimeMS : 0;\n\n\t\t// reset key cache\n\n\t\tvar h, hl = this.hierarchy.length,\n\t\t\tobject;\n\n\t\tfor ( h = 0; h < hl; h ++ ) {\n\n\t\t\tobject = this.hierarchy[ h ];\n\n\t\t\tif ( this.interpolationType !== THREE.AnimationHandler.CATMULLROM_FORWARD ) {\n\n\t\t\t\tobject.useQuaternion = true;\n\n\t\t\t}\n\n\t\t\tobject.matrixAutoUpdate = true;\n\n\t\t\tif ( object.animationCache === undefined ) {\n\n\t\t\t\tobject.animationCache = {};\n\t\t\t\tobject.animationCache.prevKey = { pos: 0, rot: 0, scl: 0 };\n\t\t\t\tobject.animationCache.nextKey = { pos: 0, rot: 0, scl: 0 };\n\t\t\t\tobject.animationCache.originalMatrix = object instanceof THREE.Bone ? object.skinMatrix : object.matrix;\n\n\t\t\t}\n\n\t\t\tvar prevKey = object.animationCache.prevKey;\n\t\t\tvar nextKey = object.animationCache.nextKey;\n\n\t\t\tprevKey.pos = this.data.hierarchy[ h ].keys[ 0 ];\n\t\t\tprevKey.rot = this.data.hierarchy[ h ].keys[ 0 ];\n\t\t\tprevKey.scl = this.data.hierarchy[ h ].keys[ 0 ];\n\n\t\t\tnextKey.pos = this.getNextKeyWith( \"pos\", h, 1 );\n\t\t\tnextKey.rot = this.getNextKeyWith( \"rot\", h, 1 );\n\t\t\tnextKey.scl = this.getNextKeyWith( \"scl\", h, 1 );\n\n\t\t}\n\n\t\tthis.update( 0 );\n\n\t}\n\n\tthis.isPaused = false;\n\n\tTHREE.AnimationHandler.addToUpdate( this );\n\n};\n\n\nTHREE.Animation.prototype.pause = function() {\n\n\tif ( this.isPaused === true ) {\n\n\t\tTHREE.AnimationHandler.addToUpdate( this );\n\n\t} else {\n\n\t\tTHREE.AnimationHandler.removeFromUpdate( this );\n\n\t}\n\n\tthis.isPaused = !this.isPaused;\n\n};\n\n\nTHREE.Animation.prototype.stop = function() {\n\n\tthis.isPlaying = false;\n\tthis.isPaused  = false;\n\tTHREE.AnimationHandler.removeFromUpdate( this );\n\n};\n\n\nTHREE.Animation.prototype.update = function ( deltaTimeMS ) {\n\n\t// early out\n\n\tif ( this.isPlaying === false ) return;\n\n\n\t// vars\n\n\tvar types = [ \"pos\", \"rot\", \"scl\" ];\n\tvar type;\n\tvar scale;\n\tvar vector;\n\tvar prevXYZ, nextXYZ;\n\tvar prevKey, nextKey;\n\tvar object;\n\tvar animationCache;\n\tvar frame;\n\tvar JIThierarchy = this.data.JIT.hierarchy;\n\tvar currentTime, unloopedCurrentTime;\n\tvar currentPoint, forwardPoint, angle;\n\n\n\tthis.currentTime += deltaTimeMS * this.timeScale;\n\n\tunloopedCurrentTime = this.currentTime;\n\tcurrentTime = this.currentTime = this.currentTime % this.data.length;\n\tframe = parseInt( Math.min( currentTime * this.data.fps, this.data.length * this.data.fps ), 10 );\n\n\n\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {\n\n\t\tobject = this.hierarchy[ h ];\n\t\tanimationCache = object.animationCache;\n\n\t\t// loop through pos/rot/scl\n\n\t\tfor ( var t = 0; t < 3; t ++ ) {\n\n\t\t\t// get keys\n\n\t\t\ttype    = types[ t ];\n\t\t\tprevKey = animationCache.prevKey[ type ];\n\t\t\tnextKey = animationCache.nextKey[ type ];\n\n\t\t\t// switch keys?\n\n\t\t\tif ( nextKey.time <= unloopedCurrentTime ) {\n\n\t\t\t\t// did we loop?\n\n\t\t\t\tif ( currentTime < unloopedCurrentTime ) {\n\n\t\t\t\t\tif ( this.loop ) {\n\n\t\t\t\t\t\tprevKey = this.data.hierarchy[ h ].keys[ 0 ];\n\t\t\t\t\t\tnextKey = this.getNextKeyWith( type, h, 1 );\n\n\t\t\t\t\t\twhile( nextKey.time < currentTime ) {\n\n\t\t\t\t\t\t\tprevKey = nextKey;\n\t\t\t\t\t\t\tnextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.stop();\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdo {\n\n\t\t\t\t\t\tprevKey = nextKey;\n\t\t\t\t\t\tnextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );\n\n\t\t\t\t\t} while( nextKey.time < currentTime )\n\n\t\t\t\t}\n\n\t\t\t\tanimationCache.prevKey[ type ] = prevKey;\n\t\t\t\tanimationCache.nextKey[ type ] = nextKey;\n\n\t\t\t}\n\n\n\t\t\tobject.matrixAutoUpdate = true;\n\t\t\tobject.matrixWorldNeedsUpdate = true;\n\n\t\t\tscale = ( currentTime - prevKey.time ) / ( nextKey.time - prevKey.time );\n\t\t\tprevXYZ = prevKey[ type ];\n\t\t\tnextXYZ = nextKey[ type ];\n\n\n\t\t\t// check scale error\n\n\t\t\tif ( scale < 0 || scale > 1 ) {\n\n\t\t\t\tconsole.log( \"THREE.Animation.update: Warning! Scale out of bounds:\" + scale + \" on bone \" + h );\n\t\t\t\tscale = scale < 0 ? 0 : 1;\n\n\t\t\t}\n\n\t\t\t// interpolate\n\n\t\t\tif ( type === \"pos\" ) {\n\n\t\t\t\tvector = object.position;\n\n\t\t\t\tif ( this.interpolationType === THREE.AnimationHandler.LINEAR ) {\n\n\t\t\t\t\tvector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;\n\t\t\t\t\tvector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;\n\t\t\t\t\tvector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;\n\n\t\t\t\t} else if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||\n\t\t\t\t\t\t    this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\n\n\t\t\t\t\tthis.points[ 0 ] = this.getPrevKeyWith( \"pos\", h, prevKey.index - 1 )[ \"pos\" ];\n\t\t\t\t\tthis.points[ 1 ] = prevXYZ;\n\t\t\t\t\tthis.points[ 2 ] = nextXYZ;\n\t\t\t\t\tthis.points[ 3 ] = this.getNextKeyWith( \"pos\", h, nextKey.index + 1 )[ \"pos\" ];\n\n\t\t\t\t\tscale = scale * 0.33 + 0.33;\n\n\t\t\t\t\tcurrentPoint = this.interpolateCatmullRom( this.points, scale );\n\n\t\t\t\t\tvector.x = currentPoint[ 0 ];\n\t\t\t\t\tvector.y = currentPoint[ 1 ];\n\t\t\t\t\tvector.z = currentPoint[ 2 ];\n\n\t\t\t\t\tif ( this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\n\n\t\t\t\t\t\tforwardPoint = this.interpolateCatmullRom( this.points, scale * 1.01 );\n\n\t\t\t\t\t\tthis.target.set( forwardPoint[ 0 ], forwardPoint[ 1 ], forwardPoint[ 2 ] );\n\t\t\t\t\t\tthis.target.sub( vector );\n\t\t\t\t\t\tthis.target.y = 0;\n\t\t\t\t\t\tthis.target.normalize();\n\n\t\t\t\t\t\tangle = Math.atan2( this.target.x, this.target.z );\n\t\t\t\t\t\tobject.rotation.set( 0, angle, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( type === \"rot\" ) {\n\n\t\t\t\tTHREE.Quaternion.slerp( prevXYZ, nextXYZ, object.quaternion, scale );\n\n\t\t\t} else if ( type === \"scl\" ) {\n\n\t\t\t\tvector = object.scale;\n\n\t\t\t\tvector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;\n\t\t\t\tvector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;\n\t\t\t\tvector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n};\n\n// Catmull-Rom spline\n\nTHREE.Animation.prototype.interpolateCatmullRom = function ( points, scale ) {\n\n\tvar c = [], v3 = [],\n\tpoint, intPoint, weight, w2, w3,\n\tpa, pb, pc, pd;\n\n\tpoint = ( points.length - 1 ) * scale;\n\tintPoint = Math.floor( point );\n\tweight = point - intPoint;\n\n\tc[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;\n\tc[ 1 ] = intPoint;\n\tc[ 2 ] = intPoint > points.length - 2 ? intPoint : intPoint + 1;\n\tc[ 3 ] = intPoint > points.length - 3 ? intPoint : intPoint + 2;\n\n\tpa = points[ c[ 0 ] ];\n\tpb = points[ c[ 1 ] ];\n\tpc = points[ c[ 2 ] ];\n\tpd = points[ c[ 3 ] ];\n\n\tw2 = weight * weight;\n\tw3 = weight * w2;\n\n\tv3[ 0 ] = this.interpolate( pa[ 0 ], pb[ 0 ], pc[ 0 ], pd[ 0 ], weight, w2, w3 );\n\tv3[ 1 ] = this.interpolate( pa[ 1 ], pb[ 1 ], pc[ 1 ], pd[ 1 ], weight, w2, w3 );\n\tv3[ 2 ] = this.interpolate( pa[ 2 ], pb[ 2 ], pc[ 2 ], pd[ 2 ], weight, w2, w3 );\n\n\treturn v3;\n\n};\n\nTHREE.Animation.prototype.interpolate = function ( p0, p1, p2, p3, t, t2, t3 ) {\n\n\tvar v0 = ( p2 - p0 ) * 0.5,\n\t\tv1 = ( p3 - p1 ) * 0.5;\n\n\treturn ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\n};\n\n\n\n// Get next key with\n\nTHREE.Animation.prototype.getNextKeyWith = function ( type, h, key ) {\n\n\tvar keys = this.data.hierarchy[ h ].keys;\n\n\tif ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||\n\t\t this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\n\n\t\tkey = key < keys.length - 1 ? key : keys.length - 1;\n\n\t} else {\n\n\t\tkey = key % keys.length;\n\n\t}\n\n\tfor ( ; key < keys.length; key++ ) {\n\n\t\tif ( keys[ key ][ type ] !== undefined ) {\n\n\t\t\treturn keys[ key ];\n\n\t\t}\n\n\t}\n\n\treturn this.data.hierarchy[ h ].keys[ 0 ];\n\n};\n\n// Get previous key with\n\nTHREE.Animation.prototype.getPrevKeyWith = function ( type, h, key ) {\n\n\tvar keys = this.data.hierarchy[ h ].keys;\n\n\tif ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||\n\t\t this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\n\n\t\tkey = key > 0 ? key : 0;\n\n\t} else {\n\n\t\tkey = key >= 0 ? key : key + keys.length;\n\n\t}\n\n\n\tfor ( ; key >= 0; key -- ) {\n\n\t\tif ( keys[ key ][ type ] !== undefined ) {\n\n\t\t\treturn keys[ key ];\n\n\t\t}\n\n\t}\n\n\treturn this.data.hierarchy[ h ].keys[ keys.length - 1 ];\n\n};\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author khang duong\n * @author erik kitson\n */\n\nTHREE.KeyFrameAnimation = function( root, data, JITCompile ) {\n\n\tthis.root = root;\n\tthis.data = THREE.AnimationHandler.get( data );\n\tthis.hierarchy = THREE.AnimationHandler.parse( root );\n\tthis.currentTime = 0;\n\tthis.timeScale = 0.001;\n\tthis.isPlaying = false;\n\tthis.isPaused = true;\n\tthis.loop = true;\n\tthis.JITCompile = JITCompile !== undefined ? JITCompile : true;\n\n\t// initialize to first keyframes\n\n\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h++ ) {\n\n\t\tvar keys = this.data.hierarchy[h].keys,\n\t\t\tsids = this.data.hierarchy[h].sids,\n\t\t\tobj = this.hierarchy[h];\n\n\t\tif ( keys.length && sids ) {\n\n\t\t\tfor ( var s = 0; s < sids.length; s++ ) {\n\n\t\t\t\tvar sid = sids[ s ],\n\t\t\t\t\tnext = this.getNextKeyWith( sid, h, 0 );\n\n\t\t\t\tif ( next ) {\n\n\t\t\t\t\tnext.apply( sid );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tobj.matrixAutoUpdate = false;\n\t\t\tthis.data.hierarchy[h].node.updateMatrix();\n\t\t\tobj.matrixWorldNeedsUpdate = true;\n\n\t\t}\n\n\t}\n\n};\n\n// Play\n\nTHREE.KeyFrameAnimation.prototype.play = function( loop, startTimeMS ) {\n\n\tif( !this.isPlaying ) {\n\n\t\tthis.isPlaying = true;\n\t\tthis.loop = loop !== undefined ? loop : true;\n\t\tthis.currentTime = startTimeMS !== undefined ? startTimeMS : 0;\n\t\tthis.startTimeMs = startTimeMS;\n\t\tthis.startTime = 10000000;\n\t\tthis.endTime = -this.startTime;\n\n\n\t\t// reset key cache\n\n\t\tvar h, hl = this.hierarchy.length,\n\t\t\tobject,\n\t\t\tnode;\n\n\t\tfor ( h = 0; h < hl; h++ ) {\n\n\t\t\tobject = this.hierarchy[ h ];\n\t\t\tnode = this.data.hierarchy[ h ];\n\t\t\tobject.useQuaternion = true;\n\n\t\t\tif ( node.animationCache === undefined ) {\n\n\t\t\t\tnode.animationCache = {};\n\t\t\t\tnode.animationCache.prevKey = null;\n\t\t\t\tnode.animationCache.nextKey = null;\n\t\t\t\tnode.animationCache.originalMatrix = object instanceof THREE.Bone ? object.skinMatrix : object.matrix;\n\n\t\t\t}\n\n\t\t\tvar keys = this.data.hierarchy[h].keys;\n\n\t\t\tif (keys.length) {\n\n\t\t\t\tnode.animationCache.prevKey = keys[ 0 ];\n\t\t\t\tnode.animationCache.nextKey = keys[ 1 ];\n\n\t\t\t\tthis.startTime = Math.min( keys[0].time, this.startTime );\n\t\t\t\tthis.endTime = Math.max( keys[keys.length - 1].time, this.endTime );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.update( 0 );\n\n\t}\n\n\tthis.isPaused = false;\n\n\tTHREE.AnimationHandler.addToUpdate( this );\n\n};\n\n\n\n// Pause\n\nTHREE.KeyFrameAnimation.prototype.pause = function() {\n\n\tif( this.isPaused ) {\n\n\t\tTHREE.AnimationHandler.addToUpdate( this );\n\n\t} else {\n\n\t\tTHREE.AnimationHandler.removeFromUpdate( this );\n\n\t}\n\n\tthis.isPaused = !this.isPaused;\n\n};\n\n\n// Stop\n\nTHREE.KeyFrameAnimation.prototype.stop = function() {\n\n\tthis.isPlaying = false;\n\tthis.isPaused  = false;\n\tTHREE.AnimationHandler.removeFromUpdate( this );\n\n\n\t// reset JIT matrix and remove cache\n\n\tfor ( var h = 0; h < this.data.hierarchy.length; h++ ) {\n        \n        var obj = this.hierarchy[ h ];\n\t\tvar node = this.data.hierarchy[ h ];\n\n\t\tif ( node.animationCache !== undefined ) {\n\n\t\t\tvar original = node.animationCache.originalMatrix;\n\n\t\t\tif( obj instanceof THREE.Bone ) {\n\n\t\t\t\toriginal.copy( obj.skinMatrix );\n\t\t\t\tobj.skinMatrix = original;\n\n\t\t\t} else {\n\n\t\t\t\toriginal.copy( obj.matrix );\n\t\t\t\tobj.matrix = original;\n\n\t\t\t}\n\n\t\t\tdelete node.animationCache;\n\n\t\t}\n\n\t}\n\n};\n\n\n// Update\n\nTHREE.KeyFrameAnimation.prototype.update = function( deltaTimeMS ) {\n\n\t// early out\n\n\tif( !this.isPlaying ) return;\n\n\n\t// vars\n\n\tvar prevKey, nextKey;\n\tvar object;\n\tvar node;\n\tvar frame;\n\tvar JIThierarchy = this.data.JIT.hierarchy;\n\tvar currentTime, unloopedCurrentTime;\n\tvar looped;\n\n\n\t// update\n\n\tthis.currentTime += deltaTimeMS * this.timeScale;\n\n\tunloopedCurrentTime = this.currentTime;\n\tcurrentTime         = this.currentTime = this.currentTime % this.data.length;\n\n\t// if looped around, the current time should be based on the startTime\n\tif ( currentTime < this.startTimeMs ) {\n\n\t\tcurrentTime = this.currentTime = this.startTimeMs + currentTime;\n\n\t}\n\n\tframe               = parseInt( Math.min( currentTime * this.data.fps, this.data.length * this.data.fps ), 10 );\n\tlooped \t\t\t\t= currentTime < unloopedCurrentTime;\n\n\tif ( looped && !this.loop ) {\n\n\t\t// Set the animation to the last keyframes and stop\n\t\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h++ ) {\n\n\t\t\tvar keys = this.data.hierarchy[h].keys,\n\t\t\t\tsids = this.data.hierarchy[h].sids,\n\t\t\t\tend = keys.length-1,\n\t\t\t\tobj = this.hierarchy[h];\n\n\t\t\tif ( keys.length ) {\n\n\t\t\t\tfor ( var s = 0; s < sids.length; s++ ) {\n\n\t\t\t\t\tvar sid = sids[ s ],\n\t\t\t\t\t\tprev = this.getPrevKeyWith( sid, h, end );\n\n\t\t\t\t\tif ( prev ) {\n\t\t\t\t\t\tprev.apply( sid );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tthis.data.hierarchy[h].node.updateMatrix();\n\t\t\t\tobj.matrixWorldNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.stop();\n\t\treturn;\n\n\t}\n\n\t// check pre-infinity\n\tif ( currentTime < this.startTime ) {\n\n\t\treturn;\n\n\t}\n\n\t// update\n\n\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h++ ) {\n\n\t\tobject = this.hierarchy[ h ];\n\t\tnode = this.data.hierarchy[ h ];\n\n\t\tvar keys = node.keys,\n\t\t\tanimationCache = node.animationCache;\n\n\t\t// use JIT?\n\n\t\tif ( this.JITCompile && JIThierarchy[ h ][ frame ] !== undefined ) {\n\n\t\t\tif( object instanceof THREE.Bone ) {\n\n\t\t\t\tobject.skinMatrix = JIThierarchy[ h ][ frame ];\n\t\t\t\tobject.matrixWorldNeedsUpdate = false;\n\n\t\t\t} else {\n\n\t\t\t\tobject.matrix = JIThierarchy[ h ][ frame ];\n\t\t\t\tobject.matrixWorldNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t// use interpolation\n\n\t\t} else if ( keys.length ) {\n\n\t\t\t// make sure so original matrix and not JIT matrix is set\n\n\t\t\tif ( this.JITCompile && animationCache ) {\n\n\t\t\t\tif( object instanceof THREE.Bone ) {\n\n\t\t\t\t\tobject.skinMatrix = animationCache.originalMatrix;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tobject.matrix = animationCache.originalMatrix;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tprevKey = animationCache.prevKey;\n\t\t\tnextKey = animationCache.nextKey;\n\n\t\t\tif ( prevKey && nextKey ) {\n\n\t\t\t\t// switch keys?\n\n\t\t\t\tif ( nextKey.time <= unloopedCurrentTime ) {\n\n\t\t\t\t\t// did we loop?\n\n\t\t\t\t\tif ( looped && this.loop ) {\n\n\t\t\t\t\t\tprevKey = keys[ 0 ];\n\t\t\t\t\t\tnextKey = keys[ 1 ];\n\n\t\t\t\t\t\twhile ( nextKey.time < currentTime ) {\n\n\t\t\t\t\t\t\tprevKey = nextKey;\n\t\t\t\t\t\t\tnextKey = keys[ prevKey.index + 1 ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( !looped ) {\n\n\t\t\t\t\t\tvar lastIndex = keys.length - 1;\n\n\t\t\t\t\t\twhile ( nextKey.time < currentTime && nextKey.index !== lastIndex ) {\n\n\t\t\t\t\t\t\tprevKey = nextKey;\n\t\t\t\t\t\t\tnextKey = keys[ prevKey.index + 1 ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tanimationCache.prevKey = prevKey;\n\t\t\t\t\tanimationCache.nextKey = nextKey;\n\n\t\t\t\t}\n                if(nextKey.time >= currentTime)\n                    prevKey.interpolate( nextKey, currentTime );\n                else\n                    prevKey.interpolate( nextKey, nextKey.time);\n\n\t\t\t}\n\n\t\t\tthis.data.hierarchy[h].node.updateMatrix();\n\t\t\tobject.matrixWorldNeedsUpdate = true;\n\n\t\t}\n\n\t}\n\n\t// update JIT?\n\n\tif ( this.JITCompile ) {\n\n\t\tif ( JIThierarchy[ 0 ][ frame ] === undefined ) {\n\n\t\t\tthis.hierarchy[ 0 ].updateMatrixWorld( true );\n\n\t\t\tfor ( var h = 0; h < this.hierarchy.length; h++ ) {\n\n\t\t\t\tif( this.hierarchy[ h ] instanceof THREE.Bone ) {\n\n\t\t\t\t\tJIThierarchy[ h ][ frame ] = this.hierarchy[ h ].skinMatrix.clone();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tJIThierarchy[ h ][ frame ] = this.hierarchy[ h ].matrix.clone();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n};\n\n// Get next key with\n\nTHREE.KeyFrameAnimation.prototype.getNextKeyWith = function( sid, h, key ) {\n\n\tvar keys = this.data.hierarchy[ h ].keys;\n\tkey = key % keys.length;\n\n\tfor ( ; key < keys.length; key++ ) {\n\n\t\tif ( keys[ key ].hasTarget( sid ) ) {\n\n\t\t\treturn keys[ key ];\n\n\t\t}\n\n\t}\n\n\treturn keys[ 0 ];\n\n};\n\n// Get previous key with\n\nTHREE.KeyFrameAnimation.prototype.getPrevKeyWith = function( sid, h, key ) {\n\n\tvar keys = this.data.hierarchy[ h ].keys;\n\tkey = key >= 0 ? key : key + keys.length;\n\n\tfor ( ; key >= 0; key-- ) {\n\n\t\tif ( keys[ key ].hasTarget( sid ) ) {\n\n\t\t\treturn keys[ key ];\n\n\t\t}\n\n\t}\n\n\treturn keys[ keys.length - 1 ];\n\n};\n/**\n * Camera for rendering cube maps\n *\t- renders scene into axis-aligned cube\n *\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.CubeCamera = function ( near, far, cubeResolution ) {\n\n\tTHREE.Object3D.call( this );\n\n\tvar fov = 90, aspect = 1;\n\n\tvar cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraPX.up.set( 0, -1, 0 );\n\tcameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );\n\tthis.add( cameraPX );\n\n\tvar cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraNX.up.set( 0, -1, 0 );\n\tcameraNX.lookAt( new THREE.Vector3( -1, 0, 0 ) );\n\tthis.add( cameraNX );\n\n\tvar cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraPY.up.set( 0, 0, 1 );\n\tcameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );\n\tthis.add( cameraPY );\n\n\tvar cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraNY.up.set( 0, 0, -1 );\n\tcameraNY.lookAt( new THREE.Vector3( 0, -1, 0 ) );\n\tthis.add( cameraNY );\n\n\tvar cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraPZ.up.set( 0, -1, 0 );\n\tcameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );\n\tthis.add( cameraPZ );\n\n\tvar cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraNZ.up.set( 0, -1, 0 );\n\tcameraNZ.lookAt( new THREE.Vector3( 0, 0, -1 ) );\n\tthis.add( cameraNZ );\n\n\tthis.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter } );\n\n\tthis.updateCubeMap = function ( renderer, scene ) {\n\n\t\tvar renderTarget = this.renderTarget;\n\t\tvar generateMipmaps = renderTarget.generateMipmaps;\n\n\t\trenderTarget.generateMipmaps = false;\n\n\t\trenderTarget.activeCubeFace = 0;\n\t\trenderer.render( scene, cameraPX, renderTarget );\n\n\t\trenderTarget.activeCubeFace = 1;\n\t\trenderer.render( scene, cameraNX, renderTarget );\n\n\t\trenderTarget.activeCubeFace = 2;\n\t\trenderer.render( scene, cameraPY, renderTarget );\n\n\t\trenderTarget.activeCubeFace = 3;\n\t\trenderer.render( scene, cameraNY, renderTarget );\n\n\t\trenderTarget.activeCubeFace = 4;\n\t\trenderer.render( scene, cameraPZ, renderTarget );\n\n\t\trenderTarget.generateMipmaps = generateMipmaps;\n\n\t\trenderTarget.activeCubeFace = 5;\n\t\trenderer.render( scene, cameraNZ, renderTarget );\n\n\t};\n\n};\n\nTHREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );\n/*\n *\t@author zz85 / http://twitter.com/blurspline / http://www.lab4games.net/zz85/blog\n *\n *\tA general perpose camera, for setting FOV, Lens Focal Length,\n *\t\tand switching between perspective and orthographic views easily.\n *\t\tUse this only if you do not wish to manage\n *\t\tboth a Orthographic and Perspective Camera\n *\n */\n\n\nTHREE.CombinedCamera = function ( width, height, fov, near, far, orthoNear, orthoFar ) {\n\n\tTHREE.Camera.call( this );\n\n\tthis.fov = fov;\n\n\tthis.left = -width / 2;\n\tthis.right = width / 2\n\tthis.top = height / 2;\n\tthis.bottom = -height / 2;\n\n\t// We could also handle the projectionMatrix internally, but just wanted to test nested camera objects\n\n\tthis.cameraO = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, \torthoNear, orthoFar );\n\tthis.cameraP = new THREE.PerspectiveCamera( fov, width / height, near, far );\n\n\tthis.zoom = 1;\n\n\tthis.toPerspective();\n\n\tvar aspect = width/height;\n\n};\n\nTHREE.CombinedCamera.prototype = Object.create( THREE.Camera.prototype );\n\nTHREE.CombinedCamera.prototype.toPerspective = function () {\n\n\t// Switches to the Perspective Camera\n\n\tthis.near = this.cameraP.near;\n\tthis.far = this.cameraP.far;\n\n\tthis.cameraP.fov =  this.fov / this.zoom ;\n\n\tthis.cameraP.updateProjectionMatrix();\n\n\tthis.projectionMatrix = this.cameraP.projectionMatrix;\n\n\tthis.inPerspectiveMode = true;\n\tthis.inOrthographicMode = false;\n\n};\n\nTHREE.CombinedCamera.prototype.toOrthographic = function () {\n\n\t// Switches to the Orthographic camera estimating viewport from Perspective\n\n\tvar fov = this.fov;\n\tvar aspect = this.cameraP.aspect;\n\tvar near = this.cameraP.near;\n\tvar far = this.cameraP.far;\n\n\t// The size that we set is the mid plane of the viewing frustum\n\n\tvar hyperfocus = ( near + far ) / 2;\n\n\tvar halfHeight = Math.tan( fov / 2 ) * hyperfocus;\n\tvar planeHeight = 2 * halfHeight;\n\tvar planeWidth = planeHeight * aspect;\n\tvar halfWidth = planeWidth / 2;\n\n\thalfHeight /= this.zoom;\n\thalfWidth /= this.zoom;\n\n\tthis.cameraO.left = -halfWidth;\n\tthis.cameraO.right = halfWidth;\n\tthis.cameraO.top = halfHeight;\n\tthis.cameraO.bottom = -halfHeight;\n\n\t// this.cameraO.left = -farHalfWidth;\n\t// this.cameraO.right = farHalfWidth;\n\t// this.cameraO.top = farHalfHeight;\n\t// this.cameraO.bottom = -farHalfHeight;\n\n\t// this.cameraO.left = this.left / this.zoom;\n\t// this.cameraO.right = this.right / this.zoom;\n\t// this.cameraO.top = this.top / this.zoom;\n\t// this.cameraO.bottom = this.bottom / this.zoom;\n\n\tthis.cameraO.updateProjectionMatrix();\n\n\tthis.near = this.cameraO.near;\n\tthis.far = this.cameraO.far;\n\tthis.projectionMatrix = this.cameraO.projectionMatrix;\n\n\tthis.inPerspectiveMode = false;\n\tthis.inOrthographicMode = true;\n\n};\n\n\nTHREE.CombinedCamera.prototype.setSize = function( width, height ) {\n\n\tthis.cameraP.aspect = width / height;\n\tthis.left = -width / 2;\n\tthis.right = width / 2\n\tthis.top = height / 2;\n\tthis.bottom = -height / 2;\n\n};\n\n\nTHREE.CombinedCamera.prototype.setFov = function( fov ) {\n\n\tthis.fov = fov;\n\n\tif ( this.inPerspectiveMode ) {\n\n\t\tthis.toPerspective();\n\n\t} else {\n\n\t\tthis.toOrthographic();\n\n\t}\n\n};\n\n// For mantaining similar API with PerspectiveCamera\n\nTHREE.CombinedCamera.prototype.updateProjectionMatrix = function() {\n\n\tif ( this.inPerspectiveMode ) {\n\n\t\tthis.toPerspective();\n\n\t} else {\n\n\t\tthis.toPerspective();\n\t\tthis.toOrthographic();\n\n\t}\n\n};\n\n/*\n* Uses Focal Length (in mm) to estimate and set FOV\n* 35mm (fullframe) camera is used if frame size is not specified;\n* Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html\n*/\nTHREE.CombinedCamera.prototype.setLens = function ( focalLength, frameHeight ) {\n\n\tif ( frameHeight === undefined ) frameHeight = 24;\n\n\tvar fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );\n\n\tthis.setFov( fov );\n\n\treturn fov;\n};\n\n\nTHREE.CombinedCamera.prototype.setZoom = function( zoom ) {\n\n\tthis.zoom = zoom;\n\n\tif ( this.inPerspectiveMode ) {\n\n\t\tthis.toPerspective();\n\n\t} else {\n\n\t\tthis.toOrthographic();\n\n\t}\n\n};\n\nTHREE.CombinedCamera.prototype.toFrontView = function() {\n\n\tthis.rotation.x = 0;\n\tthis.rotation.y = 0;\n\tthis.rotation.z = 0;\n\n\t// should we be modifing the matrix instead?\n\n\tthis.rotationAutoUpdate = false;\n\n};\n\nTHREE.CombinedCamera.prototype.toBackView = function() {\n\n\tthis.rotation.x = 0;\n\tthis.rotation.y = Math.PI;\n\tthis.rotation.z = 0;\n\tthis.rotationAutoUpdate = false;\n\n};\n\nTHREE.CombinedCamera.prototype.toLeftView = function() {\n\n\tthis.rotation.x = 0;\n\tthis.rotation.y = - Math.PI / 2;\n\tthis.rotation.z = 0;\n\tthis.rotationAutoUpdate = false;\n\n};\n\nTHREE.CombinedCamera.prototype.toRightView = function() {\n\n\tthis.rotation.x = 0;\n\tthis.rotation.y = Math.PI / 2;\n\tthis.rotation.z = 0;\n\tthis.rotationAutoUpdate = false;\n\n};\n\nTHREE.CombinedCamera.prototype.toTopView = function() {\n\n\tthis.rotation.x = - Math.PI / 2;\n\tthis.rotation.y = 0;\n\tthis.rotation.z = 0;\n\tthis.rotationAutoUpdate = false;\n\n};\n\nTHREE.CombinedCamera.prototype.toBottomView = function() {\n\n\tthis.rotation.x = Math.PI / 2;\n\tthis.rotation.y = 0;\n\tthis.rotation.z = 0;\n\tthis.rotationAutoUpdate = false;\n\n};\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n *\t- 3d asterisk shape (for line pieces THREE.Line)\n */\n\nTHREE.AsteriskGeometry = function ( innerRadius, outerRadius ) {\n\n\tTHREE.Geometry.call( this );\n\n\tvar sd = innerRadius;\n\tvar ed = outerRadius;\n\n\tvar sd2 = 0.707 * sd;\n\tvar ed2 = 0.707 * ed;\n\n\tvar rays = [ [ sd, 0, 0 ], [ ed, 0, 0 ], [ -sd, 0, 0 ], [ -ed, 0, 0 ],\n\t\t\t\t [ 0, sd, 0 ], [ 0, ed, 0 ], [ 0, -sd, 0 ], [ 0, -ed, 0 ],\n\t\t\t\t [ 0, 0, sd ], [ 0, 0, ed ], [ 0, 0, -sd ], [ 0, 0, -ed ],\n\t\t\t\t [ sd2, sd2, 0 ], [ ed2, ed2, 0 ], [ -sd2, -sd2, 0 ], [ -ed2, -ed2, 0 ],\n\t\t\t\t [ sd2, -sd2, 0 ], [ ed2, -ed2, 0 ], [ -sd2, sd2, 0 ], [ -ed2, ed2, 0 ],\n\t\t\t\t [ sd2, 0, sd2 ], [ ed2, 0, ed2 ], [ -sd2, 0, -sd2 ], [ -ed2, 0, -ed2 ],\n\t\t\t\t [ sd2, 0, -sd2 ], [ ed2, 0, -ed2 ], [ -sd2, 0, sd2 ], [ -ed2, 0, ed2 ],\n\t\t\t\t [ 0, sd2, sd2 ], [ 0, ed2, ed2 ], [ 0, -sd2, -sd2 ], [ 0, -ed2, -ed2 ],\n\t\t\t\t [ 0, sd2, -sd2 ], [ 0, ed2, -ed2 ], [ 0, -sd2, sd2 ], [ 0, -ed2, ed2 ]\n\t];\n\n\tfor ( var i = 0, il = rays.length; i < il; i ++ ) {\n\n\t\tvar x = rays[ i ][ 0 ];\n\t\tvar y = rays[ i ][ 1 ];\n\t\tvar z = rays[ i ][ 2 ];\n\n\t\tthis.vertices.push( new THREE.Vector3( x, y, z ) );\n\n\t}\n\n};\n\nTHREE.AsteriskGeometry.prototype = Object.create( THREE.Geometry.prototype );/**\n * @author hughes\n */\n\nTHREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {\n\n    THREE.Geometry.call( this );\n\n    radius = radius || 50;\n\n    thetaStart = thetaStart !== undefined ? thetaStart : 0;\n    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n    segments = segments !== undefined ? Math.max( 3, segments ) : 8;\n\n    var i, uvs = [],\n    center = new THREE.Vector3(), centerUV = new THREE.Vector2( 0.5, 0.5 );\n\n    this.vertices.push(center);\n    uvs.push( centerUV );\n\n    for ( i = 0; i <= segments; i ++ ) {\n\n        var vertex = new THREE.Vector3();\n\n        vertex.x = radius * Math.cos( thetaStart + i / segments * thetaLength );\n        vertex.y = radius * Math.sin( thetaStart + i / segments * thetaLength );\n\n        this.vertices.push( vertex );\n        uvs.push( new THREE.Vector2( ( vertex.x / radius + 1 ) / 2, - ( vertex.y / radius + 1 ) / 2 + 1 ) );\n\n    }\n\n    var n = new THREE.Vector3( 0, 0, -1 );\n\n    for ( i = 1; i <= segments; i ++ ) {\n\n        var v1 = i;\n        var v2 = i + 1 ;\n        var v3 = 0;\n\n        this.faces.push( new THREE.Face3( v1, v2, v3, [ n, n, n ] ) );\n        this.faceVertexUvs[ 0 ].push( [ uvs[ i ], uvs[ i + 1 ], centerUV ] );\n\n    }\n\n    this.computeCentroids();\n    this.computeFaceNormals();\n\n    this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\n\n};\n\nTHREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );\n/**\n * @author mrdoob / http://mrdoob.com/\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as\n */\n\nTHREE.CubeGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {\n\n\tTHREE.Geometry.call( this );\n\n\tvar scope = this;\n\n\tthis.width = width;\n\tthis.height = height;\n\tthis.depth = depth;\n\n\tthis.widthSegments = widthSegments || 1;\n\tthis.heightSegments = heightSegments || 1;\n\tthis.depthSegments = depthSegments || 1;\n\n\tvar width_half = this.width / 2;\n\tvar height_half = this.height / 2;\n\tvar depth_half = this.depth / 2;\n\n\tbuildPlane( 'z', 'y', - 1, - 1, this.depth, this.height, width_half, 0 ); // px\n\tbuildPlane( 'z', 'y',   1, - 1, this.depth, this.height, - width_half, 1 ); // nx\n\tbuildPlane( 'x', 'z',   1,   1, this.width, this.depth, height_half, 2 ); // py\n\tbuildPlane( 'x', 'z',   1, - 1, this.width, this.depth, - height_half, 3 ); // ny\n\tbuildPlane( 'x', 'y',   1, - 1, this.width, this.height, depth_half, 4 ); // pz\n\tbuildPlane( 'x', 'y', - 1, - 1, this.width, this.height, - depth_half, 5 ); // nz\n\n\tfunction buildPlane( u, v, udir, vdir, width, height, depth, materialIndex ) {\n\n\t\tvar w, ix, iy,\n\t\tgridX = scope.widthSegments,\n\t\tgridY = scope.heightSegments,\n\t\twidth_half = width / 2,\n\t\theight_half = height / 2,\n\t\toffset = scope.vertices.length;\n\n\t\tif ( ( u === 'x' && v === 'y' ) || ( u === 'y' && v === 'x' ) ) {\n\n\t\t\tw = 'z';\n\n\t\t} else if ( ( u === 'x' && v === 'z' ) || ( u === 'z' && v === 'x' ) ) {\n\n\t\t\tw = 'y';\n\t\t\tgridY = scope.depthSegments;\n\n\t\t} else if ( ( u === 'z' && v === 'y' ) || ( u === 'y' && v === 'z' ) ) {\n\n\t\t\tw = 'x';\n\t\t\tgridX = scope.depthSegments;\n\n\t\t}\n\n\t\tvar gridX1 = gridX + 1,\n\t\tgridY1 = gridY + 1,\n\t\tsegment_width = width / gridX,\n\t\tsegment_height = height / gridY,\n\t\tnormal = new THREE.Vector3();\n\n\t\tnormal[ w ] = depth > 0 ? 1 : - 1;\n\n\t\tfor ( iy = 0; iy < gridY1; iy ++ ) {\n\n\t\t\tfor ( ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\t\tvar vector = new THREE.Vector3();\n\t\t\t\tvector[ u ] = ( ix * segment_width - width_half ) * udir;\n\t\t\t\tvector[ v ] = ( iy * segment_height - height_half ) * vdir;\n\t\t\t\tvector[ w ] = depth;\n\n\t\t\t\tscope.vertices.push( vector );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( iy = 0; iy < gridY; iy++ ) {\n\n\t\t\tfor ( ix = 0; ix < gridX; ix++ ) {\n\n\t\t\t\tvar a = ix + gridX1 * iy;\n\t\t\t\tvar b = ix + gridX1 * ( iy + 1 );\n\t\t\t\tvar c = ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\tvar d = ( ix + 1 ) + gridX1 * iy;\n\n\t\t\t\tvar face = new THREE.Face4( a + offset, b + offset, c + offset, d + offset );\n\t\t\t\tface.normal.copy( normal );\n\t\t\t\tface.vertexNormals.push( normal.clone(), normal.clone(), normal.clone(), normal.clone() );\n\t\t\t\tface.materialIndex = materialIndex;\n\n\t\t\t\tscope.faces.push( face );\n\t\t\t\tscope.faceVertexUvs[ 0 ].push( [\n\t\t\t\t\t\t\tnew THREE.Vector2( ix / gridX, 1 - iy / gridY ),\n\t\t\t\t\t\t\tnew THREE.Vector2( ix / gridX, 1 - ( iy + 1 ) / gridY ),\n\t\t\t\t\t\t\tnew THREE.Vector2( ( ix + 1 ) / gridX, 1- ( iy + 1 ) / gridY ),\n\t\t\t\t\t\t\tnew THREE.Vector2( ( ix + 1 ) / gridX, 1 - iy / gridY )\n\t\t\t\t\t\t] );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tthis.computeCentroids();\n\tthis.mergeVertices();\n\n};\n\nTHREE.CubeGeometry.prototype = Object.create( THREE.Geometry.prototype );\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radiusSegments, heightSegments, openEnded ) {\n\n\tTHREE.Geometry.call( this );\n\n\tradiusTop = radiusTop !== undefined ? radiusTop : 20;\n\tradiusBottom = radiusBottom !== undefined ? radiusBottom : 20;\n\theight = height !== undefined ? height : 100;\n\n\tvar heightHalf = height / 2;\n\tvar segmentsX = radiusSegments || 8;\n\tvar segmentsY = heightSegments || 1;\n\n\tvar x, y, vertices = [], uvs = [];\n\n\tfor ( y = 0; y <= segmentsY; y ++ ) {\n\n\t\tvar verticesRow = [];\n\t\tvar uvsRow = [];\n\n\t\tvar v = y / segmentsY;\n\t\tvar radius = v * ( radiusBottom - radiusTop ) + radiusTop;\n\n\t\tfor ( x = 0; x <= segmentsX; x ++ ) {\n\n\t\t\tvar u = x / segmentsX;\n\n\t\t\tvar vertex = new THREE.Vector3();\n\t\t\tvertex.x = radius * Math.sin( u * Math.PI * 2 );\n\t\t\tvertex.y = - v * height + heightHalf;\n\t\t\tvertex.z = radius * Math.cos( u * Math.PI * 2 );\n\n\t\t\tthis.vertices.push( vertex );\n\n\t\t\tverticesRow.push( this.vertices.length - 1 );\n\t\t\tuvsRow.push( new THREE.Vector2( u, 1 - v ) );\n\n\t\t}\n\n\t\tvertices.push( verticesRow );\n\t\tuvs.push( uvsRow );\n\n\t}\n\n\tvar tanTheta = ( radiusBottom - radiusTop ) / height;\n\tvar na, nb;\n\n\tfor ( x = 0; x < segmentsX; x ++ ) {\n\n\t\tif ( radiusTop !== 0 ) {\n\n\t\t\tna = this.vertices[ vertices[ 0 ][ x ] ].clone();\n\t\t\tnb = this.vertices[ vertices[ 0 ][ x + 1 ] ].clone();\n\n\t\t} else {\n\n\t\t\tna = this.vertices[ vertices[ 1 ][ x ] ].clone();\n\t\t\tnb = this.vertices[ vertices[ 1 ][ x + 1 ] ].clone();\n\n\t\t}\n\n\t\tna.setY( Math.sqrt( na.x * na.x + na.z * na.z ) * tanTheta ).normalize();\n\t\tnb.setY( Math.sqrt( nb.x * nb.x + nb.z * nb.z ) * tanTheta ).normalize();\n\n\t\tfor ( y = 0; y < segmentsY; y ++ ) {\n\n\t\t\tvar v1 = vertices[ y ][ x ];\n\t\t\tvar v2 = vertices[ y + 1 ][ x ];\n\t\t\tvar v3 = vertices[ y + 1 ][ x + 1 ];\n\t\t\tvar v4 = vertices[ y ][ x + 1 ];\n\n\t\t\tvar n1 = na.clone();\n\t\t\tvar n2 = na.clone();\n\t\t\tvar n3 = nb.clone();\n\t\t\tvar n4 = nb.clone();\n\n\t\t\tvar uv1 = uvs[ y ][ x ].clone();\n\t\t\tvar uv2 = uvs[ y + 1 ][ x ].clone();\n\t\t\tvar uv3 = uvs[ y + 1 ][ x + 1 ].clone();\n\t\t\tvar uv4 = uvs[ y ][ x + 1 ].clone();\n\n\t\t\tthis.faces.push( new THREE.Face4( v1, v2, v3, v4, [ n1, n2, n3, n4 ] ) );\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3, uv4 ] );\n\n\t\t}\n\n\t}\n\n\t// top cap\n\n\tif ( !openEnded && radiusTop > 0 ) {\n\n\t\tthis.vertices.push( new THREE.Vector3( 0, heightHalf, 0 ) );\n\n\t\tfor ( x = 0; x < segmentsX; x ++ ) {\n\n\t\t\tvar v1 = vertices[ 0 ][ x ];\n\t\t\tvar v2 = vertices[ 0 ][ x + 1 ];\n\t\t\tvar v3 = this.vertices.length - 1;\n\n\t\t\tvar n1 = new THREE.Vector3( 0, 1, 0 );\n\t\t\tvar n2 = new THREE.Vector3( 0, 1, 0 );\n\t\t\tvar n3 = new THREE.Vector3( 0, 1, 0 );\n\n\t\t\tvar uv1 = uvs[ 0 ][ x ].clone();\n\t\t\tvar uv2 = uvs[ 0 ][ x + 1 ].clone();\n\t\t\tvar uv3 = new THREE.Vector2( uv2.u, 0 );\n\n\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );\n\n\t\t}\n\n\t}\n\n\t// bottom cap\n\n\tif ( !openEnded && radiusBottom > 0 ) {\n\n\t\tthis.vertices.push( new THREE.Vector3( 0, - heightHalf, 0 ) );\n\n\t\tfor ( x = 0; x < segmentsX; x ++ ) {\n\n\t\t\tvar v1 = vertices[ y ][ x + 1 ];\n\t\t\tvar v2 = vertices[ y ][ x ];\n\t\t\tvar v3 = this.vertices.length - 1;\n\n\t\t\tvar n1 = new THREE.Vector3( 0, - 1, 0 );\n\t\t\tvar n2 = new THREE.Vector3( 0, - 1, 0 );\n\t\t\tvar n3 = new THREE.Vector3( 0, - 1, 0 );\n\n\t\t\tvar uv1 = uvs[ y ][ x + 1 ].clone();\n\t\t\tvar uv2 = uvs[ y ][ x ].clone();\n\t\t\tvar uv3 = new THREE.Vector2( uv2.u, 1 );\n\n\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );\n\n\t\t}\n\n\t}\n\n\tthis.computeCentroids();\n\tthis.computeFaceNormals();\n\n}\n\nTHREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n *\n * Creates extruded geometry from a path shape.\n *\n * parameters = {\n *\n *  size: <float>, // size of the text\n *  height: <float>, // thickness to extrude text\n *  curveSegments: <int>, // number of points on the curves\n *  steps: <int>, // number of points for z-side extrusions / used for subdividing segements of extrude spline too\n *  amount: <int>, // Amount\n *\n *  bevelEnabled: <bool>, // turn on bevel\n *  bevelThickness: <float>, // how deep into text bevel goes\n *  bevelSize: <float>, // how far from text outline is bevel\n *  bevelSegments: <int>, // number of bevel layers\n *\n *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)\n *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals\n *\n *  material: <int> // material index for front and back faces\n *  extrudeMaterial: <int> // material index for extrusion and beveled faces\n *  uvGenerator: <Object> // object that provides UV generator functions\n *\n * }\n **/\n\nTHREE.ExtrudeGeometry = function ( shapes, options ) {\n\n\tif ( typeof( shapes ) === \"undefined\" ) {\n\t\tshapes = [];\n\t\treturn;\n\t}\n\n\tTHREE.Geometry.call( this );\n\n\tshapes = shapes instanceof Array ? shapes : [ shapes ];\n\n\tthis.shapebb = shapes[ shapes.length - 1 ].getBoundingBox();\n\n\tthis.addShapeList( shapes, options );\n\n\tthis.computeCentroids();\n\tthis.computeFaceNormals();\n\n\t// can't really use automatic vertex normals\n\t// as then front and back sides get smoothed too\n\t// should do separate smoothing just for sides\n\n\t//this.computeVertexNormals();\n\n\t//console.log( \"took\", ( Date.now() - startTime ) );\n\n};\n\nTHREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\nTHREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {\n\tvar sl = shapes.length;\n\n\tfor ( var s = 0; s < sl; s ++ ) {\n\t\tvar shape = shapes[ s ];\n\t\tthis.addShape( shape, options );\n\t}\n};\n\nTHREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {\n\n\tvar amount = options.amount !== undefined ? options.amount : 100;\n\n\tvar bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10\n\tvar bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8\n\tvar bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\n\n\tvar bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false\n\n\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\n\tvar steps = options.steps !== undefined ? options.steps : 1;\n\n\tvar extrudePath = options.extrudePath;\n\tvar extrudePts, extrudeByPath = false;\n\n\tvar material = options.material;\n\tvar extrudeMaterial = options.extrudeMaterial;\n\n\t// Use default WorldUVGenerator if no UV generators are specified.\n\tvar uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;\n\n\tvar shapebb = this.shapebb;\n\t//shapebb = shape.getBoundingBox();\n\n\n\n\tvar splineTube, binormal, normal, position2;\n\tif ( extrudePath ) {\n\n\t\textrudePts = extrudePath.getSpacedPoints( steps );\n\n\t\textrudeByPath = true;\n\t\tbevelEnabled = false; // bevels not supported for path extrusion\n\n\t\t// SETUP TNB variables\n\n\t\t// Reuse TNB from TubeGeomtry for now.\n\t\t// TODO1 - have a .isClosed in spline?\n\n\t\tsplineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames(extrudePath, steps, false);\n\n\t\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\n\n\t\tbinormal = new THREE.Vector3();\n\t\tnormal = new THREE.Vector3();\n\t\tposition2 = new THREE.Vector3();\n\n\t}\n\n\t// Safeguards if bevels are not enabled\n\n\tif ( ! bevelEnabled ) {\n\n\t\tbevelSegments = 0;\n\t\tbevelThickness = 0;\n\t\tbevelSize = 0;\n\n\t}\n\n\t// Variables initalization\n\n\tvar ahole, h, hl; // looping of holes\n\tvar scope = this;\n\tvar bevelPoints = [];\n\n\tvar shapesOffset = this.vertices.length;\n\n\tvar shapePoints = shape.extractPoints( curveSegments );\n\n\tvar vertices = shapePoints.shape;\n\tvar holes = shapePoints.holes;\n\n\tvar reverse = !THREE.Shape.Utils.isClockWise( vertices ) ;\n\n\tif ( reverse ) {\n\n\t\tvertices = vertices.reverse();\n\n\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\n\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\tahole = holes[ h ];\n\n\t\t\tif ( THREE.Shape.Utils.isClockWise( ahole ) ) {\n\n\t\t\t\tholes[ h ] = ahole.reverse();\n\n\t\t\t}\n\n\t\t}\n\n\t\treverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!\n\n\t}\n\n\n\tvar faces = THREE.Shape.Utils.triangulateShape ( vertices, holes );\n\n\t/* Vertices */\n\n\tvar contour = vertices; // vertices has all points but contour has only points of circumference\n\n\tfor ( h = 0, hl = holes.length;  h < hl; h ++ ) {\n\n\t\tahole = holes[ h ];\n\n\t\tvertices = vertices.concat( ahole );\n\n\t}\n\n\n\tfunction scalePt2 ( pt, vec, size ) {\n\n\t\tif ( !vec ) console.log( \"die\" );\n\n\t\treturn vec.clone().multiplyScalar( size ).add( pt );\n\n\t}\n\n\tvar b, bs, t, z,\n\t\tvert, vlen = vertices.length,\n\t\tface, flen = faces.length,\n\t\tcont, clen = contour.length;\n\n\n\t// Find directions for point movement\n\n\tvar RAD_TO_DEGREES = 180 / Math.PI;\n\n\n\tfunction getBevelVec( pt_i, pt_j, pt_k ) {\n\n\t\t// Algorithm 2\n\n\t\treturn getBevelVec2( pt_i, pt_j, pt_k );\n\n\t}\n\n\tfunction getBevelVec1( pt_i, pt_j, pt_k ) {\n\n\t\tvar anglea = Math.atan2( pt_j.y - pt_i.y, pt_j.x - pt_i.x );\n\t\tvar angleb = Math.atan2( pt_k.y - pt_i.y, pt_k.x - pt_i.x );\n\n\t\tif ( anglea > angleb ) {\n\n\t\t\tangleb += Math.PI * 2;\n\n\t\t}\n\n\t\tvar anglec = ( anglea + angleb ) / 2;\n\n\n\t\t//console.log('angle1', anglea * RAD_TO_DEGREES,'angle2', angleb * RAD_TO_DEGREES, 'anglec', anglec *RAD_TO_DEGREES);\n\n\t\tvar x = - Math.cos( anglec );\n\t\tvar y = - Math.sin( anglec );\n\n\t\tvar vec = new THREE.Vector2( x, y ); //.normalize();\n\n\t\treturn vec;\n\n\t}\n\n\tfunction getBevelVec2( pt_i, pt_j, pt_k ) {\n\n\t\tvar a = THREE.ExtrudeGeometry.__v1,\n\t\t\tb = THREE.ExtrudeGeometry.__v2,\n\t\t\tv_hat = THREE.ExtrudeGeometry.__v3,\n\t\t\tw_hat = THREE.ExtrudeGeometry.__v4,\n\t\t\tp = THREE.ExtrudeGeometry.__v5,\n\t\t\tq = THREE.ExtrudeGeometry.__v6,\n\t\t\tv, w,\n\t\t\tv_dot_w_hat, q_sub_p_dot_w_hat,\n\t\t\ts, intersection;\n\n\t\t// good reading for line-line intersection\n\t\t// http://sputsoft.com/blog/2010/03/line-line-intersection.html\n\n\t\t// define a as vector j->i\n\t\t// define b as vectot k->i\n\n\t\ta.set( pt_i.x - pt_j.x, pt_i.y - pt_j.y );\n\t\tb.set( pt_i.x - pt_k.x, pt_i.y - pt_k.y );\n\n\t\t// get unit vectors\n\n\t\tv = a.normalize();\n\t\tw = b.normalize();\n\n\t\t// normals from pt i\n\n\t\tv_hat.set( -v.y, v.x );\n\t\tw_hat.set( w.y, -w.x );\n\n\t\t// pts from i\n\n\t\tp.copy( pt_i ).add( v_hat );\n\t\tq.copy( pt_i ).add( w_hat );\n\n\t\tif ( p.equals( q ) ) {\n\n\t\t\t//console.log(\"Warning: lines are straight\");\n\t\t\treturn w_hat.clone();\n\n\t\t}\n\n\t\t// Points from j, k. helps prevents points cross overover most of the time\n\n\t\tp.copy( pt_j ).add( v_hat );\n\t\tq.copy( pt_k ).add( w_hat );\n\n\t\tv_dot_w_hat = v.dot( w_hat );\n\t\tq_sub_p_dot_w_hat = q.sub( p ).dot( w_hat );\n\n\t\t// We should not reach these conditions\n\n\t\tif ( v_dot_w_hat === 0 ) {\n\n\t\t\tconsole.log( \"Either infinite or no solutions!\" );\n\n\t\t\tif ( q_sub_p_dot_w_hat === 0 ) {\n\n\t\t\t\tconsole.log( \"Its finite solutions.\" );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.log( \"Too bad, no solutions.\" );\n\n\t\t\t}\n\n\t\t}\n\n\t\ts = q_sub_p_dot_w_hat / v_dot_w_hat;\n\n\t\tif ( s < 0 ) {\n\n\t\t\t// in case of emergecy, revert to algorithm 1.\n\n\t\t\treturn getBevelVec1( pt_i, pt_j, pt_k );\n\n\t\t}\n\n\t\tintersection = v.multiplyScalar( s ).add( p );\n\n\t\treturn intersection.sub( pt_i ).clone(); // Don't normalize!, otherwise sharp corners become ugly\n\n\t}\n\n\tvar contourMovements = [];\n\n\tfor ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\tif ( j === il ) j = 0;\n\t\tif ( k === il ) k = 0;\n\n\t\t//  (j)---(i)---(k)\n\t\t// console.log('i,j,k', i, j , k)\n\n\t\tvar pt_i = contour[ i ];\n\t\tvar pt_j = contour[ j ];\n\t\tvar pt_k = contour[ k ];\n\n\t\tcontourMovements[ i ]= getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\n\n\t}\n\n\tvar holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();\n\n\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\tahole = holes[ h ];\n\n\t\toneHoleMovements = [];\n\n\t\tfor ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\t\tif ( j === il ) j = 0;\n\t\t\tif ( k === il ) k = 0;\n\n\t\t\t//  (j)---(i)---(k)\n\t\t\toneHoleMovements[ i ]= getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\n\n\t\t}\n\n\t\tholesMovements.push( oneHoleMovements );\n\t\tverticesMovements = verticesMovements.concat( oneHoleMovements );\n\n\t}\n\n\n\t// Loop bevelSegments, 1 for the front, 1 for the back\n\n\tfor ( b = 0; b < bevelSegments; b ++ ) {\n\t//for ( b = bevelSegments; b > 0; b -- ) {\n\n\t\tt = b / bevelSegments;\n\t\tz = bevelThickness * ( 1 - t );\n\n\t\t//z = bevelThickness * t;\n\t\tbs = bevelSize * ( Math.sin ( t * Math.PI/2 ) ) ; // curved\n\t\t//bs = bevelSize * t ; // linear\n\n\t\t// contract shape\n\n\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\t\t\t//vert = scalePt( contour[ i ], contourCentroid, bs, false );\n\t\t\tv( vert.x, vert.y,  - z );\n\n\t\t}\n\n\t\t// expand holes\n\n\t\tfor ( h = 0, hl = holes.length; h < hl; h++ ) {\n\n\t\t\tahole = holes[ h ];\n\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\tfor ( i = 0, il = ahole.length; i < il; i++ ) {\n\n\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\t\t\t\t//vert = scalePt( ahole[ i ], holesCentroids[ h ], bs, true );\n\n\t\t\t\tv( vert.x, vert.y,  -z );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tbs = bevelSize;\n\n\t// Back facing vertices\n\n\tfor ( i = 0; i < vlen; i ++ ) {\n\n\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\tif ( !extrudeByPath ) {\n\n\t\t\tv( vert.x, vert.y, 0 );\n\n\t\t} else {\n\n\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\n\n\t\t\tnormal.copy( splineTube.normals[0] ).multiplyScalar(vert.x);\n\t\t\tbinormal.copy( splineTube.binormals[0] ).multiplyScalar(vert.y);\n\n\t\t\tposition2.copy( extrudePts[0] ).add(normal).add(binormal);\n\n\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t}\n\n\t}\n\n\t// Add stepped vertices...\n\t// Including front facing vertices\n\n\tvar s;\n\n\tfor ( s = 1; s <= steps; s ++ ) {\n\n\t\tfor ( i = 0; i < vlen; i ++ ) {\n\n\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\t\tif ( !extrudeByPath ) {\n\n\t\t\t\tv( vert.x, vert.y, amount / steps * s );\n\n\t\t\t} else {\n\n\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\n\n\t\t\t\tnormal.copy( splineTube.normals[s] ).multiplyScalar( vert.x );\n\t\t\t\tbinormal.copy( splineTube.binormals[s] ).multiplyScalar( vert.y );\n\n\t\t\t\tposition2.copy( extrudePts[s] ).add( normal ).add( binormal );\n\n\t\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\n\t// Add bevel segments planes\n\n\t//for ( b = 1; b <= bevelSegments; b ++ ) {\n\tfor ( b = bevelSegments - 1; b >= 0; b -- ) {\n\n\t\tt = b / bevelSegments;\n\t\tz = bevelThickness * ( 1 - t );\n\t\t//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );\n\t\tbs = bevelSize * Math.sin ( t * Math.PI/2 ) ;\n\n\t\t// contract shape\n\n\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\t\t\tv( vert.x, vert.y,  amount + z );\n\n\t\t}\n\n\t\t// expand holes\n\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\tahole = holes[ h ];\n\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\n\n\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n\t\t\t\tif ( !extrudeByPath ) {\n\n\t\t\t\t\tv( vert.x, vert.y,  amount + z );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/* Faces */\n\n\t// Top and bottom faces\n\n\tbuildLidFaces();\n\n\t// Sides faces\n\n\tbuildSideFaces();\n\n\n\t/////  Internal functions\n\n\tfunction buildLidFaces() {\n\n\t\tif ( bevelEnabled ) {\n\n\t\t\tvar layer = 0 ; // steps + 1\n\t\t\tvar offset = vlen * layer;\n\n\t\t\t// Bottom faces\n\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\tface = faces[ i ];\n\t\t\t\tf3( face[ 2 ]+ offset, face[ 1 ]+ offset, face[ 0 ] + offset, true );\n\n\t\t\t}\n\n\t\t\tlayer = steps + bevelSegments * 2;\n\t\t\toffset = vlen * layer;\n\n\t\t\t// Top faces\n\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\tface = faces[ i ];\n\t\t\t\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset, false );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// Bottom faces\n\n\t\t\tfor ( i = 0; i < flen; i++ ) {\n\n\t\t\t\tface = faces[ i ];\n\t\t\t\tf3( face[ 2 ], face[ 1 ], face[ 0 ], true );\n\n\t\t\t}\n\n\t\t\t// Top faces\n\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\tface = faces[ i ];\n\t\t\t\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps, false );\n\n\t\t\t}\n\t\t}\n\n\t}\n\n\t// Create faces for the z-sides of the shape\n\n\tfunction buildSideFaces() {\n\n\t\tvar layeroffset = 0;\n\t\tsidewalls( contour, layeroffset );\n\t\tlayeroffset += contour.length;\n\n\t\tfor ( h = 0, hl = holes.length;  h < hl; h ++ ) {\n\n\t\t\tahole = holes[ h ];\n\t\t\tsidewalls( ahole, layeroffset );\n\n\t\t\t//, true\n\t\t\tlayeroffset += ahole.length;\n\n\t\t}\n\n\t}\n\n\tfunction sidewalls( contour, layeroffset ) {\n\n\t\tvar j, k;\n\t\ti = contour.length;\n\n\t\twhile ( --i >= 0 ) {\n\n\t\t\tj = i;\n\t\t\tk = i - 1;\n\t\t\tif ( k < 0 ) k = contour.length - 1;\n\n\t\t\t//console.log('b', i,j, i-1, k,vertices.length);\n\n\t\t\tvar s = 0, sl = steps  + bevelSegments * 2;\n\n\t\t\tfor ( s = 0; s < sl; s ++ ) {\n\n\t\t\t\tvar slen1 = vlen * s;\n\t\t\t\tvar slen2 = vlen * ( s + 1 );\n\n\t\t\t\tvar a = layeroffset + j + slen1,\n\t\t\t\t\tb = layeroffset + k + slen1,\n\t\t\t\t\tc = layeroffset + k + slen2,\n\t\t\t\t\td = layeroffset + j + slen2;\n\n\t\t\t\tf4( a, b, c, d, contour, s, sl, j, k );\n\n\t\t\t}\n\t\t}\n\n\t}\n\n\n\tfunction v( x, y, z ) {\n\n\t\tscope.vertices.push( new THREE.Vector3( x, y, z ) );\n\n\t}\n\n\tfunction f3( a, b, c, isBottom ) {\n\n\t\ta += shapesOffset;\n\t\tb += shapesOffset;\n\t\tc += shapesOffset;\n\n\t\t// normal, color, material\n\t\tscope.faces.push( new THREE.Face3( a, b, c, null, null, material ) );\n\n\t\tvar uvs = isBottom ? uvgen.generateBottomUV( scope, shape, options, a, b, c ) : uvgen.generateTopUV( scope, shape, options, a, b, c );\n\n \t\tscope.faceVertexUvs[ 0 ].push( uvs );\n\n\t}\n\n\tfunction f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {\n\n\t\ta += shapesOffset;\n\t\tb += shapesOffset;\n\t\tc += shapesOffset;\n\t\td += shapesOffset;\n\n \t\tscope.faces.push( new THREE.Face4( a, b, c, d, null, null, extrudeMaterial ) );\n\n \t\tvar uvs = uvgen.generateSideWallUV( scope, shape, wallContour, options, a, b, c, d,\n \t\t                                    stepIndex, stepsLength, contourIndex1, contourIndex2 );\n \t\tscope.faceVertexUvs[ 0 ].push( uvs );\n\n\t}\n\n};\n\nTHREE.ExtrudeGeometry.WorldUVGenerator = {\n\n\tgenerateTopUV: function( geometry, extrudedShape, extrudeOptions, indexA, indexB, indexC ) {\n\t\tvar ax = geometry.vertices[ indexA ].x,\n\t\t\tay = geometry.vertices[ indexA ].y,\n\n\t\t\tbx = geometry.vertices[ indexB ].x,\n\t\t\tby = geometry.vertices[ indexB ].y,\n\n\t\t\tcx = geometry.vertices[ indexC ].x,\n\t\t\tcy = geometry.vertices[ indexC ].y;\n\n\t\treturn [\n\t\t\tnew THREE.Vector2( ax, ay ),\n\t\t\tnew THREE.Vector2( bx, by ),\n\t\t\tnew THREE.Vector2( cx, cy )\n\t\t];\n\n\t},\n\n\tgenerateBottomUV: function( geometry, extrudedShape, extrudeOptions, indexA, indexB, indexC ) {\n\n\t\treturn this.generateTopUV( geometry, extrudedShape, extrudeOptions, indexA, indexB, indexC );\n\n\t},\n\n\tgenerateSideWallUV: function( geometry, extrudedShape, wallContour, extrudeOptions,\n\t                              indexA, indexB, indexC, indexD, stepIndex, stepsLength,\n\t                              contourIndex1, contourIndex2 ) {\n\n\t\tvar ax = geometry.vertices[ indexA ].x,\n\t\t\tay = geometry.vertices[ indexA ].y,\n\t\t\taz = geometry.vertices[ indexA ].z,\n\n\t\t\tbx = geometry.vertices[ indexB ].x,\n\t\t\tby = geometry.vertices[ indexB ].y,\n\t\t\tbz = geometry.vertices[ indexB ].z,\n\n\t\t\tcx = geometry.vertices[ indexC ].x,\n\t\t\tcy = geometry.vertices[ indexC ].y,\n\t\t\tcz = geometry.vertices[ indexC ].z,\n\n\t\t\tdx = geometry.vertices[ indexD ].x,\n\t\t\tdy = geometry.vertices[ indexD ].y,\n\t\t\tdz = geometry.vertices[ indexD ].z;\n\n\t\tif ( Math.abs( ay - by ) < 0.01 ) {\n\t\t\treturn [\n\t\t\t\tnew THREE.Vector2( ax, 1 - az ),\n\t\t\t\tnew THREE.Vector2( bx, 1 - bz ),\n\t\t\t\tnew THREE.Vector2( cx, 1 - cz ),\n\t\t\t\tnew THREE.Vector2( dx, 1 - dz )\n\t\t\t];\n\t\t} else {\n\t\t\treturn [\n\t\t\t\tnew THREE.Vector2( ay, 1 - az ),\n\t\t\t\tnew THREE.Vector2( by, 1 - bz ),\n\t\t\t\tnew THREE.Vector2( cy, 1 - cz ),\n\t\t\t\tnew THREE.Vector2( dy, 1 - dz )\n\t\t\t];\n\t\t}\n\t}\n};\n\nTHREE.ExtrudeGeometry.__v1 = new THREE.Vector2();\nTHREE.ExtrudeGeometry.__v2 = new THREE.Vector2();\nTHREE.ExtrudeGeometry.__v3 = new THREE.Vector2();\nTHREE.ExtrudeGeometry.__v4 = new THREE.Vector2();\nTHREE.ExtrudeGeometry.__v5 = new THREE.Vector2();\nTHREE.ExtrudeGeometry.__v6 = new THREE.Vector2();\n/**\n * @author jonobr1 / http://jonobr1.com\n *\n * Creates a one-sided polygonal geometry from a path shape. Similar to\n * ExtrudeGeometry.\n *\n * parameters = {\n *\n *\tcurveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.\n *\n *\tmaterial: <int> // material index for front and back faces\n *\tuvGenerator: <Object> // object that provides UV generator functions\n *\n * }\n **/\n\nTHREE.ShapeGeometry = function ( shapes, options ) {\n\n\tTHREE.Geometry.call( this );\n\n\tif ( shapes instanceof Array === false ) shapes = [ shapes ];\n\n\tthis.shapebb = shapes[ shapes.length - 1 ].getBoundingBox();\n\n\tthis.addShapeList( shapes, options );\n\n\tthis.computeCentroids();\n\tthis.computeFaceNormals();\n\n};\n\nTHREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\n/**\n * Add an array of shapes to THREE.ShapeGeometry.\n */\nTHREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {\n\n\tfor ( var i = 0, l = shapes.length; i < l; i++ ) {\n\n\t\tthis.addShape( shapes[ i ], options );\n\n\t}\n\n\treturn this;\n\n};\n\n/**\n * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.\n */\nTHREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {\n\n\tif ( options === undefined ) options = {};\n\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\n\tvar material = options.material;\n\tvar uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;\n\n\tvar shapebb = this.shapebb;\n\n\t//\n\n\tvar i, l, hole, s;\n\n\tvar shapesOffset = this.vertices.length;\n\tvar shapePoints = shape.extractPoints( curveSegments );\n\n\tvar vertices = shapePoints.shape;\n\tvar holes = shapePoints.holes;\n\n\tvar reverse = !THREE.Shape.Utils.isClockWise( vertices );\n\n\tif ( reverse ) {\n\n\t\tvertices = vertices.reverse();\n\n\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe...\n\n\t\tfor ( i = 0, l = holes.length; i < l; i++ ) {\n\n\t\t\thole = holes[ i ];\n\n\t\t\tif ( THREE.Shape.Utils.isClockWise( hole ) ) {\n\n\t\t\t\tholes[ i ] = hole.reverse();\n\n\t\t\t}\n\n\t\t}\n\n\t\treverse = false;\n\n\t}\n\n\tvar faces = THREE.Shape.Utils.triangulateShape( vertices, holes );\n\n\t// Vertices\n\n\tvar contour = vertices;\n\n\tfor ( i = 0, l = holes.length; i < l; i++ ) {\n\n\t\thole = holes[ i ];\n\t\tvertices = vertices.concat( hole );\n\n\t}\n\n\t//\n\n\tvar vert, vlen = vertices.length;\n\tvar face, flen = faces.length;\n\tvar cont, clen = contour.length;\n\n\tfor ( i = 0; i < vlen; i++ ) {\n\n\t\tvert = vertices[ i ];\n\n\t\tthis.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );\n\n\t}\n\n\tfor ( i = 0; i < flen; i++ ) {\n\n\t\tface = faces[ i ];\n\n\t\tvar a = face[ 0 ] + shapesOffset;\n\t\tvar b = face[ 1 ] + shapesOffset;\n\t\tvar c = face[ 2 ] + shapesOffset;\n\n\t\tthis.faces.push( new THREE.Face3( a, b, c, null, null, material ) );\n\t\tthis.faceVertexUvs[ 0 ].push( uvgen.generateBottomUV( this, shape, options, a, b, c ) );\n\n\t}\n\n};\n/**\n * @author astrodud / http://astrodud.isgreat.org/\n * @author zz85 / https://github.com/zz85\n * @author bhouston / http://exocortex.com\n */\n\n// points - to create a closed torus, one must use a set of points \n//    like so: [ a, b, c, d, a ], see first is the same as last.\n// segments - the number of circumference segments to create\n// phiStart - the starting radian\n// phiLength - the radian (0 to 2*PI) range of the lathed section\n//    2*pi is a closed lathe, less than 2PI is a portion.\nTHREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {\n\n\tTHREE.Geometry.call( this );\n\n\tsegments = segments || 12;\n\tphiStart = phiStart || 0;\n\tphiLength = phiLength || 2 * Math.PI;\n\n\tvar inversePointLength = 1.0 / ( points.length - 1 );\n\tvar inverseSegments = 1.0 / segments;\n\n\tfor ( var i = 0, il = segments; i <= il; i ++ ) {\n\n\t\tvar phi = phiStart + i * inverseSegments * phiLength;\n\n\t\tvar c = Math.cos( phi ),\n\t\t\ts = Math.sin( phi );\n\n\t\tfor ( var j = 0, jl = points.length; j < jl; j ++ ) {\n\n\t\t\tvar pt = points[ j ];\n\n\t\t\tvar vertex = new THREE.Vector3();\n\n\t\t\tvertex.x = c * pt.x - s * pt.y;\n\t\t\tvertex.y = s * pt.x + c * pt.y;\n\t\t\tvertex.z = pt.z;\n\n\t\t\tthis.vertices.push( vertex );\n\n\t\t}\n\n\t}\n\n\tvar np = points.length;\n\n\tfor ( var i = 0, il = segments; i < il; i ++ ) {\n\n\t\tfor ( var j = 0, jl = points.length - 1; j < jl; j ++ ) {\n\n\t\t\tvar base = j + np * i;\n\t\t\tvar a = base;\n\t\t\tvar b = base + np;\n\t\t\tvar c = base + 1 + np;\n\t\t\tvar d = base + 1;\n\n\t\t\tthis.faces.push( new THREE.Face4( a, b, c, d ) );\n\n\t\t\tvar u0 = i * inverseSegments;\n\t\t\tvar v0 = j * inversePointLength;\n\t\t\tvar u1 = u0 + inverseSegments;\n\t\t\tvar v1 = v0 + inversePointLength;\n\n\t\t\tthis.faceVertexUvs[ 0 ].push( [\n\n\t\t\t\tnew THREE.Vector2( u0, v0 ), \n\t\t\t\tnew THREE.Vector2( u1, v0 ),\n\t\t\t\tnew THREE.Vector2( u1, v1 ),\n\t\t\t\tnew THREE.Vector2( u0, v1 )\n\n\t\t\t] );\n\n\t\t}\n\n\t}\n\n\tthis.mergeVertices();\n\tthis.computeCentroids();\n\tthis.computeFaceNormals();\n\tthis.computeVertexNormals();\n\n};\n\nTHREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );\n/**\n * @author mrdoob / http://mrdoob.com/\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\n */\n\nTHREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.width = width;\n\tthis.height = height;\n\n\tthis.widthSegments = widthSegments || 1;\n\tthis.heightSegments = heightSegments || 1;\n\n\tvar ix, iz;\n\tvar width_half = width / 2;\n\tvar height_half = height / 2;\n\n\tvar gridX = this.widthSegments;\n\tvar gridZ = this.heightSegments;\n\n\tvar gridX1 = gridX + 1;\n\tvar gridZ1 = gridZ + 1;\n\n\tvar segment_width = this.width / gridX;\n\tvar segment_height = this.height / gridZ;\n\n\tvar normal = new THREE.Vector3( 0, 0, 1 );\n\n\tfor ( iz = 0; iz < gridZ1; iz ++ ) {\n\n\t\tfor ( ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\tvar x = ix * segment_width - width_half;\n\t\t\tvar y = iz * segment_height - height_half;\n\n\t\t\tthis.vertices.push( new THREE.Vector3( x, - y, 0 ) );\n\n\t\t}\n\n\t}\n\n\tfor ( iz = 0; iz < gridZ; iz ++ ) {\n\n\t\tfor ( ix = 0; ix < gridX; ix ++ ) {\n\n\t\t\tvar a = ix + gridX1 * iz;\n\t\t\tvar b = ix + gridX1 * ( iz + 1 );\n\t\t\tvar c = ( ix + 1 ) + gridX1 * ( iz + 1 );\n\t\t\tvar d = ( ix + 1 ) + gridX1 * iz;\n\n\t\t\tvar face = new THREE.Face4( a, b, c, d );\n\t\t\tface.normal.copy( normal );\n\t\t\tface.vertexNormals.push( normal.clone(), normal.clone(), normal.clone(), normal.clone() );\n\n\t\t\tthis.faces.push( face );\n\t\t\tthis.faceVertexUvs[ 0 ].push( [\n\t\t\t\tnew THREE.Vector2( ix / gridX, 1 - iz / gridZ ),\n\t\t\t\tnew THREE.Vector2( ix / gridX, 1 - ( iz + 1 ) / gridZ ),\n\t\t\t\tnew THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iz + 1 ) / gridZ ),\n\t\t\t\tnew THREE.Vector2( ( ix + 1 ) / gridX, 1 - iz / gridZ )\n\t\t\t] );\n\n\t\t}\n\n\t}\n\n\tthis.computeCentroids();\n\n};\n\nTHREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.radius = radius || 50;\n\n\tthis.widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );\n\tthis.heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );\n\n\tphiStart = phiStart !== undefined ? phiStart : 0;\n\tphiLength = phiLength !== undefined ? phiLength : Math.PI * 2;\n\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI;\n\n\tvar x, y, vertices = [], uvs = [];\n\n\tfor ( y = 0; y <= this.heightSegments; y ++ ) {\n\n\t\tvar verticesRow = [];\n\t\tvar uvsRow = [];\n\n\t\tfor ( x = 0; x <= this.widthSegments; x ++ ) {\n\n\t\t\tvar u = x / this.widthSegments;\n\t\t\tvar v = y / this.heightSegments;\n\n\t\t\tvar vertex = new THREE.Vector3();\n\t\t\tvertex.x = - this.radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\t\t\tvertex.y = this.radius * Math.cos( thetaStart + v * thetaLength );\n\t\t\tvertex.z = this.radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\n\t\t\tthis.vertices.push( vertex );\n\n\t\t\tverticesRow.push( this.vertices.length - 1 );\n\t\t\tuvsRow.push( new THREE.Vector2( u, 1 - v ) );\n\n\t\t}\n\n\t\tvertices.push( verticesRow );\n\t\tuvs.push( uvsRow );\n\n\t}\n\n\tfor ( y = 0; y < this.heightSegments; y ++ ) {\n\n\t\tfor ( x = 0; x < this.widthSegments; x ++ ) {\n\n\t\t\tvar v1 = vertices[ y ][ x + 1 ];\n\t\t\tvar v2 = vertices[ y ][ x ];\n\t\t\tvar v3 = vertices[ y + 1 ][ x ];\n\t\t\tvar v4 = vertices[ y + 1 ][ x + 1 ];\n\n\t\t\tvar n1 = this.vertices[ v1 ].clone().normalize();\n\t\t\tvar n2 = this.vertices[ v2 ].clone().normalize();\n\t\t\tvar n3 = this.vertices[ v3 ].clone().normalize();\n\t\t\tvar n4 = this.vertices[ v4 ].clone().normalize();\n\n\t\t\tvar uv1 = uvs[ y ][ x + 1 ].clone();\n\t\t\tvar uv2 = uvs[ y ][ x ].clone();\n\t\t\tvar uv3 = uvs[ y + 1 ][ x ].clone();\n\t\t\tvar uv4 = uvs[ y + 1 ][ x + 1 ].clone();\n\n\t\t\tif ( Math.abs( this.vertices[ v1 ].y ) === this.radius ) {\n\n\t\t\t\tthis.faces.push( new THREE.Face3( v1, v3, v4, [ n1, n3, n4 ] ) );\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv3, uv4 ] );\n\n\t\t\t} else if ( Math.abs( this.vertices[ v3 ].y ) === this.radius ) {\n\n\t\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );\n\n\t\t\t} else {\n\n\t\t\t\tthis.faces.push( new THREE.Face4( v1, v2, v3, v4, [ n1, n2, n3, n4 ] ) );\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3, uv4 ] );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tthis.computeCentroids();\n\tthis.computeFaceNormals();\n\n    this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\n\n};\n\nTHREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * @author alteredq / http://alteredqualia.com/\n *\n * For creating 3D text geometry in three.js\n *\n * Text = 3D Text\n *\n * parameters = {\n *  size: \t\t\t<float>, \t// size of the text\n *  height: \t\t<float>, \t// thickness to extrude text\n *  curveSegments: \t<int>,\t\t// number of points on the curves\n *\n *  font: \t\t\t<string>,\t\t// font name\n *  weight: \t\t<string>,\t\t// font weight (normal, bold)\n *  style: \t\t\t<string>,\t\t// font style  (normal, italics)\n *\n *  bevelEnabled:\t<bool>,\t\t\t// turn on bevel\n *  bevelThickness: <float>, \t\t// how deep into text bevel goes\n *  bevelSize:\t\t<float>, \t\t// how far from text outline is bevel\n *  }\n *\n */\n\n/*\tUsage Examples\n\n\t// TextGeometry wrapper\n\n\tvar text3d = new TextGeometry( text, options );\n\n\t// Complete manner\n\n\tvar textShapes = THREE.FontUtils.generateShapes( text, options );\n\tvar text3d = new ExtrudeGeometry( textShapes, options );\n\n*/\n\n\nTHREE.TextGeometry = function ( text, parameters ) {\n\n\tvar textShapes = THREE.FontUtils.generateShapes( text, parameters );\n\n\t// translate parameters to ExtrudeGeometry API\n\n\tparameters.amount = parameters.height !== undefined ? parameters.height : 50;\n\n\t// defaults\n\n\tif ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;\n\tif ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;\n\tif ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;\n\n\tTHREE.ExtrudeGeometry.call( this, textShapes, parameters );\n\n};\n\nTHREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );\n/**\n * @author oosmoxiecode\n * @author mrdoob / http://mrdoob.com/\n * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888\n */\n\nTHREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {\n\n\tTHREE.Geometry.call( this );\n\n\tvar scope = this;\n\n\tthis.radius = radius || 100;\n\tthis.tube = tube || 40;\n\tthis.radialSegments = radialSegments || 8;\n\tthis.tubularSegments = tubularSegments || 6;\n\tthis.arc = arc || Math.PI * 2;\n\n\tvar center = new THREE.Vector3(), uvs = [], normals = [];\n\n\tfor ( var j = 0; j <= this.radialSegments; j ++ ) {\n\n\t\tfor ( var i = 0; i <= this.tubularSegments; i ++ ) {\n\n\t\t\tvar u = i / this.tubularSegments * this.arc;\n\t\t\tvar v = j / this.radialSegments * Math.PI * 2;\n\n\t\t\tcenter.x = this.radius * Math.cos( u );\n\t\t\tcenter.y = this.radius * Math.sin( u );\n\n\t\t\tvar vertex = new THREE.Vector3();\n\t\t\tvertex.x = ( this.radius + this.tube * Math.cos( v ) ) * Math.cos( u );\n\t\t\tvertex.y = ( this.radius + this.tube * Math.cos( v ) ) * Math.sin( u );\n\t\t\tvertex.z = this.tube * Math.sin( v );\n\n\t\t\tthis.vertices.push( vertex );\n\n\t\t\tuvs.push( new THREE.Vector2( i / this.tubularSegments, j / this.radialSegments ) );\n\t\t\tnormals.push( vertex.clone().sub( center ).normalize() );\n\n\t\t}\n\t}\n\n\n\tfor ( var j = 1; j <= this.radialSegments; j ++ ) {\n\n\t\tfor ( var i = 1; i <= this.tubularSegments; i ++ ) {\n\n\t\t\tvar a = ( this.tubularSegments + 1 ) * j + i - 1;\n\t\t\tvar b = ( this.tubularSegments + 1 ) * ( j - 1 ) + i - 1;\n\t\t\tvar c = ( this.tubularSegments + 1 ) * ( j - 1 ) + i;\n\t\t\tvar d = ( this.tubularSegments + 1 ) * j + i;\n\n\t\t\tvar face = new THREE.Face4( a, b, c, d, [ normals[ a ], normals[ b ], normals[ c ], normals[ d ] ] );\n\t\t\tface.normal.add( normals[ a ] );\n\t\t\tface.normal.add( normals[ b ] );\n\t\t\tface.normal.add( normals[ c ] );\n\t\t\tface.normal.add( normals[ d ] );\n\t\t\tface.normal.normalize();\n\n\t\t\tthis.faces.push( face );\n\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvs[ a ].clone(), uvs[ b ].clone(), uvs[ c ].clone(), uvs[ d ].clone() ] );\n\t\t}\n\n\t}\n\n\tthis.computeCentroids();\n\n};\n\nTHREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );\n/**\n * @author oosmoxiecode\n * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473\n */\n\nTHREE.TorusKnotGeometry = function ( radius, tube, radialSegments, tubularSegments, p, q, heightScale ) {\n\n\tTHREE.Geometry.call( this );\n\n\tvar scope = this;\n\n\tthis.radius = radius || 100;\n\tthis.tube = tube || 40;\n\tthis.radialSegments = radialSegments || 64;\n\tthis.tubularSegments = tubularSegments || 8;\n\tthis.p = p || 2;\n\tthis.q = q || 3;\n\tthis.heightScale = heightScale || 1;\n\tthis.grid = new Array( this.radialSegments );\n\n\tvar tang = new THREE.Vector3();\n\tvar n = new THREE.Vector3();\n\tvar bitan = new THREE.Vector3();\n\n\tfor ( var i = 0; i < this.radialSegments; ++ i ) {\n\n\t\tthis.grid[ i ] = new Array( this.tubularSegments );\n\n\t\tfor ( var j = 0; j < this.tubularSegments; ++ j ) {\n\n\t\t\tvar u = i / this.radialSegments * 2 * this.p * Math.PI;\n\t\t\tvar v = j / this.tubularSegments * 2 * Math.PI;\n\t\t\tvar p1 = getPos( u, v, this.q, this.p, this.radius, this.heightScale );\n\t\t\tvar p2 = getPos( u + 0.01, v, this.q, this.p, this.radius, this.heightScale );\n\t\t\tvar cx, cy;\n\n\t\t\ttang.subVectors( p2, p1 );\n\t\t\tn.addVectors( p2, p1 );\n\n\t\t\tbitan.crossVectors( tang, n );\n\t\t\tn.crossVectors( bitan, tang );\n\t\t\tbitan.normalize();\n\t\t\tn.normalize();\n\n\t\t\tcx = - this.tube * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.\n\t\t\tcy = this.tube * Math.sin( v );\n\n\t\t\tp1.x += cx * n.x + cy * bitan.x;\n\t\t\tp1.y += cx * n.y + cy * bitan.y;\n\t\t\tp1.z += cx * n.z + cy * bitan.z;\n\n\t\t\tthis.grid[ i ][ j ] = vert( p1.x, p1.y, p1.z );\n\n\t\t}\n\n\t}\n\n\tfor ( var i = 0; i < this.radialSegments; ++ i ) {\n\n\t\tfor ( var j = 0; j < this.tubularSegments; ++ j ) {\n\n\t\t\tvar ip = ( i + 1 ) % this.radialSegments;\n\t\t\tvar jp = ( j + 1 ) % this.tubularSegments;\n\n\t\t\tvar a = this.grid[ i ][ j ];\n\t\t\tvar b = this.grid[ ip ][ j ];\n\t\t\tvar c = this.grid[ ip ][ jp ];\n\t\t\tvar d = this.grid[ i ][ jp ];\n\n\t\t\tvar uva = new THREE.Vector2( i / this.radialSegments, j / this.tubularSegments );\n\t\t\tvar uvb = new THREE.Vector2( ( i + 1 ) / this.radialSegments, j / this.tubularSegments );\n\t\t\tvar uvc = new THREE.Vector2( ( i + 1 ) / this.radialSegments, ( j + 1 ) / this.tubularSegments );\n\t\t\tvar uvd = new THREE.Vector2( i / this.radialSegments, ( j + 1 ) / this.tubularSegments );\n\n\t\t\tthis.faces.push( new THREE.Face4( a, b, c, d ) );\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uva,uvb,uvc, uvd ] );\n\n\t\t}\n\t}\n\n\tthis.computeCentroids();\n\tthis.computeFaceNormals();\n\tthis.computeVertexNormals();\n\n\tfunction vert( x, y, z ) {\n\n\t\treturn scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;\n\n\t}\n\n\tfunction getPos( u, v, in_q, in_p, radius, heightScale ) {\n\n\t\tvar cu = Math.cos( u );\n\t\tvar cv = Math.cos( v );\n\t\tvar su = Math.sin( u );\n\t\tvar quOverP = in_q / in_p * u;\n\t\tvar cs = Math.cos( quOverP );\n\n\t\tvar tx = radius * ( 2 + cs ) * 0.5 * cu;\n\t\tvar ty = radius * ( 2 + cs ) * su * 0.5;\n\t\tvar tz = heightScale * radius * Math.sin( quOverP ) * 0.5;\n\n\t\treturn new THREE.Vector3( tx, ty, tz );\n\n\t}\n\n};\n\nTHREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );\n/**\n * @author WestLangley / https://github.com/WestLangley\n * @author zz85 / https://github.com/zz85\n * @author miningold / https://github.com/miningold\n *\n * Modified from the TorusKnotGeometry by @oosmoxiecode\n *\n * Creates a tube which extrudes along a 3d spline\n *\n * Uses parallel transport frames as described in\n * http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n */\n\nTHREE.TubeGeometry = function( path, segments, radius, radiusSegments, closed, debug ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.path = path;\n\tthis.segments = segments || 64;\n\tthis.radius = radius || 1;\n\tthis.radiusSegments = radiusSegments || 8;\n\tthis.closed = closed || false;\n\n\tif ( debug ) this.debug = new THREE.Object3D();\n\n\tthis.grid = [];\n\n\tvar scope = this,\n\n\t\ttangent,\n\t\tnormal,\n\t\tbinormal,\n\n\t\tnumpoints = this.segments + 1,\n\n\t\tx, y, z,\n\t\ttx, ty, tz,\n\t\tu, v,\n\n\t\tcx, cy,\n\t\tpos, pos2 = new THREE.Vector3(),\n\t\ti, j,\n\t\tip, jp,\n\t\ta, b, c, d,\n\t\tuva, uvb, uvc, uvd;\n\n\tvar frames = new THREE.TubeGeometry.FrenetFrames( this.path, this.segments, this.closed ),\n\t\ttangents = frames.tangents,\n\t\tnormals = frames.normals,\n\t\tbinormals = frames.binormals;\n\n\t// proxy internals\n\tthis.tangents = tangents;\n\tthis.normals = normals;\n\tthis.binormals = binormals;\n\n\tfunction vert( x, y, z ) {\n\n\t\treturn scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;\n\n\t}\n\n\n\t// consruct the grid\n\n\tfor ( i = 0; i < numpoints; i++ ) {\n\n\t\tthis.grid[ i ] = [];\n\n\t\tu = i / ( numpoints - 1 );\n\n\t\tpos = path.getPointAt( u );\n\n\t\ttangent = tangents[ i ];\n\t\tnormal = normals[ i ];\n\t\tbinormal = binormals[ i ];\n\n\t\tif ( this.debug ) {\n\n\t\t\tthis.debug.add( new THREE.ArrowHelper(tangent, pos, radius, 0x0000ff ) );\n\t\t\tthis.debug.add( new THREE.ArrowHelper(normal, pos, radius, 0xff0000 ) );\n\t\t\tthis.debug.add( new THREE.ArrowHelper(binormal, pos, radius, 0x00ff00 ) );\n\n\t\t}\n\n\t\tfor ( j = 0; j < this.radiusSegments; j++ ) {\n\n\t\t\tv = j / this.radiusSegments * 2 * Math.PI;\n\n\t\t\tcx = -this.radius * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.\n\t\t\tcy = this.radius * Math.sin( v );\n\n\t\t\tpos2.copy( pos );\n\t\t\tpos2.x += cx * normal.x + cy * binormal.x;\n\t\t\tpos2.y += cx * normal.y + cy * binormal.y;\n\t\t\tpos2.z += cx * normal.z + cy * binormal.z;\n\n\t\t\tthis.grid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );\n\n\t\t}\n\t}\n\n\n\t// construct the mesh\n\n\tfor ( i = 0; i < this.segments; i++ ) {\n\n\t\tfor ( j = 0; j < this.radiusSegments; j++ ) {\n\n\t\t\tip = ( this.closed ) ? (i + 1) % this.segments : i + 1;\n\t\t\tjp = (j + 1) % this.radiusSegments;\n\n\t\t\ta = this.grid[ i ][ j ];\t\t// *** NOT NECESSARILY PLANAR ! ***\n\t\t\tb = this.grid[ ip ][ j ];\n\t\t\tc = this.grid[ ip ][ jp ];\n\t\t\td = this.grid[ i ][ jp ];\n\n\t\t\tuva = new THREE.Vector2( i / this.segments, j / this.radiusSegments );\n\t\t\tuvb = new THREE.Vector2( ( i + 1 ) / this.segments, j / this.radiusSegments );\n\t\t\tuvc = new THREE.Vector2( ( i + 1 ) / this.segments, ( j + 1 ) / this.radiusSegments );\n\t\t\tuvd = new THREE.Vector2( i / this.segments, ( j + 1 ) / this.radiusSegments );\n\n\t\t\tthis.faces.push( new THREE.Face4( a, b, c, d ) );\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uva, uvb, uvc, uvd ] );\n\n\t\t}\n\t}\n\n\tthis.computeCentroids();\n\tthis.computeFaceNormals();\n\tthis.computeVertexNormals();\n\n};\n\nTHREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\n\n// For computing of Frenet frames, exposing the tangents, normals and binormals the spline\nTHREE.TubeGeometry.FrenetFrames = function(path, segments, closed) {\n\n\tvar\ttangent = new THREE.Vector3(),\n\t\tnormal = new THREE.Vector3(),\n\t\tbinormal = new THREE.Vector3(),\n\n\t\ttangents = [],\n\t\tnormals = [],\n\t\tbinormals = [],\n\n\t\tvec = new THREE.Vector3(),\n\t\tmat = new THREE.Matrix4(),\n\n\t\tnumpoints = segments + 1,\n\t\ttheta,\n\t\tepsilon = 0.0001,\n\t\tsmallest,\n\n\t\ttx, ty, tz,\n\t\ti, u, v;\n\n\n\t// expose internals\n\tthis.tangents = tangents;\n\tthis.normals = normals;\n\tthis.binormals = binormals;\n\n\t// compute the tangent vectors for each segment on the path\n\n\tfor ( i = 0; i < numpoints; i++ ) {\n\n\t\tu = i / ( numpoints - 1 );\n\n\t\ttangents[ i ] = path.getTangentAt( u );\n\t\ttangents[ i ].normalize();\n\n\t}\n\n\tinitialNormal3();\n\n\tfunction initialNormal1(lastBinormal) {\n\t\t// fixed start binormal. Has dangers of 0 vectors\n\t\tnormals[ 0 ] = new THREE.Vector3();\n\t\tbinormals[ 0 ] = new THREE.Vector3();\n\t\tif (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );\n\t\tnormals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\n\t}\n\n\tfunction initialNormal2() {\n\n\t\t// This uses the Frenet-Serret formula for deriving binormal\n\t\tvar t2 = path.getTangentAt( epsilon );\n\n\t\tnormals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();\n\t\tbinormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );\n\n\t\tnormals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\n\n\t}\n\n\tfunction initialNormal3() {\n\t\t// select an initial normal vector perpenicular to the first tangent vector,\n\t\t// and in the direction of the smallest tangent xyz component\n\n\t\tnormals[ 0 ] = new THREE.Vector3();\n\t\tbinormals[ 0 ] = new THREE.Vector3();\n\t\tsmallest = Number.MAX_VALUE;\n\t\ttx = Math.abs( tangents[ 0 ].x );\n\t\tty = Math.abs( tangents[ 0 ].y );\n\t\ttz = Math.abs( tangents[ 0 ].z );\n\n\t\tif ( tx <= smallest ) {\n\t\t\tsmallest = tx;\n\t\t\tnormal.set( 1, 0, 0 );\n\t\t}\n\n\t\tif ( ty <= smallest ) {\n\t\t\tsmallest = ty;\n\t\t\tnormal.set( 0, 1, 0 );\n\t\t}\n\n\t\tif ( tz <= smallest ) {\n\t\t\tnormal.set( 0, 0, 1 );\n\t\t}\n\n\t\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\n\n\t\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\n\t}\n\n\n\t// compute the slowly-varying normal and binormal vectors for each segment on the path\n\n\tfor ( i = 1; i < numpoints; i++ ) {\n\n\t\tnormals[ i ] = normals[ i-1 ].clone();\n\n\t\tbinormals[ i ] = binormals[ i-1 ].clone();\n\n\t\tvec.crossVectors( tangents[ i-1 ], tangents[ i ] );\n\n\t\tif ( vec.length() > epsilon ) {\n\n\t\t\tvec.normalize();\n\n\t\t\ttheta = Math.acos( tangents[ i-1 ].dot( tangents[ i ] ) );\n\n\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\n\n\t\t}\n\n\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t}\n\n\n\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n\n\tif ( closed ) {\n\n\t\ttheta = Math.acos( normals[ 0 ].dot( normals[ numpoints-1 ] ) );\n\t\ttheta /= ( numpoints - 1 );\n\n\t\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints-1 ] ) ) > 0 ) {\n\n\t\t\ttheta = -theta;\n\n\t\t}\n\n\t\tfor ( i = 1; i < numpoints; i++ ) {\n\n\t\t\t// twist a little...\n\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\n\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t\t}\n\n\t}\n};\n/**\n * @author clockworkgeek / https://github.com/clockworkgeek\n * @author timothypratley / https://github.com/timothypratley\n */\n\nTHREE.PolyhedronGeometry = function ( vertices, faces, radius, detail ) {\n\n\tTHREE.Geometry.call( this );\n\n\tradius = radius || 1;\n\tdetail = detail || 0;\n\n\tvar that = this;\n\n\tfor ( var i = 0, l = vertices.length; i < l; i ++ ) {\n\n\t\tprepare( new THREE.Vector3( vertices[ i ][ 0 ], vertices[ i ][ 1 ], vertices[ i ][ 2 ] ) );\n\n\t}\n\n\tvar midpoints = [], p = this.vertices;\n\n\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\tmake( p[ faces[ i ][ 0 ] ], p[ faces[ i ][ 1 ] ], p[ faces[ i ][ 2 ] ], detail );\n\n\t}\n\n\tthis.mergeVertices();\n\n\t// Apply radius\n\n\tfor ( var i = 0, l = this.vertices.length; i < l; i ++ ) {\n\n\t\tthis.vertices[ i ].multiplyScalar( radius );\n\n\t}\n\n\n\t// Project vector onto sphere's surface\n\n\tfunction prepare( vector ) {\n\n\t\tvar vertex = vector.normalize().clone();\n\t\tvertex.index = that.vertices.push( vertex ) - 1;\n\n\t\t// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.\n\n\t\tvar u = azimuth( vector ) / 2 / Math.PI + 0.5;\n\t\tvar v = inclination( vector ) / Math.PI + 0.5;\n\t\tvertex.uv = new THREE.Vector2( u, 1 - v );\n\n\t\treturn vertex;\n\n\t}\n\n\n\t// Approximate a curved face with recursively sub-divided triangles.\n\n\tfunction make( v1, v2, v3, detail ) {\n\n\t\tif ( detail < 1 ) {\n\n\t\t\tvar face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );\n\t\t\tface.centroid.add( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );\n\t\t\tface.normal = face.centroid.clone().normalize();\n\t\t\tthat.faces.push( face );\n\n\t\t\tvar azi = azimuth( face.centroid );\n\t\t\tthat.faceVertexUvs[ 0 ].push( [\n\t\t\t\tcorrectUV( v1.uv, v1, azi ),\n\t\t\t\tcorrectUV( v2.uv, v2, azi ),\n\t\t\t\tcorrectUV( v3.uv, v3, azi )\n\t\t\t] );\n\n\t\t} else {\n\n\t\t\tdetail -= 1;\n\n\t\t\t// split triangle into 4 smaller triangles\n\n\t\t\tmake( v1, midpoint( v1, v2 ), midpoint( v1, v3 ), detail ); // top quadrant\n\t\t\tmake( midpoint( v1, v2 ), v2, midpoint( v2, v3 ), detail ); // left quadrant\n\t\t\tmake( midpoint( v1, v3 ), midpoint( v2, v3 ), v3, detail ); // right quadrant\n\t\t\tmake( midpoint( v1, v2 ), midpoint( v2, v3 ), midpoint( v1, v3 ), detail ); // center quadrant\n\n\t\t}\n\n\t}\n\n\tfunction midpoint( v1, v2 ) {\n\n\t\tif ( !midpoints[ v1.index ] ) midpoints[ v1.index ] = [];\n\t\tif ( !midpoints[ v2.index ] ) midpoints[ v2.index ] = [];\n\n\t\tvar mid = midpoints[ v1.index ][ v2.index ];\n\n\t\tif ( mid === undefined ) {\n\n\t\t\t// generate mean point and project to surface with prepare()\n\n\t\t\tmidpoints[ v1.index ][ v2.index ] = midpoints[ v2.index ][ v1.index ] = mid = prepare(\n\t\t\t\tnew THREE.Vector3().addVectors( v1, v2 ).divideScalar( 2 )\n\t\t\t);\n\t\t}\n\n\t\treturn mid;\n\n\t}\n\n\n\t// Angle around the Y axis, counter-clockwise when looking from above.\n\n\tfunction azimuth( vector ) {\n\n\t\treturn Math.atan2( vector.z, -vector.x );\n\n\t}\n\n\n\t// Angle above the XZ plane.\n\n\tfunction inclination( vector ) {\n\n\t\treturn Math.atan2( -vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\n\n\t}\n\n\n\t// Texture fixing helper. Spheres have some odd behaviours.\n\n\tfunction correctUV( uv, vector, azimuth ) {\n\n\t\tif ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );\n\t\tif ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );\n\t\treturn uv;\n\n\t}\n\n\tthis.computeCentroids();\n\n    this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\n\n};\n\nTHREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\n/**\n * @author timothypratley / https://github.com/timothypratley\n */\n\nTHREE.IcosahedronGeometry = function ( radius, detail ) {\n\n\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\n\tvar vertices = [\n\t\t[ -1,  t,  0 ], [  1, t, 0 ], [ -1, -t,  0 ], [  1, -t,  0 ],\n\t\t[  0, -1,  t ], [  0, 1, t ], [  0, -1, -t ], [  0,  1, -t ],\n\t\t[  t,  0, -1 ], [  t, 0, 1 ], [ -t,  0, -1 ], [ -t,  0,  1 ]\n\t];\n\n\tvar faces = [\n\t\t[ 0, 11,  5 ], [ 0,  5,  1 ], [  0,  1,  7 ], [  0,  7, 10 ], [  0, 10, 11 ],\n\t\t[ 1,  5,  9 ], [ 5, 11,  4 ], [ 11, 10,  2 ], [ 10,  7,  6 ], [  7,  1,  8 ],\n\t\t[ 3,  9,  4 ], [ 3,  4,  2 ], [  3,  2,  6 ], [  3,  6,  8 ], [  3,  8,  9 ],\n\t\t[ 4,  9,  5 ], [ 2,  4, 11 ], [  6,  2, 10 ], [  8,  6,  7 ], [  9,  8,  1 ]\n\t];\n\n\tTHREE.PolyhedronGeometry.call( this, vertices, faces, radius, detail );\n\n};\n\nTHREE.IcosahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\n/**\n * @author timothypratley / https://github.com/timothypratley\n */\n\nTHREE.OctahedronGeometry = function ( radius, detail ) {\n\n\tvar vertices = [\n\t\t[ 1, 0, 0 ], [ -1, 0, 0 ], [ 0, 1, 0 ], [ 0, -1, 0 ], [ 0, 0, 1 ], [ 0, 0, -1 ]\n\t];\n\n\tvar faces = [\n\t\t[ 0, 2, 4 ], [ 0, 4, 3 ], [ 0, 3, 5 ], [ 0, 5, 2 ], [ 1, 2, 5 ], [ 1, 5, 3 ], [ 1, 3, 4 ], [ 1, 4, 2 ]\n\t];\n\n\tTHREE.PolyhedronGeometry.call( this, vertices, faces, radius, detail );\n};\n\nTHREE.OctahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\n/**\n * @author timothypratley / https://github.com/timothypratley\n */\n\nTHREE.TetrahedronGeometry = function ( radius, detail ) {\n\n\tvar vertices = [\n\t\t[ 1,  1,  1 ], [ -1, -1, 1 ], [ -1, 1, -1 ], [ 1, -1, -1 ]\n\t];\n\n\tvar faces = [\n\t\t[ 2, 1, 0 ], [ 0, 3, 2 ], [ 1, 3, 0 ], [ 2, 3, 1 ]\n\t];\n\n\tTHREE.PolyhedronGeometry.call( this, vertices, faces, radius, detail );\n\n};\n\nTHREE.TetrahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\n/**\n * @author zz85 / https://github.com/zz85\n * Parametric Surfaces Geometry\n * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\n *\n * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements, useTris );\n *\n */\n\nTHREE.ParametricGeometry = function ( func, slices, stacks, useTris ) {\n\n\tTHREE.Geometry.call( this );\n\n\tvar verts = this.vertices;\n\tvar faces = this.faces;\n\tvar uvs = this.faceVertexUvs[ 0 ];\n\n\tuseTris = (useTris === undefined) ? false : useTris;\n\n\tvar i, il, j, p;\n\tvar u, v;\n\n\tvar stackCount = stacks + 1;\n\tvar sliceCount = slices + 1;\n\n\tfor ( i = 0; i <= stacks; i ++ ) {\n\n\t\tv = i / stacks;\n\n\t\tfor ( j = 0; j <= slices; j ++ ) {\n\n\t\t\tu = j / slices;\n\n\t\t\tp = func( u, v );\n\t\t\tverts.push( p );\n\n\t\t}\n\t}\n\n\tvar a, b, c, d;\n\tvar uva, uvb, uvc, uvd;\n\n\tfor ( i = 0; i < stacks; i ++ ) {\n\n\t\tfor ( j = 0; j < slices; j ++ ) {\n\n\t\t\ta = i * sliceCount + j;\n\t\t\tb = i * sliceCount + j + 1;\n\t\t\tc = (i + 1) * sliceCount + j;\n\t\t\td = (i + 1) * sliceCount + j + 1;\n\n\t\t\tuva = new THREE.Vector2( j / slices, i / stacks );\n\t\t\tuvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );\n\t\t\tuvc = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );\n\t\t\tuvd = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );\n\n\t\t\tif ( useTris ) {\n\n\t\t\t\tfaces.push( new THREE.Face3( a, b, c ) );\n\t\t\t\tfaces.push( new THREE.Face3( b, d, c ) );\n\n\t\t\t\tuvs.push( [ uva, uvb, uvc ] );\n\t\t\t\tuvs.push( [ uvb, uvd, uvc ] );\n\n\t\t\t} else {\n\n\t\t\t\tfaces.push( new THREE.Face4( a, b, d, c ) );\n\t\t\t\tuvs.push( [ uva, uvb, uvd, uvc ] );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// console.log(this);\n\n\t// magic bullet\n\t// var diff = this.mergeVertices();\n\t// console.log('removed ', diff, ' vertices by merging');\n\n\tthis.computeCentroids();\n\tthis.computeFaceNormals();\n\tthis.computeVertexNormals();\n\n};\n\nTHREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );\n/**\n * @author qiao / https://github.com/qiao\n * @fileoverview This is a convex hull generator using the incremental method. \n * The complexity is O(n^2) where n is the number of vertices.\n * O(nlogn) algorithms do exist, but they are much more complicated.\n *\n * Benchmark: \n *\n *  Platform: CPU: P7350 @2.00GHz Engine: V8\n *\n *  Num Vertices\tTime(ms)\n *\n *     10           1\n *     20           3\n *     30           19\n *     40           48\n *     50           107\n */\n\nTHREE.ConvexGeometry = function( vertices ) {\n\n\tTHREE.Geometry.call( this );\n\n\tvar faces = [ [ 0, 1, 2 ], [ 0, 2, 1 ] ]; \n\n\tfor ( var i = 3; i < vertices.length; i++ ) {\n\n\t\taddPoint( i );\n\n\t}\n\n\n\tfunction addPoint( vertexId ) {\n\n\t\tvar vertex = vertices[ vertexId ].clone();\n\n\t\tvar mag = vertex.length();\n\t\tvertex.x += mag * randomOffset();\n\t\tvertex.y += mag * randomOffset();\n\t\tvertex.z += mag * randomOffset();\n\n\t\tvar hole = [];\n\n\t\tfor ( var f = 0; f < faces.length; ) {\n\n\t\t\tvar face = faces[ f ];\n\n\t\t\t// for each face, if the vertex can see it,\n\t\t\t// then we try to add the face's edges into the hole.\n\t\t\tif ( visible( face, vertex ) ) {\n\n\t\t\t\tfor ( var e = 0; e < 3; e++ ) {\n\n\t\t\t\t\tvar edge = [ face[ e ], face[ ( e + 1 ) % 3 ] ];\n\t\t\t\t\tvar boundary = true;\n\n\t\t\t\t\t// remove duplicated edges.\n\t\t\t\t\tfor ( var h = 0; h < hole.length; h++ ) {\n\n\t\t\t\t\t\tif ( equalEdge( hole[ h ], edge ) ) {\n\n\t\t\t\t\t\t\thole[ h ] = hole[ hole.length - 1 ];\n\t\t\t\t\t\t\thole.pop();\n\t\t\t\t\t\t\tboundary = false;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( boundary ) {\n\n\t\t\t\t\t\thole.push( edge );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// remove faces[ f ]\n\t\t\t\tfaces[ f ] = faces[ faces.length - 1 ];\n\t\t\t\tfaces.pop();\n\n\t\t\t} else { // not visible\n\n\t\t\t\tf++;\n\n\t\t\t}\n\t\t}\n\n\t\t// construct the new faces formed by the edges of the hole and the vertex\n\t\tfor ( var h = 0; h < hole.length; h++ ) {\n\n\t\t\tfaces.push( [ \n\t\t\t\thole[ h ][ 0 ],\n\t\t\t\thole[ h ][ 1 ],\n\t\t\t\tvertexId\n\t\t\t] );\n\n\t\t}\n\t}\n\n\t/**\n\t * Whether the face is visible from the vertex\n\t */\n\tfunction visible( face, vertex ) {\n\n\t\tvar va = vertices[ face[ 0 ] ];\n\t\tvar vb = vertices[ face[ 1 ] ];\n\t\tvar vc = vertices[ face[ 2 ] ];\n\n\t\tvar n = normal( va, vb, vc );\n\n\t\t// distance from face to origin\n\t\tvar dist = n.dot( va );\n\n\t\treturn n.dot( vertex ) >= dist; \n\n\t}\n\n\t/**\n\t * Face normal\n\t */\n\tfunction normal( va, vb, vc ) {\n\n\t\tvar cb = new THREE.Vector3();\n\t\tvar ab = new THREE.Vector3();\n\n\t\tcb.subVectors( vc, vb );\n\t\tab.subVectors( va, vb );\n\t\tcb.cross( ab );\n\n\t\tcb.normalize();\n\n\t\treturn cb;\n\n\t}\n\n\t/**\n\t * Detect whether two edges are equal.\n\t * Note that when constructing the convex hull, two same edges can only\n\t * be of the negative direction.\n\t */\n\tfunction equalEdge( ea, eb ) {\n\n\t\treturn ea[ 0 ] === eb[ 1 ] && ea[ 1 ] === eb[ 0 ]; \n\n\t}\n\n\t/**\n\t * Create a random offset between -1e-6 and 1e-6.\n\t */\n\tfunction randomOffset() {\n\n\t\treturn ( Math.random() - 0.5 ) * 2 * 1e-6;\n\n\t}\n\n\n\t/**\n\t * XXX: Not sure if this is the correct approach. Need someone to review.\n\t */\n\tfunction vertexUv( vertex ) {\n\n\t\tvar mag = vertex.length();\n\t\treturn new THREE.Vector2( vertex.x / mag, vertex.y / mag );\n\n\t}\n\n\t// Push vertices into `this.vertices`, skipping those inside the hull\n\tvar id = 0;\n\tvar newId = new Array( vertices.length ); // map from old vertex id to new id\n\n\tfor ( var i = 0; i < faces.length; i++ ) {\n\n\t\t var face = faces[ i ];\n\n\t\t for ( var j = 0; j < 3; j++ ) {\n\n\t\t\t\tif ( newId[ face[ j ] ] === undefined ) {\n\n\t\t\t\t\t\tnewId[ face[ j ] ] = id++;\n\t\t\t\t\t\tthis.vertices.push( vertices[ face[ j ] ] );\n\n\t\t\t\t}\n\n\t\t\t\tface[ j ] = newId[ face[ j ] ];\n\n\t\t }\n\n\t}\n\n\t// Convert faces into instances of THREE.Face3\n\tfor ( var i = 0; i < faces.length; i++ ) {\n\n\t\tthis.faces.push( new THREE.Face3( \n\t\t\t\tfaces[ i ][ 0 ],\n\t\t\t\tfaces[ i ][ 1 ],\n\t\t\t\tfaces[ i ][ 2 ]\n\t\t) );\n\n\t}\n\n\t// Compute UVs\n\tfor ( var i = 0; i < this.faces.length; i++ ) {\n\n\t\tvar face = this.faces[ i ];\n\n\t\tthis.faceVertexUvs[ 0 ].push( [\n\t\t\tvertexUv( this.vertices[ face.a ] ),\n\t\t\tvertexUv( this.vertices[ face.b ] ),\n\t\t\tvertexUv( this.vertices[ face.c ])\n\t\t] );\n\n\t}\n\n\n\tthis.computeCentroids();\n\tthis.computeFaceNormals();\n\tthis.computeVertexNormals();\n\n};\n\nTHREE.ConvexGeometry.prototype = Object.create( THREE.Geometry.prototype );\n/**\n * @author sroucheray / http://sroucheray.org/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.AxisHelper = function ( size ) {\n\n\tvar geometry = new THREE.Geometry();\n\n\tgeometry.vertices.push(\n\t\tnew THREE.Vector3(), new THREE.Vector3( size || 1, 0, 0 ),\n\t\tnew THREE.Vector3(), new THREE.Vector3( 0, size || 1, 0 ),\n\t\tnew THREE.Vector3(), new THREE.Vector3( 0, 0, size || 1 )\n\t);\n\n\tgeometry.colors.push(\n\t\tnew THREE.Color( 0xff0000 ), new THREE.Color( 0xffaa00 ),\n\t\tnew THREE.Color( 0x00ff00 ), new THREE.Color( 0xaaff00 ),\n\t\tnew THREE.Color( 0x0000ff ), new THREE.Color( 0x00aaff )\n\t);\n\n\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );\n\n\tTHREE.Line.call( this, geometry, material, THREE.LinePieces );\n\n};\n\nTHREE.AxisHelper.prototype = Object.create( THREE.Line.prototype );\n/**\n * @author WestLangley / http://github.com/WestLangley\n * @author zz85 / https://github.com/zz85\n * @author bhouston / https://exocortex.com\n *\n * Creates an arrow for visualizing directions\n *\n * Parameters:\n *  dir - Vector3\n *  origin - Vector3\n *  length - Number\n *  hex - color in hex value\n */\n\nTHREE.ArrowHelper = function ( dir, origin, length, hex ) {\n\n\tTHREE.Object3D.call( this );\n\n\tif ( length === undefined ) length = 20;\n\tif ( hex === undefined ) hex = 0xffff00;\n\n\tvar lineGeometry = new THREE.Geometry();\n\tlineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ) );\n\tlineGeometry.vertices.push( new THREE.Vector3( 0, 1, 0 ) );\n\n\tthis.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: hex } ) );\n\tthis.add( this.line );\n\n\tvar coneGeometry = new THREE.CylinderGeometry( 0, 0.05, 0.25, 5, 1 );\n\n\tthis.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: hex } ) );\n\tthis.cone.position.set( 0, 1, 0 );\n\tthis.add( this.cone );\n\n\tif ( origin instanceof THREE.Vector3 ) this.position = origin;\n\n\tthis.setDirection( dir );\n\tthis.setLength( length );\n\n};\n\nTHREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );\n\nTHREE.ArrowHelper.prototype.setDirection = function ( dir ) {\n\n    var d = THREE.ArrowHelper.__v1.copy( dir ).normalize();\n\n    if ( d.y > 0.999 ) {\n\n        this.rotation.set( 0, 0, 0 );\n \n    } else if ( d.y < - 0.999 ) {\n\n        this.rotation.set( Math.PI, 0, 0 );\n\n    } else {\n\n\t    var axis = THREE.ArrowHelper.__v2.set( d.z, 0, - d.x ).normalize();\n\t    var radians = Math.acos( d.y );\n\t    var quaternion = THREE.ArrowHelper.__q1.setFromAxisAngle( axis, radians );\n\n\t    this.rotation.setEulerFromQuaternion( quaternion, this.eulerOrder );\n\n\t}\n\n};\n\nTHREE.ArrowHelper.prototype.setLength = function ( length ) {\n\n\tthis.scale.set( length, length, length );\n\n};\n\nTHREE.ArrowHelper.prototype.setColor = function ( hex ) {\n\n\tthis.line.material.color.setHex( hex );\n\tthis.cone.material.color.setHex( hex );\n\n};\n\nTHREE.ArrowHelper.__v1 = new THREE.Vector3();\nTHREE.ArrowHelper.__v2 = new THREE.Vector3();\nTHREE.ArrowHelper.__q1 = new THREE.Quaternion();\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n *\t- shows frustum, line of sight and up of the camera\n *\t- suitable for fast updates\n * \t- based on frustum visualization in lightgl.js shadowmap example\n *\t\thttp://evanw.github.com/lightgl.js/tests/shadowmap.html\n */\n\nTHREE.CameraHelper = function ( camera ) {\n\n\tTHREE.Line.call( this );\n\n\tvar scope = this;\n\n\tthis.geometry = new THREE.Geometry();\n\tthis.material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );\n\tthis.type = THREE.LinePieces;\n\n\tthis.matrixWorld = camera.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\tthis.pointMap = {};\n\n\t// colors\n\n\tvar hexFrustum = 0xffaa00;\n\tvar hexCone = 0xff0000;\n\tvar hexUp = 0x00aaff;\n\tvar hexTarget = 0xffffff;\n\tvar hexCross = 0x333333;\n\n\t// near\n\n\taddLine( \"n1\", \"n2\", hexFrustum );\n\taddLine( \"n2\", \"n4\", hexFrustum );\n\taddLine( \"n4\", \"n3\", hexFrustum );\n\taddLine( \"n3\", \"n1\", hexFrustum );\n\n\t// far\n\n\taddLine( \"f1\", \"f2\", hexFrustum );\n\taddLine( \"f2\", \"f4\", hexFrustum );\n\taddLine( \"f4\", \"f3\", hexFrustum );\n\taddLine( \"f3\", \"f1\", hexFrustum );\n\n\t// sides\n\n\taddLine( \"n1\", \"f1\", hexFrustum );\n\taddLine( \"n2\", \"f2\", hexFrustum );\n\taddLine( \"n3\", \"f3\", hexFrustum );\n\taddLine( \"n4\", \"f4\", hexFrustum );\n\n\t// cone\n\n\taddLine( \"p\", \"n1\", hexCone );\n\taddLine( \"p\", \"n2\", hexCone );\n\taddLine( \"p\", \"n3\", hexCone );\n\taddLine( \"p\", \"n4\", hexCone );\n\n\t// up\n\n\taddLine( \"u1\", \"u2\", hexUp );\n\taddLine( \"u2\", \"u3\", hexUp );\n\taddLine( \"u3\", \"u1\", hexUp );\n\n\t// target\n\n\taddLine( \"c\", \"t\", hexTarget );\n\taddLine( \"p\", \"c\", hexCross );\n\n\t// cross\n\n\taddLine( \"cn1\", \"cn2\", hexCross );\n\taddLine( \"cn3\", \"cn4\", hexCross );\n\n\taddLine( \"cf1\", \"cf2\", hexCross );\n\taddLine( \"cf3\", \"cf4\", hexCross );\n\n\tthis.camera = camera;\n\n\tfunction addLine( a, b, hex ) {\n\n\t\taddPoint( a, hex );\n\t\taddPoint( b, hex );\n\n\t}\n\n\tfunction addPoint( id, hex ) {\n\n\t\tscope.geometry.vertices.push( new THREE.Vector3() );\n\t\tscope.geometry.colors.push( new THREE.Color( hex ) );\n\n\t\tif ( scope.pointMap[ id ] === undefined ) scope.pointMap[ id ] = [];\n\n\t\tscope.pointMap[ id ].push( scope.geometry.vertices.length - 1 );\n\n\t}\n\n\tthis.update( camera );\n\n};\n\nTHREE.CameraHelper.prototype = Object.create( THREE.Line.prototype );\n\nTHREE.CameraHelper.prototype.update = function () {\n\n\tvar scope = this;\n\n\tvar w = 1, h = 1;\n\n\t// we need just camera projection matrix\n\t// world matrix must be identity\n\n\tTHREE.CameraHelper.__c.projectionMatrix.copy( this.camera.projectionMatrix );\n\n\t// center / target\n\n\tsetPoint( \"c\", 0, 0, -1 );\n\tsetPoint( \"t\", 0, 0,  1 );\n\n\t// near\n\n\tsetPoint( \"n1\", -w, -h, -1 );\n\tsetPoint( \"n2\",  w, -h, -1 );\n\tsetPoint( \"n3\", -w,  h, -1 );\n\tsetPoint( \"n4\",  w,  h, -1 );\n\n\t// far\n\n\tsetPoint( \"f1\", -w, -h, 1 );\n\tsetPoint( \"f2\",  w, -h, 1 );\n\tsetPoint( \"f3\", -w,  h, 1 );\n\tsetPoint( \"f4\",  w,  h, 1 );\n\n\t// up\n\n\tsetPoint( \"u1\",  w * 0.7, h * 1.1, -1 );\n\tsetPoint( \"u2\", -w * 0.7, h * 1.1, -1 );\n\tsetPoint( \"u3\",        0, h * 2,   -1 );\n\n\t// cross\n\n\tsetPoint( \"cf1\", -w,  0, 1 );\n\tsetPoint( \"cf2\",  w,  0, 1 );\n\tsetPoint( \"cf3\",  0, -h, 1 );\n\tsetPoint( \"cf4\",  0,  h, 1 );\n\n\tsetPoint( \"cn1\", -w,  0, -1 );\n\tsetPoint( \"cn2\",  w,  0, -1 );\n\tsetPoint( \"cn3\",  0, -h, -1 );\n\tsetPoint( \"cn4\",  0,  h, -1 );\n\n\tfunction setPoint( point, x, y, z ) {\n\n\t\tTHREE.CameraHelper.__v.set( x, y, z );\n\t\tTHREE.CameraHelper.__projector.unprojectVector( THREE.CameraHelper.__v, THREE.CameraHelper.__c );\n\n\t\tvar points = scope.pointMap[ point ];\n\n\t\tif ( points !== undefined ) {\n\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\t\tscope.geometry.vertices[ points[ i ] ].copy( THREE.CameraHelper.__v );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tthis.geometry.verticesNeedUpdate = true;\n\n};\n\nTHREE.CameraHelper.__projector = new THREE.Projector();\nTHREE.CameraHelper.__v = new THREE.Vector3();\nTHREE.CameraHelper.__c = new THREE.Camera();\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n *\t- shows directional light color, intensity, position, orientation and target\n */\n\nTHREE.DirectionalLightHelper = function ( light, sphereSize ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.light = light;\n\n\t// position\n\n\tthis.position = light.position;\n\n\t// direction\n\n\tthis.direction = new THREE.Vector3();\n\tthis.direction.subVectors( light.target.position, light.position );\n\n\t// color\n\n\tvar intensity = THREE.Math.clamp( light.intensity, 0, 1 );\n\n\tthis.color = light.color.clone();\n\tthis.color.multiplyScalar( intensity );\n\n\tvar hexColor = this.color.getHex();\n\n\t// light helper\n\n\tvar bulbGeometry = new THREE.SphereGeometry( sphereSize, 16, 8 );\n\tvar raysGeometry = new THREE.AsteriskGeometry( sphereSize * 1.25, sphereSize * 2.25 );\n\n\tvar bulbMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false } );\n\tvar raysMaterial = new THREE.LineBasicMaterial( { color: hexColor, fog: false } );\n\n\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\n\n\tthis.lightRays = new THREE.Line( raysGeometry, raysMaterial, THREE.LinePieces );\n\n\tthis.add( this.lightSphere );\n\tthis.add( this.lightRays );\n\n\tthis.lightSphere.properties.isGizmo = true;\n\tthis.lightSphere.properties.gizmoSubject = light;\n\tthis.lightSphere.properties.gizmoRoot = this;\n\n\t// light target helper\n\n\tthis.targetSphere = null;\n\n\tif ( light.target.properties.targetInverse !== undefined ) {\n\n\t\tvar targetGeo = new THREE.SphereGeometry( sphereSize, 8, 4 );\n\t\tvar targetMaterial = new THREE.MeshBasicMaterial( { color: hexColor, wireframe: true, fog: false } );\n\n\t\tthis.targetSphere = new THREE.Mesh( targetGeo, targetMaterial );\n\t\tthis.targetSphere.position = light.target.position;\n\n\t\tthis.targetSphere.properties.isGizmo = true;\n\t\tthis.targetSphere.properties.gizmoSubject = light.target;\n\t\tthis.targetSphere.properties.gizmoRoot = this.targetSphere;\n\n\t\tvar lineMaterial = new THREE.LineDashedMaterial( { color: hexColor, dashSize: 4, gapSize: 4, opacity: 0.75, transparent: true, fog: false } );\n\t\tvar lineGeometry = new THREE.Geometry();\n\t\tlineGeometry.vertices.push( this.position.clone() );\n\t\tlineGeometry.vertices.push( this.targetSphere.position.clone() );\n\t\tlineGeometry.computeLineDistances();\n\n\t\tthis.targetLine = new THREE.Line( lineGeometry, lineMaterial );\n\t\tthis.targetLine.properties.isGizmo = true;\n\n\t}\n\n\t//\n\n\tthis.properties.isGizmo = true;\n\n}\n\nTHREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );\n\nTHREE.DirectionalLightHelper.prototype.update = function () {\n\n\t// update arrow orientation\n\t// pointing from light to target\n\n\tthis.direction.subVectors( this.light.target.position, this.light.position );\n\n\t// update arrow, spheres, rays and line colors to light color * light intensity\n\n\tvar intensity = THREE.Math.clamp( this.light.intensity, 0, 1 );\n\n\tthis.color.copy( this.light.color );\n\tthis.color.multiplyScalar( intensity );\n\n\tthis.lightSphere.material.color.copy( this.color );\n\tthis.lightRays.material.color.copy( this.color );\n\n\t// Only update targetSphere and targetLine if available\n\tif ( this.targetSphere !== null ) {\n\n\t\tthis.targetSphere.material.color.copy( this.color );\n\t\tthis.targetLine.material.color.copy( this.color );\n\n\t\t// update target line vertices\n\n\t\tthis.targetLine.geometry.vertices[ 0 ].copy( this.light.position );\n\t\tthis.targetLine.geometry.vertices[ 1 ].copy( this.light.target.position );\n\n\t\tthis.targetLine.geometry.computeLineDistances();\n\t\tthis.targetLine.geometry.verticesNeedUpdate = true;\n\n\t}\n\n}\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n *\t- shows hemisphere light intensity, sky and ground colors and directions\n */\n\nTHREE.HemisphereLightHelper = function ( light, sphereSize, arrowLength, domeSize ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.light = light;\n\n\t// position\n\n\tthis.position = light.position;\n\n\t//\n\n\tvar intensity = THREE.Math.clamp( light.intensity, 0, 1 );\n\n\t// sky color\n\n\tthis.color = light.color.clone();\n\tthis.color.multiplyScalar( intensity );\n\n\tvar hexColor = this.color.getHex();\n\n\t// ground color\n\n\tthis.groundColor = light.groundColor.clone();\n\tthis.groundColor.multiplyScalar( intensity );\n\n\tvar hexColorGround = this.groundColor.getHex();\n\n\t// double colored light bulb\n\n\tvar bulbGeometry = new THREE.SphereGeometry( sphereSize, 16, 8, 0, Math.PI * 2, 0, Math.PI * 0.5 );\n\tvar bulbGroundGeometry = new THREE.SphereGeometry( sphereSize, 16, 8, 0, Math.PI * 2, Math.PI * 0.5, Math.PI );\n\n\tvar bulbSkyMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false } );\n\tvar bulbGroundMaterial = new THREE.MeshBasicMaterial( { color: hexColorGround, fog: false } );\n\n\tfor ( var i = 0, il = bulbGeometry.faces.length; i < il; i ++ ) {\n\n\t\tbulbGeometry.faces[ i ].materialIndex = 0;\n\n\t}\n\n\tfor ( var i = 0, il = bulbGroundGeometry.faces.length; i < il; i ++ ) {\n\n\t\tbulbGroundGeometry.faces[ i ].materialIndex = 1;\n\n\t}\n\n\tTHREE.GeometryUtils.merge( bulbGeometry, bulbGroundGeometry );\n\n\tthis.lightSphere = new THREE.Mesh( bulbGeometry, new THREE.MeshFaceMaterial( [ bulbSkyMaterial, bulbGroundMaterial ] ) );\n\n\t// arrows for sky and ground light directions\n\n\tthis.lightArrow = new THREE.ArrowHelper( new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, ( sphereSize + arrowLength ) * 1.1, 0 ), arrowLength, hexColor );\n\tthis.lightArrow.rotation.x = Math.PI;\n\n\tthis.lightArrowGround = new THREE.ArrowHelper( new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, ( sphereSize + arrowLength ) * -1.1, 0 ), arrowLength, hexColorGround );\n\n\tvar joint = new THREE.Object3D();\n\tjoint.rotation.x = -Math.PI * 0.5;\n\n\tjoint.add( this.lightSphere );\n\tjoint.add( this.lightArrow );\n\tjoint.add( this.lightArrowGround );\n\n\tthis.add( joint );\n\n\t//\n\n\tthis.lightSphere.properties.isGizmo = true;\n\tthis.lightSphere.properties.gizmoSubject = light;\n\tthis.lightSphere.properties.gizmoRoot = this;\n\n\t//\n\n\tthis.properties.isGizmo = true;\n\n\t//\n\n\tthis.target = new THREE.Vector3();\n\tthis.lookAt( this.target );\n\n}\n\nTHREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );\n\nTHREE.HemisphereLightHelper.prototype.update = function () {\n\n\t// update sphere sky and ground colors to light color * light intensity\n\n\tvar intensity = THREE.Math.clamp( this.light.intensity, 0, 1 );\n\n\tthis.color.copy( this.light.color );\n\tthis.color.multiplyScalar( intensity );\n\n\tthis.groundColor.copy( this.light.groundColor );\n\tthis.groundColor.multiplyScalar( intensity );\n\n\tthis.lightSphere.material.materials[ 0 ].color.copy( this.color );\n\tthis.lightSphere.material.materials[ 1 ].color.copy( this.groundColor );\n\n\tthis.lightArrow.setColor( this.color.getHex() );\n\tthis.lightArrowGround.setColor( this.groundColor.getHex() );\n\n\tthis.lookAt( this.target );\n\n}\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n *\t- shows point light color, intensity, position and distance\n */\n\nTHREE.PointLightHelper = function ( light, sphereSize ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.light = light;\n\n\t// position\n\n\tthis.position = light.position;\n\n\t// color\n\n\tvar intensity = THREE.Math.clamp( light.intensity, 0, 1 );\n\n\tthis.color = light.color.clone();\n\tthis.color.multiplyScalar( intensity );\n\n\tvar hexColor = this.color.getHex();\n\n\t// light helper\n\n\tvar bulbGeometry = new THREE.SphereGeometry( sphereSize, 16, 8 );\n\tvar raysGeometry = new THREE.AsteriskGeometry( sphereSize * 1.25, sphereSize * 2.25 );\n\tvar distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );\n\n\tvar bulbMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false } );\n\tvar raysMaterial = new THREE.LineBasicMaterial( { color: hexColor, fog: false } );\n\tvar distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\n\n\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\n\tthis.lightRays = new THREE.Line( raysGeometry, raysMaterial, THREE.LinePieces );\n\tthis.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\n\n\tvar d = light.distance;\n\n\tif ( d === 0.0 ) {\n\n\t\tthis.lightDistance.visible = false;\n\n\t} else {\n\n\t\tthis.lightDistance.scale.set( d, d, d );\n\n\t}\n\n\tthis.add( this.lightSphere );\n\tthis.add( this.lightRays );\n\tthis.add( this.lightDistance );\n\n\t//\n\n\tthis.lightSphere.properties.isGizmo = true;\n\tthis.lightSphere.properties.gizmoSubject = light;\n\tthis.lightSphere.properties.gizmoRoot = this;\n\n\t//\n\n\tthis.properties.isGizmo = true;\n\n}\n\nTHREE.PointLightHelper.prototype = Object.create( THREE.Object3D.prototype );\n\nTHREE.PointLightHelper.prototype.update = function () {\n\n\t// update sphere and rays colors to light color * light intensity\n\n\tvar intensity = THREE.Math.clamp( this.light.intensity, 0, 1 );\n\n\tthis.color.copy( this.light.color );\n\tthis.color.multiplyScalar( intensity );\n\n\tthis.lightSphere.material.color.copy( this.color );\n\tthis.lightRays.material.color.copy( this.color );\n\tthis.lightDistance.material.color.copy( this.color );\n\n\t//\n\n\tvar d = this.light.distance;\n\n\tif ( d === 0.0 ) {\n\n\t\tthis.lightDistance.visible = false;\n\n\t} else {\n\n\t\tthis.lightDistance.visible = true;\n\t\tthis.lightDistance.scale.set( d, d, d );\n\n\t}\n\n}\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n *\t- shows spot light color, intensity, position, orientation, light cone and target\n */\n\nTHREE.SpotLightHelper = function ( light, sphereSize ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.light = light;\n\n\t// position\n\n\tthis.position = light.position;\n\n\t// direction\n\n\tthis.direction = new THREE.Vector3();\n\tthis.direction.subVectors( light.target.position, light.position );\n\n\t// color\n\n\tvar intensity = THREE.Math.clamp( light.intensity, 0, 1 );\n\n\tthis.color = light.color.clone();\n\tthis.color.multiplyScalar( intensity );\n\n\tvar hexColor = this.color.getHex();\n\n\t// light helper\n\n\tvar bulbGeometry = new THREE.SphereGeometry( sphereSize, 16, 8 );\n\tvar raysGeometry = new THREE.AsteriskGeometry( sphereSize * 1.25, sphereSize * 2.25 );\n\tvar coneGeometry = new THREE.CylinderGeometry( 0.0001, 1, 1, 8, 1, true );\n\n\tvar coneMatrix = new THREE.Matrix4();\n\tconeMatrix.rotateX( -Math.PI/2 );\n\tconeMatrix.translate( new THREE.Vector3( 0, -0.5, 0 ) );\n\tconeGeometry.applyMatrix( coneMatrix );\n\n\tvar bulbMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false } );\n\tvar raysMaterial = new THREE.LineBasicMaterial( { color: hexColor, fog: false } );\n\tvar coneMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.3, transparent: true } );\n\n\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\n\tthis.lightCone = new THREE.Mesh( coneGeometry, coneMaterial );\n\n\tvar coneLength = light.distance ? light.distance : 10000;\n\tvar coneWidth = coneLength * Math.tan( light.angle * 0.5 ) * 2;\n\tthis.lightCone.scale.set( coneWidth, coneWidth, coneLength );\n\n\tthis.lightRays = new THREE.Line( raysGeometry, raysMaterial, THREE.LinePieces );\n\n\tthis.gyroscope = new THREE.Gyroscope();\n\n\tthis.gyroscope.add( this.lightSphere );\n\tthis.gyroscope.add( this.lightRays );\n\n\tthis.add( this.gyroscope );\n\tthis.add( this.lightCone );\n\n\tthis.lookAt( light.target.position );\n\n\tthis.lightSphere.properties.isGizmo = true;\n\tthis.lightSphere.properties.gizmoSubject = light;\n\tthis.lightSphere.properties.gizmoRoot = this;\n\n\t// light target helper\n\n\tthis.targetSphere = null;\n\n\tif ( light.target.properties.targetInverse !== undefined ) {\n\n\t\tvar targetGeo = new THREE.SphereGeometry( sphereSize, 8, 4 );\n\t\tvar targetMaterial = new THREE.MeshBasicMaterial( { color: hexColor, wireframe: true, fog: false } );\n\n\t\tthis.targetSphere = new THREE.Mesh( targetGeo, targetMaterial );\n\t\tthis.targetSphere.position = light.target.position;\n\n\t\tthis.targetSphere.properties.isGizmo = true;\n\t\tthis.targetSphere.properties.gizmoSubject = light.target;\n\t\tthis.targetSphere.properties.gizmoRoot = this.targetSphere;\n\n\t\tvar lineMaterial = new THREE.LineDashedMaterial( { color: hexColor, dashSize: 4, gapSize: 4, opacity: 0.75, transparent: true, fog: false } );\n\t\tvar lineGeometry = new THREE.Geometry();\n\t\tlineGeometry.vertices.push( this.position.clone() );\n\t\tlineGeometry.vertices.push( this.targetSphere.position.clone() );\n\t\tlineGeometry.computeLineDistances();\n\n\t\tthis.targetLine = new THREE.Line( lineGeometry, lineMaterial );\n\t\tthis.targetLine.properties.isGizmo = true;\n\n\t}\n\n\t//\n\n\tthis.properties.isGizmo = true;\n\n}\n\nTHREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );\n\nTHREE.SpotLightHelper.prototype.update = function () {\n\n\t// update arrow orientation\n\t// pointing from light to target\n\n\tthis.direction.subVectors( this.light.target.position, this.light.position );\n\n\t// update light cone orientation and size\n\n\tthis.lookAt( this.light.target.position );\n\n\tvar coneLength = this.light.distance ? this.light.distance : 10000;\n\tvar coneWidth = coneLength * Math.tan( this.light.angle * 0.5 ) * 2;\n\tthis.lightCone.scale.set( coneWidth, coneWidth, coneLength );\n\n\t// update arrow, spheres, rays and line colors to light color * light intensity\n\n\tvar intensity = THREE.Math.clamp( this.light.intensity, 0, 1 );\n\n\tthis.color.copy( this.light.color );\n\tthis.color.multiplyScalar( intensity );\n\n\tthis.lightSphere.material.color.copy( this.color );\n\tthis.lightRays.material.color.copy( this.color );\n\tthis.lightCone.material.color.copy( this.color );\n\n\t// Only update targetSphere and targetLine if available\n\tif ( this.targetSphere !== null ) {\n\n\t\tthis.targetSphere.material.color.copy( this.color );\n\t\tthis.targetLine.material.color.copy( this.color );\n\n\t\t// update target line vertices\n\n\t\tthis.targetLine.geometry.vertices[ 0 ].copy( this.light.position );\n\t\tthis.targetLine.geometry.vertices[ 1 ].copy( this.light.target.position );\n\n\t\tthis.targetLine.geometry.computeLineDistances();\n\t\tthis.targetLine.geometry.verticesNeedUpdate = true;\n\n\t}\n\n};\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.ImmediateRenderObject = function () {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.render = function ( renderCallback ) { };\n\n};\n\nTHREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.LensFlare = function ( texture, size, distance, blending, color ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.lensFlares = [];\n\n\tthis.positionScreen = new THREE.Vector3();\n\tthis.customUpdateCallback = undefined;\n\n\tif( texture !== undefined ) {\n\n\t\tthis.add( texture, size, distance, blending, color );\n\n\t}\n\n};\n\nTHREE.LensFlare.prototype = Object.create( THREE.Object3D.prototype );\n\n\n/*\n * Add: adds another flare\n */\n\nTHREE.LensFlare.prototype.add = function ( texture, size, distance, blending, color, opacity ) {\n\n\tif( size === undefined ) size = -1;\n\tif( distance === undefined ) distance = 0;\n\tif( opacity === undefined ) opacity = 1;\n\tif( color === undefined ) color = new THREE.Color( 0xffffff );\n\tif( blending === undefined ) blending = THREE.NormalBlending;\n\n\tdistance = Math.min( distance, Math.max( 0, distance ) );\n\n\tthis.lensFlares.push( { texture: texture, \t\t\t// THREE.Texture\n\t\t                    size: size, \t\t\t\t// size in pixels (-1 = use texture.width)\n\t\t                    distance: distance, \t\t// distance (0-1) from light source (0=at light source)\n\t\t                    x: 0, y: 0, z: 0,\t\t\t// screen position (-1 => 1) z = 0 is ontop z = 1 is back\n\t\t                    scale: 1, \t\t\t\t\t// scale\n\t\t                    rotation: 1, \t\t\t\t// rotation\n\t\t                    opacity: opacity,\t\t\t// opacity\n\t\t\t\t\t\t\tcolor: color,\t\t\t\t// color\n\t\t                    blending: blending } );\t\t// blending\n\n};\n\n\n/*\n * Update lens flares update positions on all flares based on the screen position\n * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.\n */\n\nTHREE.LensFlare.prototype.updateLensFlares = function () {\n\n\tvar f, fl = this.lensFlares.length;\n\tvar flare;\n\tvar vecX = -this.positionScreen.x * 2;\n\tvar vecY = -this.positionScreen.y * 2;\n\n\tfor( f = 0; f < fl; f ++ ) {\n\n\t\tflare = this.lensFlares[ f ];\n\n\t\tflare.x = this.positionScreen.x + vecX * flare.distance;\n\t\tflare.y = this.positionScreen.y + vecY * flare.distance;\n\n\t\tflare.wantedRotation = flare.x * Math.PI * 0.25;\n\t\tflare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;\n\n\t}\n\n};\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.MorphBlendMesh = function( geometry, material ) {\n\n\tTHREE.Mesh.call( this, geometry, material );\n\n\tthis.animationsMap = {};\n\tthis.animationsList = [];\n\n\t// prepare default animation\n\t// (all frames played together in 1 second)\n\n\tvar numFrames = this.geometry.morphTargets.length;\n\n\tvar name = \"__default\";\n\n\tvar startFrame = 0;\n\tvar endFrame = numFrames - 1;\n\n\tvar fps = numFrames / 1;\n\n\tthis.createAnimation( name, startFrame, endFrame, fps );\n\tthis.setAnimationWeight( name, 1 );\n\n};\n\nTHREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );\n\nTHREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {\n\n\tvar animation = {\n\n\t\tstartFrame: start,\n\t\tendFrame: end,\n\n\t\tlength: end - start + 1,\n\n\t\tfps: fps,\n\t\tduration: ( end - start ) / fps,\n\n\t\tlastFrame: 0,\n\t\tcurrentFrame: 0,\n\n\t\tactive: false,\n\n\t\ttime: 0,\n\t\tdirection: 1,\n\t\tweight: 1,\n\n\t\tdirectionBackwards: false,\n\t\tmirroredLoop: false\n\n\t};\n\n\tthis.animationsMap[ name ] = animation;\n\tthis.animationsList.push( animation );\n\n};\n\nTHREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {\n\n\tvar pattern = /([a-z]+)(\\d+)/;\n\n\tvar firstAnimation, frameRanges = {};\n\n\tvar geometry = this.geometry;\n\n\tfor ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {\n\n\t\tvar morph = geometry.morphTargets[ i ];\n\t\tvar chunks = morph.name.match( pattern );\n\n\t\tif ( chunks && chunks.length > 1 ) {\n\n\t\t\tvar name = chunks[ 1 ];\n\t\t\tvar num = chunks[ 2 ];\n\n\t\t\tif ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: -Infinity };\n\n\t\t\tvar range = frameRanges[ name ];\n\n\t\t\tif ( i < range.start ) range.start = i;\n\t\t\tif ( i > range.end ) range.end = i;\n\n\t\t\tif ( ! firstAnimation ) firstAnimation = name;\n\n\t\t}\n\n\t}\n\n\tfor ( var name in frameRanges ) {\n\n\t\tvar range = frameRanges[ name ];\n\t\tthis.createAnimation( name, range.start, range.end, fps );\n\n\t}\n\n\tthis.firstAnimation = firstAnimation;\n\n};\n\nTHREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.direction = 1;\n\t\tanimation.directionBackwards = false;\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.direction = -1;\n\t\tanimation.directionBackwards = true;\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.fps = fps;\n\t\tanimation.duration = ( animation.end - animation.start ) / animation.fps;\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.duration = duration;\n\t\tanimation.fps = ( animation.end - animation.start ) / animation.duration;\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.weight = weight;\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.time = time;\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {\n\n\tvar time = 0;\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\ttime = animation.time;\n\n\t}\n\n\treturn time;\n\n};\n\nTHREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {\n\n\tvar duration = -1;\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tduration = animation.duration;\n\n\t}\n\n\treturn duration;\n\n};\n\nTHREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.time = 0;\n\t\tanimation.active = true;\n\n\t} else {\n\n\t\tconsole.warn( \"animation[\" + name + \"] undefined\" );\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.active = false;\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.update = function ( delta ) {\n\n\tfor ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {\n\n\t\tvar animation = this.animationsList[ i ];\n\n\t\tif ( ! animation.active ) continue;\n\n\t\tvar frameTime = animation.duration / animation.length;\n\n\t\tanimation.time += animation.direction * delta;\n\n\t\tif ( animation.mirroredLoop ) {\n\n\t\t\tif ( animation.time > animation.duration || animation.time < 0 ) {\n\n\t\t\t\tanimation.direction *= -1;\n\n\t\t\t\tif ( animation.time > animation.duration ) {\n\n\t\t\t\t\tanimation.time = animation.duration;\n\t\t\t\t\tanimation.directionBackwards = true;\n\n\t\t\t\t}\n\n\t\t\t\tif ( animation.time < 0 ) {\n\n\t\t\t\t\tanimation.time = 0;\n\t\t\t\t\tanimation.directionBackwards = false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tanimation.time = animation.time % animation.duration;\n\n\t\t\tif ( animation.time < 0 ) animation.time += animation.duration;\n\n\t\t}\n\n\t\tvar keyframe = animation.startFrame + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );\n\t\tvar weight = animation.weight;\n\n\t\tif ( keyframe !== animation.currentFrame ) {\n\n\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = 0;\n\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;\n\n\t\t\tthis.morphTargetInfluences[ keyframe ] = 0;\n\n\t\t\tanimation.lastFrame = animation.currentFrame;\n\t\t\tanimation.currentFrame = keyframe;\n\n\t\t}\n\n\t\tvar mix = ( animation.time % frameTime ) / frameTime;\n\n\t\tif ( animation.directionBackwards ) mix = 1 - mix;\n\n\t\tthis.morphTargetInfluences[ animation.currentFrame ] = mix * weight;\n\t\tthis.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;\n\n\t}\n\n};\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.LensFlarePlugin = function () {\n\n\tvar _gl, _renderer, _precision, _lensFlare = {};\n\n\tthis.init = function ( renderer ) {\n\n\t\t_gl = renderer.context;\n\t\t_renderer = renderer;\n\n\t\t_precision = renderer.getPrecision();\n\n\t\t_lensFlare.vertices = new Float32Array( 8 + 8 );\n\t\t_lensFlare.faces = new Uint16Array( 6 );\n\n\t\tvar i = 0;\n\t\t_lensFlare.vertices[ i++ ] = -1; _lensFlare.vertices[ i++ ] = -1;\t// vertex\n\t\t_lensFlare.vertices[ i++ ] = 0;  _lensFlare.vertices[ i++ ] = 0;\t// uv... etc.\n\n\t\t_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = -1;\n\t\t_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = 0;\n\n\t\t_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = 1;\n\t\t_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = 1;\n\n\t\t_lensFlare.vertices[ i++ ] = -1; _lensFlare.vertices[ i++ ] = 1;\n\t\t_lensFlare.vertices[ i++ ] = 0;  _lensFlare.vertices[ i++ ] = 1;\n\n\t\ti = 0;\n\t\t_lensFlare.faces[ i++ ] = 0; _lensFlare.faces[ i++ ] = 1; _lensFlare.faces[ i++ ] = 2;\n\t\t_lensFlare.faces[ i++ ] = 0; _lensFlare.faces[ i++ ] = 2; _lensFlare.faces[ i++ ] = 3;\n\n\t\t// buffers\n\n\t\t_lensFlare.vertexBuffer     = _gl.createBuffer();\n\t\t_lensFlare.elementBuffer    = _gl.createBuffer();\n\n\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, _lensFlare.vertexBuffer );\n\t\t_gl.bufferData( _gl.ARRAY_BUFFER, _lensFlare.vertices, _gl.STATIC_DRAW );\n\n\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, _lensFlare.elementBuffer );\n\t\t_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, _lensFlare.faces, _gl.STATIC_DRAW );\n\n\t\t// textures\n\n\t\t_lensFlare.tempTexture      = _gl.createTexture();\n\t\t_lensFlare.occlusionTexture = _gl.createTexture();\n\n\t\t_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.tempTexture );\n\t\t_gl.texImage2D( _gl.TEXTURE_2D, 0, _gl.RGB, 16, 16, 0, _gl.RGB, _gl.UNSIGNED_BYTE, null );\n\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\n\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\n\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MAG_FILTER, _gl.NEAREST );\n\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MIN_FILTER, _gl.NEAREST );\n\n\t\t_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.occlusionTexture );\n\t\t_gl.texImage2D( _gl.TEXTURE_2D, 0, _gl.RGBA, 16, 16, 0, _gl.RGBA, _gl.UNSIGNED_BYTE, null );\n\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\n\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\n\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MAG_FILTER, _gl.NEAREST );\n\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MIN_FILTER, _gl.NEAREST );\n\n\t\tif ( _gl.getParameter( _gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS ) <= 0 ) {\n\n\t\t\t_lensFlare.hasVertexTexture = false;\n\t\t\t_lensFlare.program = createProgram( THREE.ShaderFlares[ \"lensFlare\" ], _precision );\n\n\t\t} else {\n\n\t\t\t_lensFlare.hasVertexTexture = true;\n\t\t\t_lensFlare.program = createProgram( THREE.ShaderFlares[ \"lensFlareVertexTexture\" ], _precision );\n\n\t\t}\n\n\t\t_lensFlare.attributes = {};\n\t\t_lensFlare.uniforms = {};\n\n\t\t_lensFlare.attributes.vertex       = _gl.getAttribLocation ( _lensFlare.program, \"position\" );\n\t\t_lensFlare.attributes.uv           = _gl.getAttribLocation ( _lensFlare.program, \"uv\" );\n\n\t\t_lensFlare.uniforms.renderType     = _gl.getUniformLocation( _lensFlare.program, \"renderType\" );\n\t\t_lensFlare.uniforms.map            = _gl.getUniformLocation( _lensFlare.program, \"map\" );\n\t\t_lensFlare.uniforms.occlusionMap   = _gl.getUniformLocation( _lensFlare.program, \"occlusionMap\" );\n\t\t_lensFlare.uniforms.opacity        = _gl.getUniformLocation( _lensFlare.program, \"opacity\" );\n\t\t_lensFlare.uniforms.color          = _gl.getUniformLocation( _lensFlare.program, \"color\" );\n\t\t_lensFlare.uniforms.scale          = _gl.getUniformLocation( _lensFlare.program, \"scale\" );\n\t\t_lensFlare.uniforms.rotation       = _gl.getUniformLocation( _lensFlare.program, \"rotation\" );\n\t\t_lensFlare.uniforms.screenPosition = _gl.getUniformLocation( _lensFlare.program, \"screenPosition\" );\n\n\t};\n\n\n\t/*\n\t * Render lens flares\n\t * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,\n\t *         reads these back and calculates occlusion.\n\t *         Then _lensFlare.update_lensFlares() is called to re-position and\n\t *         update transparency of flares. Then they are rendered.\n\t *\n\t */\n\n\tthis.render = function ( scene, camera, viewportWidth, viewportHeight ) {\n\n\t\tvar flares = scene.__webglFlares,\n\t\t\tnFlares = flares.length;\n\n\t\tif ( ! nFlares ) return;\n\n\t\tvar tempPosition = new THREE.Vector3();\n\n\t\tvar invAspect = viewportHeight / viewportWidth,\n\t\t\thalfViewportWidth = viewportWidth * 0.5,\n\t\t\thalfViewportHeight = viewportHeight * 0.5;\n\n\t\tvar size = 16 / viewportHeight,\n\t\t\tscale = new THREE.Vector2( size * invAspect, size );\n\n\t\tvar screenPosition = new THREE.Vector3( 1, 1, 0 ),\n\t\t\tscreenPositionPixels = new THREE.Vector2( 1, 1 );\n\n\t\tvar uniforms = _lensFlare.uniforms,\n\t\t\tattributes = _lensFlare.attributes;\n\n\t\t// set _lensFlare program and reset blending\n\n\t\t_gl.useProgram( _lensFlare.program );\n\n\t\t_gl.enableVertexAttribArray( _lensFlare.attributes.vertex );\n\t\t_gl.enableVertexAttribArray( _lensFlare.attributes.uv );\n\n\t\t// loop through all lens flares to update their occlusion and positions\n\t\t// setup gl and common used attribs/unforms\n\n\t\t_gl.uniform1i( uniforms.occlusionMap, 0 );\n\t\t_gl.uniform1i( uniforms.map, 1 );\n\n\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, _lensFlare.vertexBuffer );\n\t\t_gl.vertexAttribPointer( attributes.vertex, 2, _gl.FLOAT, false, 2 * 8, 0 );\n\t\t_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 2 * 8, 8 );\n\n\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, _lensFlare.elementBuffer );\n\n\t\t_gl.disable( _gl.CULL_FACE );\n\t\t_gl.depthMask( false );\n\n\t\tvar i, j, jl, flare, sprite;\n\n\t\tfor ( i = 0; i < nFlares; i ++ ) {\n\n\t\t\tsize = 16 / viewportHeight;\n\t\t\tscale.set( size * invAspect, size );\n\n\t\t\t// calc object screen position\n\n\t\t\tflare = flares[ i ];\n\n\t\t\ttempPosition.set( flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14] );\n\n\t\t\ttempPosition.applyMatrix4( camera.matrixWorldInverse );\n\t\t\ttempPosition.applyProjection( camera.projectionMatrix );\n\n\t\t\t// setup arrays for gl programs\n\n\t\t\tscreenPosition.copy( tempPosition )\n\n\t\t\tscreenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;\n\t\t\tscreenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;\n\n\t\t\t// screen cull\n\n\t\t\tif ( _lensFlare.hasVertexTexture || (\n\t\t\t\tscreenPositionPixels.x > 0 &&\n\t\t\t\tscreenPositionPixels.x < viewportWidth &&\n\t\t\t\tscreenPositionPixels.y > 0 &&\n\t\t\t\tscreenPositionPixels.y < viewportHeight ) ) {\n\n\t\t\t\t// save current RGB to temp texture\n\n\t\t\t\t_gl.activeTexture( _gl.TEXTURE1 );\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.tempTexture );\n\t\t\t\t_gl.copyTexImage2D( _gl.TEXTURE_2D, 0, _gl.RGB, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );\n\n\n\t\t\t\t// render pink quad\n\n\t\t\t\t_gl.uniform1i( uniforms.renderType, 0 );\n\t\t\t\t_gl.uniform2f( uniforms.scale, scale.x, scale.y );\n\t\t\t\t_gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\n\n\t\t\t\t_gl.disable( _gl.BLEND );\n\t\t\t\t_gl.enable( _gl.DEPTH_TEST );\n\n\t\t\t\t_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );\n\n\n\t\t\t\t// copy result to occlusionMap\n\n\t\t\t\t_gl.activeTexture( _gl.TEXTURE0 );\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.occlusionTexture );\n\t\t\t\t_gl.copyTexImage2D( _gl.TEXTURE_2D, 0, _gl.RGBA, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );\n\n\n\t\t\t\t// restore graphics\n\n\t\t\t\t_gl.uniform1i( uniforms.renderType, 1 );\n\t\t\t\t_gl.disable( _gl.DEPTH_TEST );\n\n\t\t\t\t_gl.activeTexture( _gl.TEXTURE1 );\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.tempTexture );\n\t\t\t\t_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );\n\n\n\t\t\t\t// update object positions\n\n\t\t\t\tflare.positionScreen.copy( screenPosition )\n\n\t\t\t\tif ( flare.customUpdateCallback ) {\n\n\t\t\t\t\tflare.customUpdateCallback( flare );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tflare.updateLensFlares();\n\n\t\t\t\t}\n\n\t\t\t\t// render flares\n\n\t\t\t\t_gl.uniform1i( uniforms.renderType, 2 );\n\t\t\t\t_gl.enable( _gl.BLEND );\n\n\t\t\t\tfor ( j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {\n\n\t\t\t\t\tsprite = flare.lensFlares[ j ];\n\n\t\t\t\t\tif ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {\n\n\t\t\t\t\t\tscreenPosition.x = sprite.x;\n\t\t\t\t\t\tscreenPosition.y = sprite.y;\n\t\t\t\t\t\tscreenPosition.z = sprite.z;\n\n\t\t\t\t\t\tsize = sprite.size * sprite.scale / viewportHeight;\n\n\t\t\t\t\t\tscale.x = size * invAspect;\n\t\t\t\t\t\tscale.y = size;\n\n\t\t\t\t\t\t_gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\n\t\t\t\t\t\t_gl.uniform2f( uniforms.scale, scale.x, scale.y );\n\t\t\t\t\t\t_gl.uniform1f( uniforms.rotation, sprite.rotation );\n\n\t\t\t\t\t\t_gl.uniform1f( uniforms.opacity, sprite.opacity );\n\t\t\t\t\t\t_gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );\n\n\t\t\t\t\t\t_renderer.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );\n\t\t\t\t\t\t_renderer.setTexture( sprite.texture, 1 );\n\n\t\t\t\t\t\t_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// restore gl\n\n\t\t_gl.enable( _gl.CULL_FACE );\n\t\t_gl.enable( _gl.DEPTH_TEST );\n\t\t_gl.depthMask( true );\n\n\t};\n\n\tfunction createProgram ( shader, precision ) {\n\n\t\tvar program = _gl.createProgram();\n\n\t\tvar fragmentShader = _gl.createShader( _gl.FRAGMENT_SHADER );\n\t\tvar vertexShader = _gl.createShader( _gl.VERTEX_SHADER );\n\n\t\tvar prefix = \"precision \" + precision + \" float;\\n\";\n\n\t\t_gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );\n\t\t_gl.shaderSource( vertexShader, prefix + shader.vertexShader );\n\n\t\t_gl.compileShader( fragmentShader );\n\t\t_gl.compileShader( vertexShader );\n\n\t\t_gl.attachShader( program, fragmentShader );\n\t\t_gl.attachShader( program, vertexShader );\n\n\t\t_gl.linkProgram( program );\n\n\t\treturn program;\n\n\t};\n\n};\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.ShadowMapPlugin = function () {\n\n\tvar _gl,\n\t_renderer,\n\t_depthMaterial, _depthMaterialMorph, _depthMaterialSkin, _depthMaterialMorphSkin,\n\n\t_frustum = new THREE.Frustum(),\n\t_projScreenMatrix = new THREE.Matrix4(),\n\n\t_min = new THREE.Vector3(),\n\t_max = new THREE.Vector3(),\n\n\t_matrixPosition = new THREE.Vector3();\n\n\tthis.init = function ( renderer ) {\n\n\t\t_gl = renderer.context;\n\t\t_renderer = renderer;\n\n\t\tvar depthShader = THREE.ShaderLib[ \"depthRGBA\" ];\n\t\tvar depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );\n\n\t\t_depthMaterial = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms } );\n\t\t_depthMaterialMorph = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true } );\n\t\t_depthMaterialSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, skinning: true } );\n\t\t_depthMaterialMorphSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true, skinning: true } );\n\n\t\t_depthMaterial._shadowPass = true;\n\t\t_depthMaterialMorph._shadowPass = true;\n\t\t_depthMaterialSkin._shadowPass = true;\n\t\t_depthMaterialMorphSkin._shadowPass = true;\n\n\t};\n\n\tthis.render = function ( scene, camera ) {\n\n\t\tif ( ! ( _renderer.shadowMapEnabled && _renderer.shadowMapAutoUpdate ) ) return;\n\n\t\tthis.update( scene, camera );\n\n\t};\n\n\tthis.update = function ( scene, camera ) {\n\n\t\tvar i, il, j, jl, n,\n\n\t\tshadowMap, shadowMatrix, shadowCamera,\n\t\tprogram, buffer, material,\n\t\twebglObject, object, light,\n\t\trenderList,\n\n\t\tlights = [],\n\t\tk = 0,\n\n\t\tfog = null;\n\n\t\t// set GL state for depth map\n\n\t\t_gl.clearColor( 1, 1, 1, 1 );\n\t\t_gl.disable( _gl.BLEND );\n\n\t\t_gl.enable( _gl.CULL_FACE );\n\t\t_gl.frontFace( _gl.CCW );\n\n\t\tif ( _renderer.shadowMapCullFace === THREE.CullFaceFront ) {\n\n\t\t\t_gl.cullFace( _gl.FRONT );\n\n\t\t} else {\n\n\t\t\t_gl.cullFace( _gl.BACK );\n\n\t\t}\n\n\t\t_renderer.setDepthTest( true );\n\n\t\t// preprocess lights\n\t\t// \t- skip lights that are not casting shadows\n\t\t//\t- create virtual lights for cascaded shadow maps\n\n\t\tfor ( i = 0, il = scene.__lights.length; i < il; i ++ ) {\n\n\t\t\tlight = scene.__lights[ i ];\n\n\t\t\tif ( ! light.castShadow ) continue;\n\n\t\t\tif ( ( light instanceof THREE.DirectionalLight ) && light.shadowCascade ) {\n\n\t\t\t\tfor ( n = 0; n < light.shadowCascadeCount; n ++ ) {\n\n\t\t\t\t\tvar virtualLight;\n\n\t\t\t\t\tif ( ! light.shadowCascadeArray[ n ] ) {\n\n\t\t\t\t\t\tvirtualLight = createVirtualLight( light, n );\n\t\t\t\t\t\tvirtualLight.originalCamera = camera;\n\n\t\t\t\t\t\tvar gyro = new THREE.Gyroscope();\n\t\t\t\t\t\tgyro.position = light.shadowCascadeOffset;\n\n\t\t\t\t\t\tgyro.add( virtualLight );\n\t\t\t\t\t\tgyro.add( virtualLight.target );\n\n\t\t\t\t\t\tcamera.add( gyro );\n\n\t\t\t\t\t\tlight.shadowCascadeArray[ n ] = virtualLight;\n\n\t\t\t\t\t\tconsole.log( \"Created virtualLight\", virtualLight );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvirtualLight = light.shadowCascadeArray[ n ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tupdateVirtualLight( light, n );\n\n\t\t\t\t\tlights[ k ] = virtualLight;\n\t\t\t\t\tk ++;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tlights[ k ] = light;\n\t\t\t\tk ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// render depth map\n\n\t\tfor ( i = 0, il = lights.length; i < il; i ++ ) {\n\n\t\t\tlight = lights[ i ];\n\n\t\t\tif ( ! light.shadowMap ) {\n\n\t\t\t\tvar shadowFilter = THREE.LinearFilter;\n\n\t\t\t\tif ( _renderer.shadowMapType === THREE.PCFSoftShadowMap ) {\n\n\t\t\t\t\tshadowFilter = THREE.NearestFilter;\n\n\t\t\t\t}\n\n\t\t\t\tvar pars = { minFilter: shadowFilter, magFilter: shadowFilter, format: THREE.RGBAFormat };\n\n\t\t\t\tlight.shadowMap = new THREE.WebGLRenderTarget( light.shadowMapWidth, light.shadowMapHeight, pars );\n\t\t\t\tlight.shadowMapSize = new THREE.Vector2( light.shadowMapWidth, light.shadowMapHeight );\n\n\t\t\t\tlight.shadowMatrix = new THREE.Matrix4();\n\n\t\t\t}\n\n\t\t\tif ( ! light.shadowCamera ) {\n\n\t\t\t\tif ( light instanceof THREE.SpotLight ) {\n\n\t\t\t\t\tlight.shadowCamera = new THREE.PerspectiveCamera( light.shadowCameraFov, light.shadowMapWidth / light.shadowMapHeight, light.shadowCameraNear, light.shadowCameraFar );\n\n\t\t\t\t} else if ( light instanceof THREE.DirectionalLight ) {\n\n\t\t\t\t\tlight.shadowCamera = new THREE.OrthographicCamera( light.shadowCameraLeft, light.shadowCameraRight, light.shadowCameraTop, light.shadowCameraBottom, light.shadowCameraNear, light.shadowCameraFar );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( \"Unsupported light type for shadow\" );\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tscene.add( light.shadowCamera );\n\n\t\t\t\tif ( _renderer.autoUpdateScene ) scene.updateMatrixWorld();\n\n\t\t\t}\n\n\t\t\tif ( light.shadowCameraVisible && ! light.cameraHelper ) {\n\n\t\t\t\tlight.cameraHelper = new THREE.CameraHelper( light.shadowCamera );\n\t\t\t\tlight.shadowCamera.add( light.cameraHelper );\n\n\t\t\t}\n\n\t\t\tif ( light.isVirtual && virtualLight.originalCamera == camera ) {\n\n\t\t\t\tupdateShadowCamera( camera, light );\n\n\t\t\t}\n\n\t\t\tshadowMap = light.shadowMap;\n\t\t\tshadowMatrix = light.shadowMatrix;\n\t\t\tshadowCamera = light.shadowCamera;\n\n\t\t\tshadowCamera.position.getPositionFromMatrix( light.matrixWorld );\n\t\t\t_matrixPosition.getPositionFromMatrix( light.target.matrixWorld );\n\t\t\tshadowCamera.lookAt( _matrixPosition );\n\t\t\tshadowCamera.updateMatrixWorld();\n\n\t\t\tshadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );\n\n\t\t\tif ( light.cameraHelper ) light.cameraHelper.visible = light.shadowCameraVisible;\n\t\t\tif ( light.shadowCameraVisible ) light.cameraHelper.update();\n\n\t\t\t// compute shadow matrix\n\n\t\t\tshadowMatrix.set( 0.5, 0.0, 0.0, 0.5,\n\t\t\t\t\t\t\t  0.0, 0.5, 0.0, 0.5,\n\t\t\t\t\t\t\t  0.0, 0.0, 0.5, 0.5,\n\t\t\t\t\t\t\t  0.0, 0.0, 0.0, 1.0 );\n\n\t\t\tshadowMatrix.multiply( shadowCamera.projectionMatrix );\n\t\t\tshadowMatrix.multiply( shadowCamera.matrixWorldInverse );\n\n\t\t\t// update camera matrices and frustum\n\n\t\t\t_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );\n\t\t\t_frustum.setFromMatrix( _projScreenMatrix );\n\n\t\t\t// render shadow map\n\n\t\t\t_renderer.setRenderTarget( shadowMap );\n\t\t\t_renderer.clear();\n\n\t\t\t// set object matrices & frustum culling\n\n\t\t\trenderList = scene.__webglObjects;\n\n\t\t\tfor ( j = 0, jl = renderList.length; j < jl; j ++ ) {\n\n\t\t\t\twebglObject = renderList[ j ];\n\t\t\t\tobject = webglObject.object;\n\n\t\t\t\twebglObject.render = false;\n\n\t\t\t\tif ( object.visible && object.castShadow ) {\n\n\t\t\t\t\tif ( ! ( object instanceof THREE.Mesh || object instanceof THREE.ParticleSystem ) || ! ( object.frustumCulled ) || _frustum.intersectsObject( object ) ) {\n\n\t\t\t\t\t\tobject._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\n\n\t\t\t\t\t\twebglObject.render = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// render regular objects\n\n\t\t\tvar objectMaterial, useMorphing, useSkinning;\n\n\t\t\tfor ( j = 0, jl = renderList.length; j < jl; j ++ ) {\n\n\t\t\t\twebglObject = renderList[ j ];\n\n\t\t\t\tif ( webglObject.render ) {\n\n\t\t\t\t\tobject = webglObject.object;\n\t\t\t\t\tbuffer = webglObject.buffer;\n\n\t\t\t\t\t// culling is overriden globally for all objects\n\t\t\t\t\t// while rendering depth map\n\n\t\t\t\t\t// need to deal with MeshFaceMaterial somehow\n\t\t\t\t\t// in that case just use the first of material.materials for now\n\t\t\t\t\t// (proper solution would require to break objects by materials\n\t\t\t\t\t//  similarly to regular rendering and then set corresponding\n\t\t\t\t\t//  depth materials per each chunk instead of just once per object)\n\n\t\t\t\t\tobjectMaterial = getObjectMaterial( object );\n\n\t\t\t\t\tuseMorphing = object.geometry.morphTargets.length > 0 && objectMaterial.morphTargets;\n\t\t\t\t\tuseSkinning = object instanceof THREE.SkinnedMesh && objectMaterial.skinning;\n\n\t\t\t\t\tif ( object.customDepthMaterial ) {\n\n\t\t\t\t\t\tmaterial = object.customDepthMaterial;\n\n\t\t\t\t\t} else if ( useSkinning ) {\n\n\t\t\t\t\t\tmaterial = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;\n\n\t\t\t\t\t} else if ( useMorphing ) {\n\n\t\t\t\t\t\tmaterial = _depthMaterialMorph;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmaterial = _depthMaterial;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( buffer instanceof THREE.BufferGeometry ) {\n\n\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, scene.__lights, fog, material, buffer, object );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_renderer.renderBuffer( shadowCamera, scene.__lights, fog, material, buffer, object );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// set matrices and render immediate objects\n\n\t\t\trenderList = scene.__webglObjectsImmediate;\n\n\t\t\tfor ( j = 0, jl = renderList.length; j < jl; j ++ ) {\n\n\t\t\t\twebglObject = renderList[ j ];\n\t\t\t\tobject = webglObject.object;\n\n\t\t\t\tif ( object.visible && object.castShadow ) {\n\n\t\t\t\t\tobject._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\n\n\t\t\t\t\t_renderer.renderImmediateObject( shadowCamera, scene.__lights, fog, _depthMaterial, object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// restore GL state\n\n\t\tvar clearColor = _renderer.getClearColor(),\n\t\tclearAlpha = _renderer.getClearAlpha();\n\n\t\t_gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearAlpha );\n\t\t_gl.enable( _gl.BLEND );\n\n\t\tif ( _renderer.shadowMapCullFace === THREE.CullFaceFront ) {\n\n\t\t\t_gl.cullFace( _gl.BACK );\n\n\t\t}\n\n\t};\n\n\tfunction createVirtualLight( light, cascade ) {\n\n\t\tvar virtualLight = new THREE.DirectionalLight();\n\n\t\tvirtualLight.isVirtual = true;\n\n\t\tvirtualLight.onlyShadow = true;\n\t\tvirtualLight.castShadow = true;\n\n\t\tvirtualLight.shadowCameraNear = light.shadowCameraNear;\n\t\tvirtualLight.shadowCameraFar = light.shadowCameraFar;\n\n\t\tvirtualLight.shadowCameraLeft = light.shadowCameraLeft;\n\t\tvirtualLight.shadowCameraRight = light.shadowCameraRight;\n\t\tvirtualLight.shadowCameraBottom = light.shadowCameraBottom;\n\t\tvirtualLight.shadowCameraTop = light.shadowCameraTop;\n\n\t\tvirtualLight.shadowCameraVisible = light.shadowCameraVisible;\n\n\t\tvirtualLight.shadowDarkness = light.shadowDarkness;\n\n\t\tvirtualLight.shadowBias = light.shadowCascadeBias[ cascade ];\n\t\tvirtualLight.shadowMapWidth = light.shadowCascadeWidth[ cascade ];\n\t\tvirtualLight.shadowMapHeight = light.shadowCascadeHeight[ cascade ];\n\n\t\tvirtualLight.pointsWorld = [];\n\t\tvirtualLight.pointsFrustum = [];\n\n\t\tvar pointsWorld = virtualLight.pointsWorld,\n\t\t\tpointsFrustum = virtualLight.pointsFrustum;\n\n\t\tfor ( var i = 0; i < 8; i ++ ) {\n\n\t\t\tpointsWorld[ i ] = new THREE.Vector3();\n\t\t\tpointsFrustum[ i ] = new THREE.Vector3();\n\n\t\t}\n\n\t\tvar nearZ = light.shadowCascadeNearZ[ cascade ];\n\t\tvar farZ = light.shadowCascadeFarZ[ cascade ];\n\n\t\tpointsFrustum[ 0 ].set( -1, -1, nearZ );\n\t\tpointsFrustum[ 1 ].set(  1, -1, nearZ );\n\t\tpointsFrustum[ 2 ].set( -1,  1, nearZ );\n\t\tpointsFrustum[ 3 ].set(  1,  1, nearZ );\n\n\t\tpointsFrustum[ 4 ].set( -1, -1, farZ );\n\t\tpointsFrustum[ 5 ].set(  1, -1, farZ );\n\t\tpointsFrustum[ 6 ].set( -1,  1, farZ );\n\t\tpointsFrustum[ 7 ].set(  1,  1, farZ );\n\n\t\treturn virtualLight;\n\n\t}\n\n\t// Synchronize virtual light with the original light\n\n\tfunction updateVirtualLight( light, cascade ) {\n\n\t\tvar virtualLight = light.shadowCascadeArray[ cascade ];\n\n\t\tvirtualLight.position.copy( light.position );\n\t\tvirtualLight.target.position.copy( light.target.position );\n\t\tvirtualLight.lookAt( virtualLight.target );\n\n\t\tvirtualLight.shadowCameraVisible = light.shadowCameraVisible;\n\t\tvirtualLight.shadowDarkness = light.shadowDarkness;\n\n\t\tvirtualLight.shadowBias = light.shadowCascadeBias[ cascade ];\n\n\t\tvar nearZ = light.shadowCascadeNearZ[ cascade ];\n\t\tvar farZ = light.shadowCascadeFarZ[ cascade ];\n\n\t\tvar pointsFrustum = virtualLight.pointsFrustum;\n\n\t\tpointsFrustum[ 0 ].z = nearZ;\n\t\tpointsFrustum[ 1 ].z = nearZ;\n\t\tpointsFrustum[ 2 ].z = nearZ;\n\t\tpointsFrustum[ 3 ].z = nearZ;\n\n\t\tpointsFrustum[ 4 ].z = farZ;\n\t\tpointsFrustum[ 5 ].z = farZ;\n\t\tpointsFrustum[ 6 ].z = farZ;\n\t\tpointsFrustum[ 7 ].z = farZ;\n\n\t}\n\n\t// Fit shadow camera's ortho frustum to camera frustum\n\n\tfunction updateShadowCamera( camera, light ) {\n\n\t\tvar shadowCamera = light.shadowCamera,\n\t\t\tpointsFrustum = light.pointsFrustum,\n\t\t\tpointsWorld = light.pointsWorld;\n\n\t\t_min.set( Infinity, Infinity, Infinity );\n\t\t_max.set( -Infinity, -Infinity, -Infinity );\n\n\t\tfor ( var i = 0; i < 8; i ++ ) {\n\n\t\t\tvar p = pointsWorld[ i ];\n\n\t\t\tp.copy( pointsFrustum[ i ] );\n\t\t\tTHREE.ShadowMapPlugin.__projector.unprojectVector( p, camera );\n\n\t\t\tp.applyMatrix4( shadowCamera.matrixWorldInverse );\n\n\t\t\tif ( p.x < _min.x ) _min.x = p.x;\n\t\t\tif ( p.x > _max.x ) _max.x = p.x;\n\n\t\t\tif ( p.y < _min.y ) _min.y = p.y;\n\t\t\tif ( p.y > _max.y ) _max.y = p.y;\n\n\t\t\tif ( p.z < _min.z ) _min.z = p.z;\n\t\t\tif ( p.z > _max.z ) _max.z = p.z;\n\n\t\t}\n\n\t\tshadowCamera.left = _min.x;\n\t\tshadowCamera.right = _max.x;\n\t\tshadowCamera.top = _max.y;\n\t\tshadowCamera.bottom = _min.y;\n\n\t\t// can't really fit near/far\n\t\t//shadowCamera.near = _min.z;\n\t\t//shadowCamera.far = _max.z;\n\n\t\tshadowCamera.updateProjectionMatrix();\n\n\t}\n\n\t// For the moment just ignore objects that have multiple materials with different animation methods\n\t// Only the first material will be taken into account for deciding which depth material to use for shadow maps\n\n\tfunction getObjectMaterial( object ) {\n\n\t\treturn object.material instanceof THREE.MeshFaceMaterial\n\t\t\t? object.material.materials[ 0 ]\n\t\t\t: object.material;\n\n\t};\n\n};\n\nTHREE.ShadowMapPlugin.__projector = new THREE.Projector();\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.SpritePlugin = function () {\n\n\tvar _gl, _renderer, _precision, _sprite = {};\n\n\tthis.init = function ( renderer ) {\n\n\t\t_gl = renderer.context;\n\t\t_renderer = renderer;\n\n\t\t_precision = renderer.getPrecision();\n\n\t\t_sprite.vertices = new Float32Array( 8 + 8 );\n\t\t_sprite.faces    = new Uint16Array( 6 );\n\n\t\tvar i = 0;\n\n\t\t_sprite.vertices[ i++ ] = -1; _sprite.vertices[ i++ ] = -1;\t// vertex 0\n\t\t_sprite.vertices[ i++ ] = 0;  _sprite.vertices[ i++ ] = 0;\t// uv 0\n\n\t\t_sprite.vertices[ i++ ] = 1;  _sprite.vertices[ i++ ] = -1;\t// vertex 1\n\t\t_sprite.vertices[ i++ ] = 1;  _sprite.vertices[ i++ ] = 0;\t// uv 1\n\n\t\t_sprite.vertices[ i++ ] = 1;  _sprite.vertices[ i++ ] = 1;\t// vertex 2\n\t\t_sprite.vertices[ i++ ] = 1;  _sprite.vertices[ i++ ] = 1;\t// uv 2\n\n\t\t_sprite.vertices[ i++ ] = -1; _sprite.vertices[ i++ ] = 1;\t// vertex 3\n\t\t_sprite.vertices[ i++ ] = 0;  _sprite.vertices[ i++ ] = 1;\t// uv 3\n\n\t\ti = 0;\n\n\t\t_sprite.faces[ i++ ] = 0; _sprite.faces[ i++ ] = 1; _sprite.faces[ i++ ] = 2;\n\t\t_sprite.faces[ i++ ] = 0; _sprite.faces[ i++ ] = 2; _sprite.faces[ i++ ] = 3;\n\n\t\t_sprite.vertexBuffer  = _gl.createBuffer();\n\t\t_sprite.elementBuffer = _gl.createBuffer();\n\n\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, _sprite.vertexBuffer );\n\t\t_gl.bufferData( _gl.ARRAY_BUFFER, _sprite.vertices, _gl.STATIC_DRAW );\n\n\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, _sprite.elementBuffer );\n\t\t_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, _sprite.faces, _gl.STATIC_DRAW );\n\n\t\t_sprite.program = createProgram( THREE.ShaderSprite[ \"sprite\" ], _precision );\n\n\t\t_sprite.attributes = {};\n\t\t_sprite.uniforms = {};\n\n\t\t_sprite.attributes.position           = _gl.getAttribLocation ( _sprite.program, \"position\" );\n\t\t_sprite.attributes.uv                 = _gl.getAttribLocation ( _sprite.program, \"uv\" );\n\n\t\t_sprite.uniforms.uvOffset             = _gl.getUniformLocation( _sprite.program, \"uvOffset\" );\n\t\t_sprite.uniforms.uvScale              = _gl.getUniformLocation( _sprite.program, \"uvScale\" );\n\n\t\t_sprite.uniforms.rotation             = _gl.getUniformLocation( _sprite.program, \"rotation\" );\n\t\t_sprite.uniforms.scale                = _gl.getUniformLocation( _sprite.program, \"scale\" );\n\t\t_sprite.uniforms.alignment            = _gl.getUniformLocation( _sprite.program, \"alignment\" );\n\n\t\t_sprite.uniforms.color                = _gl.getUniformLocation( _sprite.program, \"color\" );\n\t\t_sprite.uniforms.map                  = _gl.getUniformLocation( _sprite.program, \"map\" );\n\t\t_sprite.uniforms.opacity              = _gl.getUniformLocation( _sprite.program, \"opacity\" );\n\n\t\t_sprite.uniforms.useScreenCoordinates = _gl.getUniformLocation( _sprite.program, \"useScreenCoordinates\" );\n\t\t_sprite.uniforms.sizeAttenuation   \t  = _gl.getUniformLocation( _sprite.program, \"sizeAttenuation\" );\n\t\t_sprite.uniforms.screenPosition    \t  = _gl.getUniformLocation( _sprite.program, \"screenPosition\" );\n\t\t_sprite.uniforms.modelViewMatrix      = _gl.getUniformLocation( _sprite.program, \"modelViewMatrix\" );\n\t\t_sprite.uniforms.projectionMatrix     = _gl.getUniformLocation( _sprite.program, \"projectionMatrix\" );\n\n\t\t_sprite.uniforms.fogType \t\t  \t  = _gl.getUniformLocation( _sprite.program, \"fogType\" );\n\t\t_sprite.uniforms.fogDensity \t\t  = _gl.getUniformLocation( _sprite.program, \"fogDensity\" );\n\t\t_sprite.uniforms.fogNear \t\t  \t  = _gl.getUniformLocation( _sprite.program, \"fogNear\" );\n\t\t_sprite.uniforms.fogFar \t\t  \t  = _gl.getUniformLocation( _sprite.program, \"fogFar\" );\n\t\t_sprite.uniforms.fogColor \t\t  \t  = _gl.getUniformLocation( _sprite.program, \"fogColor\" );\n\n\t\t_sprite.uniforms.alphaTest \t\t  \t  = _gl.getUniformLocation( _sprite.program, \"alphaTest\" );\n\n\t};\n\n\tthis.render = function ( scene, camera, viewportWidth, viewportHeight ) {\n\n\t\tvar sprites = scene.__webglSprites,\n\t\t\tnSprites = sprites.length;\n\n\t\tif ( ! nSprites ) return;\n\n\t\tvar attributes = _sprite.attributes,\n\t\t\tuniforms = _sprite.uniforms;\n\n\t\tvar invAspect = viewportHeight / viewportWidth;\n\n\t\tvar halfViewportWidth = viewportWidth * 0.5,\n\t\t\thalfViewportHeight = viewportHeight * 0.5;\n\n\t\t// setup gl\n\n\t\t_gl.useProgram( _sprite.program );\n\n\t\t_gl.enableVertexAttribArray( attributes.position );\n\t\t_gl.enableVertexAttribArray( attributes.uv );\n\n\t\t_gl.disable( _gl.CULL_FACE );\n\t\t_gl.enable( _gl.BLEND );\n\n\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, _sprite.vertexBuffer );\n\t\t_gl.vertexAttribPointer( attributes.position, 2, _gl.FLOAT, false, 2 * 8, 0 );\n\t\t_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 2 * 8, 8 );\n\n\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, _sprite.elementBuffer );\n\n\t\t_gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\n\n\t\t_gl.activeTexture( _gl.TEXTURE0 );\n\t\t_gl.uniform1i( uniforms.map, 0 );\n\n\t\tvar oldFogType = 0;\n\t\tvar sceneFogType = 0;\n\t\tvar fog = scene.fog;\n\n\t\tif ( fog ) {\n\n\t\t\t_gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );\n\n\t\t\tif ( fog instanceof THREE.Fog ) {\n\n\t\t\t\t_gl.uniform1f( uniforms.fogNear, fog.near );\n\t\t\t\t_gl.uniform1f( uniforms.fogFar, fog.far );\n\n\t\t\t\t_gl.uniform1i( uniforms.fogType, 1 );\n\t\t\t\toldFogType = 1;\n\t\t\t\tsceneFogType = 1;\n\n\t\t\t} else if ( fog instanceof THREE.FogExp2 ) {\n\n\t\t\t\t_gl.uniform1f( uniforms.fogDensity, fog.density );\n\n\t\t\t\t_gl.uniform1i( uniforms.fogType, 2 );\n\t\t\t\toldFogType = 2;\n\t\t\t\tsceneFogType = 2;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t_gl.uniform1i( uniforms.fogType, 0 );\n\t\t\toldFogType = 0;\n\t\t\tsceneFogType = 0;\n\n\t\t}\n\n\n\t\t// update positions and sort\n\n\t\tvar i, sprite, material, screenPosition, size, fogType, scale = [];\n\n\t\tfor( i = 0; i < nSprites; i ++ ) {\n\n\t\t\tsprite = sprites[ i ];\n\t\t\tmaterial = sprite.material;\n\n\t\t\tif ( ! sprite.visible || material.opacity === 0 ) continue;\n\n\t\t\tif ( ! material.useScreenCoordinates ) {\n\n\t\t\t\tsprite._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );\n\t\t\t\tsprite.z = - sprite._modelViewMatrix.elements[ 14 ];\n\n\t\t\t} else {\n\n\t\t\t\tsprite.z = - sprite.position.z;\n\n\t\t\t}\n\n\t\t}\n\n\t\tsprites.sort( painterSortStable );\n\n\t\t// render all sprites\n\n\t\tfor( i = 0; i < nSprites; i ++ ) {\n\n\t\t\tsprite = sprites[ i ];\n\t\t\tmaterial = sprite.material;\n\n\t\t\tif ( ! sprite.visible || material.opacity === 0 ) continue;\n\n\t\t\tif ( material.map && material.map.image && material.map.image.width ) {\n\n\t\t\t\t_gl.uniform1f( uniforms.alphaTest, material.alphaTest );\n\n\t\t\t\tif ( material.useScreenCoordinates === true ) {\n\n\t\t\t\t\t_gl.uniform1i( uniforms.useScreenCoordinates, 1 );\n\t\t\t\t\t_gl.uniform3f(\n\t\t\t\t\t\tuniforms.screenPosition,\n\t\t\t\t\t\t( ( sprite.position.x * _renderer.devicePixelRatio ) - halfViewportWidth  ) / halfViewportWidth,\n\t\t\t\t\t\t( halfViewportHeight - ( sprite.position.y * _renderer.devicePixelRatio ) ) / halfViewportHeight,\n\t\t\t\t\t\tMath.max( 0, Math.min( 1, sprite.position.z ) )\n\t\t\t\t\t);\n\n\t\t\t\t\tscale[ 0 ] = _renderer.devicePixelRatio;\n\t\t\t\t\tscale[ 1 ] = _renderer.devicePixelRatio;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_gl.uniform1i( uniforms.useScreenCoordinates, 0 );\n\t\t\t\t\t_gl.uniform1i( uniforms.sizeAttenuation, material.sizeAttenuation ? 1 : 0 );\n\t\t\t\t\t_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite._modelViewMatrix.elements );\n\n\t\t\t\t\tscale[ 0 ] = 1;\n\t\t\t\t\tscale[ 1 ] = 1;\n\n\t\t\t\t}\n\n\t\t\t\tif ( scene.fog && material.fog ) {\n\n\t\t\t\t\tfogType = sceneFogType;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfogType = 0;\n\n\t\t\t\t}\n\n\t\t\t\tif ( oldFogType !== fogType ) {\n\n\t\t\t\t\t_gl.uniform1i( uniforms.fogType, fogType );\n\t\t\t\t\toldFogType = fogType;\n\n\t\t\t\t}\n\n\t\t\t\tsize = 1 / ( material.scaleByViewport ? viewportHeight : 1 );\n\n\t\t\t\tscale[ 0 ] *= size * invAspect * sprite.scale.x\n\t\t\t\tscale[ 1 ] *= size * sprite.scale.y;\n\n\t\t\t\t_gl.uniform2f( uniforms.uvScale, material.uvScale.x, material.uvScale.y );\n\t\t\t\t_gl.uniform2f( uniforms.uvOffset, material.uvOffset.x, material.uvOffset.y );\n\t\t\t\t_gl.uniform2f( uniforms.alignment, material.alignment.x, material.alignment.y );\n\n\t\t\t\t_gl.uniform1f( uniforms.opacity, material.opacity );\n\t\t\t\t_gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );\n\n\t\t\t\t_gl.uniform1f( uniforms.rotation, sprite.rotation );\n\t\t\t\t_gl.uniform2fv( uniforms.scale, scale );\n\n\t\t\t\t_renderer.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\n\t\t\t\t_renderer.setDepthTest( material.depthTest );\n\t\t\t\t_renderer.setDepthWrite( material.depthWrite );\n\t\t\t\t_renderer.setTexture( material.map, 0 );\n\n\t\t\t\t_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// restore gl\n\n\t\t_gl.enable( _gl.CULL_FACE );\n\n\t};\n\n\tfunction createProgram ( shader, precision ) {\n\n\t\tvar program = _gl.createProgram();\n\n\t\tvar fragmentShader = _gl.createShader( _gl.FRAGMENT_SHADER );\n\t\tvar vertexShader = _gl.createShader( _gl.VERTEX_SHADER );\n\n\t\tvar prefix = \"precision \" + precision + \" float;\\n\";\n\n\t\t_gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );\n\t\t_gl.shaderSource( vertexShader, prefix + shader.vertexShader );\n\n\t\t_gl.compileShader( fragmentShader );\n\t\t_gl.compileShader( vertexShader );\n\n\t\t_gl.attachShader( program, fragmentShader );\n\t\t_gl.attachShader( program, vertexShader );\n\n\t\t_gl.linkProgram( program );\n\n\t\treturn program;\n\n\t};\n\n\tfunction painterSortStable ( a, b ) {\n\n\t\tif ( a.z !== b.z ) {\n\n\t\t\treturn b.z - a.z;\n\n\t\t} else {\n\n\t\t\treturn b.id - a.id;\n\n\t\t}\n\n\t};\n\n};\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.DepthPassPlugin = function () {\n\n\tthis.enabled = false;\n\tthis.renderTarget = null;\n\n\tvar _gl,\n\t_renderer,\n\t_depthMaterial, _depthMaterialMorph, _depthMaterialSkin, _depthMaterialMorphSkin,\n\n\t_frustum = new THREE.Frustum(),\n\t_projScreenMatrix = new THREE.Matrix4();\n\n\tthis.init = function ( renderer ) {\n\n\t\t_gl = renderer.context;\n\t\t_renderer = renderer;\n\n\t\tvar depthShader = THREE.ShaderLib[ \"depthRGBA\" ];\n\t\tvar depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );\n\n\t\t_depthMaterial = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms } );\n\t\t_depthMaterialMorph = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true } );\n\t\t_depthMaterialSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, skinning: true } );\n\t\t_depthMaterialMorphSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true, skinning: true } );\n\n\t\t_depthMaterial._shadowPass = true;\n\t\t_depthMaterialMorph._shadowPass = true;\n\t\t_depthMaterialSkin._shadowPass = true;\n\t\t_depthMaterialMorphSkin._shadowPass = true;\n\n\t};\n\n\tthis.render = function ( scene, camera ) {\n\n\t\tif ( ! this.enabled ) return;\n\n\t\tthis.update( scene, camera );\n\n\t};\n\n\tthis.update = function ( scene, camera ) {\n\n\t\tvar i, il, j, jl, n,\n\n\t\tprogram, buffer, material,\n\t\twebglObject, object, light,\n\t\trenderList,\n\n\t\tfog = null;\n\n\t\t// set GL state for depth map\n\n\t\t_gl.clearColor( 1, 1, 1, 1 );\n\t\t_gl.disable( _gl.BLEND );\n\n\t\t_renderer.setDepthTest( true );\n\n\t\t// update scene\n\n\t\tif ( _renderer.autoUpdateScene ) scene.updateMatrixWorld();\n\n\t\t// update camera matrices and frustum\n\n\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\n\n\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\t\t_frustum.setFromMatrix( _projScreenMatrix );\n\n\t\t// render depth map\n\n\t\t_renderer.setRenderTarget( this.renderTarget );\n\t\t_renderer.clear();\n\n\t\t// set object matrices & frustum culling\n\n\t\trenderList = scene.__webglObjects;\n\n\t\tfor ( j = 0, jl = renderList.length; j < jl; j ++ ) {\n\n\t\t\twebglObject = renderList[ j ];\n\t\t\tobject = webglObject.object;\n\n\t\t\twebglObject.render = false;\n\n\t\t\tif ( object.visible ) {\n\n\t\t\t\tif ( ! ( object instanceof THREE.Mesh || object instanceof THREE.ParticleSystem ) || ! ( object.frustumCulled ) || _frustum.intersectsObject( object ) ) {\n\n\t\t\t\t\tobject._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\n\n\t\t\t\t\twebglObject.render = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// render regular objects\n\n\t\tvar objectMaterial, useMorphing, useSkinning;\n\n\t\tfor ( j = 0, jl = renderList.length; j < jl; j ++ ) {\n\n\t\t\twebglObject = renderList[ j ];\n\n\t\t\tif ( webglObject.render ) {\n\n\t\t\t\tobject = webglObject.object;\n\t\t\t\tbuffer = webglObject.buffer;\n\n\t\t\t\t// todo: create proper depth material for particles\n\n\t\t\t\tif ( object instanceof THREE.ParticleSystem && !object.customDepthMaterial ) continue;\n\n\t\t\t\tobjectMaterial = getObjectMaterial( object );\n\n\t\t\t\tif ( objectMaterial ) _renderer.setMaterialFaces( object.material );\n\n\t\t\t\tuseMorphing = object.geometry.morphTargets.length > 0 && objectMaterial.morphTargets;\n\t\t\t\tuseSkinning = object instanceof THREE.SkinnedMesh && objectMaterial.skinning;\n\n\t\t\t\tif ( object.customDepthMaterial ) {\n\n\t\t\t\t\tmaterial = object.customDepthMaterial;\n\n\t\t\t\t} else if ( useSkinning ) {\n\n\t\t\t\t\tmaterial = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;\n\n\t\t\t\t} else if ( useMorphing ) {\n\n\t\t\t\t\tmaterial = _depthMaterialMorph;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmaterial = _depthMaterial;\n\n\t\t\t\t}\n\n\t\t\t\tif ( buffer instanceof THREE.BufferGeometry ) {\n\n\t\t\t\t\t_renderer.renderBufferDirect( camera, scene.__lights, fog, material, buffer, object );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_renderer.renderBuffer( camera, scene.__lights, fog, material, buffer, object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// set matrices and render immediate objects\n\n\t\trenderList = scene.__webglObjectsImmediate;\n\n\t\tfor ( j = 0, jl = renderList.length; j < jl; j ++ ) {\n\n\t\t\twebglObject = renderList[ j ];\n\t\t\tobject = webglObject.object;\n\n\t\t\tif ( object.visible ) {\n\n\t\t\t\tobject._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\n\n\t\t\t\t_renderer.renderImmediateObject( camera, scene.__lights, fog, _depthMaterial, object );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// restore GL state\n\n\t\tvar clearColor = _renderer.getClearColor(),\n\t\tclearAlpha = _renderer.getClearAlpha();\n\n\t\t_gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearAlpha );\n\t\t_gl.enable( _gl.BLEND );\n\n\t};\n\n\t// For the moment just ignore objects that have multiple materials with different animation methods\n\t// Only the first material will be taken into account for deciding which depth material to use\n\n\tfunction getObjectMaterial( object ) {\n\n\t\treturn object.material instanceof THREE.MeshFaceMaterial\n\t\t\t? object.material.materials[ 0 ]\n\t\t\t: object.material;\n\n\t};\n\n};\n\n/**\n * @author mikael emtinger / http://gomo.se/\n *\n */\n\nTHREE.ShaderFlares = {\n\n\t'lensFlareVertexTexture': {\n\n\t\tvertexShader: [\n\n\t\t\t\"uniform lowp int renderType;\",\n\n\t\t\t\"uniform vec3 screenPosition;\",\n\t\t\t\"uniform vec2 scale;\",\n\t\t\t\"uniform float rotation;\",\n\n\t\t\t\"uniform sampler2D occlusionMap;\",\n\n\t\t\t\"attribute vec2 position;\",\n\t\t\t\"attribute vec2 uv;\",\n\n\t\t\t\"varying vec2 vUV;\",\n\t\t\t\"varying float vVisibility;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"vUV = uv;\",\n\n\t\t\t\t\"vec2 pos = position;\",\n\n\t\t\t\t\"if( renderType == 2 ) {\",\n\n\t\t\t\t\t\"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) ) +\",\n\t\t\t\t\t\t\t\t\t  \"texture2D( occlusionMap, vec2( 0.5, 0.1 ) ) +\",\n\t\t\t\t\t\t\t\t\t  \"texture2D( occlusionMap, vec2( 0.9, 0.1 ) ) +\",\n\t\t\t\t\t\t\t\t\t  \"texture2D( occlusionMap, vec2( 0.9, 0.5 ) ) +\",\n\t\t\t\t\t\t\t\t\t  \"texture2D( occlusionMap, vec2( 0.9, 0.9 ) ) +\",\n\t\t\t\t\t\t\t\t\t  \"texture2D( occlusionMap, vec2( 0.5, 0.9 ) ) +\",\n\t\t\t\t\t\t\t\t\t  \"texture2D( occlusionMap, vec2( 0.1, 0.9 ) ) +\",\n\t\t\t\t\t\t\t\t\t  \"texture2D( occlusionMap, vec2( 0.1, 0.5 ) ) +\",\n\t\t\t\t\t\t\t\t\t  \"texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\",\n\n\t\t\t\t\t\"vVisibility = (       visibility.r / 9.0 ) *\",\n\t\t\t\t\t\t\t\t  \"( 1.0 - visibility.g / 9.0 ) *\",\n\t\t\t\t\t\t\t\t  \"(       visibility.b / 9.0 ) *\",\n\t\t\t\t\t\t\t\t  \"( 1.0 - visibility.a / 9.0 );\",\n\n\t\t\t\t\t\"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\n\t\t\t\t\t\"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\t\"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform lowp int renderType;\",\n\n\t\t\t\"uniform sampler2D map;\",\n\t\t\t\"uniform float opacity;\",\n\t\t\t\"uniform vec3 color;\",\n\n\t\t\t\"varying vec2 vUV;\",\n\t\t\t\"varying float vVisibility;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t// pink square\n\n\t\t\t\t\"if( renderType == 0 ) {\",\n\n\t\t\t\t\t\"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\",\n\n\t\t\t\t// restore\n\n\t\t\t\t\"} else if( renderType == 1 ) {\",\n\n\t\t\t\t\t\"gl_FragColor = texture2D( map, vUV );\",\n\n\t\t\t\t// flare\n\n\t\t\t\t\"} else {\",\n\n\t\t\t\t\t\"vec4 texture = texture2D( map, vUV );\",\n\t\t\t\t\t\"texture.a *= opacity * vVisibility;\",\n\t\t\t\t\t\"gl_FragColor = texture;\",\n\t\t\t\t\t\"gl_FragColor.rgb *= color;\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\"}\"\n\t\t].join( \"\\n\" )\n\n\t},\n\n\n\t'lensFlare': {\n\n\t\tvertexShader: [\n\n\t\t\t\"uniform lowp int renderType;\",\n\n\t\t\t\"uniform vec3 screenPosition;\",\n\t\t\t\"uniform vec2 scale;\",\n\t\t\t\"uniform float rotation;\",\n\n\t\t\t\"attribute vec2 position;\",\n\t\t\t\"attribute vec2 uv;\",\n\n\t\t\t\"varying vec2 vUV;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"vUV = uv;\",\n\n\t\t\t\t\"vec2 pos = position;\",\n\n\t\t\t\t\"if( renderType == 2 ) {\",\n\n\t\t\t\t\t\"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\n\t\t\t\t\t\"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\t\"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"precision mediump float;\",\n\n\t\t\t\"uniform lowp int renderType;\",\n\n\t\t\t\"uniform sampler2D map;\",\n\t\t\t\"uniform sampler2D occlusionMap;\",\n\t\t\t\"uniform float opacity;\",\n\t\t\t\"uniform vec3 color;\",\n\n\t\t\t\"varying vec2 vUV;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t// pink square\n\n\t\t\t\t\"if( renderType == 0 ) {\",\n\n\t\t\t\t\t\"gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );\",\n\n\t\t\t\t// restore\n\n\t\t\t\t\"} else if( renderType == 1 ) {\",\n\n\t\t\t\t\t\"gl_FragColor = texture2D( map, vUV );\",\n\n\t\t\t\t// flare\n\n\t\t\t\t\"} else {\",\n\n\t\t\t\t\t\"float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a +\",\n\t\t\t\t\t\t\t\t\t   \"texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a +\",\n\t\t\t\t\t\t\t\t\t   \"texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a +\",\n\t\t\t\t\t\t\t\t\t   \"texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;\",\n\n\t\t\t\t\t\"visibility = ( 1.0 - visibility / 4.0 );\",\n\n\t\t\t\t\t\"vec4 texture = texture2D( map, vUV );\",\n\t\t\t\t\t\"texture.a *= opacity * visibility;\",\n\t\t\t\t\t\"gl_FragColor = texture;\",\n\t\t\t\t\t\"gl_FragColor.rgb *= color;\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t}\n\n};\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n *\n */\n\nTHREE.ShaderSprite = {\n\n\t'sprite': {\n\n\t\tvertexShader: [\n\n\t\t\t\"uniform int useScreenCoordinates;\",\n\t\t\t\"uniform int sizeAttenuation;\",\n\t\t\t\"uniform vec3 screenPosition;\",\n\t\t\t\"uniform mat4 modelViewMatrix;\",\n\t\t\t\"uniform mat4 projectionMatrix;\",\n\t\t\t\"uniform float rotation;\",\n\t\t\t\"uniform vec2 scale;\",\n\t\t\t\"uniform vec2 alignment;\",\n\t\t\t\"uniform vec2 uvOffset;\",\n\t\t\t\"uniform vec2 uvScale;\",\n\n\t\t\t\"attribute vec2 position;\",\n\t\t\t\"attribute vec2 uv;\",\n\n\t\t\t\"varying vec2 vUV;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"vUV = uvOffset + uv * uvScale;\",\n\n\t\t\t\t\"vec2 alignedPosition = position + alignment;\",\n\n\t\t\t\t\"vec2 rotatedPosition;\",\n\t\t\t\t\"rotatedPosition.x = ( cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y ) * scale.x;\",\n\t\t\t\t\"rotatedPosition.y = ( sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y ) * scale.y;\",\n\n\t\t\t\t\"vec4 finalPosition;\",\n\n\t\t\t\t\"if( useScreenCoordinates != 0 ) {\",\n\n\t\t\t\t\t\"finalPosition = vec4( screenPosition.xy + rotatedPosition, screenPosition.z, 1.0 );\",\n\n\t\t\t\t\"} else {\",\n\n\t\t\t\t\t\"finalPosition = projectionMatrix * modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\",\n\t\t\t\t\t\"finalPosition.xy += rotatedPosition * ( sizeAttenuation == 1 ? 1.0 : finalPosition.z );\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\t\"gl_Position = finalPosition;\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform vec3 color;\",\n\t\t\t\"uniform sampler2D map;\",\n\t\t\t\"uniform float opacity;\",\n\n\t\t\t\"uniform int fogType;\",\n\t\t\t\"uniform vec3 fogColor;\",\n\t\t\t\"uniform float fogDensity;\",\n\t\t\t\"uniform float fogNear;\",\n\t\t\t\"uniform float fogFar;\",\n\t\t\t\"uniform float alphaTest;\",\n\n\t\t\t\"varying vec2 vUV;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"vec4 texture = texture2D( map, vUV );\",\n\n\t\t\t\t\"if ( texture.a < alphaTest ) discard;\",\n\n\t\t\t\t\"gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );\",\n\n\t\t\t\t\"if ( fogType > 0 ) {\",\n\n\t\t\t\t\t\"float depth = gl_FragCoord.z / gl_FragCoord.w;\",\n\t\t\t\t\t\"float fogFactor = 0.0;\",\n\n\t\t\t\t\t\"if ( fogType == 1 ) {\",\n\n\t\t\t\t\t\t\"fogFactor = smoothstep( fogNear, fogFar, depth );\",\n\n\t\t\t\t\t\"} else {\",\n\n\t\t\t\t\t\t\"const float LOG2 = 1.442695;\",\n\t\t\t\t\t\t\"float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\",\n\t\t\t\t\t\t\"fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\",\n\n\t\t\t\t\t\"}\",\n\n\t\t\t\t\t\"gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t}\n\n};"],"names":["hsl","q1","v1","points","x","y","z","mRotation","mScale","matrix","center","v2","degreeToRadiansFactor","radianToDegreesFactor","v0","sphere","localRay","facePlane","intersectPoint","matrixPosition","inverseMatrix","descSort","intersectObject","intersectDescendants","namespace","area","snip","playing","library","that","parseRecurseHierarchy","initData","THREE","REVISION","self","console","info","log","debug","warn","error","Int32Array","Array","Float32Array","String","prototype","trim","replace","extend","obj","source","Object","keys","i","il","length","prop","defineProperty","getOwnPropertyDescriptor","safeHasOwnProperty","hasOwnProperty","call","lastTime","vendors","window","requestAnimationFrame","cancelAnimationFrame","undefined","callback","currTime","Date","now","timeToCall","Math","max","id","setTimeout","clearTimeout","CullFaceNone","CullFaceBack","CullFaceFront","CullFaceFrontBack","FrontFaceDirectionCW","FrontFaceDirectionCCW","BasicShadowMap","PCFShadowMap","PCFSoftShadowMap","FrontSide","BackSide","DoubleSide","NoShading","FlatShading","SmoothShading","NoColors","FaceColors","VertexColors","NoBlending","NormalBlending","AdditiveBlending","SubtractiveBlending","MultiplyBlending","CustomBlending","AddEquation","SubtractEquation","ReverseSubtractEquation","ZeroFactor","OneFactor","SrcColorFactor","OneMinusSrcColorFactor","SrcAlphaFactor","OneMinusSrcAlphaFactor","DstAlphaFactor","OneMinusDstAlphaFactor","DstColorFactor","OneMinusDstColorFactor","SrcAlphaSaturateFactor","MultiplyOperation","MixOperation","AddOperation","UVMapping","CubeReflectionMapping","CubeRefractionMapping","SphericalReflectionMapping","SphericalRefractionMapping","RepeatWrapping","ClampToEdgeWrapping","MirroredRepeatWrapping","NearestFilter","NearestMipMapNearestFilter","NearestMipMapLinearFilter","LinearFilter","LinearMipMapNearestFilter","LinearMipMapLinearFilter","UnsignedByteType","ByteType","ShortType","UnsignedShortType","IntType","UnsignedIntType","FloatType","UnsignedShort4444Type","UnsignedShort5551Type","UnsignedShort565Type","AlphaFormat","RGBFormat","RGBAFormat","LuminanceFormat","LuminanceAlphaFormat","RGB_S3TC_DXT1_Format","RGBA_S3TC_DXT1_Format","RGBA_S3TC_DXT3_Format","RGBA_S3TC_DXT5_Format","Color","value","set","r","g","b","setHex","setStyle","hex","floor","setRGB","setHSV","h","s","v","setHSL","l","hue2rgb","p","q","t","style","test","color","exec","min","parseInt","ColorKeywords","copy","copyGammaToLinear","copyLinearToGamma","sqrt","convertGammaToLinear","convertLinearToGamma","getHex","getHexString","toString","slice","getHSL","hue","saturation","lightness","delta","getStyle","offsetHSL","add","addColors","color1","color2","addScalar","multiply","multiplyScalar","lerp","alpha","clone","Quaternion","w","setFromEuler","order","c1","cos","c2","c3","s1","sin","s2","s3","setFromAxisAngle","axis","angle","halfAngle","setFromRotationMatrix","m","te","elements","m11","m12","m13","m21","m22","m23","m31","m32","m33","trace","inverse","conjugate","normalize","lengthSq","multiplyQuaternions","a","qax","qay","qaz","qaw","qbx","qby","qbz","qbw","multiplyVector3","vector","applyQuaternion","slerp","qb","cosHalfTheta","halfTheta","acos","sinHalfTheta","abs","ratioA","ratioB","equals","qa","qm","Vector2","setX","setY","setComponent","index","Error","getComponent","addVectors","sub","subVectors","divideScalar","clamp","negate","dot","distanceTo","distanceToSquared","dx","dy","setLength","oldLength","toArray","Vector3","setZ","multiplyVectors","applyMatrix3","e","applyMatrix4","applyProjection","d","qx","qy","qz","qw","ix","iy","iz","iw","applyEuler","eulerOrder","quaternion","applyAxisAngle","transformDirection","divide","lengthManhattan","cross","crossVectors","projectOnVector","projectOnPlane","planeNormal","reflect","angleTo","theta","dz","getPositionFromMatrix","setEulerFromRotationMatrix","asin","atan2","setEulerFromQuaternion","sqx","sqy","sqz","sqw","getScaleFromMatrix","sx","sy","sz","Vector4","setW","setAxisAngleFromQuaternion","setAxisAngleFromRotationMatrix","xx","yy","zz","xy","xz","yz","PI","Box2","Infinity","setFromPoints","point","makeEmpty","setFromCenterAndSize","size","halfSize","box","empty","optionalTarget","result","expandByPoint","expandByVector","expandByScalar","scalar","containsPoint","containsBox","getParameter","isIntersectionBox","clampPoint","distanceToPoint","clampedPoint","intersect","union","translate","offset","Box3","getBoundingSphere","Sphere","radius","Matrix3","n11","n12","n13","n21","n22","n23","n31","n32","n33","identity","me","multiplyVector3Array","determinant","c","f","getInverse","throwOnInvertible","det","msg","transpose","tmp","getNormalMatrix","transposeIntoArray","Matrix4","n14","n24","n34","n41","n42","n43","n44","setRotationFromEuler","ae","af","be","bf","ce","cf","de","df","ac","ad","bc","bd","setRotationFromQuaternion","x2","y2","z2","wx","wy","wz","lookAt","eye","target","up","n","multiplyMatrices","a11","a12","a13","a14","a21","a22","a23","a24","a31","a32","a33","a34","a41","a42","a43","a44","b11","b12","b13","b14","b21","b22","b23","b24","b31","b32","b33","b34","b41","b42","b43","b44","multiplyToArray","multiplyVector4","rotateAxis","vx","vy","vz","crossVector","flattenToArray","flat","flattenToArrayOffset","getPosition","setPosition","compose","translation","rotation","scale","makeScale","decompose","extractPosition","extractRotation","scaleX","scaleY","scaleZ","rotateX","m42","m43","rotateY","m41","rotateZ","rotateByAxis","oneMinusCosine","xs","ys","zs","r11","r21","r31","r12","r22","r32","r13","r23","r33","getMaxScaleOnAxis","makeTranslation","makeRotationX","makeRotationY","makeRotationZ","makeRotationAxis","tx","ty","makeFrustum","left","right","bottom","top","near","far","makePerspective","fov","aspect","ymax","tan","degToRad","ymin","makeOrthographic","Ray","origin","direction","ray","at","recast","closestPointToPoint","directionDistance","isIntersectionSphere","isIntersectionPlane","plane","normal","distanceToPlane","denominator","constant","intersectPlane","matrix4","setFromCenterAndPoints","maxRadiusSq","intersectsSphere","radiusSum","deltaLengthSq","getBoundingBox","Frustum","p0","p1","p2","p3","p4","p5","planes","Plane","frustum","setFromMatrix","me0","me1","me2","me3","me4","me5","me6","me7","me8","me9","me10","me11","me12","me13","me14","me15","setComponents","intersectsObject","object","matrixWorld","negRadius","geometry","boundingSphere","distance","setFromNormalAndCoplanarPoint","setFromCoplanarPoints","inverseNormalLength","distanceToSphere","projectPoint","orthoPoint","perpendicularMagnitude","isIntersectionLine","line","startSign","start","endSign","end","intersectLine","coplanarPoint","optionalNormalMatrix","newNormal","newCoplanarPoint","clampBottom","mapLinear","a1","a2","b1","b2","smoothstep","smootherstep","random16","random","randInt","low","high","randFloat","randFloatSpread","range","sign","degrees","radToDeg","radians","Spline","intPoint","weight","w2","w3","pa","pb","pc","pd","v3","interpolate","t2","t3","initFromArray","getPoint","k","getControlPointsArray","coords","getLength","nSubDivisions","nSamples","position","oldIntPoint","oldPosition","tmpVec","chunkLengths","totalLength","chunks","total","reparametrizeByArcLength","samplingCoef","j","indexCurrent","indexNext","sampling","newpoints","sl","push","ceil","Triangle","resultLengthSq","barycoordFromPoint","dot00","dot01","dot02","dot11","dot12","denom","invDenom","u","constructor","setFromPointsAndIndices","i0","i1","i2","triangle","midpoint","Vertex","UV","Clock","autoStart","startTime","oldTime","elapsedTime","running","performance","stop","getElapsedTime","getDelta","diff","newTime","EventDispatcher","listeners","addEventListener","type","listener","indexOf","removeEventListener","splice","dispatchEvent","event","listenerArray","Raycaster","raycaster","intersects","Particle","face","Mesh","vertices","isFaceMaterial","material","MeshFaceMaterial","objectMaterials","materials","side","precision","matrixRotationWorld","fl","faces","materialIndex","planeDistance","planeSign","Face3","Face4","faceIndex","descendants","getDescendants","recursive","sort","intersectObjects","objects","Object3D","Object3DIdCount","name","properties","parent","children","defaultEulerOrder","renderDepth","rotationAutoUpdate","matrixAutoUpdate","matrixWorldNeedsUpdate","useQuaternion","visible","castShadow","receiveShadow","frustumCulled","_vector","applyMatrix","mat","translateX","translateY","translateZ","localToWorld","worldToLocal","__m1","remove","scene","Scene","__addObject","__removeObject","traverse","getChildByName","child","array","apply","updateMatrix","updateMatrixWorld","force","Projector","_object","_objectCount","_vertex","_vertexCount","_face","_face3Count","_face4Count","_line","_lineCount","_particle","_particleCount","_modelMatrix","_objectPool","_objectPoolLength","_vertexPool","_vertexPoolLength","_face3Pool","_face3PoolLength","_face4Pool","_face4PoolLength","_linePool","_linePoolLength","_particlePool","_particlePoolLength","_renderData","sprites","lights","_vector3","_vector4","_clipBox","_boundingBox","_points3","_points4","_viewMatrix","_viewProjectionMatrix","_modelViewProjectionMatrix","_normalMatrix","_normalViewMatrix","_centroid","_frustum","_clippedVertex1PositionScreen","_clippedVertex2PositionScreen","projectVector","camera","matrixWorldInverse","projectionMatrix","unprojectVector","projectionMatrixInverse","pickingRay","projectGraph","root","sortObjects","projectObject","cl","Light","Line","getNextObjectInPool","Sprite","painterSort","RenderableObject","getNextVertexInPool","vertex","RenderableVertex","projectScene","sortElements","o","ol","vl","nl","ul","faceVertexNormals","faceVertexUvs","uvs","v4","positionWorld","positionScreen","getNextFace3InPool","RenderableFace3","getNextFace4InPool","RenderableFace4","normalModel","normalModelView","centroidModel","centroid","vertexNormals","vertexNormalsModel","vertexNormalsModelView","vertexNormalsLength","step","LinePieces","clipLine","alpha1","alpha2","bc1near","bc2near","bc1far","bc2far","getNextLineInPool","RenderableLine","getNextParticleInPool","particle","RenderableParticle","vertexColors","vertexTangents","Geometry","GeometryIdCount","colors","normals","faceUvs","morphTargets","morphColors","morphNormals","skinWeights","skinIndices","lineDistances","boundingBox","hasTangents","dynamic","verticesNeedUpdate","elementsNeedUpdate","uvsNeedUpdate","normalsNeedUpdate","tangentsNeedUpdate","colorsNeedUpdate","lineDistancesNeedUpdate","buffersNeedUpdate","normalMatrix","jl","computeCentroids","computeFaceNormals","cb","ab","vA","vB","vC","computeVertexNormals","areaWeighted","__tmpVertices","vD","db","dc","computeMorphNormals","__originalFaceNormal","__originalVertexNormals","tmpGeo","faceNormals","faceNormal","dstNormalsFace","dstNormalsVertex","computeTangents","vertexIndex","uv","uvA","uvB","uvC","x1","y1","z1","t1","tan1","tan2","sdir","tdir","tmp2","handleTriangle","context","ua","ub","uc","computeLineDistances","computeBoundingBox","computeBoundingSphere","mergeVertices","key","indices","verticesMap","unique","changes","round","join","faceIndicesToRemove","dupIndex","newFace","uvCopy","dispose","BufferGeometry","attributes","offsets","positionArray","normalArray","normalizeNormals","positions","bb","radiusSq","nVertexElements","itemSize","numItems","pA","pB","pC","count","xA","yA","zA","xB","yB","zB","xC","yC","zC","uA","uB","uC","iA","iB","iC","nVertices","nTangentElements","tangents","n2","handleVertex","Camera","create","OrthographicCamera","updateProjectionMatrix","PerspectiveCamera","setLens","focalLength","frameHeight","atan","setViewOffset","fullWidth","fullHeight","width","height","AmbientLight","AreaLight","intensity","constantAttenuation","linearAttenuation","quadraticAttenuation","DirectionalLight","onlyShadow","shadowCameraNear","shadowCameraFar","shadowCameraLeft","shadowCameraRight","shadowCameraTop","shadowCameraBottom","shadowCameraVisible","shadowBias","shadowDarkness","shadowMapWidth","shadowMapHeight","shadowCascade","shadowCascadeOffset","shadowCascadeCount","shadowCascadeBias","shadowCascadeWidth","shadowCascadeHeight","shadowCascadeNearZ","shadowCascadeFarZ","shadowCascadeArray","shadowMap","shadowMapSize","shadowCamera","shadowMatrix","HemisphereLight","skyColorHex","groundColorHex","groundColor","PointLight","SpotLight","exponent","shadowCameraFov","Loader","showStatus","statusDomElement","addStatusElement","onLoadStart","onLoadProgress","onLoadComplete","crossOrigin","document","createElement","fontSize","textAlign","background","padding","zIndex","innerHTML","updateProgress","progress","message","loaded","toFixed","extractUrlBase","url","parts","split","pop","initMaterials","texturePath","createMaterial","needsTangents","ShaderMaterial","_this","is_pow2","LN2","nearest_pow2","pow","create_texture","where","sourceFile","repeat","wrap","anisotropy","image","isCompressed","fullPath","texture","ImageUtils","loadCompressedTexture","Texture","wrapS","wrapT","wrapMap","Image","onload","getContext","drawImage","needsUpdate","src","rgb2hex","rgb","mtype","mpars","opacity","map","lightMap","normalMap","bumpMap","wireframe","shading","toLowerCase","blending","transparent","depthTest","depthWrite","flipSided","doubleSided","colorDiffuse","DbgColor","colorSpecular","specular","colorAmbient","ambient","transparency","specularCoef","shininess","mapDiffuse","mapDiffuseRepeat","mapDiffuseOffset","mapDiffuseWrap","mapDiffuseAnisotropy","mapLight","mapLightRepeat","mapLightOffset","mapLightWrap","mapLightAnisotropy","mapBump","mapBumpRepeat","mapBumpOffset","mapBumpWrap","mapBumpAnisotropy","mapNormal","mapNormalRepeat","mapNormalOffset","mapNormalWrap","mapNormalAnisotropy","mapSpecular","mapSpecularRepeat","mapSpecularOffset","mapSpecularWrap","mapSpecularAnisotropy","mapBumpScale","bumpScale","shader","ShaderLib","uniforms","UniformsUtils","mapNormalFactor","specularMap","parameters","fragmentShader","vertexShader","fog","DbgName","ImageLoader","load","scope","content","JSONLoader","withCredentials","loadAjaxJSON","callbackProgress","xhr","XMLHttpRequest","onreadystatechange","readyState","DONE","status","responseText","json","JSON","parse","createModel","LOADING","getResponseHeader","HEADERS_RECEIVED","open","send","parseModel","fi","zLength","colorIndex","normalIndex","uvIndex","isQuad","hasMaterial","hasFaceUv","hasFaceVertexUv","hasFaceNormal","hasFaceVertexNormal","hasFaceColor","hasFaceVertexColor","uvLayer","nUvLayers","parseSkin","bones","animation","parseMorphing","dstVertices","srcVertices","dstColors","srcColors","LoadingMonitor","onLoad","loader","SceneLoader","callbackSync","geometryHandlerMap","hierarchyHandlerMap","addGeometryHandler","callbackFinished","typeID","loaderClass","addHierarchyHandler","light","counter_models","counter_textures","total_models","total_textures","fogID","fogJSON","geoID","geoJSON","objID","objJSON","textureID","textureJSON","matID","matJSON","parID","urlBase","target_array","geometries","face_materials","textures","cameras","fogs","empties","groups","data","transform","get_url","source_url","url_type","handle_objects","handle_children","dst","pos","rot","scl","quat","loading","reservedTypes","loaderParameters","parType","options","urlBaseType","create_callback_hierachy","skin","SkinnedMesh","morph","MorphAnimMesh","duration","time","mirroredLoop","groupID","node","dae","async_callback_gate","totalModels","totalTextures","loadedModels","loadedTextures","finalize","ta","targetName","targetInverse","callbackTexture","generateTextureCallback","Fog","FogExp2","density","CubeGeometry","depth","widthSegments","heightSegments","depthSegments","PlaneGeometry","SphereGeometry","CylinderGeometry","topRad","botRad","radSegs","heightSegs","TorusGeometry","tube","segmentsR","segmentsT","IcosahedronGeometry","subdivisions","create_callback_geometry","geo","modelJson","embeds","metadata","jsonLoader","create_callback_embed","mapping","url_array","loadCompressedTextureCube","loadTextureCube","fullUrl","textureCallback","loadTexture","minFilter","magFilter","diffuse","normalScale","envMap","reflectivity","displacementMap","displacementBias","displacementScale","materialArray","label","defaults","currentCamera","TextureLoader","Material","MaterialIdCount","blendSrc","blendDst","blendEquation","polygonOffset","polygonOffsetFactor","polygonOffsetUnits","alphaTest","overdraw","setValues","values","newValue","currentValue","LineBasicMaterial","linewidth","linecap","linejoin","LineDashedMaterial","dashSize","gapSize","MeshBasicMaterial","combine","refractionRatio","wireframeLinewidth","wireframeLinecap","wireframeLinejoin","skinning","MeshLambertMaterial","emissive","wrapAround","wrapRGB","MeshPhongMaterial","metal","perPixel","MeshDepthMaterial","MeshNormalMaterial","ParticleBasicMaterial","sizeAttenuation","ParticleCanvasMaterial","program","defines","SpriteMaterial","useScreenCoordinates","scaleByViewport","alignment","SpriteAlignment","uvOffset","uvScale","topLeft","topCenter","topRight","centerLeft","centerRight","bottomLeft","bottomCenter","bottomRight","format","TextureIdCount","mipmaps","generateMipmaps","premultiplyAlpha","flipY","unpackAlignment","onUpdate","CompressedTexture","DataTexture","ParticleSystem","sortParticles","LineStrip","updateMorphTargets","morphTargetBase","morphTargetForcedOrder","morphTargetInfluences","morphTargetDictionary","ml","getMorphTargetIndexByName","Bone","belongsToSkin","skinMatrix","update","parentSkinMatrix","forceUpdate","useVertexTexture","identityMatrix","boneMatrices","gbone","rotq","bone","addBone","nBones","boneTextureWidth","boneTextureHeight","boneTexture","pose","boneInverses","bl","offsetMatrix","sw","lastKeyframe","currentKeyframe","directionBackwards","setFrameRange","startKeyframe","endKeyframe","setDirectionForward","setDirectionBackward","parseAnimations","animations","firstAnimation","pattern","match","setAnimationLabel","playAnimation","fps","updateAnimation","frameTime","keyframe","mix","Ribbon","LOD","LODs","addLevel","object3D","visibleAtDistance","rotation3d","overrideMaterial","__objects","__lights","__objectsAdded","__objectsRemoved","ai","CanvasRenderer","_elements","_lights","_canvasWidth","_canvasHeight","_canvasWidthHalf","_canvasHeightHalf","_v1","_v2","_v3","_v4","_v1x","_v1y","_v2x","_v2y","_v3x","_v3y","_v4x","_v4y","_v5x","_v5y","_v6x","_v6y","_near","_far","_image","_uvs","_uv1x","_uv1y","_uv2x","_uv2y","_uv3x","_uv3y","_pixelMap","_pixelMapContext","_pixelMapImage","_pixelMapData","_gradientMap","_gradientMapContext","_projector","_canvas","canvas","_context","_clearColor","_clearOpacity","_contextGlobalAlpha","_contextGlobalCompositeOperation","_contextStrokeStyle","_contextFillStyle","_contextLineWidth","_contextLineCap","_contextLineJoin","_contextDashSize","_contextGapSize","_v5","_v6","_color","_color1","_color2","_color3","_color4","_diffuseColor","_emissiveColor","_lightColor","_patterns","_imagedatas","_clearBox","_elemBox","_enableLighting","_ambientLight","_directionalLights","_pointLights","_gradientMapQuality","setOpacity","globalAlpha","setBlending","globalCompositeOperation","setLineWidth","lineWidth","setLineCap","lineCap","setLineJoin","lineJoin","setStrokeStyle","strokeStyle","setFillStyle","fillStyle","setDashAndGap","dashSizeValue","gapSizeValue","setLineDash","fillRect","getImageData","mozDash","domElement","devicePixelRatio","autoClear","render","supportsVertexTextures","setFaceCulling","setSize","setClearColor","setClearColorHex","getMaxAnisotropy","clear","setTransform","clearRect","calculateLights","ll","lightColor","el","element","renderParticle","bitmap","bitmapWidth","bitmapHeight","save","rotate","restore","beginPath","moveTo","lineTo","stroke","expand","renderFace3","renderFace4","v5","v6","calculateLight","getGradientTexture","drawTriangle","clipImage","drawQuad","strokePath","fillPath","lightPosition","amount","uv1","uv2","uv3","patternPath","x0","y0","closePath","x3","y3","fill","u0","u1","u2","repeatX","repeatY","createPattern","idet","offsetX","offsetY","clip","color3","color4","putImageData","ShaderChunk","fog_pars_fragment","fog_fragment","envmap_pars_fragment","envmap_fragment","envmap_pars_vertex","worldpos_vertex","envmap_vertex","map_particle_pars_fragment","map_particle_fragment","map_pars_vertex","map_pars_fragment","map_vertex","map_fragment","lightmap_pars_fragment","lightmap_pars_vertex","lightmap_fragment","lightmap_vertex","bumpmap_pars_fragment","normalmap_pars_fragment","specularmap_pars_fragment","specularmap_fragment","lights_lambert_pars_vertex","lights_lambert_vertex","lights_phong_pars_vertex","lights_phong_vertex","lights_phong_pars_fragment","lights_phong_fragment","color_pars_fragment","color_fragment","color_pars_vertex","color_vertex","skinning_pars_vertex","skinbase_vertex","skinning_vertex","morphtarget_pars_vertex","morphtarget_vertex","default_vertex","morphnormal_vertex","skinnormal_vertex","defaultnormal_vertex","shadowmap_pars_fragment","shadowmap_fragment","shadowmap_pars_vertex","shadowmap_vertex","alphatest_fragment","linear_to_gamma_fragment","merge","merged","uniforms_src","parameter_src","uniforms_dst","UniformsLib","common","bump","normalmap","shadowmap","WebGLRenderer","_gl","_glExtensionTextureFloat","_glExtensionStandardDerivatives","_glExtensionTextureFilterAnisotropic","_glExtensionCompressedTextureS3TC","_precision","_alpha","_premultipliedAlpha","premultipliedAlpha","_antialias","antialias","_stencil","stencil","_preserveDrawingBuffer","preserveDrawingBuffer","clearColor","_clearAlpha","clearAlpha","autoClearColor","autoClearDepth","autoClearStencil","autoUpdateObjects","autoUpdateScene","gammaInput","gammaOutput","physicallyBasedShading","shadowMapEnabled","shadowMapAutoUpdate","shadowMapType","shadowMapCullFace","shadowMapDebug","shadowMapCascade","maxMorphTargets","maxMorphNormals","autoScaleCubemaps","renderPluginsPre","renderPluginsPost","memory","programs","calls","_programs","_programs_counter","_currentProgram","_currentFramebuffer","_currentMaterialId","_currentGeometryGroupHash","_currentCamera","_geometryGroupCounter","_usedTextureUnits","_oldDoubleSided","_oldFlipSided","_oldBlending","_oldBlendEquation","_oldBlendSrc","_oldBlendDst","_oldDepthTest","_oldDepthWrite","_oldPolygonOffset","_oldPolygonOffsetFactor","_oldPolygonOffsetUnits","_oldLineWidth","_viewportX","_viewportY","_viewportWidth","_viewportHeight","_currentWidth","_currentHeight","_enabledAttributes","_projScreenMatrix","_projScreenMatrixPS","_direction","_lightsNeedUpdate","directional","distances","spot","directions","anglesCos","exponents","hemi","skyColors","groundColors","initGL","getExtension","getShaderPrecisionFormat","clearDepth","clearStencil","enable","DEPTH_TEST","depthFunc","LEQUAL","frontFace","CCW","cullFace","BACK","CULL_FACE","BLEND","FUNC_ADD","blendFunc","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","_maxTextures","MAX_TEXTURE_IMAGE_UNITS","_maxVertexTextures","MAX_VERTEX_TEXTURE_IMAGE_UNITS","MAX_TEXTURE_SIZE","_maxCubemapSize","MAX_CUBE_MAP_TEXTURE_SIZE","_maxAnisotropy","MAX_TEXTURE_MAX_ANISOTROPY_EXT","_supportsVertexTextures","_supportsBoneTextures","COMPRESSED_TEXTURE_FORMATS","_vertexShaderPrecisionHighpFloat","VERTEX_SHADER","HIGH_FLOAT","_vertexShaderPrecisionMediumpFloat","MEDIUM_FLOAT","LOW_FLOAT","_fragmentShaderPrecisionHighpFloat","FRAGMENT_SHADER","_fragmentShaderPrecisionMediumpFloat","HIGH_INT","MEDIUM_INT","LOW_INT","highpAvailable","mediumpAvailable","supportsFloatTextures","supportsStandardDerivatives","supportsCompressedTextureS3TC","getPrecision","setViewport","viewport","setScissor","scissor","enableScissorTest","SCISSOR_TEST","disable","getClearColor","getClearAlpha","bits","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","STENCIL_BUFFER_BIT","clearTarget","renderTarget","setRenderTarget","addPostPlugin","plugin","init","addPrePlugin","updateShadowMap","shadowMapPlugin","onGeometryDispose","deallocateGeometry","onTextureDispose","deallocateTexture","onRenderTargetDispose","deallocateRenderTarget","onMaterialDispose","deallocateMaterial","__webglInit","__webglVertexBuffer","deleteBuffer","__webglNormalBuffer","__webglTangentBuffer","__webglColorBuffer","__webglUVBuffer","__webglUV2Buffer","__webglSkinIndicesBuffer","__webglSkinWeightsBuffer","__webglFaceBuffer","__webglLineBuffer","__webglLineDistanceBuffer","geometryGroups","geometryGroup","numMorphTargets","__webglMorphTargetsBuffers","numMorphNormals","__webglMorphNormalsBuffers","deleteCustomAttributesBuffers","__webglTextureCube","deleteTexture","__webglTexture","WebGLRenderTargetCube","deleteFramebuffer","__webglFramebuffer","deleteRenderbuffer","__webglRenderbuffer","programInfo","deleteProgram","usedTimes","newPrograms","__webglCustomAttributesList","buffer","initCustomAttributes","nvertices","attribute","__webglInitialized","createUniqueBuffers","createBuffer","belongsToAttribute","initMeshBuffers","faces3","faces4","ntris","nlines","getBufferMaterial","uvType","bufferGuessUVType","normalType","bufferGuessNormalType","vertexColorType","bufferGuessVertexColorType","__vertexArray","__normalArray","__tangentArray","__colorArray","__uvArray","__uv2Array","__skinIndexArray","__skinWeightArray","__faceArray","Uint16Array","__lineArray","__morphTargetsArrays","__morphNormalsArrays","__webglFaceCount","__webglLineCount","originalAttribute","property","__original","__inittedArrays","initDirectBuffers","ELEMENT_ARRAY_BUFFER","ARRAY_BUFFER","bindBuffer","bufferData","STATIC_DRAW","setDirectBuffers","hint","tangent","enableAttribute","enableVertexAttribArray","disableAttributes","disableVertexAttribArray","painterSortStable","numericalSort","renderPlugins","plugins","renderObjects","renderList","reverse","materialType","useBlending","webglObject","setDepthTest","setDepthWrite","setPolygonOffset","setMaterialFaces","renderBufferDirect","renderBuffer","renderObjectsImmediate","renderImmediateObject","addBuffer","objlist","opaque","areCustomAttributesDirty","clearCustomAttributes","removeInstances","removeInstancesDirect","setProgram","initMaterial","__webglMorphTargetInfluences","refreshMaterial","p_uniforms","m_uniforms","useProgram","uniformMatrix4fv","textureUnit","getTextureUnit","uniform1i","setTexture","boneGlobalMatrices","fogColor","fogNear","fogFar","fogDensity","setupLights","skyColor","intensitySq","dirColors","zlights","dirPositions","pointColors","pointPositions","pointDistances","spotColors","spotPositions","spotDistances","spotDirections","spotAnglesCos","spotExponents","hemiSkyColors","hemiGroundColors","hemiPositions","dirLength","pointLength","spotLength","hemiLength","dirCount","pointCount","spotCount","hemiCount","dirOffset","pointOffset","spotOffset","hemiOffset","setColorGamma","setColorLinear","ambientLightColor","directionalLightColor","directionalLightDirection","pointLightColor","pointLightPosition","pointLightDistance","spotLightColor","spotLightPosition","spotLightDistance","spotLightDirection","spotLightAngleCos","spotLightExponent","hemisphereLightSkyColor","hemisphereLightGroundColor","hemisphereLightDirection","refreshUniformsCommon","uvScaleMap","offsetRepeat","flipEnvMap","useRefract","refreshUniformsLine","totalSize","psColor","mNear","mFar","_shadowPass","refreshUniformsShadow","loadUniformsGeneric","uniform","location","slot","uniform1f","uniform2f","uniform3f","uniform4f","uniform1iv","uniform3iv","uniform1fv","uniform3fv","_array","uniform2fv","uniform4fv","setCubeTexture","createTexture","activeTexture","TEXTURE0","bindTexture","TEXTURE_CUBE_MAP","pixelStorei","UNPACK_FLIP_Y_WEBGL","cubeImage","clampToMaxSize","maxSize","maxDimension","newWidth","newHeight","ctx","isImagePowerOfTwo","isPowerOfTwo","glFormat","paramThreeToGL","glType","setTextureParameters","mipmap","compressedTexImage2D","TEXTURE_CUBE_MAP_POSITIVE_X","texImage2D","generateMipmap","uniformsList","cameraPosition","viewMatrix","modelViewMatrix","_modelViewMatrix","uniformMatrix3fv","modelMatrix","setupMatrices","polygonoffset","factor","units","POLYGON_OFFSET_FILL","getShader","string","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","addLineNumbers","textureType","texParameteri","TEXTURE_WRAP_S","TEXTURE_WRAP_T","TEXTURE_MAG_FILTER","TEXTURE_MIN_FILTER","CLAMP_TO_EDGE","filterFallback","__oldAnisotropy","texParameterf","TEXTURE_MAX_ANISOTROPY_EXT","setupFrameBuffer","framebuffer","textureTarget","bindFramebuffer","FRAMEBUFFER","framebufferTexture2D","COLOR_ATTACHMENT0","setupRenderBuffer","renderbuffer","bindRenderbuffer","RENDERBUFFER","depthBuffer","stencilBuffer","renderbufferStorage","DEPTH_COMPONENT16","framebufferRenderbuffer","DEPTH_ATTACHMENT","DEPTH_STENCIL","DEPTH_STENCIL_ATTACHMENT","RGBA4","NEAREST","LINEAR","REPEAT","MIRRORED_REPEAT","NEAREST_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LINEAR_MIPMAP_NEAREST","LINEAR_MIPMAP_LINEAR","UNSIGNED_BYTE","UNSIGNED_SHORT_4_4_4_4","UNSIGNED_SHORT_5_5_5_1","UNSIGNED_SHORT_5_6_5","BYTE","SHORT","UNSIGNED_SHORT","INT","UNSIGNED_INT","FLOAT","ALPHA","RGB","RGBA","LUMINANCE","LUMINANCE_ALPHA","FUNC_SUBTRACT","FUNC_REVERSE_SUBTRACT","ZERO","ONE","SRC_COLOR","ONE_MINUS_SRC_COLOR","DST_ALPHA","ONE_MINUS_DST_ALPHA","DST_COLOR","ONE_MINUS_DST_COLOR","SRC_ALPHA_SATURATE","COMPRESSED_RGB_S3TC_DXT1_EXT","COMPRESSED_RGBA_S3TC_DXT1_EXT","COMPRESSED_RGBA_S3TC_DXT3_EXT","COMPRESSED_RGBA_S3TC_DXT5_EXT","renderBufferImmediate","hasPositions","hasNormals","hasUvs","__webglUvBuffer","hasColors","DYNAMIC_DRAW","vertexAttribPointer","nx","ny","nz","nax","nbx","ncx","nay","nby","ncy","naz","nbz","ncz","uvArray","colorArray","drawArrays","TRIANGLES","updateBuffers","wireframeBit","geometryHash","startIndex","positionSize","normalSize","uvSize","colorSize","tangentSize","drawElements","POINTS","LINE_STRIP","primitives","geometryGroupHash","setupMorphTargets","influences","numSupportedMorphTargets","influence","activeInfluenceIndices","numSupportedMorphNormals","influenceIndex","skinIndex","skinWeight","lineDistance","LINES","__webglParticleCount","TRIANGLE_STRIP","__webglVertexCount","forceClear","initWebGLObjects","__webglObjects","unrollBufferMaterial","globject","meshMaterial","__webglObjectsImmediate","unrollImmediateBufferMaterial","TEXTURE_2D","immediateRenderCallback","__webglSprites","__webglFlares","addObject","sortFacesByMaterial","groupHash","hash_map","usesFaceMaterial","hash","counter","geometryGroupsList","createMeshBuffers","morphTargetsNeedUpdate","__lineDistanceArray","__sortArray","__webglActive","ImmediateRenderObject","addBufferImmediate","LensFlare","updateObject","customAttributesDirty","setMeshBuffers","pp","faceColor","t4","n1","n3","n4","c4","sw1","sw2","sw3","sw4","si1","si2","si3","si4","vn","uvi","uv2i","vk","vkl","vka","nka","chf","customAttribute","needsSmoothNormals","offset_uv","offset_uv2","offset_face","offset_normal","offset_tangent","offset_line","offset_color","offset_skin","offset_morphTarget","offset_custom","vertexArray","uv2Array","tangentArray","skinIndexArray","skinWeightArray","morphTargetsArrays","morphNormalsArrays","customAttributes","faceArray","lineArray","dirtyVertices","dirtyElements","dirtyUvs","dirtyNormals","dirtyTangents","dirtyColors","dirtyMorphTargets","chunk_faces3","chunk_faces4","obj_faces","obj_uvs","obj_uvs2","obj_skinIndices","obj_skinWeights","boundTo","setRibbonBuffers","ca","cal","setLineBuffers","dl","lineDistanceArray","dirtyLineDistances","setParticleBuffers","sortArray","shaderID","shaders","maxLightCount","allocateLights","dirLights","pointLights","spotLights","hemiLights","maxShadows","allocateShadows","maxBones","allocateBones","nVertexUniforms","MAX_VERTEX_UNIFORM_VECTORS","useFog","fogExp","maxDirLights","maxPointLights","maxSpotLights","maxHemiLights","buildProgram","pl","code","identifiers","shadowMapTypeDefine","customDefines","generateDefines","chunk","createProgram","prefix_vertex","glFragmentShader","prefix_fragment","glVertexShader","attachShader","linkProgram","getProgramParameter","LINK_STATUS","VALIDATE_STATUS","getError","deleteShader","cacheUniformLocations","getUniformLocation","cacheAttributeLocations","getAttribLocation","base","frontFaceDirection","CW","FRONT","FRONT_AND_BACK","depthMask","blendEquationSeparate","blendFuncSeparate","UNPACK_PREMULTIPLY_ALPHA_WEBGL","UNPACK_ALIGNMENT","isCube","isTargetPowerOfTwo","createFramebuffer","createRenderbuffer","shareDepthFrom","activeCubeFace","ShadowMapPlugin","SpritePlugin","LensFlarePlugin","WebGLRenderTarget","GeometryUtils","geometry1","object2","vertexOffset","geometry2","vertices1","vertices2","faces1","faces2","uvs1","uvs2","vertexCopy","faceCopy","faceVertexColors","removeMaterials","materialIndexArray","materialIndexMap","newFaces","randomPointInTriangle","vectorA","vectorB","vectorC","__v1","randomPointInFace","useCachedAreas","area1","area2","_area1","_area2","triangleArea","randomPointsInGeometry","totalArea","cumulativeAreas","_area","stats","binarySearchIndices","binarySearch","mid","tmp1","__v2","normalizeUVs","uvSet","triangulateQuads","triA","triB","uvD","uvsTriA","uvsTriB","faceUv","setMaterialIndex","startFace","endFace","onError","request","response","dds","parseDDS","onerror","responseType","images","loadCount","generateCubeFaceCallback","rq","img","isCubemap","mipmapCount","loadMipmaps","blockBytes","fourCCToInt32","charCodeAt","FOURCC_DXT1","FOURCC_DXT3","FOURCC_DXT5","header","fourCC","fromCharCode","dataOffset","dataLength","Uint8Array","getNormalMap","subtract","imageData","createImageData","output","ly","uy","lx","ux","num_points","idx","generateDataTexture","SceneUtils","createMultiMaterialObject","group","detach","attach","FontUtils","divisions","getFace","loadFace","family","familyName","ThreeFont","cssFontWeight","cssFontStyle","drawText","text","resolution","chars","fontPaths","path","Path","ret","extractGlyphPoints","paths","outline","cpx","cpy","cpx0","cpy0","cpx1","cpy1","cpx2","cpy2","laste","pts","glyph","glyphs","_cachedOutline","quadraticCurveTo","Shape","Utils","bezierCurveTo","b3","ha","generateShapes","curveSegments","font","shapes","toShapes","contour","verts","ax","ay","bx","by","cx","cy","px","py","aX","aY","bX","bY","cX","cY","apx","apy","bpx","bpy","cCROSSap","bCROSScp","aCROSSbp","EPSILON","Triangulate","vertIndices","nv","_typeface_js","Curve","getPointAt","getUtoTmapping","getPoints","getSpacedPoints","lengths","getLengths","__arcLengthDivisions","cacheArcLengths","current","cache","last","sum","updateArcLengths","arcLengths","targetArcLength","comparison","lengthBefore","lengthAfter","getTangent","pt1","vec","pt2","getTangentAt","LineCurve","QuadraticBezierCurve","tangentQuadraticBezier","CubicBezierCurve","tangentCubicBezier","SplineCurve","EllipseCurve","xRadius","yRadius","aStartAngle","aEndAngle","aClockwise","deltaAngle","ArcCurve","aRadius","tangentSpline","h00","getPointFunc","LineCurve3","QuadraticBezierCurve3","tz","CubicBezierCurve3","SplineCurve3","pt0","pt3","ClosedSplineCurve3","CurvePath","curves","bends","autoClose","curve","checkConnection","startPoint","endPoint","curveLengths","getCurveLengths","lens","cacheLengths","sums","maxX","maxY","maxZ","minX","minY","minZ","Number","NEGATIVE_INFINITY","POSITIVE_INFINITY","createPointsGeometry","createGeometry","createSpacedPointsGeometry","addWrapPath","bendpath","getTransformedPoints","segments","oldPts","getWrapPoints","getTransformedSpacedPoints","oldX","oldY","xNorm","bounds","pathPt","getNormalVector","Gyroscope","translationWorld","rotationWorld","scaleWorld","translationObject","rotationObject","scaleObject","actions","fromPoints","PathActions","MOVE_TO","LINE_TO","QUADRATIC_CURVE_TO","BEZIER_CURVE_TO","CSPLINE_THRU","ARC","ELLIPSE","vectors","vlen","args","arguments","action","lastargs","aCPx","aCPy","aCP1x","aCP1y","aCP2x","aCP2y","splineThru","npts","arc","absarc","absellipse","ellipse","lastPoint","closedPath","useSpacedPoints","item","spts","concat","spline","tdivisions","subPaths","lastPath","tmpPath","tmpShape","holesFirst","isClockWise","holes","extrude","ExtrudeGeometry","makeGeometry","ShapeGeometry","getPointsHoles","holesPts","getSpacedPointsHoles","extractAllPoints","shape","extractPoints","extractAllSpacedPoints","removeHoles","prevShapeVert","prevHoleVert","holeIndex","shapeIndex","h2","hole","shortest","pts1","pts2","tmpShape1","tmpShape2","tmpHole1","tmpHole2","allpoints","dist","areaapts","areaa","areabpts","areab","oldShapeIndex","oldHoleIndex","areaa2","trianglea","triangleb","isolatedPts","triangulateShape","shapeWithoutHoles","triangles","allPointsMap","b2p0","b2p1","b2p2","b3p0","b3p1","b3p2","b3p3","AnimationHandler","deltaTimeMS","addToUpdate","removeFromUpdate","get","hierarchy","initialized","usedMorphTargets","morphTargetName","morphTargetsInfluences","lengthInFrames","JIT","CATMULLROM","CATMULLROM_FORWARD","Animation","interpolationType","currentTime","timeScale","isPlaying","isPaused","loop","play","startTimeMS","hl","animationCache","prevKey","nextKey","originalMatrix","getNextKeyWith","pause","prevXYZ","nextXYZ","unloopedCurrentTime","currentPoint","forwardPoint","types","getPrevKeyWith","interpolateCatmullRom","KeyFrameAnimation","JITCompile","sids","sid","next","startTimeMs","endTime","original","frame","looped","JIThierarchy","prev","lastIndex","hasTarget","CubeCamera","cubeResolution","cameraPX","cameraNX","cameraPY","cameraNY","cameraPZ","cameraNZ","updateCubeMap","renderer","CombinedCamera","orthoNear","orthoFar","cameraO","cameraP","zoom","toPerspective","inPerspectiveMode","inOrthographicMode","toOrthographic","halfHeight","halfWidth","planeWidth","setFov","setZoom","toFrontView","toBackView","toLeftView","toRightView","toTopView","toBottomView","AsteriskGeometry","innerRadius","outerRadius","sd2","ed2","rays","CircleGeometry","thetaStart","thetaLength","centerUV","width_half","height_half","depth_half","buildPlane","udir","vdir","gridX","gridY","gridX1","gridY1","segment_width","segment_height","radiusTop","radiusBottom","radiusSegments","openEnded","na","nb","heightHalf","segmentsX","segmentsY","verticesRow","uvsRow","tanTheta","uv4","shapebb","addShapeList","addShape","extrudePts","bevelThickness","bevelSize","bevelSegments","bevelEnabled","steps","extrudePath","extrudeByPath","extrudeMaterial","uvgen","UVGenerator","WorldUVGenerator","splineTube","frames","TubeGeometry","FrenetFrames","binormal","position2","shapesOffset","shapePoints","ahole","scalePt2","pt","bs","vert","flen","getBevelVec2","pt_i","pt_j","pt_k","anglea","angleb","anglec","v_dot_w_hat","q_sub_p_dot_w_hat","v_hat","__v3","w_hat","__v4","__v5","__v6","intersection","contourMovements","oneHoleMovements","holesMovements","verticesMovements","binormals","sidewalls","layeroffset","slen1","slen2","f4","wallContour","stepIndex","stepsLength","contourIndex1","contourIndex2","generateSideWallUV","f3","isBottom","generateBottomUV","generateTopUV","buildLidFaces","buildSideFaces","extrudedShape","extrudeOptions","indexA","indexB","indexC","indexD","az","bz","cz","LatheGeometry","phiStart","phiLength","inversePointLength","inverseSegments","phi","np","gridZ","gridZ1","TextGeometry","textShapes","radialSegments","tubularSegments","TorusKnotGeometry","heightScale","grid","tang","bitan","getPos","ip","jp","uva","uvb","uvc","uvd","in_q","in_p","quOverP","cs","closed","numpoints","pos2","ArrowHelper","smallest","MAX_VALUE","PolyhedronGeometry","detail","prepare","midpoints","make","azi","azimuth","correctUV","inclination","OctahedronGeometry","TetrahedronGeometry","ParametricGeometry","func","slices","stacks","useTris","sliceCount","ConvexGeometry","addPoint","vertexId","mag","randomOffset","va","vb","vc","ea","edge","boundary","eb","vertexUv","newId","AxisHelper","dir","lineGeometry","coneGeometry","cone","setDirection","__q1","setColor","CameraHelper","addLine","pointMap","setPoint","__v","__projector","__c","DirectionalLightHelper","sphereSize","hexColor","bulbGeometry","raysGeometry","bulbMaterial","raysMaterial","lightSphere","lightRays","isGizmo","gizmoSubject","gizmoRoot","targetSphere","targetGeo","targetMaterial","lineMaterial","targetLine","HemisphereLightHelper","arrowLength","domeSize","hexColorGround","bulbGroundGeometry","bulbSkyMaterial","bulbGroundMaterial","lightArrow","lightArrowGround","joint","PointLightHelper","distanceGeometry","distanceMaterial","lightDistance","SpotLightHelper","coneMatrix","coneMaterial","lightCone","coneLength","coneWidth","gyroscope","renderCallback","lensFlares","customUpdateCallback","updateLensFlares","flare","vecX","vecY","wantedRotation","MorphBlendMesh","animationsMap","animationsList","numFrames","createAnimation","setAnimationWeight","startFrame","endFrame","lastFrame","currentFrame","active","autoCreateAnimations","frameRanges","setAnimationDirectionForward","setAnimationDirectionBackward","setAnimationFPS","setAnimationDuration","setAnimationTime","getAnimationTime","getAnimationDuration","stopAnimation","_renderer","_lensFlare","prefix","vertexBuffer","elementBuffer","tempTexture","occlusionTexture","hasVertexTexture","ShaderFlares","renderType","occlusionMap","screenPosition","viewportWidth","viewportHeight","sprite","flares","nFlares","tempPosition","invAspect","halfViewportWidth","halfViewportHeight","screenPositionPixels","TEXTURE1","copyTexImage2D","_depthMaterial","_depthMaterialMorph","_depthMaterialSkin","_depthMaterialMorphSkin","_min","_max","_matrixPosition","depthShader","depthUniforms","virtualLight","createVirtualLight","cascade","isVirtual","pointsWorld","pointsFrustum","nearZ","farZ","originalCamera","gyro","updateVirtualLight","objectMaterial","useMorphing","useSkinning","shadowFilter","pars","cameraHelper","updateShadowCamera","customDepthMaterial","_sprite","ShaderSprite","fogType","nSprites","oldFogType","sceneFogType","DepthPassPlugin","enabled"],"version":3,"file":"index.07b7c40d.js.map"}