{"mappings":"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","sources":["<anon>","lib/OrbitAndPanControls.js"],"sourcesContent":["\"use strict\"; // good practice - see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode\n/**\n * @author qiao / https://github.com/qiao\n * @author mrdoob / http://mrdoob.com\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author erich666 / http://erichaines.com\n */ /*global THREE, console */ THREE.OrbitAndPanControls = function(object, domElement) {\n    THREE.EventDispatcher.call(this);\n    this.enabled = true;\n    this.object = object;\n    this.domElement = domElement !== undefined ? domElement : document;\n    // API\n    this.enabled = true;\n    this.target = new THREE.Vector3();\n    // center is old, deprecated; use \"target\" instead\n    this.center = this.target;\n    // This option actually enables dollying in and out\n    this.noZoom = false;\n    this.zoomSpeed = 1.0;\n    this.noRotate = false;\n    this.rotateSpeed = 1.0;\n    this.noPan = false;\n    this.autoRotate = false;\n    this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\n    this.minPolarAngle = 0; // radians\n    this.maxPolarAngle = Math.PI; // radians\n    this.minDistance = 0;\n    this.maxDistance = Infinity;\n    this.noKeys = false;\n    this.keys = {\n        LEFT: 37,\n        UP: 38,\n        RIGHT: 39,\n        BOTTOM: 40\n    };\n    // internals\n    var scope = this;\n    var EPS = 0.000001;\n    var rotateStart = new THREE.Vector2();\n    var rotateEnd = new THREE.Vector2();\n    var rotateDelta = new THREE.Vector2();\n    var panStart = new THREE.Vector2();\n    var panEnd = new THREE.Vector2();\n    var panDelta = new THREE.Vector2();\n    var dollyStart = new THREE.Vector2();\n    var dollyEnd = new THREE.Vector2();\n    var dollyDelta = new THREE.Vector2();\n    var phiDelta = 0;\n    var thetaDelta = 0;\n    var scale = 1;\n    var pan = new THREE.Vector3();\n    var lastPosition = new THREE.Vector3();\n    var STATE = {\n        NONE: -1,\n        ROTATE: 0,\n        DOLLY: 1,\n        PAN: 2,\n        TOUCH_ROTATE: 3,\n        TOUCH_DOLLY: 4,\n        TOUCH_PAN: 5\n    };\n    var state = STATE.NONE;\n    // events\n    var changeEvent = {\n        type: \"change\"\n    };\n    this.rotateLeft = function(angle) {\n        if (angle === undefined) angle = getAutoRotationAngle();\n        thetaDelta -= angle;\n    };\n    this.rotateUp = function(angle) {\n        if (angle === undefined) angle = getAutoRotationAngle();\n        phiDelta -= angle;\n    };\n    // pass in distance in world space to move left\n    this.panLeft = function(distance) {\n        var panOffset = new THREE.Vector3();\n        var te = this.object.matrix.elements;\n        // get X column of matrix\n        panOffset.set(te[0], te[1], te[2]);\n        panOffset.multiplyScalar(-distance);\n        pan.add(panOffset);\n    };\n    // pass in distance in world space to move up\n    this.panUp = function(distance) {\n        var panOffset = new THREE.Vector3();\n        var te = this.object.matrix.elements;\n        // get Y column of matrix\n        panOffset.set(te[4], te[5], te[6]);\n        panOffset.multiplyScalar(distance);\n        pan.add(panOffset);\n    };\n    // main entry point; pass in Vector2 of change desired in pixel space,\n    // right and down are positive\n    this.pan = function(delta) {\n        if (scope.object.fov !== undefined) {\n            // perspective\n            var position = scope.object.position;\n            var offset = position.clone().sub(scope.target);\n            var targetDistance = offset.length();\n            // half of the fov is center to top of screen\n            targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180.0);\n            // we actually don't use screenWidth, since perspective camera is fixed to screen height\n            scope.panLeft(2 * delta.x * targetDistance / scope.domElement.height);\n            scope.panUp(2 * delta.y * targetDistance / scope.domElement.height);\n        } else if (scope.object.top !== undefined) {\n            // orthographic\n            scope.panLeft(delta.x * (scope.object.right - scope.object.left) / scope.domElement.width);\n            scope.panUp(delta.y * (scope.object.top - scope.object.bottom) / scope.domElement.height);\n        } else // camera neither orthographic or perspective - warn user\n        console.warn(\"WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.\");\n    };\n    this.dollyIn = function(dollyScale) {\n        if (dollyScale === undefined) dollyScale = getZoomScale();\n        scale /= dollyScale;\n    };\n    this.dollyOut = function(dollyScale) {\n        if (dollyScale === undefined) dollyScale = getZoomScale();\n        scale *= dollyScale;\n    };\n    this.update = function() {\n        var position = this.object.position;\n        var offset = position.clone().sub(this.target);\n        // angle from z-axis around y-axis\n        var theta = Math.atan2(offset.x, offset.z);\n        // angle from y-axis\n        var phi = Math.atan2(Math.sqrt(offset.x * offset.x + offset.z * offset.z), offset.y);\n        if (this.autoRotate) this.rotateLeft(getAutoRotationAngle());\n        theta += thetaDelta;\n        phi += phiDelta;\n        // restrict phi to be between desired limits\n        phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, phi));\n        // restrict phi to be betwee EPS and PI-EPS\n        phi = Math.max(EPS, Math.min(Math.PI - EPS, phi));\n        var radius = offset.length() * scale;\n        // restrict radius to be between desired limits\n        radius = Math.max(this.minDistance, Math.min(this.maxDistance, radius));\n        // move target to panned location\n        this.target.add(pan);\n        offset.x = radius * Math.sin(phi) * Math.sin(theta);\n        offset.y = radius * Math.cos(phi);\n        offset.z = radius * Math.sin(phi) * Math.cos(theta);\n        position.copy(this.target).add(offset);\n        this.object.lookAt(this.target);\n        thetaDelta = 0;\n        phiDelta = 0;\n        scale = 1;\n        pan.set(0, 0, 0);\n        if (lastPosition.distanceTo(this.object.position) > 0) {\n            this.dispatchEvent(changeEvent);\n            lastPosition.copy(this.object.position);\n        }\n    };\n    function getAutoRotationAngle() {\n        return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n    }\n    function getZoomScale() {\n        return Math.pow(0.95, scope.zoomSpeed);\n    }\n    function onMouseDown(event) {\n        if (scope.enabled === false) return;\n        event.preventDefault();\n        if (event.button === 0) {\n            if (scope.noRotate === true) return;\n            state = STATE.ROTATE;\n            rotateStart.set(event.clientX, event.clientY);\n        } else if (event.button === 1) {\n            if (scope.noZoom === true) return;\n            state = STATE.DOLLY;\n            dollyStart.set(event.clientX, event.clientY);\n        } else if (event.button === 2) {\n            if (scope.noPan === true) return;\n            state = STATE.PAN;\n            panStart.set(event.clientX, event.clientY);\n        }\n        document.addEventListener(\"mousemove\", onMouseMove, false);\n        document.addEventListener(\"mouseup\", onMouseUp, false);\n    }\n    function onMouseMove(event) {\n        if (scope.enabled === false) return;\n        event.preventDefault();\n        if (state === STATE.ROTATE) {\n            if (scope.noRotate === true) return;\n            rotateEnd.set(event.clientX, event.clientY);\n            rotateDelta.subVectors(rotateEnd, rotateStart);\n            // rotating across whole screen goes 360 degrees around\n            scope.rotateLeft(2 * Math.PI * rotateDelta.x / scope.domElement.width * scope.rotateSpeed);\n            // rotating up and down along whole screen attempts to go 360, but limited to 180\n            scope.rotateUp(2 * Math.PI * rotateDelta.y / scope.domElement.height * scope.rotateSpeed);\n            rotateStart.copy(rotateEnd);\n        } else if (state === STATE.DOLLY) {\n            if (scope.noZoom === true) return;\n            dollyEnd.set(event.clientX, event.clientY);\n            dollyDelta.subVectors(dollyEnd, dollyStart);\n            if (dollyDelta.y > 0) scope.dollyIn();\n            else scope.dollyOut();\n            dollyStart.copy(dollyEnd);\n        } else if (state === STATE.PAN) {\n            if (scope.noPan === true) return;\n            panEnd.set(event.clientX, event.clientY);\n            panDelta.subVectors(panEnd, panStart);\n            scope.pan(panDelta);\n            panStart.copy(panEnd);\n        }\n    }\n    function onMouseUp() {\n        if (scope.enabled === false) return;\n        document.removeEventListener(\"mousemove\", onMouseMove, false);\n        document.removeEventListener(\"mouseup\", onMouseUp, false);\n        state = STATE.NONE;\n    }\n    function onMouseWheel(event) {\n        // this is needed when the program is inside an iframe\n        // to prevent scrolling the whole page\n        event.preventDefault();\n        if (scope.enabled === false) return;\n        if (scope.noZoom === true) return;\n        var delta = 0;\n        if (event.wheelDelta) delta = event.wheelDelta;\n        else if (event.detail) delta = -event.detail;\n        if (delta > 0) scope.dollyOut();\n        else scope.dollyIn();\n    }\n    function onKeyDown(event) {\n        if (scope.enabled === false) return;\n        if (scope.noKeys === true) return;\n        if (scope.noPan === true) return;\n        // pan a pixel - I guess for precise positioning?\n        switch(event.keyCode){\n            case scope.keys.UP:\n                scope.pan(new THREE.Vector2(0, 1));\n                break;\n            case scope.keys.BOTTOM:\n                scope.pan(new THREE.Vector2(0, -1));\n                break;\n            case scope.keys.LEFT:\n                scope.pan(new THREE.Vector2(1, 0));\n                break;\n            case scope.keys.RIGHT:\n                scope.pan(new THREE.Vector2(-1, 0));\n                break;\n        }\n    }\n    function touchstart(event) {\n        if (scope.enabled === false) return;\n        switch(event.touches.length){\n            case 1:\n                if (scope.noRotate === true) return;\n                state = STATE.TOUCH_ROTATE;\n                rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);\n                break;\n            case 2:\n                if (scope.noZoom === true) return;\n                state = STATE.TOUCH_DOLLY;\n                var dx = event.touches[0].pageX - event.touches[1].pageX;\n                var dy = event.touches[0].pageY - event.touches[1].pageY;\n                var distance = Math.sqrt(dx * dx + dy * dy);\n                dollyStart.set(0, distance);\n                break;\n            case 3:\n                if (scope.noPan === true) return;\n                state = STATE.TOUCH_PAN;\n                panStart.set(event.touches[0].pageX, event.touches[0].pageY);\n                break;\n            default:\n                state = STATE.NONE;\n        }\n    }\n    function touchmove(event) {\n        if (scope.enabled === false) return;\n        event.preventDefault();\n        event.stopPropagation();\n        switch(event.touches.length){\n            case 1:\n                if (scope.noRotate === true) return;\n                if (state !== STATE.TOUCH_ROTATE) return;\n                rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n                rotateDelta.subVectors(rotateEnd, rotateStart);\n                // rotating across whole screen goes 360 degrees around\n                scope.rotateLeft(2 * Math.PI * rotateDelta.x / scope.domElement.width * scope.rotateSpeed);\n                // rotating up and down along whole screen attempts to go 360, but limited to 180\n                scope.rotateUp(2 * Math.PI * rotateDelta.y / scope.domElement.height * scope.rotateSpeed);\n                rotateStart.copy(rotateEnd);\n                break;\n            case 2:\n                if (scope.noZoom === true) return;\n                if (state !== STATE.TOUCH_DOLLY) return;\n                var dx = event.touches[0].pageX - event.touches[1].pageX;\n                var dy = event.touches[0].pageY - event.touches[1].pageY;\n                var distance = Math.sqrt(dx * dx + dy * dy);\n                dollyEnd.set(0, distance);\n                dollyDelta.subVectors(dollyEnd, dollyStart);\n                if (dollyDelta.y > 0) scope.dollyOut();\n                else scope.dollyIn();\n                dollyStart.copy(dollyEnd);\n                break;\n            case 3:\n                if (scope.noPan === true) return;\n                if (state !== STATE.TOUCH_PAN) return;\n                panEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n                panDelta.subVectors(panEnd, panStart);\n                scope.pan(panDelta);\n                panStart.copy(panEnd);\n                break;\n            default:\n                state = STATE.NONE;\n        }\n    }\n    function touchend() {\n        if (scope.enabled === false) return;\n        state = STATE.NONE;\n    }\n    this.domElement.addEventListener(\"contextmenu\", function(event) {\n        event.preventDefault();\n    }, false);\n    this.domElement.addEventListener(\"mousedown\", onMouseDown, false);\n    this.domElement.addEventListener(\"mousewheel\", onMouseWheel, false);\n    this.domElement.addEventListener(\"DOMMouseScroll\", onMouseWheel, false); // firefox\n    this.domElement.addEventListener(\"keydown\", onKeyDown, false);\n    this.domElement.addEventListener(\"touchstart\", touchstart, false);\n    this.domElement.addEventListener(\"touchend\", touchend, false);\n    this.domElement.addEventListener(\"touchmove\", touchmove, false);\n};\n\n//# sourceMappingURL=index.7090b043.js.map\n","\"use strict\"; // good practice - see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode\n/**\n * @author qiao / https://github.com/qiao\n * @author mrdoob / http://mrdoob.com\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author erich666 / http://erichaines.com\n */\n/*global THREE, console */\n\nTHREE.OrbitAndPanControls = function ( object, domElement ) {\n\n\tTHREE.EventDispatcher.call( this );\n\n\tthis.enabled = true;\n\n\tthis.object = object;\n\tthis.domElement = ( domElement !== undefined ) ? domElement : document;\n\n\t// API\n\n\tthis.enabled = true;\n\n\tthis.target = new THREE.Vector3();\n\t// center is old, deprecated; use \"target\" instead\n\tthis.center = this.target;\n\n\t// This option actually enables dollying in and out\n\tthis.noZoom = false;\n\tthis.zoomSpeed = 1.0;\n\n\tthis.noRotate = false;\n\tthis.rotateSpeed = 1.0;\n\n\tthis.noPan = false;\n\n\tthis.autoRotate = false;\n\tthis.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\n\n\tthis.minPolarAngle = 0; // radians\n\tthis.maxPolarAngle = Math.PI; // radians\n\n\tthis.minDistance = 0;\n\tthis.maxDistance = Infinity;\n\n\tthis.noKeys = false;\n\tthis.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };\n\n\t// internals\n\n\tvar scope = this;\n\n\tvar EPS = 0.000001;\n\n\tvar rotateStart = new THREE.Vector2();\n\tvar rotateEnd = new THREE.Vector2();\n\tvar rotateDelta = new THREE.Vector2();\n\n\tvar panStart = new THREE.Vector2();\n\tvar panEnd = new THREE.Vector2();\n\tvar panDelta = new THREE.Vector2();\n\n\tvar dollyStart = new THREE.Vector2();\n\tvar dollyEnd = new THREE.Vector2();\n\tvar dollyDelta = new THREE.Vector2();\n\n\tvar phiDelta = 0;\n\tvar thetaDelta = 0;\n\tvar scale = 1;\n\tvar pan = new THREE.Vector3();\n\n\tvar lastPosition = new THREE.Vector3();\n\n\tvar STATE = { NONE : -1, ROTATE : 0, DOLLY : 1, PAN : 2, TOUCH_ROTATE : 3, TOUCH_DOLLY : 4, TOUCH_PAN : 5 };\n\tvar state = STATE.NONE;\n\n\t// events\n\n\tvar changeEvent = { type: 'change' };\n\n\n\tthis.rotateLeft = function ( angle ) {\n\n\t\tif ( angle === undefined ) {\n\n\t\t\tangle = getAutoRotationAngle();\n\n\t\t}\n\n\t\tthetaDelta -= angle;\n\n\t};\n\n\tthis.rotateUp = function ( angle ) {\n\n\t\tif ( angle === undefined ) {\n\n\t\t\tangle = getAutoRotationAngle();\n\n\t\t}\n\n\t\tphiDelta -= angle;\n\n\t};\n\n\t// pass in distance in world space to move left\n\tthis.panLeft = function ( distance ) {\n\n\t\tvar panOffset = new THREE.Vector3();\n\t\tvar te = this.object.matrix.elements;\n\t\t// get X column of matrix\n\t\tpanOffset.set( te[0], te[1], te[2] );\n\t\tpanOffset.multiplyScalar(-distance);\n\t\t\n\t\tpan.add( panOffset );\n\n\t};\n\n\t// pass in distance in world space to move up\n\tthis.panUp = function ( distance ) {\n\n\t\tvar panOffset = new THREE.Vector3();\n\t\tvar te = this.object.matrix.elements;\n\t\t// get Y column of matrix\n\t\tpanOffset.set( te[4], te[5], te[6] );\n\t\tpanOffset.multiplyScalar(distance);\n\t\t\n\t\tpan.add( panOffset );\n\t};\n\t\n\t// main entry point; pass in Vector2 of change desired in pixel space,\n\t// right and down are positive\n\tthis.pan = function ( delta ) {\n\n\t\tif ( scope.object.fov !== undefined )\n\t\t{\n\t\t\t// perspective\n\t\t\tvar position = scope.object.position;\n\t\t\tvar offset = position.clone().sub( scope.target );\n\t\t\tvar targetDistance = offset.length();\n\n\t\t\t// half of the fov is center to top of screen\n\t\t\ttargetDistance *= Math.tan( (scope.object.fov/2) * Math.PI / 180.0 );\n\t\t\t// we actually don't use screenWidth, since perspective camera is fixed to screen height\n\t\t\tscope.panLeft( 2 * delta.x * targetDistance / scope.domElement.height );\n\t\t\tscope.panUp( 2 * delta.y * targetDistance / scope.domElement.height );\n\t\t}\n\t\telse if ( scope.object.top !== undefined )\n\t\t{\n\t\t\t// orthographic\n\t\t\tscope.panLeft( delta.x * (scope.object.right - scope.object.left) / scope.domElement.width );\n\t\t\tscope.panUp( delta.y * (scope.object.top - scope.object.bottom) / scope.domElement.height );\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// camera neither orthographic or perspective - warn user\n\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );\n\t\t}\n\t};\n\n\tthis.dollyIn = function ( dollyScale ) {\n\n\t\tif ( dollyScale === undefined ) {\n\n\t\t\tdollyScale = getZoomScale();\n\n\t\t}\n\n\t\tscale /= dollyScale;\n\n\t};\n\n\tthis.dollyOut = function ( dollyScale ) {\n\n\t\tif ( dollyScale === undefined ) {\n\n\t\t\tdollyScale = getZoomScale();\n\n\t\t}\n\n\t\tscale *= dollyScale;\n\n\t};\n\n\tthis.update = function () {\n\n\t\tvar position = this.object.position;\n\t\tvar offset = position.clone().sub( this.target );\n\n\t\t// angle from z-axis around y-axis\n\n\t\tvar theta = Math.atan2( offset.x, offset.z );\n\n\t\t// angle from y-axis\n\n\t\tvar phi = Math.atan2( Math.sqrt( offset.x * offset.x + offset.z * offset.z ), offset.y );\n\n\t\tif ( this.autoRotate ) {\n\n\t\t\tthis.rotateLeft( getAutoRotationAngle() );\n\n\t\t}\n\n\t\ttheta += thetaDelta;\n\t\tphi += phiDelta;\n\n\t\t// restrict phi to be between desired limits\n\t\tphi = Math.max( this.minPolarAngle, Math.min( this.maxPolarAngle, phi ) );\n\n\t\t// restrict phi to be betwee EPS and PI-EPS\n\t\tphi = Math.max( EPS, Math.min( Math.PI - EPS, phi ) );\n\n\t\tvar radius = offset.length() * scale;\n\n\t\t// restrict radius to be between desired limits\n\t\tradius = Math.max( this.minDistance, Math.min( this.maxDistance, radius ) );\n\t\t\n\t\t// move target to panned location\n\t\tthis.target.add( pan );\n\n\t\toffset.x = radius * Math.sin( phi ) * Math.sin( theta );\n\t\toffset.y = radius * Math.cos( phi );\n\t\toffset.z = radius * Math.sin( phi ) * Math.cos( theta );\n\n\t\tposition.copy( this.target ).add( offset );\n\n\t\tthis.object.lookAt( this.target );\n\n\t\tthetaDelta = 0;\n\t\tphiDelta = 0;\n\t\tscale = 1;\n\t\tpan.set(0,0,0);\n\n\t\tif ( lastPosition.distanceTo( this.object.position ) > 0 ) {\n\n\t\t\tthis.dispatchEvent( changeEvent );\n\n\t\t\tlastPosition.copy( this.object.position );\n\n\t\t}\n\n\t};\n\n\n\tfunction getAutoRotationAngle() {\n\n\t\treturn 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n\n\t}\n\n\tfunction getZoomScale() {\n\n\t\treturn Math.pow( 0.95, scope.zoomSpeed );\n\n\t}\n\n\tfunction onMouseDown( event ) {\n\n\t\tif ( scope.enabled === false ) { return; }\n\t\tevent.preventDefault();\n\n\t\tif ( event.button === 0 ) {\n\t\t\tif ( scope.noRotate === true ) { return; }\n\n\t\t\tstate = STATE.ROTATE;\n\n\t\t\trotateStart.set( event.clientX, event.clientY );\n\n\t\t} else if ( event.button === 1 ) {\n\t\t\tif ( scope.noZoom === true ) { return; }\n\n\t\t\tstate = STATE.DOLLY;\n\n\t\t\tdollyStart.set( event.clientX, event.clientY );\n\n\t\t} else if ( event.button === 2 ) {\n\t\t\tif ( scope.noPan === true ) { return; }\n\n\t\t\tstate = STATE.PAN;\n\n\t\t\tpanStart.set( event.clientX, event.clientY );\n\n\t\t}\n\n\t\tdocument.addEventListener( 'mousemove', onMouseMove, false );\n\t\tdocument.addEventListener( 'mouseup', onMouseUp, false );\n\n\t}\n\n\tfunction onMouseMove( event ) {\n\n\t\tif ( scope.enabled === false ) { return; }\n\n\t\tevent.preventDefault();\n\n\t\tif ( state === STATE.ROTATE ) {\n\t\t\tif ( scope.noRotate === true ) { return; }\n\n\t\t\trotateEnd.set( event.clientX, event.clientY );\n\t\t\trotateDelta.subVectors( rotateEnd, rotateStart );\n\n\t\t\t// rotating across whole screen goes 360 degrees around\n\t\t\tscope.rotateLeft( 2 * Math.PI * rotateDelta.x / scope.domElement.width * scope.rotateSpeed );\n\t\t\t// rotating up and down along whole screen attempts to go 360, but limited to 180\n\t\t\tscope.rotateUp( 2 * Math.PI * rotateDelta.y / scope.domElement.height * scope.rotateSpeed );\n\n\t\t\trotateStart.copy( rotateEnd );\n\n\t\t} else if ( state === STATE.DOLLY ) {\n\t\t\tif ( scope.noZoom === true ) { return; }\n\n\t\t\tdollyEnd.set( event.clientX, event.clientY );\n\t\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\n\n\t\t\tif ( dollyDelta.y > 0 ) {\n\n\t\t\t\tscope.dollyIn();\n\n\t\t\t} else {\n\n\t\t\t\tscope.dollyOut();\n\n\t\t\t}\n\n\t\t\tdollyStart.copy( dollyEnd );\n\n\t\t} else if ( state === STATE.PAN ) {\n\t\t\tif ( scope.noPan === true ) { return; }\n\n\t\t\tpanEnd.set( event.clientX, event.clientY );\n\t\t\tpanDelta.subVectors( panEnd, panStart );\n\t\t\t\n\t\t\tscope.pan( panDelta );\n\n\t\t\tpanStart.copy( panEnd );\n\n\t\t}\n\n\t}\n\n\tfunction onMouseUp( /* event */ ) {\n\n\t\tif ( scope.enabled === false ) { return; }\n\n\t\tdocument.removeEventListener( 'mousemove', onMouseMove, false );\n\t\tdocument.removeEventListener( 'mouseup', onMouseUp, false );\n\n\t\tstate = STATE.NONE;\n\n\t}\n\n\tfunction onMouseWheel( event ) {\n\t\t// this is needed when the program is inside an iframe\n\t\t// to prevent scrolling the whole page\n\t\tevent.preventDefault();\n\t\tif ( scope.enabled === false ) { return; }\n\t\tif ( scope.noZoom === true ) { return; }\n\n\t\tvar delta = 0;\n\n\t\tif ( event.wheelDelta ) { // WebKit / Opera / Explorer 9\n\n\t\t\tdelta = event.wheelDelta;\n\n\t\t} else if ( event.detail ) { // Firefox\n\n\t\t\tdelta = - event.detail;\n\n\t\t}\n\n\t\tif ( delta > 0 ) {\n\n\t\t\tscope.dollyOut();\n\n\t\t} else {\n\n\t\t\tscope.dollyIn();\n\n\t\t}\n\n\t}\n\n\tfunction onKeyDown( event ) {\n\n\t\tif ( scope.enabled === false ) { return; }\n\t\tif ( scope.noKeys === true ) { return; }\n\t\tif ( scope.noPan === true ) { return; }\n\n\t\t// pan a pixel - I guess for precise positioning?\n\t\tswitch ( event.keyCode ) {\n\n\t\t\tcase scope.keys.UP:\n\t\t\t\tscope.pan( new THREE.Vector2( 0, 1 ) );\n\t\t\t\tbreak;\n\t\t\tcase scope.keys.BOTTOM:\n\t\t\t\tscope.pan( new THREE.Vector2( 0, -1 ) );\n\t\t\t\tbreak;\n\t\t\tcase scope.keys.LEFT:\n\t\t\t\tscope.pan( new THREE.Vector2( 1, 0 ) );\n\t\t\t\tbreak;\n\t\t\tcase scope.keys.RIGHT:\n\t\t\t\tscope.pan( new THREE.Vector2( -1, 0 ) );\n\t\t\t\tbreak;\n\t\t}\n\n\t}\n\t\n\tfunction touchstart( event ) {\n\n\t\tif ( scope.enabled === false ) { return; }\n\n\t\tswitch ( event.touches.length ) {\n\n\t\t\tcase 1:\t// one-fingered touch: rotate\n\t\t\t\tif ( scope.noRotate === true ) { return; }\n\n\t\t\t\tstate = STATE.TOUCH_ROTATE;\n\n\t\t\t\trotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\t// two-fingered touch: dolly\n\t\t\t\tif ( scope.noZoom === true ) { return; }\n\n\t\t\t\tstate = STATE.TOUCH_DOLLY;\n\n\t\t\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\n\t\t\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\n\t\t\t\tvar distance = Math.sqrt( dx * dx + dy * dy );\n\t\t\t\tdollyStart.set( 0, distance );\n\t\t\t\tbreak;\n\n\t\t\tcase 3: // three-fingered touch: pan\n\t\t\t\tif ( scope.noPan === true ) { return; }\n\n\t\t\t\tstate = STATE.TOUCH_PAN;\n\n\t\t\t\tpanStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tstate = STATE.NONE;\n\n\t\t}\n\t}\n\n\tfunction touchmove( event ) {\n\n\t\tif ( scope.enabled === false ) { return; }\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tswitch ( event.touches.length ) {\n\n\t\t\tcase 1: // one-fingered touch: rotate\n\t\t\t\tif ( scope.noRotate === true ) { return; }\n\t\t\t\tif ( state !== STATE.TOUCH_ROTATE ) { return; }\n\n\t\t\t\trotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\t\t\t\trotateDelta.subVectors( rotateEnd, rotateStart );\n\n\t\t\t\t// rotating across whole screen goes 360 degrees around\n\t\t\t\tscope.rotateLeft( 2 * Math.PI * rotateDelta.x / scope.domElement.width * scope.rotateSpeed );\n\t\t\t\t// rotating up and down along whole screen attempts to go 360, but limited to 180\n\t\t\t\tscope.rotateUp( 2 * Math.PI * rotateDelta.y / scope.domElement.height * scope.rotateSpeed );\n\n\t\t\t\trotateStart.copy( rotateEnd );\n\t\t\t\tbreak;\n\n\t\t\tcase 2: // two-fingered touch: dolly\n\t\t\t\tif ( scope.noZoom === true ) { return; }\n\t\t\t\tif ( state !== STATE.TOUCH_DOLLY ) { return; }\n\n\t\t\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\n\t\t\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\n\t\t\t\tvar distance = Math.sqrt( dx * dx + dy * dy );\n\n\t\t\t\tdollyEnd.set( 0, distance );\n\t\t\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\n\n\t\t\t\tif ( dollyDelta.y > 0 ) {\n\n\t\t\t\t\tscope.dollyOut();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tscope.dollyIn();\n\n\t\t\t\t}\n\n\t\t\t\tdollyStart.copy( dollyEnd );\n\t\t\t\tbreak;\n\n\t\t\tcase 3: // three-fingered touch: pan\n\t\t\t\tif ( scope.noPan === true ) { return; }\n\t\t\t\tif ( state !== STATE.TOUCH_PAN ) { return; }\n\n\t\t\t\tpanEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\t\t\t\tpanDelta.subVectors( panEnd, panStart );\n\t\t\t\t\n\t\t\t\tscope.pan( panDelta );\n\n\t\t\t\tpanStart.copy( panEnd );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tstate = STATE.NONE;\n\n\t\t}\n\n\t}\n\n\tfunction touchend( /* event */ ) {\n\n\t\tif ( scope.enabled === false ) { return; }\n\n\t\tstate = STATE.NONE;\n\t}\n\n\tthis.domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );\n\tthis.domElement.addEventListener( 'mousedown', onMouseDown, false );\n\tthis.domElement.addEventListener( 'mousewheel', onMouseWheel, false );\n\tthis.domElement.addEventListener( 'DOMMouseScroll', onMouseWheel, false ); // firefox\n\n\tthis.domElement.addEventListener( 'keydown', onKeyDown, false );\n\n\tthis.domElement.addEventListener( 'touchstart', touchstart, false );\n\tthis.domElement.addEventListener( 'touchend', touchend, false );\n\tthis.domElement.addEventListener( 'touchmove', touchmove, false );\n\n};\n"],"names":["THREE","OrbitAndPanControls","object","domElement","EventDispatcher","call","enabled","undefined","document","target","Vector3","center","noZoom","zoomSpeed","noRotate","rotateSpeed","noPan","autoRotate","autoRotateSpeed","minPolarAngle","maxPolarAngle","Math","PI","minDistance","maxDistance","Infinity","noKeys","keys","LEFT","UP","RIGHT","BOTTOM","scope","rotateStart","Vector2","rotateEnd","rotateDelta","panStart","panEnd","panDelta","dollyStart","dollyEnd","dollyDelta","phiDelta","thetaDelta","scale","pan","lastPosition","STATE","NONE","ROTATE","DOLLY","PAN","TOUCH_ROTATE","TOUCH_DOLLY","TOUCH_PAN","state","changeEvent","type","getAutoRotationAngle","getZoomScale","pow","onMouseMove","event","preventDefault","set","clientX","clientY","subVectors","rotateLeft","x","width","rotateUp","y","height","copy","dollyIn","dollyOut","onMouseUp","removeEventListener","onMouseWheel","delta","wheelDelta","detail","angle","panLeft","distance","panOffset","te","matrix","elements","multiplyScalar","add","panUp","fov","targetDistance","offset","position","clone","sub","length","tan","top","right","left","bottom","console","warn","dollyScale","update","theta","atan2","z","phi","sqrt","max","min","radius","sin","cos","lookAt","distanceTo","dispatchEvent","addEventListener","button","keyCode","touches","pageX","pageY","dx","dy","stopPropagation"],"version":3,"file":"index.7090b043.js.map"}