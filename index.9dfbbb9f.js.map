{"mappings":"","sources":["lib/Coordinates.js"],"sourcesContent":["\"use strict\"; // good practice - see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode\n/*global THREE, scene*/\nvar Coordinates = {\n\tdrawGrid:function(params) {\n\t\tparams = params || {};\n\t\tvar size = params.size !== undefined ? params.size:100;\n\t\tvar scale = params.scale !== undefined ? params.scale:0.1;\n\t\tvar orientation = params.orientation !== undefined ? params.orientation:\"x\";\n\t\tvar grid = new THREE.Mesh(\n\t\t\tnew THREE.PlaneGeometry(size, size, size * scale, size * scale),\n\t\t\tnew THREE.MeshBasicMaterial({ color: 0x555555, wireframe: true }) \n\t\t\t);\n\t\t// Yes, these are poorly labeled! It would be a mess to fix.\n\t\t// What's really going on here:\n\t\t// \"x\" means \"rotate 90 degrees around x\", etc.\n\t\t// So \"x\" really means \"show a grid with a normal of Y\"\n\t\t//    \"y\" means \"show a grid with a normal of X\"\n\t\t//    \"z\" means (logically enough) \"show a grid with a normal of Z\"\n\t\tif (orientation === \"x\") {\n\t\t\tgrid.rotation.x = - Math.PI / 2;\n\t\t} else if (orientation === \"y\") {\n\t\t\tgrid.rotation.y = - Math.PI / 2;\n\t\t} else if (orientation === \"z\") {\n\t\t\tgrid.rotation.z = - Math.PI / 2;\n\t\t}\n\n\t\tscene.add(grid);\n\t},\n\tdrawGround:function(params) {\n\t\tparams = params || {};\n\t\tvar size = params.size !== undefined ? params.size:100;\n\t\tvar color = params.color !== undefined ? params.color:0xFFFFFF;\n\t\tvar ground = new THREE.Mesh(\n\t\t\tnew THREE.PlaneGeometry(size, size),\n\t\t\t// When we use a ground plane we use directional lights, so illuminating\n\t\t\t// just the corners is sufficient.\n\t\t\t// Use MeshPhongMaterial if you want to capture per-pixel lighting:\n\t\t\t// new THREE.MeshPhongMaterial({ color: color, specular: 0x000000,\n\t\t\tnew THREE.MeshLambertMaterial({ color: color,\n\t\t\t\t// polygonOffset moves the plane back from the eye a bit, so that the lines on top of\n\t\t\t\t// the grid do not have z-fighting with the grid:\n\t\t\t\t// Factor == 1 moves it back relative to the slope (more on-edge means move back farther)\n\t\t\t\t// Units == 4 is a fixed amount to move back, and 4 is usually a good value\n\t\t\t\tpolygonOffset: true, polygonOffsetFactor: 1.0, polygonOffsetUnits: 4.0\n\t\t\t}));\n\t\tground.rotation.x = - Math.PI / 2;\n\t\tscene.add(ground);\n\t},\n\tdrawAxes:function(params) {\n\t\t// x = red, y = green, z = blue  (RGB = xyz)\n\t\tparams = params || {};\n\t\tvar axisRadius = params.axisRadius !== undefined ? params.axisRadius:0.04;\n\t\tvar axisLength = params.axisLength !== undefined ? params.axisLength:11;\n\t\tvar axisTess = params.axisTess !== undefined ? params.axisTess:48;\n\t\tvar axisOrientation = params.axisOrientation !== undefined ? params.axisOrientation:\"x\";\n\n\t\tvar axisMaterial = new THREE.MeshLambertMaterial({ color: 0x000000, side: THREE.DoubleSide });\n\t\tvar axis = new THREE.Mesh(\n\t\t\tnew THREE.CylinderGeometry(axisRadius, axisRadius, axisLength, axisTess, 1, true), \n\t\t\taxisMaterial\n\t\t\t);\n\t\tif (axisOrientation === \"x\") {\n\t\t\taxis.rotation.z = - Math.PI / 2;\n\t\t\taxis.position.x = axisLength/2-1;\n\t\t} else if (axisOrientation === \"y\") {\n\t\t\t\taxis.position.y = axisLength/2-1;\n\t\t}\n\t\t\n\t\tscene.add( axis );\n\t\t\n\t\tvar arrow = new THREE.Mesh(\n\t\t\tnew THREE.CylinderGeometry(0, 4*axisRadius, 8*axisRadius, axisTess, 1, true), \n\t\t\taxisMaterial\n\t\t\t);\n\t\tif (axisOrientation === \"x\") {\n\t\t\tarrow.rotation.z = - Math.PI / 2;\n\t\t\tarrow.position.x = axisLength - 1 + axisRadius*4/2;\n\t\t} else if (axisOrientation === \"y\") {\n\t\t\tarrow.position.y = axisLength - 1 + axisRadius*4/2;\n\t\t}\n\n\t\tscene.add( arrow );\n\n\t},\n\tdrawAllAxes:function(params) {\n\t\tparams = params || {};\n\t\tvar axisRadius = params.axisRadius !== undefined ? params.axisRadius:0.04;\n\t\tvar axisLength = params.axisLength !== undefined ? params.axisLength:11;\n\t\tvar axisTess = params.axisTess !== undefined ? params.axisTess:48;\n\n\t\tvar axisXMaterial = new THREE.MeshLambertMaterial({ color: 0xFF0000 });\n\t\tvar axisYMaterial = new THREE.MeshLambertMaterial({ color: 0x00FF00 });\n\t\tvar axisZMaterial = new THREE.MeshLambertMaterial({ color: 0x0000FF });\n\t\taxisXMaterial.side = THREE.DoubleSide;\n\t\taxisYMaterial.side = THREE.DoubleSide;\n\t\taxisZMaterial.side = THREE.DoubleSide;\n\t\tvar axisX = new THREE.Mesh(\n\t\t\tnew THREE.CylinderGeometry(axisRadius, axisRadius, axisLength, axisTess, 1, true), \n\t\t\taxisXMaterial\n\t\t\t);\n\t\tvar axisY = new THREE.Mesh(\n\t\t\tnew THREE.CylinderGeometry(axisRadius, axisRadius, axisLength, axisTess, 1, true), \n\t\t\taxisYMaterial\n\t\t\t);\n\t\tvar axisZ = new THREE.Mesh(\n\t\t\tnew THREE.CylinderGeometry(axisRadius, axisRadius, axisLength, axisTess, 1, true), \n\t\t\taxisZMaterial\n\t\t\t);\n\t\taxisX.rotation.z = - Math.PI / 2;\n\t\taxisX.position.x = axisLength/2-1;\n\n\t\taxisY.position.y = axisLength/2-1;\n\t\t\n\t\taxisZ.rotation.y = - Math.PI / 2;\n\t\taxisZ.rotation.z = - Math.PI / 2;\n\t\taxisZ.position.z = axisLength/2-1;\n\n\t\tscene.add( axisX );\n\t\tscene.add( axisY );\n\t\tscene.add( axisZ );\n\n\t\tvar arrowX = new THREE.Mesh(\n\t\t\tnew THREE.CylinderGeometry(0, 4*axisRadius, 4*axisRadius, axisTess, 1, true), \n\t\t\taxisXMaterial\n\t\t\t);\n\t\tvar arrowY = new THREE.Mesh(\n\t\t\tnew THREE.CylinderGeometry(0, 4*axisRadius, 4*axisRadius, axisTess, 1, true), \n\t\t\taxisYMaterial\n\t\t\t);\n\t\tvar arrowZ = new THREE.Mesh(\n\t\t\tnew THREE.CylinderGeometry(0, 4*axisRadius, 4*axisRadius, axisTess, 1, true), \n\t\t\taxisZMaterial\n\t\t\t);\n\t\tarrowX.rotation.z = - Math.PI / 2;\n\t\tarrowX.position.x = axisLength - 1 + axisRadius*4/2;\n\n\t\tarrowY.position.y = axisLength - 1 + axisRadius*4/2;\n\n\t\tarrowZ.rotation.z = - Math.PI / 2;\n\t\tarrowZ.rotation.y = - Math.PI / 2;\n\t\tarrowZ.position.z = axisLength - 1 + axisRadius*4/2;\n\n\t\tscene.add( arrowX );\n\t\tscene.add( arrowY );\n\t\tscene.add( arrowZ );\n\n\t}\n\n};"],"names":[],"version":3,"file":"index.9dfbbb9f.js.map"}